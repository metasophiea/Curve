<!DOCTYPE html>
<html lang="en">
    
    <head>
        <title>curve - next</title>
        <meta charset="utf-8">
        <link href="https://fonts.googleapis.com/css?family=Roboto:100,300&display=swap" rel="stylesheet">
        <link href="/help/navigation_bar.css" rel="stylesheet">
        <style>
            html, body{
                margin:1%;
                font-family: Roboto;
            }
            h1{
                font-size: xxx-large;
            }

            #cards{
                max-width: 800px;
                margin: auto;
            }
            .card{
                margin-top: 10px;
                margin-bottom: 10px;

                background-color: #f5f5f5;
                display: inline-block;
                padding: 10px;
            }
            .centred-image {
                display: block;
                margin-left: auto;
                margin-right: auto;
            }
            .caption {
                text-align: center;
                font-size: small;
                font-style: italic;
                color: #aaaaaa;
            }
            .broken-link {
                pointer-events: none;
                color: #aaaaaa;
            }
        </style>
    </head>

    <body>

        <h1 style='font-style: italic;'>Next</h1>

        <p>After discovering the bug that made the site essentially unusable for any real purpose, I found myself in a depressing place. I wanted to continue working on this project that has brought me so much joy and passion, so I have decided to use the Rust programming language that I learned to make the core-engine webASM rewrite, and use it to produce a stand-alone desktop app for Mac, Linux and Windows.</p>
        <p>Here, you can find a mini-blog on the development of that project.</p>
        <p>I don't know how to do signing yet, so, your anti-virus is not going to be super happy about any of this.</p>

        <div id="cards">

            <div class="card">
                <h2>Completion Of Rendering Engine</h2>
                <p>2022-01-03</p>
                <p>It's been a while. How are you? I've been a little busy. The rendering engine has developed to draft 29, which I'm now calling v1. I've also taken to naming the rendering engine "Vivid" which I think is a pretty cool name.</p>
                <img style="width:40%; display:block; margin:auto;" src="/next/images/vivid_logo_1.png"></img>
                <p>Initially, I was mostly done at draft 23, but after a little testing with profilers I noticed that a feature of the core architecture of the engine was taking up a lot of processing time, so I re-wrote it - which resulted in re-writing much of the program overall. This new version is noticeably faster and simpler. It also has a better thought-out layout and plenty of testing code.</p>
                <img style="width:70%; display:block; margin:auto;" src="/next/images/vivid_layout_1.png"></img>
                <p>The "shell" is simply a way of covering over all the sections of the renderer, presenting a nice package api.</p>
                <p>Additionally, the program comes with a new feature; extremity replacement elements. This allows one to tell a group element not to calculate any of its internal geometry, but instead use a provided replacement element. This allows one to put together complex structures and tell the engine "hay, don't worry about any of this. It won't be used for collision and there won't be any mouse or keyboard interaction. I know that it also means that no visibility calculations will take place, but I'll handle it. Just trust me." Visibility calculations and determinations can be quite costly, so having the option of telling the system not to worry about them can save a lot of time.</p>
                <p>One might also notice that the colours are deeper than before. This is due to Brandon figuring out what texture formats were and which ones to use, thus the presented colours now match the ones that were actually wanted.</p>
                <img style="width: 100%;" src="/next/images/render_rectangle_count_test_2.png"></img>
                <p>I've included a number of demo programs for you to play with;</p>
                <ul style="list-style-type:none">
                    <li>console_example_1 : all shapes</li>
                    <li>console_example_2 : lots of random boxes</li>
                    <li>console_example_3 : wavey boxes</li>
                    <li>console_example_4 : four corners test</li>
                    <li>console_example_5 : angle and scale adjustment on groups with children</li>
                    <li>console_example_6 : viewport adjustment</li>
                    <li>console_example_7 : mouse action test</li>
                    <li>console_example_8 : character default fonts</li>
                    <li>console_example_11 : all the fonts</li>
                    <li>console_example_12 : character detail levels</li>
                    <li>console_example_21 : much usage of the canvas and imagebitmap transfers (the one that caused crashes on chrome)</li>
                    <li>console_example_22 : rotating area of rectangles</li>
                    <li>console_example_23 : mouse simulator</li>
                </ul>
                <p>Some of these are programs you've seen before - but with the new engine running them - others are brand new. Importantly, console_example_2 comes with a command line argument, with which you can define the number of rectangles the program will put on screen, for example;</p>
                <img style="width: 100%;" src="/next/images/render_rectangle_count_test_3.png"></img>
                <p>Next stop; the upper levels. I've already made a start on a generalised platform - the Orchestrator - which draws together the rendering engine and other such resources. A bit like a browser engine, one would be able to write whatever they liked atop it, using the resources of the platform. Other resources can be added at a later date, such as the "Glide" audio engine which I have in development. Beyond that lies the interface section, which (should) act like a framework. Useful, but not necessary to using the platform. This section would contain the same sort of items as the previous interface section of the website  - ie. buttons, sliders, dials, lights, meters, readouts, cable connections, etc.</p>
                <img style="width:70%; display:block; margin:auto;" src="/next/images/overall_layout_1.png"></img>
                <p>I've been thinking of renaming Curve to Alchemy... we'll see if that sticks in my mind</p>
                <h3>Downloads</h3>
                <p>Here are the usual downloads, first the "bundles" which contain all the programs listed above. Secondly, I've included a variation of console_example_2, which is a single-threaded version with timing code. This is useful for seeing how much time a system spends on any part of the rendering procedure.</p>
                <h4>Bundles</h4>
                <p><a href="/next/apps/renderer_1_bundle/macos/11.6.zip">MacOS 11.6</a></p>
                <p><a href="/next/apps/renderer_1_bundle/win10.zip">Windows 10</a></p>
                <h4>Speed Test</h4>
                <p><a href="/next/apps/renderer_1_speed_test/macos11.6.zip">MacOS 11.6</a></p>
                <p><a href="/next/apps/renderer_1_speed_test/win10.zip">Windows 10</a></p>
            </div>

            <div class="card">
                <h2>Character Test Using Default Fonts</h2>
                <p>2021-08-10 - Made with draft 19 of the project, this test shows the all the characters of the two default fonts; "Default Thick" and "Default Thin". Additionally I've added some simple mouse interaction, so that the characters will change colour when you mouse over them.</p>
                <p>These two fonts are baked-in to the program. I plan to add more, fancier fonts; but those will be loaded from external font files - requiring an amount of processing. The default fonts require no processing so can be used in the place of fonts that haven't yet loaded.</p>
                <img style="width: 100%;" src="/next/images/default_fonts_characters.png"></img>
                <p>Fun fact: I designed these two default fonts by hand for the website, using some graph paper and a graphing program. I started with just "Default Thick" (at the time, only known as "Default") but after finishing I realised that it was pretty ugly, so I created "Default Thin" which was slightly better. Not long after I added external fonts, much to the relief to those blessed with the gift of sight.</p>
                <img class="centred-image" style="width: 60%; " src="/next/images/early characters.jpg"></img>
                <p class="caption">I only drew characters that I was having trouble with. I think they look better on paper</p>
                <h3>Downloads</h3>
                <p><a href="/next/apps/default_fonts/macos/11.5/default_fonts.zip">MacOS 11.5</a></p>
                <p><a href="/next/apps/default_fonts/macos/10.11/default_fonts.zip">MacOS 10.11</a></p>
                <p><a class="broken-link" href="/next/apps/default_fonts/windows10/default_fonts.zip">Windows 10</a></p>
            </div>

            <div class="card">
                <h2>Element Test - Plus Automatic Image Update</h2>
                <p>2021-06-09 - Made with draft 16 of the project, as a way of testing all the elements that the engine can render. This collection will of course change in future - as the character and string elements are added - but with the addition of the image element and its auto-update feature, I wanted to share how it is right now.</p>
                <p>In this demo you can see that we've expanded from just being able to render a rectangle (and the group). Now available are:</p>
                <ul>
                    <li>Rectangle With Outline</li>
                    <li>Circle</li>
                    <li>Circle With Outline</li>
                    <li>Polygon</li>
                    <li>Polygon With Outline</li>
                    <li>Path</li>
                    <li>Image</li>
                </ul>
                <img style="width: 100%;" src="/next/images/element_test_1.png"></img>
                <p>You'll notice that this demo also comes with an "images" folder, which contains the file used in the Image element: "colour_squares.jpg". You can modify this file how you like and the system will render it. Whats more; you don't have to restart the program for those updates to take effect. The engine is constantly checking that file every second for changes, so once you press save in your editor - the engine will reload and re-render the image automatically.</p>
                <h3>Downloads</h3>
                <p><a href="/next/apps/element_test_1/macos/10.11/element_test_1.zip">MacOS 10.11</a></p>
                <p><a href="/next/apps/element_test_1/windows10/element_test_1.zip">Windows 10</a></p>
            </div>

            <div class="card">
                <h2>Chrome Update - 09/06/2021</h2>
                <p>Recently I've noticed that it appears some changes have been made to Chrome that stop the crash from occurring. Unfortunately, these changes haven't entirely solved the issue as now instead of crashing Chrome instead seems to enter enormous difficulty with a heavily reduced frame-rate - which isn't super promising.</p>
                <p>There's also been no comment on the bug report page <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1149413">https://bugs.chromium.org/p/chromium/issues/detail?id=1149413</a></p>
            </div>

            <div class="card">
                <h2>Callback Interaction</h2>
                <p>2021-03-15 - Made with draft 15 of the project, as a way of testing the callback section of the rendering engine. </p>
                <p>This section handles mouse and keyboard interaction, mapping those actions against the elements arranged on screen, allowing the actions to relate to those elements. In turn, elements can activate certain callbacks ("onmousedown" or "onkeydown" for example). When an action occurs that coincides with an element who has activated a callback that matches this action; an event is made which the outer system can collect and work with.</p>
                <p>Mousing over the rectangles on screen will cause them to glow. The square at the top right of the screen will react to mouse wheel motion, both in the x and y directions. Double-clicking this square will change the "activation mode", which determines how the system deals with elements that are layered on top of one another</p>
                <img style="width: 100%;" src="/next/images/callback_interaction.jpg"></img>
                <h3>Downloads</h3>
                <p><a href="/next/apps/callback_interaction/macos/10.11/callback_interaction.zip">MacOS 10.11</a></p>
                <p><a href="/next/apps/callback_interaction/windows10/callback_interaction.zip">Windows 10</a></p>
            </div>

            <div class="card">
                <h2>Wavey Boxes</h2>
                <p>The world famous, original recipe, EU approved, religiously important, oscar nominated, executive deluxe luxury edition visualisation program that has taken the world by storm and that all the kids are talking about, is here. That's right, Wavey Boxes has made it to desktop.</p>
                <p>2021-02-19 - Made with draft 12 of the project, as a way of testing the inter-process rendering communication, along with the system's ability to perform long-term state-based game-like actions (instead of just rendering a single frame). The wave patterns are calculated on the spot, as are the randomly selected colours.</p>
                <img style="width: 100%;" src="/next/images/wavey_boxes.png"></img>
                <h3>Downloads</h3>
                <p><a href="/next/apps/wavey_boxes/macos/10.11/wavey_boxes.zip">MacOS 10.11</a></p>
                <p><a href="/next/apps/wavey_boxes/windows10/wavey_boxes.zip">Windows 10</a></p>
            </div>

            <div class="card">
                <h2>Rectangle Count Test</h2>
                <p>Based on draft 8 of the project, these are applications used to test just how many rectangles the engine can produce and render. I recommend building up from the smallest value, and probably not running the 10m one at all.</p>
                <img style="width: 100%;" src="/next/images/render_rectangle_count_test.jpg"></img>
                <h3>Downloads</h3>
                <p><a href="/next/apps/render_rectangle_count_test/macos/11.2.zip">MacOS 11.2</a></p>
                <p><a href="/next/apps/render_rectangle_count_test/windows10/tests.zip">Windows 10</a></p>
            </div>

            <div class="card">
                <h2>Going Native</h2>
                <p>So far its been a little of an uphill battle, and I don't expect it to have similar functionality to the website version for some time - I have yet to even look at how I'm going to do audio. I hope however that by the end of this year (2021) I will have a large chunk of the program together. Alongside, I will also be working on the website. Partly so that if the bug is ever fixed, I don't feel like I've left it to languish for all this time. Partly so I don't feel like I'm eternally in this loop of restarting.</p>
                <p>I am using WGPU for the graphical back-end. Luckily I had most of a rendering engine already written in Rust as I had been rewriting most of the website version's rendering engine to use webASM, so I was able to copy over a lot of that code into this project and currently have a version of the engine working nicely. At the moment it can only render rectangles, but I have tested it on my desktop as being able to render around 2,000,000 rectangles in a second. Much faster than the top-speed I could get from the website version, which was about 720,000. Also thanks to the fact I could copy a lot of it over, the engine already has a moveable viewport, element render judgements, frame skipping, stencilling, a tree-based element data structure, extremity calculation, and more. Plus all the mouse/keyboard interaction code that I had been working on most recently. And one or two small editions along the way that I forgot to add in the website version, for example, multi-level stencilling. Much has had to change thanks to the switch from webGL to WGPU which has added a whole new host of issues, but I'm confident that it's shaping up to be a faster and more stable version of the engine. I hope in future to re-write certain parts to expand functionality, though currently I am trying only to match what the original can do.</p>
                <p>I'm going to keep the code secret for now, but above you can find completed applications that I've put together as I develop the larger project.</p>
            </div>

        </div>

    </body>

</html>