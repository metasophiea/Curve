(function() {
    const __canvasPrefix = 'curve';
    const __canvasElements = document.getElementsByTagName('canvas');
    for(let __canvasElements_count = 0; __canvasElements_count < __canvasElements.length; __canvasElements_count++){
        if( __canvasElements[__canvasElements_count].hasAttribute(__canvasPrefix) ){
            const _canvas_ = __canvasElements[__canvasElements_count];
            _canvas_.layers = new function(){
                const layerRegistry = {};
            
                this.registerLayerLoaded = function(layerName, layer){
                    if(layerRegistry[layerName] == undefined){ layerRegistry[layerName] = {}; }
                    layerRegistry[layerName].isLoaded = true;
                    layerRegistry[layerName].versionInformation = layer.versionInformation;
                    if(this.onLayerLoad){this.onLayerLoad(layerName,layerRegistry);}
                };
                this.onLayerLoad = function(layerName,layerRegistry){};
            
                this.getVersionInformation = function(){
                    return Object.keys(layerRegistry).map(key => { return {name:key, data:layerRegistry[key].versionInformation} });
                };
            };
            _canvas_.library = new function(){
                this.versionInformation = { tick:0, lastDateModified:{y:2020,m:3,d:8} };
                const library = this;
            
                this.go = new function(){
                    const functionList = [];
            
                    this.add = function(newFunction){ functionList.push(newFunction); };
                    this.__activate = function(){ functionList.forEach(f => f()); };
                };
                
                const dev = {
                    prefix:'library',
                
                    active:{ math:false, structure:false, audio:false, font:false, misc:false },
                
                    log:{
                        math:function(){
                            if(!dev.active.math){return;}
                            console.log( dev.prefix+'.math'+arguments[0], ...(new Array(...arguments).slice(1)) );
                        },
                        structure:function(){
                            if(!dev.active.structure){return;}
                            console.log( dev.prefix+'.structure'+arguments[0], ...(new Array(...arguments).slice(1)) );
                        },
                        audio:function(){
                            if(!dev.active.audio){return;}
                            console.log( dev.prefix+'.audio'+arguments[0], ...(new Array(...arguments).slice(1)) );
                        },
                        font:function(){
                            if(!dev.active.font){return;}
                            console.log( dev.prefix+'.font'+arguments[0], ...(new Array(...arguments).slice(1)) );
                        },
                        misc:function(){
                            if(!dev.active.misc){return;}
                            console.log( dev.prefix+'.misc'+arguments[0], ...(new Array(...arguments).slice(1)) );
                        },
                    },
                
                    countActive:false,
                    countMemory:{},
                    count:function(commandTag){
                        if(!dev.countActive){return;}
                        if(commandTag in dev.countMemory){ dev.countMemory[commandTag]++; }
                        else{ dev.countMemory[commandTag] = 1; }
                    },
                    countResults:function(){return countMemory;},
                };
                
                this.math = new function(){
                    this.averageArray = function(array){
                    
                        // return array.reduce( ( p, c ) => p + c, 0 ) / array.length
                    
                        //this seems to be a little faster
                        let sum = array[0];
                        for(let a = 1; a < array.length; a++){ sum += array[a]; }
                        return sum/array.length;
                    };
                    this.averagePoint = function(points){
                    
                        const sum = points.reduce((a,b) => {return {x:(a.x+b.x),y:(a.y+b.y)};} );
                        return {x:sum.x/points.length,y:sum.y/points.length};
                    };
                    this.boundingBoxFromPoints = function(points){
                    
                        if(points.length == 0){
                            return { topLeft:{x:0,y:0}, bottomRight:{x:0,y:0} };
                        }
                    
                        if(points.length == 1){
                            return { topLeft:{x:points[0].x,y:points[0].y}, bottomRight:{x:points[0].x,y:points[0].y} };
                        }
                    
                        if(points.length == 2){
                            if(points[0].x < points[1].x){
                                if(points[0].y < points[1].y){
                                    return {
                                        topLeft:{x:points[0].x,y:points[0].y},
                                        bottomRight:{x:points[1].x,y:points[1].y},
                                    };
                                }else{
                                    return {
                                        topLeft:{x:points[0].x,y:points[1].y},
                                        bottomRight:{x:points[1].x,y:points[0].y},
                                    };
                                }
                            }else{
                                if(points[0].y < points[1].y){
                                    return {
                                        topLeft:{x:points[1].x,y:points[0].y},
                                        bottomRight:{x:points[0].x,y:points[1].y},
                                    };
                                }else{
                                    return {
                                        topLeft:{x:points[1].x,y:points[1].y},
                                        bottomRight:{x:points[0].x,y:points[0].y},
                                    };
                                }
                            }
                        }
                    
                        let left = points[0].x; let right = points[0].x;
                        let top = points[0].y;  let bottom = points[0].y;
                    
                        for(let a = 1; a < points.length; a++){
                            if( points[a].x < left ){ left = points[a].x; }
                            else if(points[a].x > right){ right = points[a].x; }
                    
                            if( points[a].y < top ){ top = points[a].y; }
                            else if(points[a].y > bottom){ bottom = points[a].y; }
                        }
                    
                        return {
                            topLeft:{x:left,y:top},
                            bottomRight:{x:right,y:bottom}
                        };
                    };
                    this.cartesianAngleAdjust = function(x,y,angle){
                    
                        // //v1    
                        //     if(angle == 0){ return {x:x,y:y}; }
                        //     if(angle == Math.PI){ return {x:-x,y:-y}; }
                        //     if(angle == Math.PI*0.5){ return {x:-y,y:x}; }
                        //     if(angle == Math.PI*1.5){ return {x:y,y:-x}; }
                    
                        //     const polar = library.math.cartesian2polar( x, y );
                        //     polar.ang += angle;
                        //     return library.math.polar2cartesian( polar.ang, polar.dis );
                        
                        //v2    
                            if(angle == 0){ return {x:x,y:y}; }
                            return { x:x*Math.cos(angle) - y*Math.sin(angle), y:y*Math.cos(angle) + x*Math.sin(angle) };
                    };
                    this.convertColour = new function(){
                        this.obj2rgba = function(obj){
                    
                            return 'rgba('+obj.r*255+','+obj.g*255+','+obj.b*255+','+obj.a+')';
                        };
                        this.rgba2obj = function(rgba){
                    
                            rgba = rgba.split(',');
                            rgba[0] = rgba[0].replace('rgba(', '');
                            rgba[3] = rgba[3].replace(')', '');
                            rgba = rgba.map(function(a){return parseFloat(a);})
                            return {r:rgba[0]/255,g:rgba[1]/255,b:rgba[2]/255,a:rgba[3]};
                        };
                    };
                    this.curveGenerator = new function(){
                        this.linear = function(stepCount=2, start=0, end=1){
                    
                            stepCount = Math.abs(stepCount)-1;
                            const outputArray = [0];
                            for(let a = 1; a < stepCount; a++){ 
                                outputArray.push(a/stepCount);
                            }
                            outputArray.push(1); 
                    
                            const mux = end-start;
                            for(let a = 0 ; a < outputArray.length; a++){
                                outputArray[a] = outputArray[a]*mux + start;
                            }
                    
                            return outputArray;
                        };
                        this.sin = function(stepCount=2, start=0, end=1){
                    
                            stepCount = Math.abs(stepCount) -1;
                            let outputArray = [0];
                            for(let a = 1; a < stepCount; a++){ 
                                outputArray.push(
                                    Math.sin( Math.PI/2*(a/stepCount) )
                                );
                            }
                            outputArray.push(1); 
                    
                            const mux = end-start;
                            for(let a = 0 ; a < outputArray.length; a++){
                                outputArray[a] = outputArray[a]*mux + start;
                            }
                    
                            return outputArray;		
                        };
                        this.cos = function(stepCount=2, start=0, end=1){
                    
                            stepCount = Math.abs(stepCount) -1;
                            let outputArray = [0];
                            for(let a = 1; a < stepCount; a++){ 
                                outputArray.push(
                                    1 - Math.cos( Math.PI/2*(a/stepCount) )
                                );
                            }
                            outputArray.push(1); 
                    
                            const mux = end-start;
                            for(let a = 0 ; a < outputArray.length; a++){
                                outputArray[a] = outputArray[a]*mux + start;
                            }
                    
                            return outputArray;	
                        };
                        this.s = function(stepCount=2, start=0, end=1, sharpness=8){
                    
                            if(sharpness == 0){sharpness = 1/1000000;}
                    
                            let curve = [];
                            for(let a = 0; a < stepCount; a++){
                                curve.push(
                                    1/( 1 + Math.exp(-sharpness*((a/stepCount)-0.5)) )
                                );
                            }
                    
                            const outputArray = library.math.normalizeStretchArray(curve);
                    
                            const mux = end-start;
                            for(let a = 0 ; a < outputArray.length; a++){
                                outputArray[a] = outputArray[a]*mux + start;
                            }
                    
                            return outputArray;
                        };
                        this.sigmoid = function(stepCount=2, start=0, end=1, sharpness=0.5){
                            if(sharpness < 0){sharpness = 0;}
                            if(sharpness > 1){sharpness = 1;}
                    
                            stepCount--;
                    
                            let curve = [];
                            for(let a = 0; a <= stepCount; a++){
                                const x = a/stepCount;
                                curve.push(
                                    0.5 + ( ((2*x) - 1) / ( 1 - sharpness + sharpness*Math.abs((2*x) - 1) ) )/2
                                );
                            }
                    
                            const mux = end-start;
                            for(let a = 0 ; a < curve.length; a++){
                                curve[a] = curve[a]*mux + start;
                            }
                    
                            return curve;
                        };
                        this.halfSigmoid_up = function(stepCount=2, start=0, end=1, sharpness=0.5){
                            if(sharpness < 0){sharpness = 0;}
                            if(sharpness > 1){sharpness = 1;}
                    
                            let curve = [];
                    
                            stepCount--;
                            for(let a = 0; a <= stepCount; a++){
                                const x = a/stepCount;
                                curve.push( library.math.curvePoint.halfSigmoid_up(x,start,end,sharpness) );
                            }
                    
                            return curve;
                        };
                        this.halfSigmoid_down = function(stepCount=2, start=0, end=1, sharpness=0.5){
                            if(sharpness < 0){sharpness = 0;}
                            if(sharpness > 1){sharpness = 1;}
                    
                            let curve = [];
                    
                            stepCount--;
                            for(let a = 0; a <= stepCount; a++){
                                const x = a/stepCount;
                                curve.push( library.math.curvePoint.halfSigmoid_down(x,start,end,sharpness) );
                            }
                    
                            return curve;
                        };
                        this.exponential = function(stepCount=2, start=0, end=1, sharpness=2){
                    
                            stepCount = stepCount-1;
                            let outputArray = [];
                            
                            for(let a = 0; a <= stepCount; a++){
                                outputArray.push( (Math.exp(sharpness*(a/stepCount))-1)/(Math.E-1) ); // Math.E == Math.exp(1)
                            }
                    
                            outputArray = library.math.normalizeStretchArray(outputArray);
                    
                            const mux = end-start;
                            for(let a = 0 ; a < outputArray.length; a++){
                                outputArray[a] = outputArray[a]*mux + start;
                            }
                    
                            return outputArray;
                        };
                    };
                    this.curvePoint = new function(){
                        this.linear = function(x=0.5, start=0, end=1){
                    
                            return x *(end-start)+start;
                        };
                        this.sin = function(x=0.5, start=0, end=1){
                    
                            return Math.sin(Math.PI/2*x) *(end-start)+start;
                        };
                        this.cos = function(x=0.5, start=0, end=1){
                    
                            return (1-Math.cos(Math.PI/2*x)) *(end-start)+start;
                        };
                        this.s = function(x=0.5, start=0, end=1, sharpness=8){
                    
                            const temp = library.math.normalizeStretchArray([
                                1/( 1 + Math.exp(-sharpness*(0-0.5)) ),
                                1/( 1 + Math.exp(-sharpness*(x-0.5)) ),
                                1/( 1 + Math.exp(-sharpness*(1-0.5)) ),
                            ]);
                            return temp[1] *(end-start)+start;
                        };
                        this.sigmoid = function(x=0.5, start=0, end=1, sharpness=0.5){
                    
                            return ( 0.5 + ( ((2*x) - 1) / ( 1 - sharpness + sharpness*Math.abs((2*x) - 1) ) )/2 ) *(end-start)+start;
                        };
                        this.halfSigmoid_up = function(x=0.5, start=0, end=1, sharpness=0.5){
                    
                            return (x / ( 1 - sharpness + sharpness*Math.abs(x))) *(end-start)+start;
                        };
                        this.halfSigmoid_down = function(x=0.5, start=0, end=1, sharpness=0.5){
                    
                            return library.math.curvePoint.halfSigmoid_up(1-x,end,start,sharpness);
                        };
                        this.exponential = function(x=0.5, start=0, end=1, sharpness=2){
                    
                            const temp = library.math.normalizeStretchArray([
                                (Math.exp(sharpness*0)-1)/(Math.E-1),
                                (Math.exp(sharpness*x)-1)/(Math.E-1),
                                (Math.exp(sharpness*1)-1)/(Math.E-1),
                            ]);
                            return temp[1] *(end-start)+start;
                        };
                    };
                    this.getAngleOfTwoPoints = function(point_1,point_2){
                    
                        if(point_1.x == point_2.x && point_1.y == point_2.y){return 0;}
                    
                        const xDelta = point_2.x - point_1.x;
                        const yDelta = point_2.y - point_1.y;
                        let angle = Math.atan( yDelta/xDelta );
                    
                        if(xDelta < 0){ angle = Math.PI + angle; }
                        else if(yDelta < 0){ angle = Math.PI*2 + angle; }
                    
                        return angle;
                    };
                    this.getIndexOfSequence = function(array,sequence){ 
                    
                        function comp(thing_A,thing_B){
                            const keys = Object.keys(thing_A);
                            if(keys.length == 0){ return thing_A == thing_B; }
                    
                            for(let a = 0; a < keys.length; a++){
                                if( !thing_B.hasOwnProperty(keys[a]) ){ return false; }
                                if( thing_A[keys[a]] != thing_B[keys[a]] ){ return false; }
                            }
                            return true;
                        }
                    
                        if(array.length == 0 || sequence.length == 0){return undefined;}
                    
                        let index = 0;
                        for(index = 0; index < array.length - sequence.length + 1; index++){
                            if( comp(array[index], sequence[0]) ){
                                let match = true;
                                for(let a = 1; a < sequence.length; a++){
                                    if( !comp(array[index+a],sequence[a]) ){
                                        match = false;
                                        break;
                                    }
                                }
                                if(match){return index;}
                            }
                        }
                    
                        return undefined;
                    };
                    this.largestValueFound = function(array){
                    
                        if(array.length == 0){return undefined;}
                        return array.reduce(function(max,current){
                            return Math.abs(max) > Math.abs(current) ? max : current;
                        });
                    };
                    this.normalizeStretchArray = function(array){
                    
                        //discover the largest number
                            const biggestIndex = array.reduce( function(oldIndex, currentValue, index, array){ return currentValue > array[oldIndex] ? index : oldIndex; }, 0);
                    
                        //divide everything by this largest number, making everything a ratio of this value 
                            const dux = Math.abs(array[biggestIndex]);
                            array = array.map(x => x / dux);
                    
                        //stretch the other side of the array to meet 0 or 1
                            if(array[0] == 0 && array[array.length-1] == 1){return array;}
                            const pertinentValue = array[0] != 0 ? array[0] : array[array.length-1];
                            array = array.map(x => (x-pertinentValue)/(1-pertinentValue) );
                    
                        return array;
                    };
                    this.relativeDistance = function(realLength, start,end, d, allowOverflow=false){
                    
                        const mux = (d - start)/(end - start);
                        if(!allowOverflow){ if(mux > 1){return realLength;}else if(mux < 0){return 0;} }
                        return mux*realLength;
                    };
                    this.seconds2time = function(seconds){
                    
                        const result = {h:0, m:0, s:0, ms:0, µs:0, ns:0, ps:0, fs:0};
                        
                        result.h = Math.floor(seconds/3600);
                        seconds = seconds - result.h*3600;
                        if(seconds <= 0){return result;}
                    
                        result.m = Math.floor(seconds/60);
                        seconds = seconds - result.m*60;
                        if(seconds <= 0){return result;}
                    
                        result.s = Math.floor(seconds);
                        seconds = seconds - result.s;
                        if(seconds <= 0){return result;}
                    
                        result.ms = Math.floor(seconds*1000);
                        seconds = seconds*1000 - result.ms;
                        if(seconds <= 0){return result;}
                    
                        result.µs = Math.floor(seconds*1000);
                        seconds = seconds*1000 - result.µs;
                        if(seconds <= 0){return result;}
                    
                        result.ns = Math.floor(seconds*1000);
                        seconds = seconds*1000 - result.ns;
                        if(seconds <= 0){return result;}
                    
                        result.ps = Math.floor(seconds*1000);
                        seconds = seconds*1000 - result.ps;
                        if(seconds <= 0){return result;}
                    
                        result.fs = seconds*1000;
                        
                        return result;
                    };
                    
                    this.distanceBetweenTwoPoints = function(point_a,point_b){
                        return Math.hypot(point_b.x-point_a.x, point_b.y-point_a.y);
                    };
                    this.cartesian2polar = function(x,y){
                    
                        const dis = Math.pow(Math.pow(x,2)+Math.pow(y,2),0.5);
                        let ang = 0;
                    
                        if(x === 0){
                            if(y === 0){ang = 0;}
                            else if(y > 0){ang = 0.5*Math.PI;}
                            else{ang = 1.5*Math.PI;}
                        }
                        else if(y === 0){
                            if(x >= 0){ang = 0;}else{ang = Math.PI;}
                        }
                        else if(x >= 0){ ang = Math.atan(y/x); }
                        else{ /*if(x < 0)*/ ang = Math.atan(y/x) + Math.PI; }
                    
                        return {'dis':dis,'ang':ang};
                    };
                    this.polar2cartesian = function(angle,distance){
                    
                        return {'x':(distance*Math.cos(angle)), 'y':(distance*Math.sin(angle))};
                    };
                    
                    this.blendColours = function(rgba_1,rgba_2,ratio){
                    
                        return {
                            r: (1-ratio)*rgba_1.r + ratio*rgba_2.r,
                            g: (1-ratio)*rgba_1.g + ratio*rgba_2.g,
                            b: (1-ratio)*rgba_1.b + ratio*rgba_2.b,
                            a: (1-ratio)*rgba_1.a + ratio*rgba_2.a,
                        };           
                    };
                    this.multiBlendColours = function(rgbaList,ratio){
                    
                        //special cases
                            if(ratio == 0){return rgbaList[0];}
                            if(ratio == 1){return rgbaList[rgbaList.length-1];}
                        //calculate the start colour and ratio(represented by as "colourIndex.ratio"), then blend
                            const p = ratio*(rgbaList.length-1);
                            return library.math.blendColours(rgbaList[~~p],rgbaList[~~p+1], p%1);
                    };
                    
                    
                    
                    this.polygonToSubTriangles = function(regions,inputFormat='XYArray'){
                    
                        if(inputFormat == 'flatArray'){
                            const tmp = [];
                            for(let a = 0; a < regions.length; a+=2){ tmp.push( {x:regions[a+0], y:regions[a+1]} ); }
                            regions = [tmp];
                        }
                    
                        const holes = regions.reverse().map(region => region.length);
                        holes.forEach((item,index) => { if(index > 0){ holes[index] = item + holes[index-1]; } });
                        holes.pop();
                    
                        return _thirdparty.earcut(regions.flat().map(item => [item.x,item.y]).flat(),holes);
                    };
                    this.unionPolygons = function(polygon1,polygon2){
                    
                        //martinez (not working)
                        // for(let a = 0; a < polygon1.length; a++){
                        //     polygon1[a].push( polygon1[a][0] );
                        // }
                        // for(let a = 0; a < polygon2.length; a++){
                        //     polygon2[a].push( polygon2[a][0] );
                        // }
                    
                        // const ans = _thirdparty.martinez.union(
                        //     polygon1.map(region => region.map(item => [item.x,item.y])  ),
                        //     polygon2.map(region => region.map(item => [item.x,item.y])  )
                        // );
                        // return ans.flat().map(region => region.map(item => ({x:item[0],y:item[1]})));
                    
                        //PolyBool
                        return _thirdparty.PolyBool.union(
                            {regions:polygon1.map(region => region.map(item => [item.x,item.y]))}, 
                            {regions:polygon2.map(region => region.map(item => [item.x,item.y]))}
                        ).regions.map(region => region.map(item => ({x:item[0],y:item[1]})));
                    }
                    this.detectIntersect = new function(){
                        this.boundingBoxes = function(box_a, box_b){
                    
                            return box_a.bottomRight.y >= box_b.topLeft.y && 
                                box_a.bottomRight.x >= box_b.topLeft.x && 
                                box_a.topLeft.y <= box_b.bottomRight.y && 
                                box_a.topLeft.x <= box_b.bottomRight.x;
                        };
                    
                        this.pointWithinBoundingBox = function(point,box){
                            return !(
                                point.x < box.topLeft.x     ||  point.y < box.topLeft.y     ||
                                point.x > box.bottomRight.x ||  point.y > box.bottomRight.y
                            );
                        };
                        this.pointOnLine = function(point,line){
                            
                            if( 
                                point.x < line[0].x && point.x < line[1].x ||
                                point.y < line[0].y && point.y < line[1].y ||
                                point.x > line[0].x && point.x > line[1].x ||
                                point.y > line[0].y && point.y > line[1].y
                            ){return false;}
                    
                            if(point.x == line[0].x && point.y == line[0].y){ return true; }
                            if(point.x == line[1].x && point.y == line[1].y){ return true; }
                            if(line[0].x == line[1].x && point.x == line[0].x){
                                return (line[0].y > point.y && point.y > line[1].y) || (line[1].y > point.y && point.y > line[0].y);
                            }
                            if(line[0].y == line[1].y && point.y == line[0].y){
                                return (line[0].x > point.x && point.x > line[1].x) || (line[1].x > point.x && point.x > line[0].x);
                            }
                    
                            return ((line[1].y - line[0].y) / (line[1].x - line[0].x))*(point.x - line[0].x) + line[0].y - point.y == 0;
                        }
                        this.pointWithinPoly = function(point,poly){
                    
                            if(poly.boundingBox == undefined){ poly.boundingBox = library.math.boundingBoxFromPoints(poly.points); }
                            if( !library.math.detectIntersect.boundingBoxes( library.math.boundingBoxFromPoints([point]), poly.boundingBox ) ){ return 'outside'; }
                    
                            // outside / onPoint / onEdge / inside
                    
                            //check if the point is on a point of the poly; bail and return 'onPoint'
                            for(let a = 0; a < poly.points.length; a++){
                                if( point.x == poly.points[a].x && point.y == poly.points[a].y ){
                                    return 'onPoint';
                                }
                            }
                    
                            function pointLevelWithPolyPointChecker(poly,point,a,b){
                                //only flip, if the point is not perfectly level with point a of the line 
                                //or if you can prove that the a's two adjacent points are higher and lower than the matching point's level
                                //(the system will come round to having this same point be point b)
                                if( poly.points[a].y != point.y && poly.points[b].y != point.y ){
                                    return true;
                                }else if(poly.points[a].y == point.y){
                                    const pointInFront = a+1 >= poly.points.length ? 0 : a+1;
                                    const pointBehind = a-1 <= 0 ? poly.points.length-1 : a-1;
                                    if(
                                        poly.points[pointBehind].y <= poly.points[a].y && poly.points[pointInFront].y <= poly.points[a].y ||
                                        poly.points[pointBehind].y >= poly.points[a].y && poly.points[pointInFront].y >= poly.points[a].y
                                    ){
                                    }else{
                                        return true;
                                    }
                                }
                    
                                return false;
                            }
                    
                            //Ray casting algorithm
                            let inside = false;
                            for(let a = 0, b = poly.points.length - 1; a < poly.points.length; b = a++){
                    
                                //point must be on the same level of the line
                                if( (poly.points[b].y >= point.y && poly.points[a].y <= point.y) || (poly.points[a].y >= point.y && poly.points[b].y <= point.y) ){
                                    //discover if the point is on the far right of the line
                                    if( poly.points[a].x < point.x && poly.points[b].x < point.x ){
                                        //only flip if the line is not perfectly level (which would make the ray skirt the line)
                                        if( poly.points[a].y != poly.points[b].y ){
                                            if( pointLevelWithPolyPointChecker(poly,point,a,b) ){
                                                inside = !inside;
                                            }
                                        }
                    
                                    //discover if the point is on the far left of the line, skip it if so
                                    }else if( poly.points[a].x > point.x && poly.points[b].x > point.x ){
                                        continue;
                                    }else{
                                        //calculate what side of the line this point is
                                            let areaLocation;
                                            if( poly.points[b].y > poly.points[a].y && poly.points[b].x > poly.points[a].x ){
                                                areaLocation = (point.x-poly.points[a].x)/(poly.points[b].x-poly.points[a].x) - (point.y-poly.points[a].y)/(poly.points[b].y-poly.points[a].y) + 1;
                                            }else if( poly.points[b].y <= poly.points[a].y && poly.points[b].x <= poly.points[a].x ){
                                                areaLocation = (point.x-poly.points[b].x)/(poly.points[a].x-poly.points[b].x) - (point.y-poly.points[b].y)/(poly.points[a].y-poly.points[b].y) + 1;
                                            }else if( poly.points[b].y > poly.points[a].y && poly.points[b].x < poly.points[a].x ){
                                                areaLocation = (point.x-poly.points[b].x)/(poly.points[a].x-poly.points[b].x) + (point.y-poly.points[a].y)/(poly.points[b].y-poly.points[a].y);
                                            }else if( poly.points[b].y <= poly.points[a].y && poly.points[b].x >= poly.points[a].x ){
                                                areaLocation = (point.x-poly.points[a].x)/(poly.points[b].x-poly.points[a].x) + (point.y-poly.points[b].y)/(poly.points[a].y-poly.points[b].y);
                                            }
                    
                                        //if its on the line, return 'onEdge' immediately, if it's above 1 do a flip
                                            if( areaLocation == 1 || isNaN(areaLocation) ){
                                                return 'onEdge';
                                            }else if(areaLocation > 1){
                                                if( pointLevelWithPolyPointChecker(poly,point,a,b) ){
                                                    inside = !inside;
                                                }
                                            }
                                    }
                                }else{
                                }
                            }
                    
                            return inside ? 'inside' : 'outside';
                        };
                    
                        this.lineOnLine = function(segment1,segment2){
                    
                            if( !library.math.detectIntersect.boundingBoxes( library.math.boundingBoxFromPoints(segment1), library.math.boundingBoxFromPoints(segment2) ) ){
                                return {x:undefined, y:undefined, intersect:false, contact:false};
                            }
                    
                            //identical segments
                            if(
                                (segment1[0].x == segment2[0].x && segment1[0].y == segment2[0].y) && (segment1[1].x == segment2[1].x && segment1[1].y == segment2[1].y) ||
                                (segment1[0].x == segment2[1].x && segment1[0].y == segment2[1].y) && (segment1[1].x == segment2[0].x && segment1[1].y == segment2[0].y)
                            ){
                                return {x:undefined, y:undefined, intersect:false, contact:true};
                            }
                                
                            //point on point
                            if( (segment1[0].x == segment2[0].x && segment1[0].y == segment2[0].y) || (segment1[0].x == segment2[1].x && segment1[0].y == segment2[1].y) ){
                                return {x:segment1[0].x, y:segment1[0].y, intersect:false, contact:true};
                            }
                            if( (segment1[1].x == segment2[0].x && segment1[1].y == segment2[0].y) || (segment1[1].x == segment2[1].x && segment1[1].y == segment2[1].y) ){
                                return {x:segment1[1].x, y:segment1[1].y, intersect:false, contact:true};
                            }
                    
                            //calculate denominator
                            const denominator = (segment2[1].y-segment2[0].y)*(segment1[1].x-segment1[0].x) - (segment2[1].x-segment2[0].x)*(segment1[1].y-segment1[0].y);
                            if(denominator == 0){
                                const points = [];
                                const output = {x1:undefined, y1:undefined, x2:undefined, y2:undefined, intersect:false, contact:true};
                                if( library.math.detectIntersect.pointOnLine(segment1[0],segment2) ){
                                    output.x1 = segment1[0].x;
                                    output.y1 = segment1[0].y;
                                }
                                if( library.math.detectIntersect.pointOnLine(segment1[1],segment2) ){
                                    if(output.x1 == undefined){
                                        output.x1 = segment1[1].x;
                                        output.y1 = segment1[1].y;
                                    }else{
                                        output.x2 = segment1[1].x;
                                        output.y2 = segment1[1].y;
                                        return output;
                                    }
                                }
                                if( library.math.detectIntersect.pointOnLine(segment2[0],segment1) ){
                                    if(output.x1 == undefined){
                                        output.x1 = segment2[0].x;
                                        output.y1 = segment2[0].y;
                                    }else{
                                        output.x2 = segment2[0].x;
                                        output.y2 = segment2[0].y;
                                        return output;
                                    }
                                }
                                if( library.math.detectIntersect.pointOnLine(segment2[1],segment1) ){
                                    if(output.x1 == undefined){
                                        output.x1 = segment2[1].x;
                                        output.y1 = segment2[1].y;
                                    }else{
                                        output.x2 = segment2[1].x;
                                        output.y2 = segment2[1].y;
                                        return output;
                                    }
                                }
                    
                                return output;
                            }
                                
                            //point on line
                            if( library.math.detectIntersect.pointOnLine(segment1[0],segment2) ){ return {x:segment1[0].x, y:segment1[0].y, intersect:false, contact:true}; }
                            if( library.math.detectIntersect.pointOnLine(segment1[1],segment2) ){ return {x:segment1[1].x, y:segment1[1].y, intersect:false, contact:true}; }
                            if( library.math.detectIntersect.pointOnLine(segment2[0],segment1) ){ return {x:segment2[0].x, y:segment2[0].y, intersect:false, contact:true}; }
                            if( library.math.detectIntersect.pointOnLine(segment2[1],segment1) ){ return {x:segment2[1].x, y:segment2[1].y, intersect:false, contact:true}; }
                    
                            //produce output
                            const u1 = ((segment2[1].x-segment2[0].x)*(segment1[0].y-segment2[0].y) - (segment2[1].y-segment2[0].y)*(segment1[0].x-segment2[0].x))/denominator;
                            const u2 = ((segment1[1].x-segment1[0].x)*(segment1[0].y-segment2[0].y) - (segment1[1].y-segment1[0].y)*(segment1[0].x-segment2[0].x))/denominator;
                            const intersect = (u1 >= 0 && u1 <= 1) && (u2 >= 0 && u2 <= 1);
                            return {
                                x:         (segment1[0].x + u1*(segment1[1].x-segment1[0].x)),
                                y:         (segment1[0].y + u1*(segment1[1].y-segment1[0].y)),
                                intersect: intersect,
                                contact:   intersect,
                            };
                        };
                        this.lineOnPoly = function(line,poly){
                    
                            if(poly.boundingBox == undefined){ poly.boundingBox = library.math.boundingBoxFromPoints(poly.points); }
                            if( !library.math.detectIntersect.boundingBoxes( library.math.boundingBoxFromPoints(line), poly.boundingBox ) ){
                                return { points:[], intersect:false, contact:false };
                            }
                    
                            function oneWhileTheOtherIs(val_1,val_2,a,b){
                                if( val_1 == a && val_2 == b ){return 1;}
                                if( val_2 == a && val_1 == b ){return 2;}
                                return 0;
                            }
                            function huntForIntersection(line,polyPoints){
                                for(let a = polyPoints.length-1, b = 0; b < polyPoints.length; a = b++){
                                    const result = library.math.detectIntersect.lineOnLine(line,[polyPoints[a],polyPoints[b]]);
                                    if(result.contact){
                                        output.contact = true;
                                        if(result.intersect){
                                            output.intersect = true;
                                        }
                    
                                        if( result.x != undefined && (result.x != line[0].x && result.x != line[1].x) ){
                                            output.intersect = true;
                                        }
                    
                                        //if the result is a range of values, add the ends of this range
                                            if( result.x2 != undefined ){
                                                if( output.points.find(item => item.x == result.x1 && item.y == result.y1 ) == undefined ){
                                                    output.points.push({x:result.x1,y:result.y1});
                                                }
                                                if( output.points.find(item => item.x == result.x2 && item.y == result.y2 ) == undefined ){
                                                    output.points.push({x:result.x2,y:result.y2});
                                                }
                                                break;
                                            }
                    
                                        //add point, but don't add duplicate points
                                            if( output.points.find(item => item.x == result.x && item.y == result.y ) == undefined ){
                                                output.points.push({x:result.x,y:result.y});
                                            }
                                    }
                                }
                    
                                //situation where the line passes perfectly through a point on the poly
                                if(output.points.length == 0){
                                    for(let a = 0; a < poly.points.length; a++){
                                        if( poly.points[a].x != line[0].x && poly.points[a].y != line[0].y && poly.points[a].x != line[1].x && poly.points[a].y != line[1].y){
                                            if( library.math.detectIntersect.pointOnLine(poly.points[a],line) ){
                                                output.points.push(poly.points[a]);
                                                output.intersect = true;
                                            }
                                        }
                                    }
                                }
                            }
                    
                            const output = { points:[], contact:false, intersect:false };
                            const point_a = library.math.detectIntersect.pointWithinPoly(line[0],poly);
                            const point_b = library.math.detectIntersect.pointWithinPoly(line[1],poly);
                    
                            let dir = 0;
                            if( oneWhileTheOtherIs(point_a,point_b,'outside','outside') ){
                                huntForIntersection(line,poly.points);
                            }else if( dir = oneWhileTheOtherIs(point_a,point_b,'outside','onPoint') ){
                                huntForIntersection(line,poly.points);
                                // if(dir == 1){
                                //     output.points.push(line[1]);
                                // }else if(dir == 2){
                                //     output.points.push(line[0]);
                                // }
                                output.contact = true;
                            }else if( dir = oneWhileTheOtherIs(point_a,point_b,'outside','onEdge') ){
                                huntForIntersection(line,poly.points);
                                // if(dir == 1){
                                //     output.points.push(line[1]);
                                // }else if(dir == 2){
                                //     output.points.push(line[0]);
                                // }
                                output.contact = true;
                            }else if( oneWhileTheOtherIs(point_a,point_b,'outside','inside') ){
                                huntForIntersection(line,poly.points);
                                output.intersect = true;
                                output.contact = true;
                            }else if( oneWhileTheOtherIs(point_a,point_b,'onPoint','onPoint') ){
                                output.points = [line[0],line[1]];
                                output.contact = true;
                                output.intersect = library.math.detectIntersect.pointWithinPoly({ x:(output.points[0].x + output.points[1].x)/2, y:(output.points[0].y + output.points[1].y)/2 }, poly) == 'inside';
                            }else if( oneWhileTheOtherIs(point_a,point_b,'onPoint','onEdge') ){
                                output.points = [line[0],line[1]];
                                output.contact = true;
                                output.intersect = library.math.detectIntersect.pointWithinPoly({ x:(output.points[0].x + output.points[1].x)/2, y:(output.points[0].y + output.points[1].y)/2 }, poly) == 'inside';
                            }else if( dir = oneWhileTheOtherIs(point_a,point_b,'onPoint','inside') ){
                                if(dir == 1){
                                    output.points.push(line[1]);
                                }else if(dir == 2){
                                    output.points.push(line[0]);
                                }
                                output.contact = true;
                                output.intersect = true;
                            }else if( oneWhileTheOtherIs(point_a,point_b,'onEdge','onEdge') ){
                                output.points = [line[0],line[1]];
                                output.contact = true;
                                output.intersect = library.math.detectIntersect.pointWithinPoly({ x:(output.points[0].x + output.points[1].x)/2, y:(output.points[0].y + output.points[1].y)/2 }, poly) == 'inside';
                            }else if( dir = oneWhileTheOtherIs(point_a,point_b,'onEdge','inside') ){
                                if(dir == 1){
                                    output.points.push(line[1]);
                                }else if(dir == 2){
                                    output.points.push(line[0]);
                                }
                                output.contact = true;
                                output.intersect = true;
                            }else if( oneWhileTheOtherIs(point_a,point_b,'inside','inside') ){
                                output.intersect = true;
                                output.contact = false;
                            }
                            
                            return output;
                        };
                    
                        this.polyOnPoly = function(poly_a,poly_b){
                    
                            if(poly_a.boundingBox == undefined){ 
                                poly_a.boundingBox = library.math.boundingBoxFromPoints(poly_a.points);
                            }
                            if(poly_b.boundingBox == undefined){ 
                                poly_b.boundingBox = library.math.boundingBoxFromPoints(poly_b.points);
                            }
                            if( !library.math.detectIntersect.boundingBoxes( poly_a.boundingBox, poly_b.boundingBox ) ){
                                return { points:[], intersect:false, contact:false };
                            }
                    
                    
                            const results = {
                                points:[],
                                contact:false,
                                intersect:false,
                            };
                    
                            //identical polys
                                const sudo_poly_a_points = Object.assign([],poly_a.points);
                                poly_b.points.forEach(point_b => {
                                    const index = sudo_poly_a_points.indexOf(sudo_poly_a_points.find(point_a => point_a.x==point_b.x && point_a.y==point_b.y) );
                                    if(index != -1){sudo_poly_a_points.splice(index, 1);}
                                });
                                if(sudo_poly_a_points.length == 0){
                                    return {
                                        points:Object.assign([],poly_a.points),
                                        contact:true,
                                        intersect:true,
                                    };
                                }
                    
                            //find all side intersection points
                                for(let a_a = poly_a.points.length-1, a_b = 0; a_b < poly_a.points.length; a_a = a_b++){
                                    const tmp = library.math.detectIntersect.lineOnPoly([poly_a.points[a_a],poly_a.points[a_b]],poly_b);
                    
                                    results.points = results.points.concat(
                                        tmp.points.filter(point => results.points.find(item => item.x == point.x && item.y == point.y ) == undefined )
                                    );
                    
                                    results.contact = results.contact || tmp.contact;
                                    results.intersect = results.intersect || tmp.intersect;
                                }
                        
                            //check if poly_a is totally inside poly_b (if necessary)
                                for(let a = 0; a < poly_b.points.length; a++){
                                    if( results.intersect ){break;}
                                    if( library.math.detectIntersect.pointWithinPoly(poly_b.points[a],poly_a) != 'outside' ){   
                                        results.intersect = true;
                                    }
                                }
                    
                            return results;
                        };
                    };
                    this.pathExtrapolation = function(path,thickness=10,capType='none',joinType='none',loopPath=false,detail=5,sharpLimit=thickness*4){
                        dev.log.math('.pathExtrapolation(',path,thickness,capType,joinType,loopPath,detail,sharpLimit);
                    
                        function loopThisPath(path){
                            dev.log.math('.pathExtrapolation::loopThisPath(',path);
                        
                            const joinPoint = [ (path[0]+path[2])/2, (path[1]+path[3])/2 ];
                            let loopingPath = [];
                        
                            loopingPath = loopingPath.concat(joinPoint);
                            for(let a = 2; a < path.length; a+=2){
                                loopingPath = loopingPath.concat( [path[a], path[a+1]] );
                            }
                            loopingPath = loopingPath.concat( [path[0], path[1]] );
                            loopingPath = loopingPath.concat(joinPoint);
                    
                            return loopingPath;
                        }
                        function calculateJointData(path,thickness){
                            dev.log.math('.pathExtrapolation::calculateJointData(',path,thickness);
                        
                            const jointData = [];
                            //parse path
                                for(let a = 0; a < path.length/2; a++){
                                    jointData.push({ point:{ x:path[a*2], y:path[a*2 +1] } });
                                }
                            //calculation of joint data
                                for(let a = 0; a < jointData.length; a++){
                                    //calculate segment angles    
                                        if( a != jointData.length-1 ){
                                            const tmp = library.math.getAngleOfTwoPoints( jointData[a].point, jointData[a+1].point );
                                            if(jointData[a] != undefined){jointData[a].departAngle = tmp;}
                                            if(jointData[a+1] != undefined){jointData[a+1].implementAngle = tmp;}
                                        }
                                    //wing angle and width
                                        if( jointData[a].departAngle != undefined && jointData[a].implementAngle != undefined ){
                                            jointData[a].joiningAngle = jointData[a].departAngle - jointData[a].implementAngle + Math.PI;
                                            while(jointData[a].joiningAngle < 0){jointData[a].joiningAngle += Math.PI*2;}
                                            while(jointData[a].joiningAngle >= Math.PI*2){jointData[a].joiningAngle -= Math.PI*2;} 
                                            jointData[a].wingAngle = jointData[a].implementAngle + jointData[a].joiningAngle/2 - Math.PI;
                                            while(jointData[a].wingAngle < 0){jointData[a].wingAngle += Math.PI*2;}
                                            while(jointData[a].wingAngle > Math.PI*2){jointData[a].wingAngle -= Math.PI*2;} 
                                            jointData[a].wingWidth = thickness / Math.sin(jointData[a].joiningAngle/2);
                                        }
                                }
                    
                            return jointData;
                        }
                        function path_to_rectangleSeries(path,thickness){
                            dev.log.math('.pathExtrapolation::path_to_rectangleSeries(',path,thickness);
                        
                            let outputPoints = [];
                            for(let a = 1; a < path.length/2; a++){
                                const angle = library.math.getAngleOfTwoPoints( {x:path[a*2-2], y:path[a*2 -1]}, {x:path[a*2], y:path[a*2 +1]});
                                const left =  library.math.cartesianAngleAdjust(thickness, 0, Math.PI/2 + angle);
                                const right = { x:-left.x, y:-left.y };
                        
                                outputPoints.push([
                                    {x:path[a*2-2]+left.x,  y:path[a*2-1]+left.y},
                                    {x:path[a*2-2]+right.x, y:path[a*2-1]+right.y},
                                    {x:path[a*2]+right.x,   y:path[a*2+1]+right.y},
                                    {x:path[a*2]+left.x,    y:path[a*2+1]+left.y},
                                ]);
                            }
                        
                            return outputPoints;
                        }
                    
                        function flatJoints(jointData,thickness){
                        
                            const polygons = [];
                    
                            let perpenL = library.math.cartesianAngleAdjust(thickness, 0, jointData[0].departAngle - Math.PI/2);
                            let perpenR = {x:-perpenL.x, y:-perpenL.y};
                            for(let a = 1; a < jointData.length-1; a++){
                                const last_perpenL = perpenL;
                                const last_perpenR = perpenR;
                                perpenL = library.math.cartesianAngleAdjust(thickness, 0, jointData[a].departAngle - Math.PI/2);
                                perpenR = {x:-perpenL.x, y:-perpenL.y};
                    
                                if(jointData[a].joiningAngle == Math.PI){
                                    //do nothing
                                }else if(jointData[a].joiningAngle < Math.PI){
                                    polygons.push([
                                        {x:jointData[a].point.x, y:jointData[a].point.y},
                                        {x:jointData[a].point.x + last_perpenR.x, y:jointData[a].point.y + last_perpenR.y},
                                        {x:jointData[a].point.x + perpenR.x, y:jointData[a].point.y + perpenR.y},
                                    ]);
                                }else if(jointData[a].joiningAngle > Math.PI){
                                    polygons.push([
                                        {x:jointData[a].point.x, y:jointData[a].point.y},
                                        {x:jointData[a].point.x + last_perpenL.x, y:jointData[a].point.y + last_perpenL.y},
                                        {x:jointData[a].point.x + perpenL.x, y:jointData[a].point.y + perpenL.y},
                                    ]);
                                }
                            }
                    
                            return polygons;
                        }
                        function roundJoints(jointData,thickness,detail=5){
                        
                            const polygons = [];
                            if(detail < 1){detail = 1;}
                    
                            let perpenL = library.math.cartesianAngleAdjust(thickness, 0, jointData[0].departAngle - Math.PI/2);
                            let perpenR = {x:-perpenL.x, y:-perpenL.y};
                            for(let a = 1; a < jointData.length-1; a++){
                                const newPolygon = [];
                                const last_perpenL = perpenL;
                                const last_perpenR = perpenR;
                                perpenL = library.math.cartesianAngleAdjust(thickness, 0, jointData[a].departAngle - Math.PI/2);
                                perpenR = {x:-perpenL.x, y:-perpenL.y};
                    
                                if(jointData[a].joiningAngle == Math.PI){
                                    //do nothing
                                }else if(jointData[a].joiningAngle < Math.PI){
                                    newPolygon.push( {x:jointData[a].point.x, y:jointData[a].point.y} );
                                    newPolygon.push( {x:jointData[a].point.x + last_perpenR.x, y:jointData[a].point.y + last_perpenR.y} );
                    
                                    const gapSize = Math.PI - jointData[a].joiningAngle;
                                    const partialDetail = Math.floor((2+detail)*(Math.abs(gapSize)/Math.PI));
                                    for(let b = 1; b < partialDetail; b++){
                                        const angle = b*(gapSize/partialDetail);
                                        const p = library.math.cartesianAngleAdjust(last_perpenR.x, last_perpenR.y, -angle);
                                        newPolygon.push( {x:jointData[a].point.x + p.x, y:jointData[a].point.y + p.y} );
                                    }
                    
                                    newPolygon.push( {x:jointData[a].point.x + perpenR.x, y:jointData[a].point.y + perpenR.y} );
                                }else if(jointData[a].joiningAngle > Math.PI){
                                    newPolygon.push( {x:jointData[a].point.x, y:jointData[a].point.y} );
                                    newPolygon.push( {x:jointData[a].point.x + last_perpenL.x, y:jointData[a].point.y + last_perpenL.y} );
                    
                                    const gapSize = Math.PI - jointData[a].joiningAngle;
                                    const partialDetail = Math.floor((2+detail)*(Math.abs(gapSize)/Math.PI));
                                    for(let b = 1; b < partialDetail; b++){
                                        const angle = b*(gapSize/partialDetail);
                                        const p = library.math.cartesianAngleAdjust(last_perpenL.x, last_perpenL.y, -angle);
                                        newPolygon.push( {x:jointData[a].point.x + p.x, y:jointData[a].point.y + p.y} );
                                    }
                    
                                    newPolygon.push( {x:jointData[a].point.x + perpenL.x, y:jointData[a].point.y + perpenL.y} );
                                }
                    
                                polygons.push(newPolygon);
                            }
                    
                            return polygons;
                        }
                        function sharpJoints(jointData,thickness,sharpLimit=thickness*4){
                        
                            const polygons = [];
                    
                            let perpenL = library.math.cartesianAngleAdjust(thickness, 0, jointData[0].departAngle - Math.PI/2);
                            let perpenR = {x:-perpenL.x, y:-perpenL.y};
                            for(let a = 1; a < jointData.length-1; a++){
                                const newPolygon = [];
                                const last_perpenL = perpenL;
                                const last_perpenR = perpenR;
                                perpenL = library.math.cartesianAngleAdjust(thickness, 0, jointData[a].departAngle - Math.PI/2);
                                perpenR = {x:-perpenL.x, y:-perpenL.y};
                    
                                if(jointData[a].joiningAngle == Math.PI){
                                    //do nothing
                                }else if(jointData[a].joiningAngle < Math.PI){
                                    if( Math.abs(jointData[a].wingWidth) <= sharpLimit ){
                                        const plus = library.math.cartesianAngleAdjust(0, jointData[a].wingWidth, Math.PI/2 + jointData[a].wingAngle);
                                        newPolygon.push( {x:plus.x + jointData[a].point.x, y:plus.y + jointData[a].point.y} );
                                        newPolygon.push( {x:jointData[a].point.x + last_perpenR.x, y:jointData[a].point.y + last_perpenR.y} );
                                        newPolygon.push( {x:jointData[a].point.x, y:jointData[a].point.y} );
                                        newPolygon.push( {x:jointData[a].point.x + perpenR.x, y:jointData[a].point.y + perpenR.y} );
                                    }else{
                                        const length = Math.cos(jointData[a].joiningAngle/2)*sharpLimit;
                                        const partialWingA = library.math.cartesianAngleAdjust(0, -length, Math.PI/2 + jointData[a].implementAngle);
                                        const partialWingB = library.math.cartesianAngleAdjust(0, length, Math.PI/2 + jointData[a].departAngle);
                    
                                        newPolygon.push( {x:jointData[a].point.x, y:jointData[a].point.y} );
                                        newPolygon.push( {x:jointData[a].point.x + last_perpenR.x, y:jointData[a].point.y + last_perpenR.y} );
                                        newPolygon.push( {x:jointData[a].point.x + last_perpenR.x + partialWingA.x, y:jointData[a].point.y + last_perpenR.y + partialWingA.y} );
                                        newPolygon.push( {x:jointData[a].point.x + perpenR.x + partialWingB.x, y:jointData[a].point.y + perpenR.y + partialWingB.y} );
                                        newPolygon.push( {x:jointData[a].point.x + perpenR.x, y:jointData[a].point.y + perpenR.y} );
                                    }
                                }else if(jointData[a].joiningAngle > Math.PI){
                                    if( Math.abs(jointData[a].wingWidth) <= sharpLimit ){
                                        const plus = library.math.cartesianAngleAdjust(0, -jointData[a].wingWidth, Math.PI/2 + jointData[a].wingAngle);
                                        newPolygon.push( {x:plus.x + jointData[a].point.x, y:plus.y + jointData[a].point.y} );
                                        newPolygon.push( {x:jointData[a].point.x + last_perpenL.x, y:jointData[a].point.y + last_perpenL.y} );
                                        newPolygon.push( {x:jointData[a].point.x, y:jointData[a].point.y} );
                                        newPolygon.push( {x:jointData[a].point.x + perpenL.x, y:jointData[a].point.y + perpenL.y} );
                                    }else{
                                        const length = Math.cos(jointData[a].joiningAngle/2)*sharpLimit;
                                        const partialWingA = library.math.cartesianAngleAdjust(0, length, Math.PI/2 + jointData[a].implementAngle);
                                        const partialWingB = library.math.cartesianAngleAdjust(0, -length, Math.PI/2 + jointData[a].departAngle);
                    
                                        newPolygon.push( {x:jointData[a].point.x, y:jointData[a].point.y} );
                                        newPolygon.push( {x:jointData[a].point.x + last_perpenL.x, y:jointData[a].point.y + last_perpenL.y} );
                                        newPolygon.push( {x:jointData[a].point.x + last_perpenL.x + partialWingA.x, y:jointData[a].point.y + last_perpenL.y + partialWingA.y} );
                                        newPolygon.push( {x:jointData[a].point.x + perpenL.x + partialWingB.x, y:jointData[a].point.y + perpenL.y + partialWingB.y} );
                                        newPolygon.push( {x:jointData[a].point.x + perpenL.x, y:jointData[a].point.y + perpenL.y} );
                                    }
                                }
                    
                                polygons.push(newPolygon);
                            }
                    
                            return polygons;
                        }
                    
                        function roundCaps(jointData,thickness,detail=5){
                        
                            if(detail < 1){detail = 1;}
                    
                            const polygons = [];
                    
                            //top
                                const newPolygon_top = [];
                                newPolygon_top.push( { x:jointData[0].point.x, y:jointData[0].point.y } );
                                for(let a = 0; a < detail+1; a++){
                                    const p = library.math.cartesianAngleAdjust(thickness, 0, jointData[0].departAngle + Math.PI/2 + (a/(detail))*(Math.PI) );
                                    newPolygon_top.push( {x:jointData[0].point.x + p.x, y:jointData[0].point.y + p.y} );
                                }
                                polygons.push(newPolygon_top);
                            //bottom
                                const newPolygon_bottom = [];
                                newPolygon_bottom.push( { x:jointData[jointData.length-1].point.x, y:jointData[jointData.length-1].point.y } );
                                for(let a = 0; a < detail+1; a++){
                                    const p = library.math.cartesianAngleAdjust(thickness, 0, jointData[jointData.length-1].implementAngle - Math.PI/2 + (a/(detail))*(Math.PI) );
                                    newPolygon_bottom.push( {x:jointData[jointData.length-1].point.x + p.x, y:jointData[jointData.length-1].point.y + p.y} );
                                }
                                polygons.push(newPolygon_bottom);
                    
                            return polygons;
                        }
                    
                    
                        if(loopPath){path = loopThisPath(path);}
                        const jointData = calculateJointData(path,thickness);
                        if(jointData.length == 0){return [];}
                    
                        //generate polygons
                            let polygons = path_to_rectangleSeries(path,thickness);
                            //joints
                            if(joinType == 'flat'){ polygons = polygons.concat(flatJoints(jointData,thickness)); }
                            if(joinType == 'round'){ polygons = polygons.concat(roundJoints(jointData,thickness,detail)); }
                            if(joinType == 'sharp'){ polygons = polygons.concat(sharpJoints(jointData,thickness,sharpLimit)); }
                            //caps
                            if(capType == 'round'){ polygons = polygons.concat(roundCaps(jointData,thickness,detail)); }
                    
                        //union all polygons, convert to triangles and return
                            return library.math.polygonToSubTriangles( polygons.map(a=>[a]).reduce((conglomerate,polygon) => library.math.unionPolygons(conglomerate, polygon) ) );
                    };

                    this.fitPolyIn = function(freshPoly,environmentPolys,snapping={active:false,x:10,y:10,angle:Math.PI/8},returnPathData=false){
                        dev.log.math('.fitPolyIn(',freshPoly,environmentPolys,snapping);
                    
                        function applyOffsetToPoints(offset,points){
                        
                            return points.map(a => { return{x:a.x+offset.x,y:a.y+offset.y} } );
                        };
                        function applyOffsetToPolygon(offset,poly){
                        
                            const newPolygon = { points: applyOffsetToPoints(offset,poly.points), boundingBox:{} };
                            newPolygon.boundingBox = library.math.boundingBoxFromPoints(newPolygon.points);
                            return newPolygon;
                        };
                        function polyOnPolys(polygon,environmentPolys){
                            for(let a = 0; a < environmentPolys.length; a++){
                                if(library.math.detectIntersect.polyOnPoly(polygon,environmentPolys[a]).intersect){
                                    return true;
                                }
                            }
                            return false;
                        }
                    
                        
                    
                        let offset = {x:0,y:0};
                        const paths = [[],[],[]];
                    
                        //get the middle ("average") point of freshPoly
                            const middlePoint = library.math.averagePoint(freshPoly.points);
                    
                        //circle out to find initial offsets
                            let successfulOffsets = [];
                            let stepCount = 1;
                            {
                                const maxIterationCount = 100;
                    
                                for(stepCount = 1; stepCount < maxIterationCount+1; stepCount++){
                                    successfulOffsets = [];
                                    const stepsInThisCircle = 2*stepCount + 1;
                                    const circularStepSizeInRad = (2*Math.PI) / stepsInThisCircle;
                                    const radius = Math.pow(stepCount,2);
                                    
                                    //head round the circle, testing each point as an offset
                                        for(let a = 0; a < stepsInThisCircle; a++){
                                            //calculate the current offset
                                                const tmpOffset = library.math.polar2cartesian( circularStepSizeInRad*a, radius );
                                                tmpOffset.x = snapping.active ? Math.round(tmpOffset.x/snapping.x)*snapping.x : tmpOffset.x;
                                                tmpOffset.y = snapping.active ? Math.round(tmpOffset.y/snapping.y)*snapping.y : tmpOffset.y;
                    
                                                if(dev){paths[0].push( {x:tmpOffset.x+middlePoint.x, y:tmpOffset.y+middlePoint.y} );}
                                            
                                            //if offsetting the shape in this way results in no collision; save this offset in 'successfulOffsets'
                                                if(!polyOnPolys(applyOffsetToPolygon(tmpOffset,freshPoly),environmentPolys)){
                                                    successfulOffsets.push( {ang:circularStepSizeInRad*a, dis:radius} );
                                                }
                                        }
                    
                                    //if on this circle we've found at least one possible location; break out of this section and move on to the next
                                        if( successfulOffsets.length != 0 ){break;}
                                }
                            }
                    
                    
                        //use midpointing from these points to find the single closest circular offset
                            let successfulOffset;
                            {
                                const maxIterationCount = 10;
                                if(successfulOffsets.length == 1){
                                    successfulOffset = successfulOffsets[0];
                                }else{
                                    //there was more than one possible offset for this radius, so we need to edge each of them closer
                                    //to the original point, to whittle them down to the one angle that can provide the smallest radius
                    
                                    let maxRadius = Math.pow(stepCount,2);
                                    let minRadius = Math.pow(stepCount-1,2);
                    
                                    const provenFunctionalOffsets = [];
                                    for(let i = 0; i < maxIterationCount; i++){
                                        const tmp_successfulOffsets = [];
                                        const midRadius = (maxRadius - minRadius)/2 + minRadius;
                    
                                        //check this new midpoint radius with the successfulOffset values 
                                            for(let a = 0; a < successfulOffsets.length; a++){
                                                //calculate the current offset using the midpoint value
                                                    const tmpOffset = library.math.polar2cartesian( successfulOffsets[a].ang, midRadius );
                                                    tmpOffset.x = snapping.active ? Math.round(tmpOffset.x/snapping.x)*snapping.x : tmpOffset.x;
                                                    tmpOffset.y = snapping.active ? Math.round(tmpOffset.y/snapping.y)*snapping.y : tmpOffset.y;
                                                    if(dev){paths[1].push( {x:tmpOffset.x+middlePoint.x, y:tmpOffset.y+middlePoint.y} );}
                                                            
                                                //if offsetting the shape in this way results in no collision; save this offset in 'tmp_successfulOffsets'
                                                    if(!polyOnPolys(applyOffsetToPolygon(tmpOffset,freshPoly),environmentPolys)){
                                                        tmp_successfulOffsets.push( {ang:successfulOffsets[a].ang, dis:midRadius} );
                                                        provenFunctionalOffsets.push( {ang:successfulOffsets[a].ang, dis:midRadius} );
                                                    }
                                            }
                    
                                        //check if there's only one offset left
                                            if( tmp_successfulOffsets.length == 1 ){ successfulOffset = tmp_successfulOffsets[0]; break; }
                    
                                        //decide whether to check further out or closer in
                                            if( tmp_successfulOffsets.length == 0 ){
                                                minRadius = midRadius; //somewhere further out
                                            }else{
                                                maxRadius = midRadius; //somewhere further in
                                            }
                                    }
                    
                                    //if everything goes wrong with the midpoint method; and we end up with no offsets, use whatever the last proven functional offset was
                                        if(successfulOffset == undefined){ successfulOffset = provenFunctionalOffsets.pop(); }
                                }
                            }
                    
                        //adjust along x and y to find the closest offset
                            {
                                const maxIterationCount = 10;
                    
                                offset = library.math.polar2cartesian( successfulOffset.ang, successfulOffset.dis );
                                if(dev){paths[2].push( {x:offset.x+middlePoint.x, y:offset.y+middlePoint.y} );}
                                const max = {x:offset.x, y:offset.y};
                                const min = {x:0, y:0};
                                
                                //use midpoint methods to edge the shape (over x and y) to as close as it can be to the original point
                                    for(let i = 0; i < maxIterationCount; i++){
                                        const midpoint = { x:(max.x-min.x)/2 + min.x, y:(max.y-min.y)/2 + min.y };
                                        midpoint.x = snapping.active ? Math.round(midpoint.x/snapping.x)*snapping.x : midpoint.x;
                                        midpoint.y = snapping.active ? Math.round(midpoint.y/snapping.y)*snapping.y : midpoint.y;
                    
                                        //can you make a x movement? you can? then do it
                                            if(dev){paths[2].push( {x:midpoint.x+middlePoint.x, y:max.y+middlePoint.y} );}
                                            if(!polyOnPolys(applyOffsetToPolygon({x:midpoint.x, y:max.y},freshPoly),environmentPolys)){
                                                max.x = midpoint.x; //too far
                                            }else{ 
                                                min.x = midpoint.x; //too close
                                            }
                    
                                        //can you make a y movement? you can? then do it
                                            if(dev){paths[2].push( {x:max.x+middlePoint.x, y:midpoint.y+middlePoint.y} );}
                                            if(!polyOnPolys(applyOffsetToPolygon({x:max.x, y:midpoint.y},freshPoly),environmentPolys)){
                                                max.y = midpoint.y; //too far
                                            }else{
                                                min.y = midpoint.y; //too close
                                            }
                                    }
                    
                                offset = {x:max.x, y:max.y};
                            }
                    
                        return returnPathData ? {offset:offset,paths:paths} : offset;
                    };
                    this.polygonsToVisibilityGraph = function(polys){
                        const graph = polys.flatMap((poly,polyIndex) => {
                            return poly.points.map((point,pointIndex) => ({
                                polyIndex:polyIndex,
                                pointIndex:pointIndex,
                                destination:[ /*{index:n, polyIndex:n, pointIndex:n, distance:n} */ ],
                            }))
                        });
                    
                        const scannedRoutes = {};
                    
                        graph.forEach((graphPoint_source,index_source) => {
                            graph.forEach((graphPoint_destination,index_destination) => {
                                if(index_source == index_destination){return;}
                                // if( index_source != 4 ){return;} if( index_destination != 2 ){return;}
                    
                                const route_source = graphPoint_source.polyIndex+'_'+graphPoint_source.pointIndex;
                                const route_destination = graphPoint_destination.polyIndex+'_'+graphPoint_destination.pointIndex;
                    
                                //check to see if we've scanned this route before
                                if( scannedRoutes[route_destination] != undefined && scannedRoutes[route_destination][route_source] != undefined ){ return; }
                    
                                //convert for convenience
                                const point_source = polys[graphPoint_source.polyIndex].points[graphPoint_source.pointIndex];
                                const point_destination = polys[graphPoint_destination.polyIndex].points[graphPoint_destination.pointIndex];
                    
                                //scan route
                                let addRoute = true;
                                for(let a = 0; a < polys.length; a++){
                                    const result = library.math.detectIntersect.lineOnPoly( [point_source,point_destination], polys[a] );
                                    if( result.intersect ){
                                        addRoute = false;
                                        break;
                                    }
                                }
                    
                                //if route is valid, add to graph
                                if(addRoute){
                                    const distance = library.math.distanceBetweenTwoPoints(point_source,point_destination);
                    
                                    //forward route
                                    if(scannedRoutes[route_source] == undefined){ scannedRoutes[route_source] = {}; }
                                    scannedRoutes[route_source][route_destination] = {
                                        index: index_destination,
                                        polyIndex: graphPoint_destination.polyIndex, 
                                        pointIndex: graphPoint_destination.pointIndex,
                                        distance: distance,
                                    };
                                    graphPoint_source.destination.push( scannedRoutes[route_source][route_destination] );
                    
                                    //backward route
                                    if(scannedRoutes[route_destination] == undefined){ scannedRoutes[route_destination] = {}; }
                                    scannedRoutes[route_destination][route_source] = {
                                        index: index_source,
                                        polyIndex: graphPoint_source.polyIndex, 
                                        pointIndex: graphPoint_source.pointIndex,
                                        distance: distance,
                                    };
                                    graphPoint_destination.destination.push( scannedRoutes[route_destination][route_source] );
                                }
                            });
                        });
                    
                        return graph;
                    };
                    this.shortestRouteFromVisibilityGraph = function(visibilityGraph,start,end){
                    
                        //if the starting location or ending location are totally inaccessible, bail on this whole thing
                        //though return the point (if any) that was ok
                            if( visibilityGraph[start].destination.length == 0 && visibilityGraph[end].destination.length == 0 ){
                                return [];
                            }
                            if( visibilityGraph[start].destination.length == 0 ){
                                return [end];
                            }
                            if( visibilityGraph[end].destination.length == 0 ){ 
                                return [start];
                            }
                    
                        //set the 'current' location as the start
                            let current = start;
                    
                        //if in a cruel twist of fate, the ending location is the starting location;
                        //create a new starting location with all the same data, and set that as
                        //the 'current' location
                            if(start == end){
                                visibilityGraph['_'+start] = JSON.parse(JSON.stringify(visibilityGraph[start]));
                                current = '_'+start;
                            }
                    
                        //generate the location set
                        //(don't forget to set the current location's distance to zero)
                            const locationSet = Object.keys(visibilityGraph).map( () => ({ distance:Infinity, visited:false, route:'' }) );
                            locationSet[current].distance = 0;
                    
                        //loop through locations, until the end location has been visited
                            let limit = 100;
                            do{
                                if(limit <= 0){console.error('.shortestRouteFromVisibilityGraph has encountered an overflow'); break;}
                                limit--;
                    
                    
                                //update unvisited distance values
                                    for(let a = 0; a < visibilityGraph[current].destination.length; a++){
                                        if( locationSet[visibilityGraph[current].destination[a].index].visited ){
                                            continue;
                                        }
                    
                                        //only update the value if this new value is smaller than the one it already has
                                        const newValue = locationSet[current].distance + visibilityGraph[current].destination[a].distance;
                                        if( newValue < locationSet[visibilityGraph[current].destination[a].index].distance ){
                                            locationSet[visibilityGraph[current].destination[a].index].route = current;
                                            locationSet[visibilityGraph[current].destination[a].index].distance = newValue;
                                        }
                                    }
                    
                                //mark current location as visited
                                    locationSet[current].visited = true;
                    
                                //find location with smallest distance value - that is unvisited - and set it as the current
                                    let smallest = Infinity;
                                    Object.keys(locationSet).forEach(location => {
                                        if(!locationSet[location].visited && locationSet[location].distance < smallest ){
                                            smallest = locationSet[location].distance;
                                            current = location;
                                        }
                                    });
                            }while( !locationSet[end].visited )
                        
                        //go back through the location set to discover the shortest route
                            let route = [];
                            current = end;
                            while(current != start){
                                route.unshift(parseInt(current));
                                current = locationSet[current].route;
                            }
                            route.unshift(parseInt(current));
                    
                        return route;
                    };

                };
                this.glsl = new function(){
                    this.geometry = `
                        #define PI 3.141592653589793
                    
                        vec2 cartesian2polar(vec2 xy){
                            float dis = pow(pow(xy.x,2.0)+pow(xy.y,2.0),0.5);
                            float ang = 0.0;
                    
                            if(xy.x == 0.0){
                                if(xy.y == 0.0){ang = 0.0;}
                                else if(xy.y > 0.0){ang = 0.5*PI;}
                                else{ang = 1.5*PI;}
                            }
                            else if(xy.y == 0.0){
                                if(xy.x >= 0.0){ang = 0.0;}else{ang = PI;}
                            }
                            else if(xy.x >= 0.0){ ang = atan(xy.y/xy.x); }
                            else{ /*if(xy.x < 0.0)*/ ang = atan(xy.y/xy.x) + PI; }
                    
                            return vec2(ang,dis);
                        }
                        vec2 polar2cartesian(vec2 ad){
                            return vec2( ad[1]*cos(ad[0]), ad[1]*sin(ad[0]) );
                        }
                        vec2 cartesianAngleAdjust(vec2 xy, float angle){
                            // //v1
                            // if(angle == 0.0 || mod(angle,PI*2.0) == 0.0){ return xy; }
                            //
                            // vec2 polar = cartesian2polar( xy );
                            // polar[0] += angle;
                            // return polar2cartesian( polar );
                    
                            //v2
                            if(angle == 0.0 || mod(angle,PI*2.0) == 0.0){ return xy; }
                            return vec2( xy.x*cos(angle) - xy.y*sin(angle), xy.y*cos(angle) + xy.x*sin(angle) ); 
                        }
                    `;
                };
                this.structure = new function(){
                    this.functionListRunner = function(list,activeKeys){
                    
                        //function builder for working with the 'functionList' format
                    
                        return function(event,data){
                            //run through function list, and activate functions where necessary
                                for(let a = 0; a < list.length; a++){
                                    let shouldRun = true;
                    
                                    //determine if the requirements of this function are met
                                        for(let b = 0; b < list[a].requiredKeys.length; b++){
                                            shouldRun = true;
                                            for(let c = 0; c < list[a].requiredKeys[b].length; c++){
                                                shouldRun = shouldRun && activeKeys[ list[a].requiredKeys[b][c] ];
                                                if(!shouldRun){break;} //(one is already not a match, so save time and just skip to the next one)
                                            }
                                            if(shouldRun){ break; } //one of the collections worked, so save time and skip the rest
                                        }
                    
                                    //if requirements were met, run the function
                    	            if(shouldRun){  
                                        //if the function returns 'false', continue with the list; otherwise stop here
                            	            if( list[a].function(event,data) ){ break; }
                                    }
                                }
                        }
                    };
                    
                    this.signalRegistry = function(rightLimit=-1,bottomLimit=-1,signalLengthLimit=-1){
                    
                        let signals = [];
                        let selectedSignals = [];
                        let events = [];
                        let events_byID = [];
                        let events_byPosition = {};
                        let positions = [];
                    
                        this.__dump = function(){
                        
                            console.log('---- signalRegistry dump ----');
                    
                            console.log('\tsignals');
                            for(let a = 0; a < signals.length; a++){ 
                                console.log( '\t\t', a, ' ' + JSON.stringify(signals[a]) );
                            }
                    
                            console.log('\tselectedSignals');
                            for(let a = 0; a < tselectedSignals.length; a++){ 
                                console.log( '\t\t', a, ' ' + JSON.stringify(tselectedSignals[a]) );
                            }
                    
                            console.log('\tevents');
                            for(let a = 0; a < events.length; a++){ 
                                console.log( '\t\t', a, ' ' + JSON.stringify(events[a]) );
                            }
                    
                            console.log('\tevents_byID');
                            for(let a = 0; a < events_byID.length; a++){ 
                                console.log( '\t\t', a, ' ' + JSON.stringify(events_byID[a]) );
                            }
                    
                            console.log('\tevents_byPosition');
                            const keys = Object.keys(events_byPosition);
                            for(let a = 0; a < keys.length; a++){ 
                                console.log( '\t\t', keys[a], ' ' + JSON.stringify(events_byPosition[keys[a]]) );
                            }
                    
                            console.log('\tpositions');
                            for(let a = 0; a < positions.length; a++){ 
                                console.log( '\t\t', a, ' ' + JSON.stringify(positions[a]) );
                            }
                        };
                    
                        this.export = function(){
                        
                            return JSON.parse(JSON.stringify(
                                {
                                    signals:            signals,
                                    selectedSignals:    selectedSignals,
                                    events:             events,
                                    events_byID:        events_byID,
                                    events_byPosition:  events_byPosition,
                                    positions:          positions,
                                }
                            ));
                        };
                        this.import = function(data){
                        
                            signals =           JSON.parse(JSON.stringify(data.signals));
                            selectedSignals =   JSON.parse(JSON.stringify(data.selectedSignals));
                            events =            JSON.parse(JSON.stringify(data.events));
                            events_byID =       JSON.parse(JSON.stringify(data.events_byID));
                            events_byPosition = JSON.parse(JSON.stringify(data.events_byPosition));
                            positions =         JSON.parse(JSON.stringify(data.positions));
                        };
                    
                        this.getAllSignals = function(){ 
                        
                            return JSON.parse(JSON.stringify(signals));
                        };
                        this.getAllEvents = function(){ 
                        
                            return JSON.parse(JSON.stringify(events));
                        };
                        this.getSignal = function(id){
                        
                            if( signals[id] == undefined ){return;}
                            return JSON.parse(JSON.stringify(signals[id]));
                        };
                        this.eventsBetween = function(start,end){
                        
                            //depending on whether theres an end position or not; get all the events positions that 
                            //lie on the start positions, or get all the events that how positions which lie between
                            //the start and end positions
                            const eventNumbers = end == undefined ? 
                                Array.from(new Set(positions.filter(function(a){return a == start;}))) : 
                                Array.from(new Set(positions.filter(function(a){return a >= start && a < end;}))) ;
                    
                            //for each position, convert the number to a string, and gather the associated event number arrays
                            //then, for each array, get each event and place that into the output array
                            const compiledEvents = [];
                            for(let a = 0; a < eventNumbers.length; a++){
                                eventNumbers[a] = events_byPosition[String(eventNumbers[a])];
                                for(let b = 0; b < eventNumbers[a].length; b++){
                                    compiledEvents.push(events[eventNumbers[a][b]]);
                                }
                            }
                    
                            //sort array by position (soonest first)
                            return compiledEvents.sort(function(a, b){
                                if(a.position < b.position) return -1;
                                if(a.position > b.position) return 1;
                                return 0;
                            });
                        };
                        this.add = function(data,forceID){
                        
                            //clean up data
                                if(data == undefined || !('line' in data) || !('position' in data) || !('length' in data)){return;}
                                if(!('strength' in data)){data.strength = 1;}
                            //check for and correct disallowed data
                                if(data.line < 0){data.line = 0;}
                                if(data.length < 0){data.length = 0;}
                                if(data.position < 0){data.position = 0;}
                                if(data.strength < 0){data.strength = 0;}
                    
                                if(bottomLimit > -1 && (data.line > bottomLimit-1)){data.line = bottomLimit-1;}
                                if(signalLengthLimit > -1 && (data.length > signalLengthLimit)){data.length = signalLengthLimit;}
                                if(rightLimit > -1 && (data.position > rightLimit) ){data.position = rightLimit-data.length;}
                                if(rightLimit > -1 && (data.position+data.length > rightLimit)){ data.length = rightLimit-data.position; }
                                if(rightLimit > -1 && (data.position+data.length > rightLimit)){data.position = rightLimit-data.length;}
                                if(data.strength > 1){data.strength = 1;}
                    
                            //generate signal ID
                                let newID = 0;
                                if(forceID == undefined){
                                    while(signals[newID] != undefined){newID++;}
                                }else{newID = forceID;}
                    
                            //add signal to storage
                                signals[newID] = JSON.parse(JSON.stringify(data));
                    
                            //generate event data
                                const newEvents = [
                                    {signalID:newID, line:data.line, position:data.position,               strength:data.strength},
                                    {signalID:newID, line:data.line, position:(data.position+data.length), strength:0}
                                ];
                    
                            //add event data to storage
                                let eventLocation = 0;
                                //start event
                                    while(events[eventLocation] != undefined){eventLocation++;}
                                    events[eventLocation] = newEvents[0];
                                    events_byID[newID] = [eventLocation];
                                    if( events_byPosition[newEvents[0].position] == undefined ){
                                        events_byPosition[newEvents[0].position] = [eventLocation];
                                    }else{
                                        events_byPosition[newEvents[0].position].push(eventLocation);
                                    }
                                    positions.push(newEvents[0].position);
                                //end event
                                    while(events[eventLocation] != undefined){eventLocation++;}
                                    events[eventLocation] = newEvents[1];
                                    events_byID[newID] = events_byID[newID].concat(eventLocation);
                                    if( events_byPosition[newEvents[1].position] == undefined ){
                                        events_byPosition[newEvents[1].position] = [eventLocation];
                                    }else{
                                        events_byPosition[newEvents[1].position].push(eventLocation);
                                    }
                                    positions.push(newEvents[1].position);
                    
                            return newID;
                        };
                        this.remove = function(id){
                        
                            if( signals[id] == undefined ){return;}
                    
                            delete signals[id];
                    
                            for(let a = 0; a < events_byID[id].length; a++){
                                const tmp = events_byID[id][a];
                                events_byPosition[events[tmp].position].splice( events_byPosition[events[tmp].position].indexOf(tmp) ,1);
                                positions.splice(positions.indexOf(events[tmp].position),1);
                                if( events_byPosition[events[tmp].position].length == 0 ){delete events_byPosition[events[tmp].position];}
                                delete events[tmp];
                            }
                    
                            delete events_byID[id];
                        };
                        this.update = function(id,data){
                        
                            //clean input
                                if(data == undefined){return;}
                                if(!('line' in data)){data.line = signals[id].line;}
                    
                                //Special cases where either by movement or lengthening, the signal stretches further than the rightLimit
                                //will allow. In these cases the signal either has to be clipped, or prevented from moving further to the
                                //right. In the case where a signal is being lengthened and moved to the right; the system should opt to
                                //clip it's length
                                //Obviously, if there's no right limit don't bother
                                if(rightLimit > -1){
                                    if('position' in data && 'length' in data){//clip length
                                        if(data.length+data.position > rightLimit){ data.length = rightLimit-data.position; }
                                    }else{
                                        if('position' in data){//prevent movement
                                            if(signals[id].length+data.position >= rightLimit){ data.position = rightLimit - signals[id].length; }
                                        }else{ data.position = signals[id].position; }
                                        if('length' in data){//clip length
                                            if(data.length+data.position > rightLimit){ data.length = rightLimit-data.position; }
                                        }else{ data.length = signals[id].length; }
                                    }
                                }
                    
                                if(!('strength' in data)){data.strength = signals[id].strength;}
                            
                            this.remove(id);
                            this.add(data,id);
                        };
                        this.reset = function(){
                        
                            signals = [];
                            selectedSignals = [];
                            events = [];
                            events_byID = [];
                            events_byPosition = {};
                            positions = [];
                        };
                    };
                };
                this.font = new function(){
                    this.listAllAvailableGlyphs = function(fontFileData){
                    
                        const font = this.decodeFont(fontFileData);
                        return Object.keys(font.glyphs.glyphs).map(a => String.fromCharCode(font.glyphs.glyphs[a].unicode));
                    };
                    this.decodeFont = function(fontFileData){
                    
                        return _thirdparty.opentype.parse(fontFileData);
                    };
                    this.getAllAvailableGlyphDrawingPaths = function(font,reducedGlyphSet){
                    
                        const glyphs = reducedGlyphSet != undefined ? reducedGlyphSet : Object.keys(font.glyphs.glyphs).map(a => String.fromCharCode(font.glyphs.glyphs[a].unicode));
                        const paths = glyphs.map( a => font.getPath(a,0,0,1) );
                    
                        let outputData = {};
                        for(let a = 0; a < glyphs.length; a++){
                            outputData[glyphs[a]] = paths[a].commands;
                        }
                    
                        return outputData;
                    };
                    this.convertPathToPoints = function(path,detail=2){
                    
                        let output = [];
                        let currentPoints = [];
                    
                        path.forEach(function(element){
                            switch(element.type){
                                case 'M': currentPoints.push( {x:element.x,y:element.y} ); break;
                                case 'L': currentPoints.push( {x:element.x,y:element.y} ); break;
                    
                                case 'H': break;
                                case 'V': break;
                                case 'C': break;
                                case 'S': break;
                    
                                case 'Q':
                                    const p = {
                                        start:{x:currentPoints[currentPoints.length-1].x, y:currentPoints[currentPoints.length-1].y},
                                        control:{x:element.x1,y:element.y1},
                                        end:{x:element.x,y:element.y},
                                    };
                                    
                                    for(let a = 1; a <= detail; a++){
                                        let mux = a/detail;
                                        currentPoints.push({
                                            x: p.start.x + mux*(2*(p.control.x - p.start.x) + mux*(p.end.x - 2*p.control.x + p.start.x)),
                                            y: p.start.y + mux*(2*(p.control.y - p.start.y) + mux*(p.end.y - 2*p.control.y + p.start.y)),
                                        });
                                    }
                                break;
                    
                                case 'T': break;
                                case 'A': break;
                    
                                case 'Z': case 'z': 
                                    output = output.concat(currentPoints);
                                    currentPoints = [];
                                break;
                            }
                        });
                    
                        return output;
                    };
                    this.getTrianglesFromGlyphPath = function(glyphPath,detail=2){
                    
                        //input checking
                            if(glyphPath.length == 0){return [];}
                    
                        //convert glyphPath into segments with holes
                            const minmax = {top:Infinity,left:Infinity,bottom:0,right:0};
                    
                            //gather minmax
                                glyphPath.forEach(a => {
                                    if(a.x < minmax.left){minmax.left = a.x;}
                                    if(a.y < minmax.top){minmax.top = a.y;}
                                    if(a.x > minmax.right){minmax.right = a.x;}
                                    if(a.y > minmax.bottom){minmax.bottom = a.y;}
                                });
                            //split glyph paths up
                                let paths = [];
                                let tmpPath = [];
                                glyphPath.forEach(pathSegment => {
                                    tmpPath.push(pathSegment);
                                    if(pathSegment.type == 'Z'){ paths.push(tmpPath); tmpPath = []; }
                                });
                            //convert paths to points
                                paths = paths.map(a => library.font.convertPathToPoints(a,detail) );
                    
                            //reorder paths in order of size
                                paths = paths.map(a => {
                                    const tmp = library.math.boundingBoxFromPoints(a); 
                                    return {vector:a, size:(tmp.bottomRight.x-tmp.topLeft.x) * (tmp.bottomRight.y-tmp.topLeft.y)};
                                }).sort(function(a,b){ return a.size <= b.size ? 1 : -1; 
                                }).map(a => a.vector);
                    
                            //sort point collections into segments with paths and holes
                                let segments = [];
                                paths.forEach(path => {
                                    let isHole = false;
                                    for(let a = 0; a < segments.length; a++){
                                        if( library.math.detectIntersect.polyOnPoly({points:path},{points:segments[a].path}).intersect ){
                                            segments[a].path = segments[a].path.concat(path);
                                            segments[a].regions.unshift(path);
                                            isHole = true;
                                            break;
                                        }
                                    }
                                    if(!isHole){ segments.push({ path:path, regions:[path] }); }
                                });
                    
                        //produce triangles from points
                            return segments.flatMap(segment => library.math.polygonToSubTriangles(segment.regions) );
                    };
                    this.extractGlyphs = function(fontFileData,reducedGlyphSet){
                    
                        //decode font data
                            const font = library.font.decodeFont(fontFileData);
                        //collect all glyph paths
                            const tmp = library.font.getAllAvailableGlyphDrawingPaths(font,reducedGlyphSet);
                        //convert all glyph paths to triangles
                            const outputObject = {};
                            Object.keys(tmp).forEach(glyph => { 
                                const extraData = font.glyphs.glyphs[glyph.charCodeAt(0)];
                    
                                outputObject[glyph] = {
                                    vector:library.font.getTrianglesFromGlyphPath(tmp[glyph]),
                                    ascender:font.ascender,
                                    descender:font.descender,
                                    leftSideBearing: extraData.leftSideBearing,
                                    advanceWidth: extraData.advanceWidth,
                                    xMax: extraData.xMax,
                                    yMax: extraData.yMax,
                                    xMin: extraData.xMin,
                                    yMin: extraData.yMin,
                                    top:Infinity,
                                    left:Infinity,
                                    bottom:0,
                                    right:0,
                                };
                                
                                //determine extremities for this glyph
                                    for(let a = 0; a < outputObject[glyph].vector.length; a+=2){
                                        if( outputObject[glyph].vector[a] < outputObject[glyph].left ){
                                            outputObject[glyph].left = outputObject[glyph].vector[a];
                                        }else if( outputObject[glyph].vector[a] > outputObject[glyph].right ){
                                            outputObject[glyph].right = outputObject[glyph].vector[a];
                                        }
                    
                                        if( outputObject[glyph].vector[a+1] < outputObject[glyph].top ){
                                            outputObject[glyph].top = outputObject[glyph].vector[a+1];
                                        }else if( outputObject[glyph].vector[a+1] > outputObject[glyph].bottom ){
                                            outputObject[glyph].bottom = outputObject[glyph].vector[a+1];
                                        }
                                    }
                            });
                    
                        //normalize all glyph vectors for this font
                            //establish ratio
                                const ratio = {height:0,width:0,master:0};
                                Object.keys(outputObject).forEach(glyph => {
                                    const height = outputObject[glyph].bottom - outputObject[glyph].top;
                                    if(height > ratio.height){ratio.height = height;}
                                    const width = outputObject[glyph].right - outputObject[glyph].left;
                                    if(width > ratio.width){ratio.width = width;}
                                });
                                ratio.master = ratio.height < ratio.width ? ratio.height : ratio.width;
                            //adjust vectors and extremity values with ratios
                                Object.keys(outputObject).forEach(glyph => {
                                    for(let a = 0; a < outputObject[glyph].vector.length; a+=2){
                                        outputObject[glyph].vector[a] /= ratio.master;
                                        outputObject[glyph].vector[a+1] /= ratio.master;
                                    }
                                    outputObject[glyph].top /= ratio.master;
                                    outputObject[glyph].bottom /= ratio.master;
                                    outputObject[glyph].left /= ratio.master;
                                    outputObject[glyph].right  /= ratio.master;
                                });
                    
                        return outputObject;
                    };
                    
                    
                    
                    
                    const vectorLibrary = {};
                    const reducedGlyphSet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.,:;?!/\\()[]{}#-_\'"|><+=&*~%^'.split('');
                    const fontFilesLocation = '/fonts/';
                    const systemFonts = [
                        'defaultThick',
                        'defaultThin',
                    ];
                    const fontFileNames = [
                        'Roboto/Roboto-Regular.ttf',
                        'Roboto/Roboto-Italic.ttf',
                        'Roboto/Roboto-Black.ttf',
                        'Roboto/Roboto-BlackItalic.ttf',
                        'Roboto/Roboto-Bold.ttf',
                        'Roboto/Roboto-BoldItalic.ttf',
                        'Roboto/Roboto-Light.ttf',
                        'Roboto/Roboto-LightItalic.ttf',
                        'Roboto/Roboto-Medium.ttf',
                        'Roboto/Roboto-MediumItalic.ttf',
                        'Roboto/Roboto-Thin.ttf',
                        'Roboto/Roboto-ThinItalic.ttf',
                    
                        'Helvetica/Helvetica-Bold.ttf',
                        'Helvetica/Helvetica-BoldItalic.ttf',
                        'Helvetica/Helvetica-Italic.ttf',
                        'Helvetica/Helvetica-Light.ttf',
                        'Helvetica/Helvetica.ttf',
                        
                        'Arial/Arial.ttf',
                    
                        'Cute_Font/CuteFont-Regular.ttf',
                    
                        'Lobster/Lobster-Regular.ttf',
                    
                        'AppleGaramond/AppleGaramond.ttf',
                    ];
                    //create locations in the vector library for these fonts
                    fontFileNames.forEach(name => {
                        const fontName = name.split('.').slice(0,-1)[0].split('/').slice(1,2)[0]; //produce font name from file name
                        vectorLibrary[fontName] = { fileName:name, loadAttempted:false, isLoaded:false };
                    });
                    vectorLibrary.defaultThick = {
                        loadAttempted:true,
                        isLoaded:true,
                        'default':{ 
                            //vector: [ 0,0, 1,0, 1,1, 0,1, 0,0, 0.2,0.2,  0.2,0.8, 0.8,0.8, 0.8,0.2, 0.2,0.2 ]
                            vector:[0.8,0.2,0.2,0.2,0,0,0,1,0,0,0.2,0.2,0.8,0.2,0,0,1,0,0,1,0.2,0.2,0.2,0.8,0.8,0.8,0.8,0.2,1,0,1,1,0,1,0.2,0.8,0.8,0.8,1,0,1,1,1,1,0.2,0.8,0.8,0.8],
                        },
                        '':{ 
                            //vector: [ 0,0, 1,0, 1,1, 0,1, 0,0, 0.2,0.2,  0.2,0.8, 0.8,0.8, 0.8,0.2, 0.2,0.2 ]
                            vector:[0.8,0.2,0.2,0.2,0,0,0,1,0,0,0.2,0.2,0.8,0.2,0,0,1,0,0,1,0.2,0.2,0.2,0.8,0.8,0.8,0.8,0.2,1,0,1,1,0,1,0.2,0.8,0.8,0.8,1,0,1,1,1,1,0.2,0.8,0.8,0.8],
                        },
                    
                    
                        'A':{ 
                            //vector: [ 0,1, 0.4,0, 0.6,0, 1,1, 0.8,1, 0.5,0.2, 0.4,0.5, 0.65,0.5, 0.7,0.7, 0.3,0.7, 0.2,1 ] 
                            vector:[0.3,0.7,0.2,1,0,1,0,1,0.4,0,0.6,0,0.6,0,1,1,0.8,1,0.4,0.5,0.65,0.5,0.7,0.7,0.6,0,0.8,1,0.5,0.2,0.4,0.5,0.7,0.7,0.3,0.7,0,1,0.6,0,0.5,0.2,0.5,0.2,0.4,0.5,0.3,0.7,0.3,0.7,0,1,0.5,0.2],
                        },
                        'B':{ 
                            //vector: [ 0,0, 0.2,0, 0.2,0.8, 0.7,0.8, 0.8,0.7, 0.8,0.6, 0.7,0.5, 0.2,0.5, 0.2,0.3, 0.7,0.3, 0.7,0.2, 0.2,0.2, 0.2,0, 0.8,0, 0.9,0.1, 0.9,0.3, 0.8,0.4, 1,0.6, 1,0.8, 0.8,1, 0,1 ] 
                            vector:[0,1,0,0,0.2,0,0.7,0.5,0.2,0.5,0.2,0.3,0.7,0.2,0.2,0.2,0.2,0,0.2,0,0.8,0,0.9,0.1,0.9,0.1,0.9,0.3,0.8,0.4,0.8,0.4,1,0.6,1,0.8,1,0.8,0.8,1,0,1,0,1,0.2,0,0.2,0.8,0.7,0.5,0.2,0.3,0.7,0.3,0.7,0.2,0.2,0,0.9,0.1,0,1,0.2,0.8,0.7,0.8,0.8,0.6,0.7,0.5,0.7,0.3,0.7,0.3,0.7,0.2,0.9,0.1,1,0.8,0,1,0.7,0.8,0.7,0.3,0.9,0.1,0.8,0.4,1,0.8,0.7,0.8,0.8,0.7,0.8,0.6,0.7,0.3,0.8,0.4,1,0.8,0.8,0.7,0.8,0.6,0.8,0.6,0.8,0.4,1,0.8],
                        },
                        'C':{ 
                            //vector: [ 0.3,0, 0.8,0, 1,0.2, 0.8,0.3, 0.7,0.2, 0.4,0.2, 0.2,0.4, 0.2,0.6, 0.4,0.8, 0.7,0.8, 0.8,0.7, 1,0.8, 0.8,1, 0.3,1, 0,0.7, 0,0.3 ] 
                            vector:[0,0.7,0,0.3,0.3,0,0.3,0,0.8,0,1,0.2,1,0.2,0.8,0.3,0.7,0.2,0.7,0.8,0.8,0.7,1,0.8,1,0.8,0.8,1,0.3,1,0.3,0,1,0.2,0.7,0.2,0.7,0.8,1,0.8,0.3,1,0.3,0,0.7,0.2,0.4,0.2,0.4,0.8,0.7,0.8,0.3,1,0.3,0,0.4,0.2,0.2,0.4,0.2,0.6,0.4,0.8,0.3,1,0,0.7,0.3,0,0.2,0.4,0.2,0.6,0.3,1,0,0.7,0,0.7,0.2,0.4,0.2,0.6],
                        },
                        'D':{ 
                            //vector: [ 0,0, 0.2,0, 0.2,0.8, 0.7,0.8, 0.8,0.7, 0.8,0.3, 0.7,0.2, 0.2,0.2, 0.2,0, 0.8,0, 1,0.2, 1,0.8, 0.8,1, 0,1 ] 
                            vector:[0,1,0,0,0.2,0,0.7,0.2,0.2,0.2,0.2,0,0.2,0,0.8,0,1,0.2,1,0.2,1,0.8,0.8,1,0,1,0.2,0,0.2,0.8,0.7,0.2,0.2,0,1,0.2,0.8,1,0,1,0.2,0.8,0.8,0.3,0.7,0.2,1,0.2,0.8,1,0.2,0.8,0.7,0.8,0.8,0.7,0.8,0.3,1,0.2,0.8,1,0.7,0.8,0.8,0.7,0.8,0.7,1,0.2,0.8,1],
                        },
                        'E':{ 
                            //vector: [ 0,0, 1,0, 1,0.2, 0.2,0.2, 0.2,0.4, 1,0.4, 1,0.6, 0.2,0.6, 0.2,0.8, 1,0.8, 1,1, 0,1 ] 
                            vector:[0,0,1,0,1,0.2,0.2,0.4,1,0.4,1,0.6,0.2,0.8,1,0.8,1,1,0,0,1,0.2,0.2,0.2,0.2,0.4,1,0.6,0.2,0.6,0.2,0.8,1,1,0,1,0,1,0,0,0.2,0.2,0.2,0.6,0.2,0.8,0,1,0,1,0.2,0.2,0.2,0.4,0.2,0.4,0.2,0.6,0,1],
                        },
                        'F':{ 
                            //vector: [ 0,0, 1,0, 1,0.2, 0.2,0.2, 0.2,0.4, 1,0.4, 1,0.6, 0.2,0.6, 0.2,1, 0,1 ] 
                            vector:[0.2,1,0,1,0,0,0,0,1,0,1,0.2,0.2,0.4,1,0.4,1,0.6,0.2,0.6,0.2,1,0,0,0,0,1,0.2,0.2,0.2,0.2,0.4,1,0.6,0.2,0.6,0,0,0.2,0.2,0.2,0.4,0.2,0.4,0.2,0.6,0,0],
                        },
                        'G':{ 
                            //vector: [ 0.3,0, 0.8,0, 1,0.2, 0.8,0.3, 0.7,0.2, 0.4,0.2, 0.2,0.4, 0.2,0.6, 0.4,0.8, 0.8,0.8, 0.8,0.6, 1,0.6, 1,1, 0.3,1, 0,0.7, 0,0.3 ] 
                            vector:[0,0.7,0,0.3,0.3,0,0.3,0,0.8,0,1,0.2,1,0.2,0.8,0.3,0.7,0.2,0.8,0.8,0.8,0.6,1,0.6,1,1,0.3,1,0,0.7,0.3,0,1,0.2,0.7,0.2,0.8,0.8,1,0.6,1,1,0.3,0,0.7,0.2,0.4,0.2,0.4,0.8,0.8,0.8,1,1,0.3,0,0.4,0.2,0.2,0.4,0.4,0.8,1,1,0,0.7,0,0.7,0.3,0,0.2,0.4,0.2,0.6,0.4,0.8,0,0.7,0,0.7,0.2,0.4,0.2,0.6],
                        },
                        'H':{ 
                            //vector: [ 0,0, 0.2,0, 0.2,0.4, 0.8,0.4, 0.8,0, 1,0, 1,1, 0.8,1, 0.8,0.6, 0.2,0.6, 0.2,1, 0,1 ] 
                            vector:[0.2,1,0,1,0,0,0,0,0.2,0,0.2,0.4,0.8,0.4,0.8,0,1,0,1,0,1,1,0.8,1,0.2,0.6,0.2,1,0,0,1,0,0.8,1,0.8,0.6,0.2,0.6,0,0,0.2,0.4,0.8,0.4,1,0,0.8,0.6,0.8,0.6,0.2,0.6,0.2,0.4,0.2,0.4,0.8,0.4,0.8,0.6],
                        },
                        'I':{ 
                            //vector: [ 0,0, 1,0, 1,0.2, 0.6,0.2, 0.6,0.8, 1,0.8, 1,1, 0,1, 0,0.8, 0.4,0.8, 0.4,0.2, 0,0.2 ] 
                            vector:[0.4,0.2,0,0.2,0,0,0,0,1,0,1,0.2,0.6,0.8,1,0.8,1,1,1,1,0,1,0,0.8,0,0,1,0.2,0.6,0.2,1,1,0,0.8,0.4,0.8,0.4,0.2,0,0,0.6,0.2,0.6,0.8,1,1,0.4,0.8,0.4,0.8,0.4,0.2,0.6,0.2,0.6,0.2,0.6,0.8,0.4,0.8],
                        },
                        'J':{ 
                            //vector: [ 0,0, 1,0, 1,0.2, 0.6,0.2, 0.6,0.8, 0.4,1, 0,1, 0,0.8, 0.3,0.8, 0.4,0.7, 0.4,0.2, 0,0.2 ] 
                            vector:[0.4,0.2,0,0.2,0,0,0,0,1,0,1,0.2,0.6,0.2,0.6,0.8,0.4,1,0.4,1,0,1,0,0.8,0,0,1,0.2,0.6,0.2,0.4,1,0,0.8,0.3,0.8,0.4,0.2,0,0,0.6,0.2,0.4,1,0.3,0.8,0.4,0.7,0.4,0.7,0.4,0.2,0.6,0.2,0.6,0.2,0.4,1,0.4,0.7],
                        },
                        'K':{ 
                            //vector: [ 0,0, 0.2,0, 0.2,0.3, 1,0, 1,0.2, 0.5,0.4, 1,1, 0.75,1, 0.3,0.45, 0.2,0.5, 0.2,1, 0,1 ] 
                            vector:[0.2,1,0,1,0,0,0,0,0.2,0,0.2,0.3,0.2,0.3,1,0,1,0.2,0.5,0.4,1,1,0.75,1,0.2,0.5,0.2,1,0,0,0.2,0.3,1,0.2,0.5,0.4,0.5,0.4,0.75,1,0.3,0.45,0.3,0.45,0.2,0.5,0,0,0.2,0.3,0.5,0.4,0.3,0.45,0.3,0.45,0,0,0.2,0.3],
                        },
                        'L':{ 
                            //vector: [ 0,0, 0.2,0, 0.2,0.8, 1,0.8, 1,1, 0,1 ] 
                            vector:[0,1,0,0,0.2,0,0.2,0.8,1,0.8,1,1,0,1,0.2,0,0.2,0.8,0.2,0.8,1,1,0,1],
                        },
                        'M':{ 
                            //vector: [ 0,0, 0.2,0, 0.5,0.4, 0.8,0, 1,0, 1,1, 0.8,1, 0.8,0.3, 0.5,0.7, 0.2,0.3, 0.2,1, 0,1 ] 
                            vector:[0.2,1,0,1,0,0,0,0,0.2,0,0.5,0.4,0.5,0.4,0.8,0,1,0,1,0,1,1,0.8,1,0.2,0.3,0.2,1,0,0,1,0,0.8,1,0.8,0.3,0.5,0.7,0.2,0.3,0,0,0.5,0.4,1,0,0.8,0.3,0.5,0.7,0,0,0.5,0.4,0.5,0.4,0.8,0.3,0.5,0.7],
                        },
                        'N':{ 
                            //vector: [ 0,0, 0.2,0, 0.8,0.7, 0.8,0, 1,0, 1,1, 0.8,1, 0.2,0.3, 0.2,1, 0,1 ] 
                            vector:[0.2,1,0,1,0,0,0,0,0.2,0,0.8,0.7,0.8,0.7,0.8,0,1,0,1,0,1,1,0.8,1,0.2,0.3,0.2,1,0,0,0.8,0.7,1,0,0.8,1,0.8,1,0.2,0.3,0,0,0,0,0.8,0.7,0.8,1],
                        },
                        'O':{ 
                            //vector: [ 0.3,0, 0.7,0, 1,0.3, 1,0.7, 0.7,1, 0.3,1, 0,0.7, 0,0.3, 0.3,0, 0.4,0.2, 0.2,0.4, 0.2,0.6, 0.4,0.8, 0.6,0.8, 0.8,0.6, 0.8,0.4, 0.6,0.2, 0.4,0.2 ] 
                            vector:[0.6,0.2,0.4,0.2,0.3,0,0.3,0,0.7,0,1,0.3,1,0.3,1,0.7,0.7,1,0.7,1,0.3,1,0,0.7,0,0.7,0,0.3,0.3,0,0.3,0,0.4,0.2,0.2,0.4,0.6,0.2,0.3,0,1,0.3,0,0.7,0.3,0,0.2,0.4,0.8,0.4,0.6,0.2,1,0.3,0,0.7,0.2,0.4,0.2,0.6,0.8,0.6,0.8,0.4,1,0.3,0,0.7,0.2,0.6,0.4,0.8,0.8,0.6,1,0.3,0.7,1,0.7,1,0,0.7,0.4,0.8,0.6,0.8,0.8,0.6,0.7,1,0.7,1,0.4,0.8,0.6,0.8],
                        },
                        'P':{ 
                            //vector: [ 0,0, 0.8,0, 1,0.2, 1,0.4, 0.8,0.6, 0.2,0.6, 0.2,0.4, 0.7,0.4, 0.8,0.3, 0.7,0.2, 0.2,0.2, 0.2,1, 0,1 ] 
                            vector:[0.2,1,0,1,0,0,0,0,0.8,0,1,0.2,1,0.2,1,0.4,0.8,0.6,0.8,0.6,0.2,0.6,0.2,0.4,0.2,0.2,0.2,1,0,0,0.8,0.6,0.2,0.4,0.7,0.4,0.7,0.2,0.2,0.2,0,0,1,0.2,0.8,0.6,0.7,0.4,0.7,0.2,0,0,1,0.2,1,0.2,0.7,0.4,0.8,0.3,0.8,0.3,0.7,0.2,1,0.2],
                        },
                        'Q':{ 
                            //vector: [ 0.3,0, 0.7,0, 1,0.3, 1,0.7, 0.95,0.75, 1,0.8, 1,1, 0.8,1, 0.5,0.7, 0.5,0.5, 0.7,0.5, 0.8,0.6, 0.8,0.4, 0.6,0.2, 0.4,0.2, 0.2,0.4, 0.2,0.6, 0.4,0.8, 0.6,0.8, 0.75,0.95, 0.7,1, 0.3,1, 0,0.7, 0,0.3 ] 
                            vector:[0,0.7,0,0.3,0.3,0,0.3,0,0.7,0,1,0.3,1,0.3,1,0.7,0.95,0.75,0.95,0.75,1,0.8,1,1,1,1,0.8,1,0.5,0.7,0.5,0.7,0.5,0.5,0.7,0.5,0.4,0.8,0.6,0.8,0.75,0.95,0.75,0.95,0.7,1,0.3,1,0.95,0.75,1,1,0.5,0.7,0.5,0.7,0.7,0.5,0.8,0.6,0.4,0.8,0.75,0.95,0.3,1,0.95,0.75,0.5,0.7,0.8,0.6,0.2,0.6,0.4,0.8,0.3,1,1,0.3,0.95,0.75,0.8,0.6,0.2,0.6,0.3,1,0,0.7,1,0.3,0.8,0.6,0.8,0.4,0.2,0.4,0.2,0.6,0,0.7,1,0.3,0.8,0.4,0.6,0.2,0.2,0.4,0,0.7,0.3,0,0.3,0,1,0.3,0.6,0.2,0.4,0.2,0.2,0.4,0.3,0,0.3,0,0.6,0.2,0.4,0.2],
                            encroach:{'{':1},
                        },
                        'R':{ 
                            //vector: [ 0,0, 0.8,0, 1,0.2, 1,0.4, 0.8,0.6, 0.6,0.6, 1,1, 0.75,1, 0.35,0.6, 0.2,0.6, 0.2,0.4, 0.7,0.4, 0.8,0.3, 0.7,0.2, 0.2,0.2, 0.2,1, 0,1 ] 
                            vector:[0.2,1,0,1,0,0,0,0,0.8,0,1,0.2,1,0.2,1,0.4,0.8,0.6,0.6,0.6,1,1,0.75,1,0.35,0.6,0.2,0.6,0.2,0.4,0.2,0.2,0.2,1,0,0,1,0.2,0.8,0.6,0.6,0.6,0.6,0.6,0.75,1,0.35,0.6,0.35,0.6,0.2,0.4,0.7,0.4,0.7,0.2,0.2,0.2,0,0,0.6,0.6,0.35,0.6,0.7,0.4,0.7,0.2,0,0,1,0.2,1,0.2,0.6,0.6,0.7,0.4,0.8,0.3,0.7,0.2,1,0.2,1,0.2,0.7,0.4,0.8,0.3],
                        },
                        'S':{ 
                            //vector: [ 0.2,0, 0.8,0, 1,0.2, 1,0.3, 0.8,0.3, 0.7,0.2, 0.3,0.2, 0.2,0.3, 0.3,0.4, 0.8,0.4, 1,0.6, 1,0.8, 0.8,1, 0.2,1, 0,0.8, 0,0.7, 0.2,0.7, 0.3,0.8, 0.7,0.8, 0.8,0.7, 0.7,0.6, 0.2,0.6, 0,0.4, 0,0.2 ] 
                            vector:[0,0.4,0,0.2,0.2,0,0.2,0,0.8,0,1,0.2,1,0.2,1,0.3,0.8,0.3,0.3,0.4,0.8,0.4,1,0.6,1,0.6,1,0.8,0.8,1,0.8,1,0.2,1,0,0.8,0,0.8,0,0.7,0.2,0.7,0.7,0.6,0.2,0.6,0,0.4,1,0.2,0.8,0.3,0.7,0.2,0,0.8,0.2,0.7,0.3,0.8,0.2,0,1,0.2,0.7,0.2,0.8,1,0,0.8,0.3,0.8,0.2,0,0.7,0.2,0.3,0.2,0.8,1,0.3,0.8,0.7,0.8,0,0.4,0.2,0,0.3,0.2,1,0.6,0.8,1,0.7,0.8,0,0.4,0.3,0.2,0.2,0.3,1,0.6,0.7,0.8,0.8,0.7,0,0.4,0.2,0.3,0.3,0.4,1,0.6,0.8,0.7,0.7,0.6,0.7,0.6,0,0.4,0.3,0.4,0.3,0.4,1,0.6,0.7,0.6],
                        },
                        'T':{ 
                            //vector: [ 0,0, 1,0, 1,0.2, 0.6,0.2, 0.6,1, 0.4,1, 0.4,0.2, 0,0.2 ] 
                            vector:[0.4,0.2,0,0.2,0,0,0,0,1,0,1,0.2,0.6,0.2,0.6,1,0.4,1,0,0,1,0.2,0.6,0.2,0.6,0.2,0.4,1,0.4,0.2,0.4,0.2,0,0,0.6,0.2],
                        },
                        'U':{ 
                            //vector: [ 0,0, 0.2,0, 0.2,0.6, 0.4,0.8, 0.6,0.8, 0.8,0.6, 0.8,0, 1,0, 1,0.7, 0.7,1, 0.3,1, 0,0.7 ] 
                            vector:[0.3,1,0,0.7,0,0,0,0,0.2,0,0.2,0.6,0.8,0.6,0.8,0,1,0,1,0,1,0.7,0.7,1,0.3,1,0,0,0.2,0.6,0.8,0.6,1,0,0.7,1,0.3,1,0.2,0.6,0.4,0.8,0.6,0.8,0.8,0.6,0.7,1,0.7,1,0.3,1,0.4,0.8,0.4,0.8,0.6,0.8,0.7,1],
                        },
                        'V':{ 
                            //vector: [ 0,0, 0.2,0, 0.5,0.7, 0.8,0, 1,0, 0.6,1, 0.4,1 ] 
                            vector:[0.6,1,0.4,1,0,0,0,0,0.2,0,0.5,0.7,0.5,0.7,0.8,0,1,0,0.6,1,0,0,0.5,0.7,0.5,0.7,1,0,0.6,1],
                        },
                        'W':{ 
                            //vector: [ 0,1, 0.2,1, 0.5,0.6, 0.8,1, 1,1, 1,0, 0.8,0, 0.8,0.7, 0.5,0.3, 0.2,0.7, 0.2,0, 0,0 ] 
                            vector:[0.2,1,0,1,0,0,0,0,0.2,0,0.2,0.7,0.8,0.7,0.8,0,1,0,1,0,1,1,0.8,1,0.2,1,0,0,0.2,0.7,0.8,0.7,1,0,0.8,1,0.5,0.6,0.2,1,0.2,0.7,0.5,0.3,0.8,0.7,0.8,1,0.5,0.6,0.2,0.7,0.5,0.3,0.5,0.3,0.8,1,0.5,0.6],
                        },
                        'X':{ 
                            //vector: [ 0,0, 0.25,0, 0.5,0.35, 0.75,0, 1,0, 0.6,0.5, 1,1, 0.75,1, 0.5,0.65, 0.25,1, 0,1, 0.4,0.5 ] 
                            vector:[0.4,0.5,0,0,0.25,0,0.5,0.35,0.75,0,1,0,0.6,0.5,1,1,0.75,1,0.5,0.65,0.25,1,0,1,0.4,0.5,0.25,0,0.5,0.35,0.5,0.35,1,0,0.6,0.5,0.6,0.5,0.75,1,0.5,0.65,0.5,0.65,0,1,0.4,0.5,0.4,0.5,0.5,0.35,0.6,0.5,0.6,0.5,0.5,0.65,0.4,0.5],
                        },
                        'Y':{ 
                            //vector: [ 0,0, 0.25,0, 0.5,0.35, 0.75,0, 1,0, 0.25,1, 0,1, 0.35,0.5 ] 
                            vector:[0.35,0.5,0,0,0.25,0,0.5,0.35,0.75,0,1,0,1,0,0.25,1,0,1,0.35,0.5,0.25,0,0.5,0.35,0.5,0.35,1,0,0,1,0,1,0.35,0.5,0.5,0.35],
                        },
                        'Z':{ 
                            //vector: [ 0,0, 1,0, 1,0.2, 0.3,0.2, 1,0.8, 1,1, 0,1, 0,0.8, 0.7,0.8, 0,0.2 ] 
                            vector:[0.7,0.8,0,0.2,0,0,0,0,1,0,1,0.2,0.3,0.2,1,0.8,1,1,1,1,0,1,0,0.8,0,0,1,0.2,0.3,0.2,1,1,0,0.8,0.7,0.8,0.7,0.8,0,0,0.3,0.2,0.3,0.2,1,1,0.7,0.8],
                        },
                    
                    
                        'a':{
                            //vector: [ 0.2/0.8,0.0/0.6, 0.5/0.8,0.0/0.6, 0.7/0.8,0.2/0.6, 0.7/0.8,0.5/0.6, 0.8/0.8,0.6/0.6, 0.5/0.8,0.6/0.6, 0.5/0.8,0.3/0.6, 0.4/0.8,0.2/0.6, 0.3/0.8,0.2/0.6, 0.2/0.8,0.3/0.6, 0.3/0.8,0.4/0.6, 0.5/0.8,0.4/0.6, 0.5/0.8,0.6/0.6, 0.2/0.8,0.6/0.6, 0.0/0.8,0.4/0.6, 0.0/0.8,0.2/0.6 ]
                            vector:[0,0.6666666666666667,0,0.33333333333333337,0.25,0,0.25,0,0.625,0,0.8749999999999999,0.33333333333333337,0.8749999999999999,0.8333333333333334,1,1,0.625,1,0.37499999999999994,0.6666666666666667,0.625,0.6666666666666667,0.625,1,0.625,1,0.25,1,0,0.6666666666666667,0.8749999999999999,0.33333333333333337,0.8749999999999999,0.8333333333333334,0.625,1,0.37499999999999994,0.6666666666666667,0.625,1,0,0.6666666666666667,0.8749999999999999,0.33333333333333337,0.625,1,0.625,0.5,0.25,0.5,0.37499999999999994,0.6666666666666667,0,0.6666666666666667,0.25,0,0.8749999999999999,0.33333333333333337,0.625,0.5,0.37499999999999994,0.33333333333333337,0.25,0.5,0,0.6666666666666667,0.25,0,0.625,0.5,0.5,0.33333333333333337,0.37499999999999994,0.33333333333333337,0,0.6666666666666667,0.25,0,0.25,0,0.5,0.33333333333333337,0.37499999999999994,0.33333333333333337],
                            ratio:{x:0.8,y:0.6}, offset:{y:0.4},
                            encroach:{'a':1,'t':1,'Y':3},
                        },
                        'b':{
                            //vector: [ 0,0, 0.2/0.7,0, 0.2/0.7,0.8, 0.4/0.7,0.8, 0.5/0.7,0.7, 0.4/0.7,0.6, 0.2/0.7,0.6, 0.2/0.7,0.4, 0.5/0.7,0.4, 0.7/0.7,0.6, 0.7/0.7,0.8, 0.5/0.7,1, 0,1 ]
                            vector:[0,1,0,0,0.28571428571428575,0,0.5714285714285715,0.6,0.28571428571428575,0.6,0.28571428571428575,0.4,0.28571428571428575,0.4,0.7142857142857143,0.4,1,0.6,1,0.6,1,0.8,0.7142857142857143,1,0,1,0.28571428571428575,0,0.28571428571428575,0.8,0.5714285714285715,0.6,0.28571428571428575,0.4,1,0.6,0.7142857142857143,1,0,1,0.28571428571428575,0.8,0.7142857142857143,0.7,0.5714285714285715,0.6,1,0.6,0.7142857142857143,1,0.28571428571428575,0.8,0.5714285714285715,0.8,0.5714285714285715,0.8,0.7142857142857143,0.7,1,0.6,1,0.6,0.7142857142857143,1,0.5714285714285715,0.8],
                            ratio:{x:0.7}
                        },
                        'c':{
                            //vector: [ 0.2/0.7,0.0/0.6, 0.7/0.7,0.0/0.6, 0.7/0.7,0.2/0.6, 0.3/0.7,0.2/0.6, 0.2/0.7,0.3/0.6, 0.3/0.7,0.4/0.6, 0.7/0.7,0.4/0.6, 0.7/0.7,0.6/0.6, 0.2/0.7,0.6/0.6, 0.0/0.7,0.4/0.6, 0.0/0.7,0.2/0.6 ]
                            vector:[0,0.6666666666666667,0,0.33333333333333337,0.28571428571428575,0,0.28571428571428575,0,1,0,1,0.33333333333333337,0.4285714285714286,0.6666666666666667,1,0.6666666666666667,1,1,1,1,0.28571428571428575,1,0,0.6666666666666667,0.28571428571428575,0,1,0.33333333333333337,0.4285714285714286,0.33333333333333337,0.4285714285714286,0.6666666666666667,1,1,0,0.6666666666666667,0,0.6666666666666667,0.28571428571428575,0,0.4285714285714286,0.33333333333333337,0.28571428571428575,0.5,0.4285714285714286,0.6666666666666667,0,0.6666666666666667,0,0.6666666666666667,0.4285714285714286,0.33333333333333337,0.28571428571428575,0.5],
                            ratio:{x:0.7,y:0.6}, offset:{y:0.4},
                            encroach:{'a':1},
                        },
                        'd':{
                            //vector: [ 0.0/0.7,0.6, 0.2/0.7,0.4, 0.5/0.7,0.4, 0.5/0.7,0.6, 0.3/0.7,0.6, 0.2/0.7,0.7, 0.3/0.7,0.8, 0.5/0.7,0.8, 0.5/0.7,0.0, 0.7/0.7,0.0, 0.7/0.7,1.0, 0.2/0.7,1.0, 0.0/0.7,0.8 ]
                            vector:[0.28571428571428575,1,0,0.8,0,0.6,0,0.6,0.28571428571428575,0.4,0.7142857142857143,0.4,0.7142857142857143,0.4,0.7142857142857143,0.6,0.4285714285714286,0.6,0.7142857142857143,0.8,0.7142857142857143,0,1,0,0,0.6,0.7142857142857143,0.4,0.4285714285714286,0.6,0.7142857142857143,0.8,1,0,1,1,0,0.6,0.4285714285714286,0.6,0.28571428571428575,0.7,0.4285714285714286,0.8,0.7142857142857143,0.8,1,1,0.28571428571428575,1,0,0.6,0.28571428571428575,0.7,0.4285714285714286,0.8,1,1,0.28571428571428575,1,0.28571428571428575,1,0.28571428571428575,0.7,0.4285714285714286,0.8],
                            ratio:{x:0.7},
                            encroach:{'a':1},
                        },
                        'e':{
                            //vector: [ 0.2,0.0/0.8, 0.8,0.0/0.8, 1.0,0.2/0.8, 1.0,0.4/0.8, 0.9,0.5/0.8, 0.2,0.5/0.8, 0.2,0.3/0.8, 0.8,0.3/0.8, 0.7,0.2/0.8, 0.3,0.2/0.8, 0.2,0.3/0.8, 0.2,0.5/0.8, 0.3,0.6/0.8, 1.0,0.6/0.8, 0.8,0.8/0.8, 0.2,0.8/0.8, 0.0,0.6/0.8, 0.0,0.2/0.8 ]
                            vector:[0,0.7499999999999999,0,0.25,0.2,0,0.2,0,0.8,0,1,0.25,1,0.25,1,0.5,0.9,0.625,0.3,0.7499999999999999,1,0.7499999999999999,0.8,1,0.8,1,0.2,1,0,0.7499999999999999,0.3,0.7499999999999999,0.8,1,0,0.7499999999999999,0.2,0.625,0.3,0.7499999999999999,0,0.7499999999999999,0.2,0.37499999999999994,0.2,0.625,0,0.7499999999999999,0.2,0.37499999999999994,0,0.7499999999999999,0.2,0,0.9,0.625,0.2,0.625,0.2,0.37499999999999994,0.3,0.25,0.2,0.37499999999999994,0.2,0,0.9,0.625,0.2,0.37499999999999994,0.8,0.37499999999999994,0.7,0.25,0.3,0.25,0.2,0,1,0.25,0.9,0.625,0.8,0.37499999999999994,0.7,0.25,0.2,0,1,0.25,1,0.25,0.8,0.37499999999999994,0.7,0.25],
                            ratio:{x:0.7,y:0.6}, offset:{y:0.4},
                            encroach:{'K':1,'t':1,'v':0.5,'x':1},
                        },
                        'f':{
                            //vector: [ 0.3/0.4,0.0, 0.4/0.4,0.0, 0.4/0.4,0.2, 0.3/0.4,0.3, 0.3/0.4,0.4, 0.4/0.4,0.4, 0.4/0.4,0.6, 0.3/0.4,0.6, 0.3/0.4,1.0, 0.1/0.4,1.0, 0.1/0.4,0.6, 0.0/0.4,0.6, 0.0/0.4,0.4, 0.1/0.4,0.4, 0.1/0.4,0.2 ]
                            vector:[0.25,0.4,0.25,0.2,0.7499999999999999,0,0.7499999999999999,0,1,0,1,0.2,0.7499999999999999,0.4,1,0.4,1,0.6,0.7499999999999999,0.6,0.7499999999999999,1,0.25,1,0.25,0.6,0,0.6,0,0.4,0.25,0.4,0.7499999999999999,0,1,0.2,0.7499999999999999,0.4,1,0.6,0.7499999999999999,0.6,0.7499999999999999,0.6,0.25,1,0.25,0.6,0.25,0.6,0,0.4,0.25,0.4,0.25,0.4,1,0.2,0.7499999999999999,0.3,0.7499999999999999,0.4,0.7499999999999999,0.6,0.25,0.6,0.25,0.6,0.25,0.4,0.7499999999999999,0.3,0.7499999999999999,0.3,0.7499999999999999,0.4,0.25,0.6],
                            ratio:{x:0.4}, 
                        },
                        'g':{
                            //vector: [ 0.2/0.7,0.0/1.1, 0.6/0.7,0.0/1.1, 0.7/0.7,0.1/1.1, 0.7/0.7,0.9/1.1, 0.5/0.7,1.1/1.1, 0.2/0.7,1.1/1.1, 0.0/0.7,0.9/1.1, 0.0/0.7,0.8/1.1, 0.2/0.7,0.8/1.1, 0.3/0.7,0.9/1.1, 0.4/0.7,0.9/1.1, 0.5/0.7,0.8/1.1, 0.5/0.7,0.2/1.1, 0.3/0.7,0.2/1.1, 0.2/0.7,0.3/1.1, 0.3/0.7,0.4/1.1, 0.5/0.7,0.4/1.1, 0.5/0.7,0.6/1.1, 0.2/0.7,0.6/1.1, 0.0/0.7,0.4/1.1, 0.0/0.7,0.2/1.1 ]
                            vector:[0,0.36363636363636365,0,0.18181818181818182,0.28571428571428575,0,0.28571428571428575,0,0.8571428571428572,0,1,0.09090909090909091,1,0.09090909090909091,1,0.8181818181818181,0.7142857142857143,1,0.7142857142857143,1,0.28571428571428575,1,0,0.8181818181818181,0,0.8181818181818181,0,0.7272727272727273,0.28571428571428575,0.7272727272727273,0.4285714285714286,0.36363636363636365,0.7142857142857143,0.36363636363636365,0.7142857142857143,0.5454545454545454,0.7142857142857143,0.5454545454545454,0.28571428571428575,0.5454545454545454,0,0.36363636363636365,0.7142857142857143,1,0,0.8181818181818181,0.28571428571428575,0.7272727272727273,0.4285714285714286,0.36363636363636365,0.7142857142857143,0.5454545454545454,0,0.36363636363636365,0.7142857142857143,1,0.28571428571428575,0.7272727272727273,0.4285714285714286,0.8181818181818181,0.28571428571428575,0.2727272727272727,0.4285714285714286,0.36363636363636365,0,0.36363636363636365,0.7142857142857143,1,0.4285714285714286,0.8181818181818181,0.5714285714285715,0.8181818181818181,0.4285714285714286,0.18181818181818182,0.28571428571428575,0.2727272727272727,0,0.36363636363636365,0.7142857142857143,1,0.5714285714285715,0.8181818181818181,0.7142857142857143,0.7272727272727273,0.4285714285714286,0.18181818181818182,0,0.36363636363636365,0.28571428571428575,0,1,0.09090909090909091,0.7142857142857143,1,0.7142857142857143,0.7272727272727273,0.7142857142857143,0.18181818181818182,0.4285714285714286,0.18181818181818182,0.28571428571428575,0,1,0.09090909090909091,0.7142857142857143,0.7272727272727273,0.7142857142857143,0.18181818181818182,0.7142857142857143,0.18181818181818182,0.28571428571428575,0,1,0.09090909090909091],
                            ratio:{x:0.7,y:1.1}, offset:{y:0.4},
                        },
                        'h':{
                            //vector: [ 0.0/0.7,0.0, 0.2/0.7,0.0, 0.2/0.7,0.4, 0.5/0.7,0.4, 0.7/0.7,0.6, 0.7/0.7,1.0, 0.5/0.7,1.0, 0.5/0.7,0.7, 0.4/0.7,0.6, 0.2/0.7,0.6, 0.2/0.7,1.0, 0.0/0.7,1.0 ]
                            vector:[0.28571428571428575,1,0,1,0,0,0,0,0.28571428571428575,0,0.28571428571428575,0.4,0.28571428571428575,0.4,0.7142857142857143,0.4,1,0.6,1,0.6,1,1,0.7142857142857143,1,0.28571428571428575,0.6,0.28571428571428575,1,0,0,1,0.6,0.7142857142857143,1,0.7142857142857143,0.7,0.28571428571428575,0.6,0,0,0.28571428571428575,0.4,1,0.6,0.7142857142857143,0.7,0.5714285714285715,0.6,0.5714285714285715,0.6,0.28571428571428575,0.6,0.28571428571428575,0.4,0.28571428571428575,0.4,1,0.6,0.5714285714285715,0.6],
                            ratio:{x:0.7}
                        },
                        'i':{
                            //vector: [ 0.0/0.2,0.0/0.9, 0.2/0.2,0.0/0.9, 0.2/0.2,0.2/0.9, 0.0/0.2,0.2/0.9, 0.0/0.2,0.3/0.9, 0.2/0.2,0.3/0.9, 0.2/0.2,0.9/0.9, 0.0/0.2,0.9/0.9 ]
                            vector:[0,0,1,0,1,0.22222222222222224,0,0.3333333333333333,1,0.3333333333333333,1,1,0,0,1,0.22222222222222224,0,0.22222222222222224,0,0.3333333333333333,1,1,0,1],
                            ratio:{x:0.2,y:0.9}, offset:{y:0.1},
                        },
                        'j':{
                            //vector: [ 0.2/0.4,0.0/1.2, 0.4/0.4,0.0/1.2, 0.4/0.4,0.2/1.2, 0.2/0.4,0.2/1.2, 0.2/0.4,0.3/1.2, 0.4/0.4,0.3/1.2, 0.4/0.4,1.0/1.2, 0.2/0.4,1.2/1.2, 0.0/0.4,1.2/1.2, 0.0/0.4,1.0/1.2, 0.1/0.4,1.0/1.2, 0.2/0.4,0.9/1.2 ]
                            vector:[0.5,0,1,0,1,0.16666666666666669,0.5,0.25,1,0.25,1,0.8333333333333334,1,0.8333333333333334,0.5,1,0,1,0,1,0,0.8333333333333334,0.25,0.8333333333333334,0.5,0,1,0.16666666666666669,0.5,0.16666666666666669,1,0.8333333333333334,0,1,0.25,0.8333333333333334,1,0.8333333333333334,0.25,0.8333333333333334,0.5,0.75,0.5,0.25,1,0.8333333333333334,0.5,0.75],
                            ratio:{x:0.4,y:1.2}, offset:{y:0.1},
                            encroach:{
                                'A':1,'B':1,'C':1,'D':1,'E':1,'F':1,'G':1,'H':1,'I':1,'J':1,'L':1,'K':1,'M':1,'N':1,'O':1,'P':1,'Q':1,'R':1,'S':1,'T':1,'U':1,'V':1,'W':1,'X':1,'Y':1,'Z':1,
                                'a':2,'b':1,'c':1,'d':1,'e':1,'f':1,'h':1,'i':1,'k':1,'l':1,'n':1,'m':1,'o':1,'p':1,'r':1,'s':1,'t':1,'u':1,'v':1,'w':1,'x':1,'z':1,
                            },
                        },
                        'k':{
                            //vector: [ 0.0/0.75,0.0, 0.2/0.75,0.0, 0.2/0.75,0.5, 0.5/0.75,0.3, 0.75/0.75,0.3, 0.35/0.75,0.6, 0.75/0.75,1.0, 0.5/0.75,1.0, 0.2/0.75,0.7, 0.2/0.75,1.0, 0.0/0.75,1.0 ]
                            vector:[0.26666666666666666,1,0,1,0,0,0,0,0.26666666666666666,0,0.26666666666666666,0.5,0.26666666666666666,0.5,0.6666666666666666,0.3,1,0.3,0.4666666666666666,0.6,1,1,0.6666666666666666,1,0.26666666666666666,0.7,0.26666666666666666,1,0,0,0.26666666666666666,0.5,1,0.3,0.4666666666666666,0.6,0.4666666666666666,0.6,0.6666666666666666,1,0.26666666666666666,0.7,0.26666666666666666,0.7,0,0,0.26666666666666666,0.5,0.26666666666666666,0.5,0.4666666666666666,0.6,0.26666666666666666,0.7],
                            ratio:{x:0.75}
                        },
                        'l':{
                            //vector: [ 0.0/0.5,0.0, 0.2/0.5,0.0, 0.2/0.5,0.7, 0.3/0.5,0.8, 0.5/0.5,0.8, 0.5/0.5,1.0, 0.2/0.5,1.0, 0.0/0.5,0.8 ]
                            vector:[0.4,1,0,0.8,0,0,0,0,0.4,0,0.4,0.7,0.6,0.8,1,0.8,1,1,0.4,1,0,0,0.4,0.7,0.6,0.8,1,1,0.4,1,0.4,1,0.4,0.7,0.6,0.8],
                            ratio:{x:0.5},
                            encroach:{'a':1},
                        },
                        'm':{
                            //vector: [ 0.0/1.2,0.0/0.6, 1.0/1.2,0.0/0.6, 1.2/1.2,0.2/0.6, 1.2/1.2,0.6/0.6, 1.0/1.2,0.6/0.6, 1.0/1.2,0.3/0.6, 0.9/1.2,0.2/0.6, 0.7/1.2,0.2/0.6, 0.7/1.2,0.6/0.6, 0.5/1.2,0.6/0.6, 0.5/1.2,0.3/0.6, 0.4/1.2,0.2/0.6, 0.2/1.2,0.2/0.6, 0.2/1.2,0.6/0.6, 0.0/1.2,0.6/0.6 ]
                            vector:[0.16666666666666669,1,0,1,0,0,0,0,0.8333333333333334,0,1,0.33333333333333337,1,0.33333333333333337,1,1,0.8333333333333334,1,0.5833333333333334,0.33333333333333337,0.5833333333333334,1,0.4166666666666667,1,0.16666666666666669,0.33333333333333337,0.16666666666666669,1,0,0,1,0.33333333333333337,0.8333333333333334,1,0.8333333333333334,0.5,0.5833333333333334,0.33333333333333337,0.4166666666666667,1,0.4166666666666667,0.5,0.33333333333333337,0.33333333333333337,0.16666666666666669,0.33333333333333337,0,0,1,0.33333333333333337,0.8333333333333334,0.5,0.75,0.33333333333333337,0.5833333333333334,0.33333333333333337,0.4166666666666667,0.5,0.33333333333333337,0.33333333333333337,0,0,1,0.33333333333333337,0.75,0.33333333333333337,0.5833333333333334,0.33333333333333337,0.33333333333333337,0.33333333333333337,0,0,0,0,0.75,0.33333333333333337,0.5833333333333334,0.33333333333333337],
                            ratio:{x:1.2,y:0.6}, offset:{y:0.4},
                        },
                        'n':{
                            //vector: [ 0.0/0.7,0.0/0.6, 0.5/0.7,0.0/0.6, 0.7/0.7,0.2/0.6, 0.7/0.7,0.6/0.6, 0.5/0.7,0.6/0.6, 0.5/0.7,0.3/0.6, 0.4/0.7,0.2/0.6, 0.2/0.7,0.2/0.6, 0.2/0.7,0.6/0.6, 0.0/0.7,0.6/0.6 ]
                            vector:[0.28571428571428575,1,0,1,0,0,0,0,0.7142857142857143,0,1,0.33333333333333337,1,0.33333333333333337,1,1,0.7142857142857143,1,0.28571428571428575,0.33333333333333337,0.28571428571428575,1,0,0,1,0.33333333333333337,0.7142857142857143,1,0.7142857142857143,0.5,0.5714285714285715,0.33333333333333337,0.28571428571428575,0.33333333333333337,0,0,1,0.33333333333333337,0.7142857142857143,0.5,0.5714285714285715,0.33333333333333337,0.5714285714285715,0.33333333333333337,0,0,1,0.33333333333333337],
                            ratio:{x:0.7,y:0.6}, offset:{y:0.4},
                        },
                        'o':{
                            //vector: [ 0.2/0.6,0.0/0.6, 0.4/0.6,0.0/0.6, 0.6/0.6,0.2/0.6, 0.6/0.6,0.4/0.6, 0.4/0.6,0.6/0.6, 0.2/0.6,0.6/0.6, 0.0/0.6,0.4/0.6, 0.0/0.6,0.2/0.6, 0.2/0.6,0.3/0.6, 0.3/0.6,0.4/0.6, 0.4/0.6,0.3/0.6, 0.3/0.6,0.2/0.6, 0.2/0.6,0.3/0.6, 0.0/0.6,0.2/0.6 ]
                            vector:[0.33333333333333337,0.5,0,0.33333333333333337,0.33333333333333337,0,0.33333333333333337,0,0.6666666666666667,0,1,0.33333333333333337,1,0.33333333333333337,1,0.6666666666666667,0.6666666666666667,1,0.6666666666666667,1,0.33333333333333337,1,0,0.6666666666666667,0,0.6666666666666667,0,0.33333333333333337,0.33333333333333337,0.5,0.5,0.33333333333333337,0.33333333333333337,0.5,0.33333333333333337,0,0.6666666666666667,1,0,0.6666666666666667,0.33333333333333337,0.5,0.6666666666666667,0.5,0.5,0.33333333333333337,0.33333333333333337,0,0.6666666666666667,1,0.33333333333333337,0.5,0.5,0.6666666666666667,0.6666666666666667,0.5,0.33333333333333337,0,1,0.33333333333333337,1,0.33333333333333337,0.6666666666666667,1,0.5,0.6666666666666667,0.5,0.6666666666666667,0.6666666666666667,0.5,1,0.33333333333333337],
                            ratio:{x:0.6,y:0.6}, offset:{y:0.4},
                            encroach:{'T':1,'a':1,'t':1,'v':1,'x':1},
                        },
                        'p':{
                            //vector: [ 0.0/0.7,0.0, 0.5/0.7,0.0, 0.7/0.7,0.2, 0.7/0.7,0.4, 0.5/0.7,0.6, 0.2/0.7,0.6, 0.2/0.7,0.4, 0.4/0.7,0.4, 0.5/0.7,0.3, 0.4/0.7,0.2, 0.2/0.7,0.2, 0.2/0.7,1.0, 0.0/0.7,1.0 ]
                            vector:[0.28571428571428575,1,0,1,0,0,0,0,0.7142857142857143,0,1,0.2,1,0.2,1,0.4,0.7142857142857143,0.6,0.7142857142857143,0.6,0.28571428571428575,0.6,0.28571428571428575,0.4,0.28571428571428575,0.2,0.28571428571428575,1,0,0,0.7142857142857143,0.6,0.28571428571428575,0.4,0.5714285714285715,0.4,0.5714285714285715,0.2,0.28571428571428575,0.2,0,0,1,0.2,0.7142857142857143,0.6,0.5714285714285715,0.4,0.5714285714285715,0.2,0,0,1,0.2,1,0.2,0.5714285714285715,0.4,0.7142857142857143,0.3,0.7142857142857143,0.3,0.5714285714285715,0.2,1,0.2],
                            ratio:{x:0.7}, offset:{y:0.4},
                        },
                        'q':{
                            //vector: [ 0.2/0.7,0.0, 0.7/0.7,0.0, 0.7/0.7,1.0, 0.5/0.7,1.0, 0.5/0.7,0.2, 0.3/0.7,0.2, 0.2/0.7,0.3, 0.3/0.7,0.4, 0.5/0.7,0.4, 0.5/0.7,0.6, 0.2/0.7,0.6, 0.0/0.7,0.4, 0.0/0.7,0.2 ]
                            vector:[0,0.4,0,0.2,0.28571428571428575,0,1,0,1,1,0.7142857142857143,1,0.4285714285714286,0.4,0.7142857142857143,0.4,0.7142857142857143,0.6,0.7142857142857143,0.6,0.28571428571428575,0.6,0,0.4,1,0,0.7142857142857143,1,0.7142857142857143,0.2,0.4285714285714286,0.4,0.7142857142857143,0.6,0,0.4,0.28571428571428575,0,1,0,0.7142857142857143,0.2,0.28571428571428575,0.3,0.4285714285714286,0.4,0,0.4,0.28571428571428575,0,0.7142857142857143,0.2,0.4285714285714286,0.2,0.4285714285714286,0.2,0.28571428571428575,0.3,0,0.4,0,0.4,0.28571428571428575,0,0.4285714285714286,0.2],
                            ratio:{x:0.7}, offset:{y:0.4},
                        },
                        'r':{
                            //vector: [ 0.0/0.7,0.0/0.6, 0.2/0.7,0.0/0.6, 0.2/0.7,0.1/0.6, 0.4/0.7,0.0/0.6, 0.7/0.7,0.1/0.6, 0.7/0.7,0.3/0.6, 0.4/0.7,0.2/0.6, 0.2/0.7,0.3/0.6, 0.2/0.7,0.6/0.6, 0.0/0.7,0.6/0.6 ]
                            vector:[0.28571428571428575,1,0,1,0,0,0,0,0.28571428571428575,0,0.28571428571428575,0.16666666666666669,0.28571428571428575,0.16666666666666669,0.5714285714285715,0,1,0.16666666666666669,1,0.16666666666666669,1,0.5,0.5714285714285715,0.33333333333333337,0.28571428571428575,0.5,0.28571428571428575,1,0,0,0.28571428571428575,0.16666666666666669,1,0.16666666666666669,0.5714285714285715,0.33333333333333337,0.28571428571428575,0.5,0,0,0.28571428571428575,0.16666666666666669,0.28571428571428575,0.16666666666666669,0.5714285714285715,0.33333333333333337,0.28571428571428575,0.5],
                            ratio:{x:0.7,y:0.6}, offset:{y:0.4},
                        },
                        's':{
                            //vector: [ 0.2/0.8,0.0/0.8, 0.7/0.8,0.0/0.8, 0.8/0.8,0.2/0.8, 0.3/0.8,0.2/0.8, 0.25/0.8,0.3/0.8, 0.7/0.8,0.3/0.8, 0.8/0.8,0.6/0.8, 0.6/0.8,0.8/0.8, 0.1/0.8,0.8/0.8, 0.0/0.8,0.6/0.8, 0.5/0.8,0.6/0.8, 0.55/0.8,0.5/0.8, 0.1/0.8,0.5/0.8, 0.0/0.8,0.2/0.8 ]
                            vector:[0.125,0.625,0,0.25,0.25,0,0.25,0,0.8749999999999999,0,1,0.25,0.3125,0.37499999999999994,0.8749999999999999,0.37499999999999994,1,0.7499999999999999,1,0.7499999999999999,0.7499999999999999,1,0.125,1,0.125,1,0,0.7499999999999999,0.625,0.7499999999999999,0.25,0,1,0.25,0.37499999999999994,0.25,1,0.7499999999999999,0.125,1,0.625,0.7499999999999999,0.125,0.625,0.25,0,0.37499999999999994,0.25,1,0.7499999999999999,0.625,0.7499999999999999,0.6875,0.625,0.125,0.625,0.37499999999999994,0.25,0.3125,0.37499999999999994,0.3125,0.37499999999999994,1,0.7499999999999999,0.6875,0.625,0.6875,0.625,0.125,0.625,0.3125,0.37499999999999994],
                            ratio:{x:0.7,y:0.6}, offset:{y:0.4},
                        },
                        't':{
                            //vector: [ 0.2/0.6,0.0, 0.4/0.6,0.0, 0.4/0.6,0.2, 0.6/0.6,0.2, 0.6/0.6,0.4, 0.4/0.6,0.4, 0.4/0.6,1.0, 0.2/0.6,1.0, 0.2/0.6,0.4, 0.0/0.6,0.4, 0.0/0.6,0.2, 0.2/0.6,0.2 ]
                            vector:[0.33333333333333337,0.2,0.33333333333333337,0,0.6666666666666667,0,0.6666666666666667,0.2,1,0.2,1,0.4,0.6666666666666667,0.4,0.6666666666666667,1,0.33333333333333337,1,0.33333333333333337,0.4,0,0.4,0,0.2,0.33333333333333337,0.2,0.6666666666666667,0,0.6666666666666667,0.2,0.6666666666666667,0.2,1,0.4,0.6666666666666667,0.4,0.6666666666666667,0.4,0.33333333333333337,1,0.33333333333333337,0.4,0.33333333333333337,0.4,0,0.2,0.33333333333333337,0.2,0.33333333333333337,0.2,0.6666666666666667,0.2,0.6666666666666667,0.4,0.6666666666666667,0.4,0.33333333333333337,0.4,0.33333333333333337,0.2],
                            ratio:{x:0.6},
                            encroach:{'a':1,'h':1,'l':1,'n':1,'o':1,'p':1,'r':1,'s':1,'u':1},
                        },
                        'u':{
                            //vector: [ 0.0/0.7,0.0/0.6, 0.2/0.7,0.0/0.6, 0.2/0.7,0.3/0.6, 0.3/0.7,0.4/0.6, 0.5/0.7,0.4/0.6, 0.5/0.7,0.0/0.6, 0.7/0.7,0.0/0.6, 0.7/0.7,0.6/0.6, 0.2/0.7,0.6/0.6, 0.0/0.7,0.4/0.6 ]
                            vector:[0.28571428571428575,1,0,0.6666666666666667,0,0,0,0,0.28571428571428575,0,0.28571428571428575,0.5,0.7142857142857143,0.6666666666666667,0.7142857142857143,0,1,0,0.28571428571428575,1,0,0,0.28571428571428575,0.5,0.7142857142857143,0.6666666666666667,1,0,1,1,0.28571428571428575,1,0.28571428571428575,0.5,0.4285714285714286,0.6666666666666667,0.4285714285714286,0.6666666666666667,0.7142857142857143,0.6666666666666667,1,1,1,1,0.28571428571428575,1,0.4285714285714286,0.6666666666666667],
                            ratio:{x:0.7,y:0.6}, offset:{y:0.4},
                            encroach:{'A':1,'a':0.5},
                        },
                        'v':{
                            //vector: [ 0.0/0.7,0.0/0.6, 0.2/0.7,0.0/0.6, 0.35/0.7,0.35/0.6, 0.5/0.7,0.0/0.6, 0.7/0.7,0.0/0.6, 0.45/0.7,0.6/0.6, 0.25/0.7,0.6/0.6 ]
                            vector:[0.6428571428571429,1,0.35714285714285715,1,0,0,0,0,0.28571428571428575,0,0.5,0.5833333333333334,0.5,0.5833333333333334,0.7142857142857143,0,1,0,0.6428571428571429,1,0,0,0.5,0.5833333333333334,0.5,0.5833333333333334,1,0,0.6428571428571429,1],
                            ratio:{x:0.7,y:0.6}, offset:{y:0.4},
                            encroach:{'a':1},
                        },
                        'w':{
                            //vector: [ 0.0/1.2,0.0/0.6, 0.2/1.2,0.0/0.6, 0.2/1.2,0.3/0.6, 0.3/1.2,0.4/0.6, 0.5/1.2,0.4/0.6, 0.5/1.2,0.0/0.6, 0.7/1.2,0.0/0.6, 0.7/1.2,0.3/0.6, 0.8/1.2,0.4/0.6, 1.0/1.2,0.4/0.6, 1.0/1.2,0.0/0.6, 1.2/1.2,0.0/0.6, 1.2/1.2,0.6/0.6, 0.2/1.2,0.6/0.6, 0.0/1.2,0.4/0.6 ]
                            vector:[0.16666666666666669,1,0,0.6666666666666667,0,0,0,0,0.16666666666666669,0,0.16666666666666669,0.5,0.4166666666666667,0.6666666666666667,0.4166666666666667,0,0.5833333333333334,0,0.8333333333333334,0.6666666666666667,0.8333333333333334,0,1,0,0.16666666666666669,1,0,0,0.16666666666666669,0.5,0.4166666666666667,0.6666666666666667,0.5833333333333334,0,0.5833333333333334,0.5,0.8333333333333334,0.6666666666666667,1,0,1,1,0.16666666666666669,1,0.16666666666666669,0.5,0.25,0.6666666666666667,0.4166666666666667,0.6666666666666667,0.5833333333333334,0.5,0.6666666666666667,0.6666666666666667,0.6666666666666667,0.6666666666666667,0.8333333333333334,0.6666666666666667,1,1,1,1,0.16666666666666669,1,0.25,0.6666666666666667,0.4166666666666667,0.6666666666666667,0.6666666666666667,0.6666666666666667,1,1,1,1,0.25,0.6666666666666667,0.4166666666666667,0.6666666666666667],
                            ratio:{x:1.2,y:0.6}, offset:{y:0.4},
                        },
                        'x':{
                            //vector: [ 0.0/0.7,0.0/0.6, 0.2/0.7,0.0/0.6, 0.35/0.7,0.175/0.6, 0.5/0.7,0.0/0.6, 0.7/0.7,0.0/0.6, 0.45/0.7,0.3/0.6, 0.7/0.7,0.6/0.6, 0.5/0.7,0.6/0.6, 0.35/0.7,0.425/0.6, 0.2/0.7,0.6/0.6, 0.0/0.7,0.6/0.6, 0.25/0.7,0.3/0.6 ]
                            vector:[0.35714285714285715,0.5,0,0,0.28571428571428575,0,0.5,0.2916666666666667,0.7142857142857143,0,1,0,0.6428571428571429,0.5,1,1,0.7142857142857143,1,0.5,0.7083333333333334,0.28571428571428575,1,0,1,0.35714285714285715,0.5,0.28571428571428575,0,0.5,0.2916666666666667,0.5,0.2916666666666667,1,0,0.6428571428571429,0.5,0.6428571428571429,0.5,0.7142857142857143,1,0.5,0.7083333333333334,0.5,0.7083333333333334,0,1,0.35714285714285715,0.5,0.35714285714285715,0.5,0.5,0.2916666666666667,0.6428571428571429,0.5,0.6428571428571429,0.5,0.5,0.7083333333333334,0.35714285714285715,0.5],
                            ratio:{x:0.7,y:0.6}, offset:{y:0.4},
                        },
                        'y':{
                            //vector: [ 0.0/0.7,0.0/1.1, 0.2/0.7,0.0/1.1, 0.2/0.7,0.3/1.1, 0.3/0.7,0.4/1.1, 0.5/0.7,0.4/1.1, 0.5/0.7,0.0/1.1, 0.7/0.7,0.0/1.1, 0.7/0.7,0.9/1.1, 0.5/0.7,1.1/1.1, 0.2/0.7,1.1/1.1, 0.0/0.7,0.9/1.1, 0.0/0.7,0.8/1.1, 0.2/0.7,0.8/1.1, 0.3/0.7,0.9/1.1, 0.4/0.7,0.9/1.1, 0.5/0.7,0.8/1.1, 0.5/0.7,0.6/1.1, 0.2/0.7,0.6/1.1, 0.0/0.7,0.4/1.1 ]
                            vector:[0.28571428571428575,0.5454545454545454,0,0.36363636363636365,0,0,0,0,0.28571428571428575,0,0.28571428571428575,0.2727272727272727,0.7142857142857143,0.36363636363636365,0.7142857142857143,0,1,0,1,0,1,0.8181818181818181,0.7142857142857143,1,0.7142857142857143,1,0.28571428571428575,1,0,0.8181818181818181,0,0.8181818181818181,0,0.7272727272727273,0.28571428571428575,0.7272727272727273,0.28571428571428575,0.5454545454545454,0,0,0.28571428571428575,0.2727272727272727,0.7142857142857143,1,0,0.8181818181818181,0.28571428571428575,0.7272727272727273,0.28571428571428575,0.5454545454545454,0.28571428571428575,0.2727272727272727,0.4285714285714286,0.36363636363636365,0.7142857142857143,1,0.28571428571428575,0.7272727272727273,0.4285714285714286,0.8181818181818181,0.7142857142857143,0.5454545454545454,0.28571428571428575,0.5454545454545454,0.4285714285714286,0.36363636363636365,0.7142857142857143,1,0.4285714285714286,0.8181818181818181,0.5714285714285715,0.8181818181818181,0.7142857142857143,0.5454545454545454,0.4285714285714286,0.36363636363636365,0.7142857142857143,0.36363636363636365,0.7142857142857143,1,0.5714285714285715,0.8181818181818181,0.7142857142857143,0.7272727272727273,0.7142857142857143,0.5454545454545454,0.7142857142857143,0.36363636363636365,1,0,1,0,0.7142857142857143,1,0.7142857142857143,0.7272727272727273,0.7142857142857143,0.7272727272727273,0.7142857142857143,0.5454545454545454,1,0],
                            ratio:{x:0.7,y:1.1}, offset:{y:0.4},
                            encroach:{'a':1},
                        },
                        'z':{
                            //vector: [ 0.0/0.7,0.0/0.6, 0.7/0.7,0.0/0.6, 0.7/0.7,0.2/0.6, 0.35/0.7,0.2/0.6, 0.7/0.7,0.4/0.6, 0.7/0.7,0.6/0.6, 0.0/0.7,0.6/0.6, 0.0/0.7,0.4/0.6, 0.35/0.7,0.4/0.6, 0.0/0.7,0.2/0.6 ]
                            vector:[0.5,0.6666666666666667,0,0.33333333333333337,0,0,0,0,1,0,1,0.33333333333333337,0.5,0.33333333333333337,1,0.6666666666666667,1,1,1,1,0,1,0,0.6666666666666667,0,0,1,0.33333333333333337,0.5,0.33333333333333337,1,1,0,0.6666666666666667,0.5,0.6666666666666667,0.5,0.6666666666666667,0,0,0.5,0.33333333333333337,0.5,0.33333333333333337,1,1,0.5,0.6666666666666667],
                            ratio:{x:0.7,y:0.6}, offset:{y:0.4},
                        },
                    
                    
                        '0':{ 
                            //vector: [ 0.2,0, 0.8,0, 1,0.3, 1,0.7, 0.8,1, 0.2,1, 0,0.7, 0,0.3, 0.2,0, 0.3,0.2, 0.2,0.4, 0.2,0.6, 0.3,0.8, 0.7,0.8, 0.8,0.6, 0.8,0.4, 0.7,0.2, 0.3,0.2 ] 
                            vector:[0.7,0.2,0.3,0.2,0.2,0,0.2,0,0.8,0,1,0.3,1,0.3,1,0.7,0.8,1,0.8,1,0.2,1,0,0.7,0,0.7,0,0.3,0.2,0,0.2,0,0.3,0.2,0.2,0.4,0.7,0.2,0.2,0,1,0.3,0,0.7,0.2,0,0.2,0.4,0.8,0.4,0.7,0.2,1,0.3,0,0.7,0.2,0.4,0.2,0.6,0.8,0.6,0.8,0.4,1,0.3,0,0.7,0.2,0.6,0.3,0.8,0.7,0.8,0.8,0.6,1,0.3,0.8,1,0,0.7,0.3,0.8,0.7,0.8,1,0.3,0.8,1,0.8,1,0.3,0.8,0.7,0.8],
                        },
                        '1':{ 
                            //vector: [ 1/2,0, 2/3,0, 2/3,0.8, 1,0.8, 1,1, 0,1, 0,0.8, 1/3,0.8, 1/3,0.3, 0,0.3, 0,0.2 ] ratio:{x:2/3} 
                            vector:[0,0.3,0,0.2,0.5,0,0.5,0,0.6666666666666666,0,0.6666666666666666,0.8,0.6666666666666666,0.8,1,0.8,1,1,1,1,0,1,0,0.8,0.3333333333333333,0.3,0,0.3,0.5,0,1,1,0,0.8,0.3333333333333333,0.8,0.3333333333333333,0.8,0.3333333333333333,0.3,0.5,0,0.6666666666666666,0.8,1,1,0.3333333333333333,0.8,0.3333333333333333,0.8,0.5,0,0.6666666666666666,0.8],
                        },
                        '2':{ 
                            //vector: [ 0,0.2, 0.2,0, 0.8,0, 1,0.2, 1,0.5, 0.4,0.8, 1,0.8, 1,1, 0,1, 0,0.8, 0.8,0.4, 0.7,0.2, 0.3,0.2, 0.2,0.3, 0,0.3 ] 
                            vector:[0.2,0.3,0,0.3,0,0.2,0,0.2,0.2,0,0.8,0,0.8,0,1,0.2,1,0.5,0.4,0.8,1,0.8,1,1,1,1,0,1,0,0.8,0.3,0.2,0.2,0.3,0,0.2,0.4,0.8,1,1,0,0.8,0.3,0.2,0,0.2,0.8,0,1,0.5,0.4,0.8,0,0.8,0.7,0.2,0.3,0.2,0.8,0,1,0.5,0,0.8,0.8,0.4,0.8,0.4,0.7,0.2,0.8,0,0.8,0,1,0.5,0.8,0.4],
                        },
                        '3':{ 
                            //vector: [ 0,0.2, 0.2,0, 0.8,0, 1,0.2, 1,0.4, 0.9,0.5, 1,0.6, 1,0.8, 0.8,1, 0.2,1, 0,0.8, 0.2,0.7, 0.3,0.8, 0.7,0.8, 0.8,0.7, 0.7,0.6, 0.4,0.6, 0.4,0.4, 0.7,0.4, 0.8,0.3, 0.7,0.2, 0.3,0.2, 0.2,0.3 ] 
                            vector:[0.3,0.2,0.2,0.3,0,0.2,0,0.2,0.2,0,0.8,0,0.8,0,1,0.2,1,0.4,0.9,0.5,1,0.6,1,0.8,1,0.8,0.8,1,0.2,1,0.2,1,0,0.8,0.2,0.7,0.7,0.6,0.4,0.6,0.4,0.4,0.3,0.2,0,0.2,0.8,0,0.8,0,1,0.4,0.9,0.5,0.2,1,0.2,0.7,0.3,0.8,0.7,0.6,0.4,0.4,0.7,0.4,0.7,0.2,0.3,0.2,0.8,0,0.2,1,0.3,0.8,0.7,0.8,0.8,0.7,0.7,0.6,0.7,0.4,0.8,0.3,0.7,0.2,0.8,0,1,0.8,0.2,1,0.7,0.8,0.8,0.7,0.7,0.4,0.8,0.3,0.8,0.3,0.8,0,0.9,0.5,1,0.8,0.7,0.8,0.8,0.7,0.8,0.7,0.8,0.3,0.9,0.5,0.9,0.5,1,0.8,0.8,0.7],
                        },
                        '4':{ 
                            //vector: [ 0.6,0, 0.8,0, 0.8,0.6, 1,0.6, 1,0.8, 0.8,0.8, 0.8,1, 0.6,1, 0.6,0.3, 0.3,0.6, 0.6,0.6, 0.6,0.8, 0,0.8, 0,0.6 ] 
                            vector:[0,0.8,0,0.6,0.6,0,0.6,0,0.8,0,0.8,0.6,0.8,0.6,1,0.6,1,0.8,0.8,0.8,0.8,1,0.6,1,0.3,0.6,0.6,0.6,0.6,0.8,0.8,0.6,1,0.8,0.8,0.8,0.8,0.8,0.6,1,0.6,0.3,0.3,0.6,0.6,0.8,0,0.8,0.6,0,0.8,0.6,0.8,0.8,0.6,0.3,0.3,0.6,0,0.8,0.6,0,0.8,0.8,0.6,0.3,0.6,0.3,0,0.8,0.6,0],
                        },
                        '5':{ 
                            //vector: [ 0,0, 1,0, 1,0.2, 0.2,0.2, 0.2,0.4, 0.9,0.4, 1,0.5, 1,0.8, 0.8,1, 0.1,1, 0,0.9, 0,0.7, 0.2,0.7, 0.2,0.8, 0.7,0.8, 0.8,0.7, 0.8,0.6, 0,0.6 ] 
                            vector:[0,0,1,0,1,0.2,0.2,0.4,0.9,0.4,1,0.5,1,0.5,1,0.8,0.8,1,0.8,1,0.1,1,0,0.9,0,0.9,0,0.7,0.2,0.7,0,0,1,0.2,0.2,0.2,0,0.9,0.2,0.7,0.2,0.8,0,0.6,0,0,0.2,0.2,0.8,1,0,0.9,0.2,0.8,0,0.6,0.2,0.2,0.2,0.4,0.8,1,0.2,0.8,0.7,0.8,0.8,0.6,0,0.6,0.2,0.4,0.8,1,0.7,0.8,0.8,0.7,0.8,0.6,0.2,0.4,1,0.5,1,0.5,0.8,1,0.8,0.7,0.8,0.7,0.8,0.6,1,0.5],
                        },
                        '6':{ 
                            //vector: [ 0.2,0, 0.8,0, 1,0.2, 1,0.3, 0.8,0.3, 0.7,0.2, 0.3,0.2, 0.2,0.3, 0.3,0.4, 0.8,0.4, 1,0.6, 1,0.8, 0.8,1, 0.2,1, 0,0.8, 0,0.2, 0.2,0.6, 0.2,0.7, 0.3,0.8, 0.7,0.8, 0.8,0.7, 0.7,0.6, 0.2,0.6, 0,0.2 ] 
                            vector:[0,0.2,0.2,0,0.8,0,0.8,0,1,0.2,1,0.3,1,0.3,0.8,0.3,0.7,0.2,0.3,0.4,0.8,0.4,1,0.6,1,0.6,1,0.8,0.8,1,0.8,1,0.2,1,0,0.8,0,0.8,0,0.2,0.2,0.6,0.8,0,1,0.3,0.7,0.2,0,0.8,0.2,0.6,0.2,0.7,0.8,0,0.7,0.2,0.3,0.2,0,0.8,0.2,0.7,0.3,0.8,0,0.2,0.8,0,0.3,0.2,0.8,1,0,0.8,0.3,0.8,0,0.2,0.3,0.2,0.2,0.3,0.8,1,0.3,0.8,0.7,0.8,0.2,0.6,0,0.2,0.2,0.3,1,0.6,0.8,1,0.7,0.8,0.2,0.6,0.2,0.3,0.3,0.4,1,0.6,0.7,0.8,0.8,0.7,0.7,0.6,0.2,0.6,0.3,0.4,1,0.6,0.8,0.7,0.7,0.6,0.7,0.6,0.3,0.4,1,0.6],
                        },
                        '7':{ 
                            //vector: [ 0,0, 1,0, 1,0.2, 0.5,1, 0.25,1, 0.75,0.2, 0,0.2 ] 
                            vector:[0.75,0.2,0,0.2,0,0,0,0,1,0,1,0.2,1,0.2,0.5,1,0.25,1,0.75,0.2,0,0,1,0.2,1,0.2,0.25,1,0.75,0.2],
                        },
                        '8':{ 
                            //vector: [ 0.2,0, 0.8,0, 1,0.2, 1,0.4, 0.9,0.5, 1,0.6, 1,0.8, 0.8,1, 0.2,1, 0,0.8, 0,0.6, 0.2,0.7, 0.3,0.8, 0.7,0.8, 0.8,0.7, 0.7,0.6, 0.3,0.6, 0.2,0.7, 0,0.6, 0.1,0.5, 0,0.4, 0,0.2, 0.2,0.3, 0.3,0.4, 0.7,0.4, 0.8,0.3, 0.7,0.2, 0.3,0.2, 0.2,0.3, 0,0.2 ] 
                            vector:[0.2,0.3,0,0.2,0.2,0,0.2,0,0.8,0,1,0.2,1,0.2,1,0.4,0.9,0.5,0.9,0.5,1,0.6,1,0.8,1,0.8,0.8,1,0.2,1,0.2,1,0,0.8,0,0.6,0,0.6,0.2,0.7,0.3,0.8,0.3,0.6,0.2,0.7,0,0.6,0.1,0.5,0,0.4,0,0.2,0,0.2,0.2,0.3,0.3,0.4,0.3,0.2,0.2,0.3,0.2,0,0.2,1,0,0.6,0.3,0.8,0.3,0.6,0,0.6,0.1,0.5,0.1,0.5,0,0.2,0.3,0.4,0.7,0.2,0.3,0.2,0.2,0,0.2,1,0.3,0.8,0.7,0.8,0.7,0.6,0.3,0.6,0.1,0.5,0.1,0.5,0.3,0.4,0.7,0.4,0.7,0.2,0.2,0,1,0.2,1,0.8,0.2,1,0.7,0.8,0.7,0.6,0.1,0.5,0.7,0.4,0.8,0.3,0.7,0.2,1,0.2,1,0.8,0.7,0.8,0.8,0.7,0.8,0.7,0.7,0.6,0.7,0.4,0.7,0.4,0.8,0.3,1,0.2,0.9,0.5,1,0.8,0.8,0.7,0.8,0.7,0.7,0.4,1,0.2,1,0.2,0.9,0.5,0.8,0.7],
                        },
                        '9':{ 
                            //vector: [ 0.8,1, 0.2,1, 0,0.8, 0,0.7, 0.2,0.7, 0.3,0.8, 0.7,0.8, 0.8,0.7, 0.7,0.6, 0.2,0.6, 0,0.4, 0,0.2, 0.2,0, 0.8,0, 1,0.2, 1,0.8, 0.8,0.4, 0.8,0.3, 0.7,0.2, 0.3,0.2, 0.2,0.3, 0.3,0.4, 0.8,0.4, 1,0.8 ] 
                            vector:[1,0.8,0.8,1,0.2,1,0.2,1,0,0.8,0,0.7,0,0.7,0.2,0.7,0.3,0.8,0.7,0.6,0.2,0.6,0,0.4,0,0.4,0,0.2,0.2,0,0.2,0,0.8,0,1,0.2,1,0.2,1,0.8,0.8,0.4,0.2,1,0,0.7,0.3,0.8,1,0.2,0.8,0.4,0.8,0.3,0.2,1,0.3,0.8,0.7,0.8,1,0.2,0.8,0.3,0.7,0.2,1,0.8,0.2,1,0.7,0.8,0.2,0,1,0.2,0.7,0.2,1,0.8,0.7,0.8,0.8,0.7,0.2,0,0.7,0.2,0.3,0.2,0.8,0.4,1,0.8,0.8,0.7,0,0.4,0.2,0,0.3,0.2,0.8,0.4,0.8,0.7,0.7,0.6,0,0.4,0.3,0.2,0.2,0.3,0.3,0.4,0.8,0.4,0.7,0.6,0,0.4,0.2,0.3,0.3,0.4,0.3,0.4,0.7,0.6,0,0.4],
                        },
                    
                    
                        '.':{
                            //vector: [ 0,0, 1,0, 1,1, 0,1 ]
                            vector:[1,1,0,1,0,0,0,0,1,0,1,1],
                            ratio:{x:0.2, y:0.2}, offset:{y:0.8},
                        },
                        ',':{
                            //vector: [ 0.2,0., 1,0, 0.8,1, 0,1 ]
                            vector:[0.8,1,0,1,0.2,0,0.2,0,1,0,0.8,1],
                            ratio:{x:0.2, y:0.4}, offset:{y:0.8},
                        },
                        ':':{
                            //vector: [ 0,0, 1,0, 1,0.3, 0,0.3, 0,0.7, 1,0.7, 1,1, 0,1 ]
                            vector:[0,0,1,0,1,0.3,0,0.7,1,0.7,1,1,0,0,1,0.3,0,0.3,0,0.7,1,1,0,1],
                            ratio:{x:0.2, y:0.8}, offset:{y:0.1},
                        },
                        ';':{
                            //vector: [ 0.2,0, 1,0, 1,0.3, 0.2,0.3, 0.2,0.7, 1,0.7, 0.8,1, 0,1, 0.2,0.7 ]
                            vector:[0.2,0,1,0,1,0.3,1,0.7,0.8,1,0,1,0.2,0,1,0.3,0.2,0.3,1,0.7,0,1,0.2,0.7],
                            ratio:{x:0.2, y:0.8}, offset:{y:0.1},
                        },
                        '?':{
                            //vector: [ 0,0.4, 0,0.1, 0.1,0, 0.9,0, 1,0.1, 1,0.5, 0.9,0.6, 0.6,0.6, 0.6,0.7, 0.4,0.7, 0.4,0.8, 0.6,0.8, 0.6,1, 0.4,1, 0.4,0.8, 0.4,0.7, 0.4,0.5, 0.5,0.4, 0.8,0.4, 0.8,0.2, 0.2,0.2, 0.2,0.4 ]
                            vector:[0.2,0.2,0.2,0.4,0,0.4,0,0.4,0,0.1,0.1,0,0.1,0,0.9,0,1,0.1,1,0.1,1,0.5,0.9,0.6,0.6,0.8,0.6,1,0.4,1,0.4,0.5,0.5,0.4,0.8,0.4,0.2,0.2,0,0.4,0.1,0,0.8,0.2,0.2,0.2,0.1,0,0.8,0.2,0.1,0,1,0.1,0.8,0.4,0.8,0.2,1,0.1,0.8,0.4,1,0.1,0.9,0.6,0.4,0.5,0.8,0.4,0.9,0.6,0.4,0.5,0.9,0.6,0.6,0.6,0.4,0.5,0.6,0.6,0.6,0.7,0.4,0.5,0.6,0.7,0.4,0.7,0.4,0.8,0.6,0.8,0.4,1],
                            encroach:{'a':2},
                        },
                        '!':{
                            //vector: [ 0,0, 1,0, 1,0.7, 0,0.7, 0,0.8, 1,0.8, 1,1, 0,1 ]
                            vector:[0,0,1,0,1,0.7,0,0.8,1,0.8,1,1,0,0,1,0.7,0,0.7,0,0.8,1,1,0,1],
                            ratio:{x:0.2},
                        },
                        '/':{
                            //vector: [ 0.3,0, 1,0, 0.7,1, 0,1 ]
                            vector:[0.7,1,0,1,0.3,0,0.3,0,1,0,0.7,1],
                            ratio:{x:1/4},
                        },
                       '\\':{
                            //vector: [ 0.7,0, 0,0, 0.3,1, 1,1 ]
                            vector:[0,0,0.7,0,1,1,1,1,0.3,1,0,0],
                            ratio:{x:1/4},
                        },
                        '(':{
                            //vector: [ 0.6,0, 1,0, 0.6,0.2, 0.4,0.5, 0.6,0.8, 1,1, 0.6,1, 0.2,0.8, 0,0.5, 0.2,0.2 ]
                            vector:[0,0.5,0.2,0.2,0.6,0,0.6,0,1,0,0.6,0.2,0.6,0.8,1,1,0.6,1,0.6,1,0.2,0.8,0,0.5,0,0.5,0.6,0,0.6,0.2,0.4,0.5,0.6,0.8,0.6,1,0,0.5,0.6,0.2,0.4,0.5,0.4,0.5,0.6,1,0,0.5],
                            ratio:{x:0.4},
                        },
                        ')':{
                            //vector: [ 0.4,0, 0,0, 0.4,0.2, 0.6,0.5, 0.4,0.8, 0,1, 0.4,1, 0.8,0.8, 1,0.5, 0.8,0.2 ]
                            vector:[0,0,0.4,0,0.8,0.2,0.8,0.2,1,0.5,0.8,0.8,0.8,0.8,0.4,1,0,1,0.4,0.2,0,0,0.8,0.2,0.8,0.8,0,1,0.4,0.8,0.6,0.5,0.4,0.2,0.8,0.2,0.8,0.2,0.8,0.8,0.4,0.8,0.4,0.8,0.6,0.5,0.8,0.2],
                            ratio:{x:0.4},
                            encroach:{'p':1},
                        },
                        '[':{
                            //vector: [ 0,0, 1,0, 1,0.2, 0.4,0.2, 0.4,0.8, 1,0.8, 1,1, 0,1 ]
                            vector:[0,0,1,0,1,0.2,0.4,0.8,1,0.8,1,1,0,0,1,0.2,0.4,0.2,0.4,0.8,1,1,0,1,0,1,0,0,0.4,0.2,0.4,0.2,0.4,0.8,0,1],
                            ratio:{x:0.4},
                        },
                        ']':{
                            //vector: [ 1,0, 0,0, 0,0.2, 0.6,0.2, 0.6,0.8, 0,0.8, 0,1, 1,1 ]
                            vector:[1,1,0,1,0,0.8,0.6,0.2,0,0.2,0,0,1,1,0,0.8,0.6,0.8,0.6,0.2,0,0,1,0,1,0,1,1,0.6,0.8,0.6,0.8,0.6,0.2,1,0],
                            ratio:{x:0.4},
                        },
                        '#':{
                            //vector: [ 0.2,0, 0.4,0, 0.38,0.2, 0.68,0.2, 0.7,0, 0.9,0, 0.88,0.2, 1,0.2, 1,0.4, 0.86,0.4, 0.84,0.6, 1,0.6, 1,0.8, 0.82,0.8, 0.8,1, 0.6,1, 0.62,0.8, 0.32,0.8, 0.3,1, 0.1,1, 0.12,0.8, 0,0.8, 0,0.6, 0.14,0.6, 0.16,0.4, 0,0.4, 0,0.2, 0.18,0.2, 0.36,0.4, 0.34,0.6, 0.64,0.6, 0.66,0.4, 0.36,0.4, 0.18,0.2 ]
                            vector:[0.36,0.4,0.18,0.2,0.2,0,0.2,0,0.4,0,0.38,0.2,0.68,0.2,0.7,0,0.9,0,0.88,0.2,1,0.2,1,0.4,0.84,0.6,1,0.6,1,0.8,0.82,0.8,0.8,1,0.6,1,0.32,0.8,0.3,1,0.1,1,0.12,0.8,0,0.8,0,0.6,0.16,0.4,0,0.4,0,0.2,0,0.2,0.18,0.2,0.36,0.4,0.36,0.4,0.2,0,0.38,0.2,0.68,0.2,0.9,0,0.88,0.2,0.88,0.2,1,0.4,0.86,0.4,0.84,0.6,1,0.8,0.82,0.8,0.82,0.8,0.6,1,0.62,0.8,0.32,0.8,0.1,1,0.12,0.8,0.12,0.8,0,0.6,0.14,0.6,0.16,0.4,0,0.2,0.36,0.4,0.66,0.4,0.36,0.4,0.38,0.2,0.68,0.2,0.88,0.2,0.86,0.4,0.84,0.6,0.82,0.8,0.62,0.8,0.32,0.8,0.12,0.8,0.14,0.6,0.14,0.6,0.16,0.4,0.36,0.4,0.66,0.4,0.38,0.2,0.68,0.2,0.68,0.2,0.86,0.4,0.84,0.6,0.84,0.6,0.62,0.8,0.32,0.8,0.32,0.8,0.14,0.6,0.36,0.4,0.66,0.4,0.68,0.2,0.84,0.6,0.32,0.8,0.36,0.4,0.34,0.6,0.64,0.6,0.66,0.4,0.84,0.6,0.32,0.8,0.34,0.6,0.64,0.6,0.64,0.6,0.84,0.6,0.32,0.8],
                        },
                        '-':{
                            //vector: [ 0,0, 1,0, 1,1, 0,1 ]
                            vector:[1,1,0,1,0,0,0,0,1,0,1,1],
                            ratio:{x:0.5, y:0.2}, offset:{y:0.4},
                        },
                        '_':{
                            //vector: [ 0,0, 1,0, 1,1, 0,1 ]
                            vector:[1,1,0,1,0,0,0,0,1,0,1,1],
                            ratio:{y:0.2}, offset:{y:1},
                        },
                        "'":{
                            //vector: [ 0,0, 1,0, 1,1, 0,1 ]
                            vector:[1,1,0,1,0,0,0,0,1,0,1,1],
                            ratio:{x:0.2, y:0.4},
                        },
                        '"':{
                            //vector: [ 0.4,0, 0,0, 0,1, 0.4,1, 0.4,0, 0.6,0, 0.6,1, 1,1, 1,0 ]
                            vector:[1,0,1,1,0.6,1,0.4,1,0,1,0,0,1,0,0.6,1,0.6,0,0.4,1,0,0,0.4,0],
                            ratio:{x:0.5, y:0.4},
                        },
                        '|':{
                            //vector: [ 0,0, 1,0, 1,1, 0,1 ]
                            vector:[1,1,0,1,0,0,0,0,1,0,1,1],
                            ratio:{x:0.2},
                        },
                        '>':{
                            //vector: [ 0,0, 1,0.4, 1,0.6, 0,1, 0,0.8, 0.7,0.5, 0,0.2 ]
                            vector:[0.7,0.5,0,0.2,0,0,0,0,1,0.4,1,0.6,1,0.6,0,1,0,0.8,0.7,0.5,0,0,1,0.6,1,0.6,0,0.8,0.7,0.5],
                        },
                        '<':{
                            //vector: [ 1,0, 0,0.4, 0,0.6, 1,1, 1,0.8, 0.3,0.5, 1,0.2 ]
                            vector:[0,0.4,1,0,1,0.2,0.3,0.5,1,0.8,1,1,1,1,0,0.6,0,0.4,0,0.4,1,0.2,0.3,0.5,0.3,0.5,1,1,0,0.4],
                        },
                        '+':{
                            //vector: [ 0.3,0, 0.7,0, 0.7,0.3, 1,0.3, 1,0.7, 0.7,0.7, 0.7,1, 0.3,1, 0.3,0.7, 0,0.7, 0,0.3, 0.3,0.3 ]
                            vector:[0.3,0.3,0.3,0,0.7,0,0.7,0.3,1,0.3,1,0.7,0.7,0.7,0.7,1,0.3,1,0.3,0.7,0,0.7,0,0.3,0.3,0.3,0.7,0,0.7,0.3,0.7,0.3,1,0.7,0.7,0.7,0.7,0.7,0.3,1,0.3,0.7,0.3,0.7,0,0.3,0.3,0.3,0.3,0.3,0.7,0.3,0.7,0.7,0.7,0.7,0.3,0.7,0.3,0.3],
                            ratio:{x:0.5, y:0.5}, offset:{y:0.25}
                        },
                        '=':{
                            //vector: [ 0,0, 1,0, 1,0.3, 0,0.3, 0,0.7, 1,0.7, 1,1, 0,1 ]
                            vector:[0,0,1,0,1,0.3,0,0.7,1,0.7,1,1,0,0,1,0.3,0,0.3,0,0.7,1,1,0,1],
                            ratio:{x:0.8, y:0.5}, offset:{y:0.25}
                        },
                        '&':{
                            //vector: [ 0.1,0, 0.6,0, 0.7,0.2, 0.7,0.4, 0.6,0.5, 0.4,0.6, 0.6,0.7, 0.8,0.5, 0.9,0.6, 0.9,0.7, 0.8,0.8, 1,0.8, 1,1, 0.8,1, 0.6,0.9, 0.5,1, 0.1,1, 0,0.9, 0,0.6, 0.1,0.5, 0.2,0.65, 0.2,0.8, 0.4,0.8, 0.2,0.65, 0,0.4, 0,0.3, 0.1,0, 0.2,0.2, 0.2,0.3, 0.3,0.4, 0.5,0.4, 0.5,0.2, 0.2,0.2 ]
                            vector:[0.5,0.2,0.2,0.2,0.1,0,0.1,0,0.6,0,0.7,0.2,0.7,0.2,0.7,0.4,0.6,0.5,0.6,0.7,0.8,0.5,0.9,0.6,0.9,0.6,0.9,0.7,0.8,0.8,0.8,0.8,1,0.8,1,1,1,1,0.8,1,0.6,0.9,0.6,0.9,0.5,1,0.1,1,0.1,1,0,0.9,0,0.6,0,0.6,0.1,0.5,0.2,0.65,0.4,0.8,0.2,0.65,0,0.4,0,0.4,0,0.3,0.1,0,0.1,0,0.2,0.2,0.2,0.3,0.5,0.2,0.1,0,0.7,0.2,0.7,0.2,0.6,0.5,0.4,0.6,0.6,0.7,0.9,0.6,0.8,0.8,0.8,0.8,1,1,0.6,0.9,0.1,1,0,0.6,0.2,0.65,0,0.4,0.1,0,0.2,0.3,0.5,0.4,0.5,0.2,0.7,0.2,0.4,0.6,0.6,0.7,0.8,0.8,0.8,0.8,0.6,0.9,0.1,1,0.1,1,0.2,0.65,0.2,0.8,0.4,0.8,0,0.4,0.2,0.3,0.5,0.4,0.7,0.2,0.4,0.6,0.1,1,0.2,0.8,0.4,0.8,0.4,0.8,0.2,0.3,0.3,0.4,0.3,0.4,0.5,0.4,0.4,0.6,0.8,0.8,0.1,1,0.4,0.8,0.4,0.8,0.3,0.4,0.4,0.6,0.4,0.6,0.8,0.8,0.4,0.8],
                        },
                        '*':{
                            //vector: [ 0.4,0, 0.6,0, 0.6,0.25, 0.775,0.075, 0.925,0.225, 0.75,0.4, 1,0.4, 1,0.6, 0.75,0.6, 0.925,0.775, 0.775,0.925, 0.6,0.75, 0.6,1, 0.4,1, 0.4,0.75, 0.225,0.925, 0.075,0.775, 0.25,0.6, 0,0.6, 0,0.4, 0.25,0.4, 0.075,0.225, 0.225,0.075, 0.4,0.25 ]
                            vector:[0.4,0.25,0.4,0,0.6,0,0.6,0.25,0.775,0.075,0.925,0.225,0.75,0.4,1,0.4,1,0.6,0.75,0.6,0.925,0.775,0.775,0.925,0.6,0.75,0.6,1,0.4,1,0.4,0.75,0.225,0.925,0.075,0.775,0.25,0.6,0,0.6,0,0.4,0.25,0.4,0.075,0.225,0.225,0.075,0.4,0.25,0.6,0,0.6,0.25,0.6,0.25,0.925,0.225,0.75,0.4,0.75,0.4,1,0.6,0.75,0.6,0.75,0.6,0.775,0.925,0.6,0.75,0.6,0.75,0.4,1,0.4,0.75,0.4,0.75,0.075,0.775,0.25,0.6,0.25,0.6,0,0.4,0.25,0.4,0.25,0.4,0.225,0.075,0.4,0.25,0.4,0.25,0.6,0.25,0.75,0.4,0.75,0.4,0.75,0.6,0.6,0.75,0.6,0.75,0.4,0.75,0.25,0.6,0.25,0.6,0.25,0.4,0.4,0.25,0.4,0.25,0.75,0.4,0.6,0.75,0.6,0.75,0.25,0.6,0.4,0.25],
                            ratio:{x:0.5, y:0.5}, offset:{y:0.25}
                        },
                        '~':{
                            //vector: [ 0,0.25, 0.25,0.0, 0.75,0.5, 1,0.25, 1,0.75, 0.75,1, 0.25,0.5, 0,0.75 ]
                            vector:[0.25,0.5,0,0.75,0,0.25,0,0.25,0.25,0,0.75,0.5,0.75,0.5,1,0.25,1,0.75,1,0.75,0.75,1,0.25,0.5,0.25,0.5,0,0.25,0.75,0.5,0.75,0.5,1,0.75,0.25,0.5],
                            ratio:{x:0.8, y:0.4}, offset:{y:0.25},
                        },
                        '%':{
                            //vector: [ 0.8,0, 1,0.2, 0.2,1, 0,0.8, 0,0.2, 0,0.1, 0.1,0, 0.2,0, 0.3,0.1, 0.3,0.2, 0.3,0.2, 0.2,0.3, 0.1,0.3, 0,0.2, 0,0.8, 0.2,1, 0.8,1, 0.7,0.9, 0.7,0.8, 0.8,0.7, 0.9,0.7, 1,0.8, 1,0.9, 0.9,1, 0.8,1, 0.2,1, 0,0.8 ]
                            vector:[0,0.1,0.1,0,0.2,0,0.7,0.9,0.7,0.8,0.8,0.7,0.8,0.7,0.9,0.7,1,0.8,1,0.8,1,0.9,0.9,1,0,0.1,0.2,0,0.3,0.1,0.7,0.9,0.8,0.7,1,0.8,0.7,0.9,1,0.8,0.9,1,0,0.1,0.3,0.1,0.3,0.2,0.3,0.2,0.2,0.3,0.1,0.3,0.8,1,0.7,0.9,0.9,1,0,0.1,0.3,0.2,0.1,0.3,0,0.1,0.1,0.3,0,0.2,1,0.2,0.2,1,0,0.8,0,0.8,0.8,0,1,0.2],
                        },
                        '{':{
                            //vector: [ 0.3/0.45,0.0, 0.45/0.45,0.0, 0.45/0.45,0.1, 0.3/0.45,0.2, 0.3/0.45,0.4, 0.225/0.45,0.5, 0.3/0.45,0.6, 0.3/0.45,0.8, 0.45/0.45,0.9, 0.45/0.45,1.0, 0.3/0.45,1.0, 0.15/0.45,0.9, 0.15/0.45,0.6, 0.0/0.45,0.5, 0.15/0.45,0.4, 0.15/0.45,0.1 ]
                            vector:[0.3333333333333333,0.4,0.3333333333333333,0.1,0.6666666666666666,0,0.6666666666666666,0,1,0,1,0.1,0.6666666666666666,0.2,0.6666666666666666,0.4,0.5,0.5,0.5,0.5,0.6666666666666666,0.6,0.6666666666666666,0.8,0.6666666666666666,0.8,1,0.9,1,1,1,1,0.6666666666666666,1,0.3333333333333333,0.9,0.3333333333333333,0.6,0,0.5,0.3333333333333333,0.4,0.6666666666666666,0,1,0.1,0.6666666666666666,0.2,0.6666666666666666,0.8,1,1,0.3333333333333333,0.9,0.3333333333333333,0.6,0.3333333333333333,0.4,0.6666666666666666,0,0.6666666666666666,0,0.6666666666666666,0.2,0.5,0.5,0.5,0.5,0.6666666666666666,0.8,0.3333333333333333,0.9,0.3333333333333333,0.9,0.3333333333333333,0.6,0.6666666666666666,0,0.6666666666666666,0,0.5,0.5,0.3333333333333333,0.9],
                            ratio:{x:0.45},
                        },
                        '}':{
                            //vector: [ 0.15/0.45,0.0, 0.0/0.45,0.0, 0.0/0.45,0.1, 0.15/0.45,0.2, 0.15/0.45,0.4, 0.225/0.45,0.5, 0.15/0.45,0.6, 0.15/0.45,0.8, 0.0/0.45,0.9, 0.0/0.45,1.0, 0.15/0.45,1.0, 0.3/0.45,0.9, 0.3/0.45,0.6, 0.45/0.45,0.5, 0.3/0.45,0.4, 0.3/0.45,0.1 ]
                            vector:[0,0,0.3333333333333333,0,0.6666666666666666,0.1,0.6666666666666666,0.4,1,0.5,0.6666666666666666,0.6,0.6666666666666666,0.6,0.6666666666666666,0.9,0.3333333333333333,1,0.3333333333333333,1,0,1,0,0.9,0.3333333333333333,0.8,0.3333333333333333,0.6,0.5,0.5,0.5,0.5,0.3333333333333333,0.4,0.3333333333333333,0.2,0.3333333333333333,0.2,0,0.1,0,0,0.6666666666666666,0.4,0.6666666666666666,0.6,0.3333333333333333,1,0.3333333333333333,1,0,0.9,0.3333333333333333,0.8,0.3333333333333333,0.2,0,0,0.6666666666666666,0.1,0.6666666666666666,0.1,0.6666666666666666,0.4,0.3333333333333333,1,0.3333333333333333,1,0.3333333333333333,0.8,0.5,0.5,0.5,0.5,0.3333333333333333,0.2,0.6666666666666666,0.1,0.6666666666666666,0.1,0.3333333333333333,1,0.5,0.5],
                            ratio:{x:0.45},
                        },
                        '^':{
                            //vector: [ 0.0/0.6,0.3/0.3, 0.3/0.6,0.0/0.3, 0.6/0.6,0.3/0.3, 0.4/0.6,0.3/0.3, 0.3/0.6,0.2/0.3, 0.2/0.6,0.3/0.3],'flatArray'),
                            vector:[0.5, 0.6666666666666667, 0.33333333333333337, 1, 0, 1, 0.5, 0, 1, 1, 0.6666666666666667, 1, 0.5, 0.6666666666666667, 0, 1, 0.5, 0, 0.5, 0, 0.6666666666666667, 1, 0.5, 0.6666666666666667],
                            ratio:{x:0.6,y:0.3},
                        },
                    };
                    
                    //correct font to be compatible with the new way of fonting
                    reducedGlyphSet.concat(['default','']).forEach(key => {
                        if(vectorLibrary.defaultThick[key] == undefined){return;}
                    
                        //generate limits
                            vectorLibrary.defaultThick[key].top = vectorLibrary.defaultThick[key].ratio != undefined && vectorLibrary.defaultThick[key].ratio.y != undefined ? -vectorLibrary.defaultThick[key].ratio.y : -1;
                            vectorLibrary.defaultThick[key].right = vectorLibrary.defaultThick[key].ratio != undefined && vectorLibrary.defaultThick[key].ratio.x != undefined ? vectorLibrary.defaultThick[key].ratio.x + 0.1 : 1.1;
                            vectorLibrary.defaultThick[key].bottom = 0;
                            vectorLibrary.defaultThick[key].left = 0;
                    
                        //adjust for ratio and offset
                            for(let a = 0; a < vectorLibrary.defaultThick[key].vector.length; a+=2){
                                //ratio correction
                                    if( vectorLibrary.defaultThick[key].ratio != undefined ){
                                        if(vectorLibrary.defaultThick[key].ratio.x != undefined){
                                            vectorLibrary.defaultThick[key].vector[a] *= vectorLibrary.defaultThick[key].ratio.x;
                                        }
                                        if(vectorLibrary.defaultThick[key].ratio.y != undefined){
                                            vectorLibrary.defaultThick[key].vector[a+1] *= vectorLibrary.defaultThick[key].ratio.y;
                                        }
                                    }
                                //offset correction
                                    if( vectorLibrary.defaultThick[key].offset != undefined ){
                                        if(vectorLibrary.defaultThick[key].offset.x != undefined){
                                            vectorLibrary.defaultThick[key].vector[a] += vectorLibrary.defaultThick[key].offset.x;
                                        }
                                        if(vectorLibrary.defaultThick[key].offset.y != undefined){
                                            vectorLibrary.defaultThick[key].vector[a+1] += vectorLibrary.defaultThick[key].offset.y;
                                        }
                                    }
                            }
                    
                        //flip y axis
                            for(let a = 0; a < vectorLibrary.defaultThick[key].vector.length; a+=2){
                                vectorLibrary.defaultThick[key].vector[a+1] -= 1;
                            }
                    });
                    vectorLibrary.defaultThin = {
                        loadAttempted:true,
                        isLoaded:true,
                        'default':{ 
                            //vector: [ 0.0,0.0, 1.0,0.0, 1.0,1.0, 0.0,1.0, 0.0,0.0, 0.1,0.1,  0.1,0.9, 0.9,0.9, 0.9,0.1, 0.1,0.1 ]
                            vector:[0.9,0.1,0.1,0.1,0,0,0,1,0,0,0.1,0.1,0.9,0.1,0,0,1,0,0,1,0.1,0.1,0.1,0.9,0.9,0.9,0.9,0.1,1,0,1,1,0,1,0.1,0.9,0.9,0.9,1,0,1,1,1,1,0.1,0.9,0.9,0.9],
                        },
                        '':{ 
                            //vector: [ 0.0,0.0, 1.0,0.0, 1.0,1.0, 0.0,1.0, 0.0,0.0, 0.1,0.1,  0.1,0.9, 0.9,0.9, 0.9,0.1, 0.1,0.1 ]
                            vector:[0.9,0.1,0.1,0.1,0,0,0,1,0,0,0.1,0.1,0.9,0.1,0,0,1,0,0,1,0.1,0.1,0.1,0.9,0.9,0.9,0.9,0.1,1,0,1,1,0,1,0.1,0.9,0.9,0.9,1,0,1,1,1,1,0.1,0.9,0.9,0.9],
                        },
                    
                        'A':{
                            //vector: [ 0.2,0.0, 0.5,0.0, 1.0,1.0, 0.9,1.0, 0.65,0.5, 0.1,0.5, 0.1,0.4, 0.6,0.4, 0.45,0.1, 0.25,0.1, 0.1,0.25, 0.1,1.0, 0.0,1.0, 0.0,0.2 ]
                            vector:[0.5,0,1,1,0.9,1,0.65,0.5,0.1,0.5,0.1,0.4,0.1,0.25,0.1,1,0,1,0.5,0,0.9,1,0.65,0.5,0.65,0.5,0.1,0.4,0.6,0.4,0.1,0.25,0,1,0,0.2,0.5,0,0.65,0.5,0.6,0.4,0.25,0.1,0.1,0.25,0,0.2,0.5,0,0.6,0.4,0.45,0.1,0.25,0.1,0,0.2,0.2,0,0.2,0,0.5,0,0.45,0.1,0.45,0.1,0.25,0.1,0.2,0],
                        },
                        'B':{
                            //vector: [ 0.0,0.0, 0.1,0.0, 0.1,0.9, 0.75,0.9, 0.9,0.75, 0.9,0.65, 0.75,0.5, 0.1,0.5, 0.1,0.4, 0.7,0.4, 0.8,0.3, 0.8,0.2, 0.65,0.1, 0.1,0.1, 0.1,0.0, 0.7,0.0, 0.9,0.15, 0.9,0.35, 0.825,0.425, 1.0,0.6, 1.0,0.8, 0.8,1.0, 0.0,1.0 ]
                            vector:[0,1,0,0,0.1,0,0.75,0.5,0.1,0.5,0.1,0.4,0.65,0.1,0.1,0.1,0.1,0,0.7,0,0.9,0.15,0.9,0.35,0.825,0.425,1,0.6,1,0.8,0,1,0.1,0,0.1,0.9,0.75,0.5,0.1,0.4,0.7,0.4,0.65,0.1,0.1,0,0.7,0,0.8,1,0,1,0.1,0.9,0.9,0.65,0.75,0.5,0.7,0.4,0.8,0.2,0.65,0.1,0.7,0,0.8,1,0.1,0.9,0.75,0.9,0.8,0.2,0.7,0,0.9,0.35,1,0.8,0.8,1,0.75,0.9,0.8,0.3,0.8,0.2,0.9,0.35,1,0.8,0.75,0.9,0.9,0.75,0.7,0.4,0.8,0.3,0.9,0.35,1,0.8,0.9,0.75,0.9,0.65,0.7,0.4,0.9,0.35,0.825,0.425,0.825,0.425,1,0.8,0.9,0.65,0.9,0.65,0.7,0.4,0.825,0.425],
                        },
                        'C':{
                            //vector: [ 0.2,0.0, 0.8,0.0, 1.0,0.2, 0.9,0.25, 0.75,0.1, 0.25,0.1, 0.1,0.25, 0.1,0.75, 0.25,0.9, 0.75,0.9, 0.9,0.75, 1.0,0.8, 0.8,1.0, 0.2,1.0, 0.0,0.8, 0.0,0.2 ]
                            vector:[0.8,0,1,0.2,0.9,0.25,0.75,0.9,0.9,0.75,1,0.8,0.8,0,0.9,0.25,0.75,0.1,0.75,0.9,1,0.8,0.8,1,0.2,0,0.8,0,0.75,0.1,0.25,0.9,0.75,0.9,0.8,1,0.2,0,0.75,0.1,0.25,0.1,0.25,0.9,0.8,1,0.2,1,0,0.2,0.2,0,0.25,0.1,0.1,0.75,0.25,0.9,0.2,1,0,0.2,0.25,0.1,0.1,0.25,0.1,0.75,0.2,1,0,0.8,0,0.8,0,0.2,0.1,0.25,0.1,0.25,0.1,0.75,0,0.8],
                        },
                        'D':{
                            //vector: [ 0.0,0.0, 0.1,0.0, 0.1,0.9, 0.75,0.9, 0.9,0.75, 0.9,0.25, 0.75,0.1, 0.1,0.1, 0.1,0.0, 0.8,0.0, 1.0,0.2, 1.0,0.8, 0.8,1.0, 0.0,1.0 ]
                            vector:[0,1,0,0,0.1,0,0.75,0.1,0.1,0.1,0.1,0,0,1,0.1,0,0.1,0.9,0.75,0.1,0.1,0,0.8,0,0.8,1,0,1,0.1,0.9,0.9,0.25,0.75,0.1,0.8,0,0.8,1,0.1,0.9,0.75,0.9,0.9,0.25,0.8,0,1,0.2,1,0.8,0.8,1,0.75,0.9,0.9,0.75,0.9,0.25,1,0.2,1,0.8,0.75,0.9,0.9,0.75,0.9,0.75,1,0.2,1,0.8],
                        },
                        'E':{
                            //vector: [ 0.0,0.0, 1.0,0.0, 1.0,0.1, 0.1,0.1, 0.1,0.4, 0.9,0.4, 0.9,0.5, 0.1,0.5, 0.1,0.9, 1.0,0.9, 1.0,1.0, 0.0,1.0 ]
                            vector:[0,0,1,0,1,0.1,0.1,0.4,0.9,0.4,0.9,0.5,0.1,0.9,1,0.9,1,1,0,0,1,0.1,0.1,0.1,0.1,0.4,0.9,0.5,0.1,0.5,0.1,0.9,1,1,0,1,0,1,0,0,0.1,0.1,0.1,0.5,0.1,0.9,0,1,0,1,0.1,0.1,0.1,0.4,0.1,0.4,0.1,0.5,0,1],
                        },
                        'F':{
                            //vector: [ 0.0,0.0, 1.0,0.0, 1.0,0.1, 0.1,0.1, 0.1,0.4, 0.9,0.4, 0.9,0.5, 0.1,0.5, 0.1,1.0, 0.0,1.0 ]
                            vector:[0.1,1,0,1,0,0,0,0,1,0,1,0.1,0.1,0.4,0.9,0.4,0.9,0.5,0.1,0.5,0.1,1,0,0,0,0,1,0.1,0.1,0.1,0.1,0.4,0.9,0.5,0.1,0.5,0,0,0.1,0.1,0.1,0.4,0.1,0.4,0.1,0.5,0,0],
                        },
                        'G':{
                            //vector: [ 0.2,0.0, 1.0,0.0, 1.0,0.1, 0.25,0.1, 0.1,0.25, 0.1,0.75, 0.25,0.9, 0.75,0.9, 0.9,0.75, 0.9,0.55, 0.85,0.5, 0.5,0.5, 0.5,0.4, 0.9,0.4, 1.0,0.5, 1.0,0.8, 0.8,1.0, 0.2,1.0, 0.0,0.8, 0.0,0.2 ]
                            vector:[0.2,0,1,0,1,0.1,0.85,0.5,0.5,0.5,0.5,0.4,0.5,0.4,0.9,0.4,1,0.5,0.2,0,1,0.1,0.25,0.1,0.85,0.5,0.5,0.4,1,0.5,0,0.2,0.2,0,0.25,0.1,0.9,0.55,0.85,0.5,1,0.5,0,0.2,0.25,0.1,0.1,0.25,0.9,0.75,0.9,0.55,1,0.5,0,0.8,0,0.2,0.1,0.25,0.9,0.75,1,0.5,1,0.8,0,0.8,0.1,0.25,0.1,0.75,0.75,0.9,0.9,0.75,1,0.8,0.2,1,0,0.8,0.1,0.75,0.75,0.9,1,0.8,0.8,1,0.2,1,0.1,0.75,0.25,0.9,0.25,0.9,0.75,0.9,0.8,1,0.8,1,0.2,1,0.25,0.9],
                        },
                        'H':{
                            //vector: [ 0.0,0.0, 0.1,0.0, 0.1,0.4, 0.9,0.4, 0.9,0.0, 1.0,0.0, 1.0,1.0, 0.9,1.0, 0.9,0.5, 0.1,0.5, 0.1,1.0, 0.0,1.0 ]
                            vector:[0.1,1,0,1,0,0,0,0,0.1,0,0.1,0.4,0.9,0.4,0.9,0,1,0,1,0,1,1,0.9,1,0.1,0.5,0.1,1,0,0,1,0,0.9,1,0.9,0.5,0.1,0.5,0,0,0.1,0.4,0.9,0.4,1,0,0.9,0.5,0.9,0.5,0.1,0.5,0.1,0.4,0.1,0.4,0.9,0.4,0.9,0.5],
                        },
                        'I':{
                            //vector: [ 0.0,0.0, 1.0,0.0, 1.0,0.1, 0.55,0.1, 0.55,0.9, 1.0,0.9, 1.0,1.0, 0.0,1.0, 0.0,0.9, 0.45,0.9, 0.45,0.1, 0.0,0.1 ]
                            vector:[0.45,0.1,0,0.1,0,0,0,0,1,0,1,0.1,0.55,0.9,1,0.9,1,1,1,1,0,1,0,0.9,0,0,1,0.1,0.55,0.1,1,1,0,0.9,0.45,0.9,0.45,0.1,0,0,0.55,0.1,0.55,0.9,1,1,0.45,0.9,0.45,0.9,0.45,0.1,0.55,0.1,0.55,0.1,0.55,0.9,0.45,0.9],
                        },
                        'J':{
                            //vector: [ 0.5,0.0, 1.0,0.0, 1.0,0.8, 0.8,1.0, 0.0,1.0, 0.0,0.9, 0.75,0.9, 0.9,0.75, 0.9,0.1, 0.5,0.1 ]
                            vector:[0.9,0.1,0.5,0.1,0.5,0,0.8,1,0,1,0,0.9,0.9,0.1,0.5,0,1,0,0.8,1,0,0.9,0.75,0.9,0.9,0.75,0.9,0.1,1,0,1,0.8,0.8,1,0.75,0.9,0.9,0.75,1,0,1,0.8,1,0.8,0.75,0.9,0.9,0.75],
                        },
                        'K':{
                            //vector: [ 0.0,0.0, 0.1,0.0, 0.1,0.4, 0.7,0.4, 0.9,0.2, 0.9,0.0, 1.0,0.0, 1.0,0.25, 0.8,0.45, 1.0,0.65, 1.0,1.0, 0.9,1.0, 0.9,0.7, 0.7,0.5, 0.1,0.5, 0.1,1.0, 0.0,1.0 ]
                            vector:[0.1,1,0,1,0,0,0,0,0.1,0,0.1,0.4,0.9,0.2,0.9,0,1,0,1,0,1,0.25,0.8,0.45,1,0.65,1,1,0.9,1,0.1,0.5,0.1,1,0,0,0.9,0.2,1,0,0.8,0.45,1,0.65,0.9,1,0.9,0.7,0.1,0.5,0,0,0.1,0.4,0.7,0.4,0.9,0.2,0.8,0.45,0.8,0.45,1,0.65,0.9,0.7,0.7,0.5,0.1,0.5,0.1,0.4,0.1,0.4,0.7,0.4,0.8,0.45,0.8,0.45,0.9,0.7,0.7,0.5,0.7,0.5,0.1,0.4,0.8,0.45],
                        },
                        'L':{
                            //vector: [ 0.0,0.0, 0.1,0.0, 0.1,0.9, 1.0,0.9, 1.0,1.0, 0.0,1.0 ]
                            vector:[0,1,0,0,0.1,0,0.1,0.9,1,0.9,1,1,0,1,0.1,0,0.1,0.9,0.1,0.9,1,1,0,1],
                        },
                        'M':{
                            //vector: [ 0.0,0.0, 0.1,0.0, 0.5,0.4, 0.9,0.0, 1.0,0.0, 1.0,1.0, 0.9,1.0, 0.9,0.15, 0.5,0.55, 0.1,0.15, 0.1,1.0, 0.0,1.0 ]
                            vector:[0.1,1,0,1,0,0,0,0,0.1,0,0.5,0.4,0.5,0.4,0.9,0,1,0,1,0,1,1,0.9,1,0.1,0.15,0.1,1,0,0,1,0,0.9,1,0.9,0.15,0.5,0.55,0.1,0.15,0,0,0.5,0.4,1,0,0.9,0.15,0.5,0.55,0,0,0.5,0.4,0.5,0.4,0.9,0.15,0.5,0.55],
                        },
                        'N':{
                            //vector: [ 0.0,0.0, 0.1,0.0, 0.9,0.85, 0.9,0.0, 1.0,0.0, 1.0,1.0, 0.9,1.0, 0.1,0.15, 0.1,1.0, 0.0,1.0 ]
                            vector:[0.1,1,0,1,0,0,0,0,0.1,0,0.9,0.85,0.9,0.85,0.9,0,1,0,1,0,1,1,0.9,1,0.1,0.15,0.1,1,0,0,0.9,0.85,1,0,0.9,1,0.9,1,0.1,0.15,0,0,0,0,0.9,0.85,0.9,1],
                        },
                        'O':{
                            //vector: [ 0.2,0.0, 0.8,0.0, 1.0,0.2, 1.0,0.8, 0.8,1.0, 0.2,1.0, 0.0,0.8, 0.0,0.2, 0.2,0.0, 0.25,0.1, 0.1,0.25, 0.1,0.75, 0.25,0.9, 0.75,0.9, 0.9,0.75, 0.9,0.25, 0.75,0.1, 0.25,0.1 ]
                            vector:[0.75,0.1,0.25,0.1,0.2,0,0,0.2,0.2,0,0.25,0.1,0.75,0.1,0.2,0,0.8,0,0,0.2,0.25,0.1,0.1,0.25,0.9,0.25,0.75,0.1,0.8,0,0,0.8,0,0.2,0.1,0.25,0.9,0.25,0.8,0,1,0.2,0,0.8,0.1,0.25,0.1,0.75,0.9,0.75,0.9,0.25,1,0.2,0.2,1,0,0.8,0.1,0.75,0.9,0.75,1,0.2,1,0.8,0.2,1,0.1,0.75,0.25,0.9,0.75,0.9,0.9,0.75,1,0.8,0.8,1,0.2,1,0.25,0.9,0.75,0.9,1,0.8,0.8,1,0.8,1,0.25,0.9,0.75,0.9],
                        },
                        'P':{
                            //vector: [ 0.0,0.0, 0.8,0.0, 1.0,0.2, 1.0,0.3, 0.8,0.5, 0.1,0.5, 0.1,0.4, 0.75,0.4, 0.9,0.25, 0.75,0.1, 0.1,0.1, 0.1,1.0, 0.0,1.0 ]
                            vector:[0.1,1,0,1,0,0,0.8,0,1,0.2,1,0.3,0.8,0.5,0.1,0.5,0.1,0.4,0.1,0.1,0.1,1,0,0,0.8,0.5,0.1,0.4,0.75,0.4,0.75,0.1,0.1,0.1,0,0,1,0.3,0.8,0.5,0.75,0.4,0.75,0.1,0,0,0.8,0,1,0.3,0.75,0.4,0.9,0.25,0.9,0.25,0.75,0.1,0.8,0,0.8,0,1,0.3,0.9,0.25],
                        },
                        'Q':{
                            //vector: [ 0.2,0.0, 0.8,0.0, 1.0,0.2, 1.0,0.6, 0.84,0.76, 1.0,0.92, 0.92,1.0, 0.76,0.84, 0.6,1.0, 0.2,1.0, 0.0,0.8, 0.0,0.2, 0.2,0.0, 0.25,0.1, 0.1,0.25, 0.1,0.75, 0.25,0.9, 0.55,0.9, 0.68,0.76, 0.51,0.59, 0.59,0.51, 0.76,0.68, 0.9,0.55, 0.9,0.25, 0.75,0.1, 0.25,0.1 ]
                            vector:[0.75,0.1,0.25,0.1,0.2,0,0.84,0.76,1,0.92,0.92,1,0,0.2,0.2,0,0.25,0.1,0.68,0.76,0.51,0.59,0.59,0.51,0.75,0.1,0.2,0,0.8,0,0.84,0.76,0.92,1,0.76,0.84,0,0.2,0.25,0.1,0.1,0.25,0.68,0.76,0.59,0.51,0.76,0.68,0.9,0.25,0.75,0.1,0.8,0,0,0.8,0,0.2,0.1,0.25,0.55,0.9,0.68,0.76,0.76,0.68,0.9,0.25,0.8,0,1,0.2,0,0.8,0.1,0.25,0.1,0.75,0.55,0.9,0.76,0.68,0.9,0.55,0.9,0.55,0.9,0.25,1,0.2,0.2,1,0,0.8,0.1,0.75,0.9,0.55,1,0.2,1,0.6,0.2,1,0.1,0.75,0.25,0.9,0.55,0.9,0.9,0.55,1,0.6,0.6,1,0.2,1,0.25,0.9,0.55,0.9,1,0.6,0.84,0.76,0.6,1,0.25,0.9,0.55,0.9,0.55,0.9,0.84,0.76,0.76,0.84,0.76,0.84,0.6,1,0.55,0.9],
                        },
                        'R':{
                            //vector: [ 0.0,0.0, 0.8,0.0, 1.0,0.2, 1.0,0.3, 0.8,0.5, 1.0,0.7, 1.0,1.0, 0.9,1.0, 0.9,0.75, 0.65,0.5, 0.1,0.5, 0.1,0.4, 0.75,0.4, 0.9,0.25, 0.75,0.1, 0.1,0.1, 0.1,1.0, 0.0,1.0 ]
                            vector:[0.1,1,0,1,0,0,0.8,0,1,0.2,1,0.3,1,0.7,1,1,0.9,1,0.65,0.5,0.1,0.5,0.1,0.4,0.1,0.1,0.1,1,0,0,1,0.7,0.9,1,0.9,0.75,0.65,0.5,0.1,0.4,0.75,0.4,0.75,0.1,0.1,0.1,0,0,0.8,0.5,1,0.7,0.9,0.75,0.9,0.75,0.65,0.5,0.75,0.4,0.75,0.1,0,0,0.8,0,0.8,0.5,0.9,0.75,0.75,0.4,0.9,0.25,0.75,0.1,0.8,0,1,0.3,0.8,0.5,0.75,0.4,0.9,0.25,0.8,0,1,0.3,1,0.3,0.75,0.4,0.9,0.25],
                        },
                        'S':{
                            //vector: [ 0.3,0.0, 1.0,0.0, 1.0,0.1, 0.35,0.1, 0.1,0.35, 0.1,0.4, 1.0,0.4, 1.0,0.6, 0.6,1.0, 0.0,1.0, 0.0,0.9, 0.55,0.9, 0.9,0.55, 0.9,0.5, 0.0,0.5, 0.0,0.3 ]
                            vector:[0,0.5,0,0.3,0.3,0,0.3,0,1,0,1,0.1,0.6,1,0,1,0,0.9,0.3,0,1,0.1,0.35,0.1,0.6,1,0,0.9,0.55,0.9,0.3,0,0.35,0.1,0.1,0.35,1,0.6,0.6,1,0.55,0.9,0,0.5,0.3,0,0.1,0.35,1,0.6,0.55,0.9,0.9,0.55,0,0.5,0.1,0.35,0.1,0.4,1,0.4,1,0.6,0.9,0.55,0.9,0.5,0,0.5,0.1,0.4,1,0.4,0.9,0.55,0.9,0.5,0.9,0.5,0.1,0.4,1,0.4],
                        },
                        'T':{
                            //vector: [ 0.0,0.0, 1.0,0.0, 1.0,0.1, 0.55,0.1, 0.55,1.0, 0.45,1.0, 0.45,0.1, 0.0,0.1 ]
                            vector:[0.45,0.1,0,0.1,0,0,0,0,1,0,1,0.1,0.55,0.1,0.55,1,0.45,1,0,0,1,0.1,0.55,0.1,0.55,0.1,0.45,1,0.45,0.1,0.45,0.1,0,0,0.55,0.1],
                            encroach:{'t':1},
                        },
                        'U':{
                            //vector: [ 0.0,0.0, 0.1,0.0, 0.1,0.75, 0.25,0.9, 0.75,0.9, 0.9,0.75, 0.9,0.0, 1.0,0.0, 1.0,0.8, 0.8,1.0, 0.2,1.0, 0.0,0.8 ]
                            vector:[0,0.8,0,0,0.1,0,0.9,0.75,0.9,0,1,0,0,0.8,0.1,0,0.1,0.75,0.9,0.75,1,0,1,0.8,0.2,1,0,0.8,0.1,0.75,0.75,0.9,0.9,0.75,1,0.8,0.2,1,0.1,0.75,0.25,0.9,0.75,0.9,1,0.8,0.8,1,0.8,1,0.2,1,0.25,0.9,0.25,0.9,0.75,0.9,0.8,1],
                        },
                        'V':{
                            //vector: [ 0.0,0.0, 0.1,0.0, 0.5,0.85, 0.9,0.0, 1.0,0.0, 0.55,1.0, 0.45,1.0 ]
                            vector:[0.55,1,0.45,1,0,0,0,0,0.1,0,0.5,0.85,0.5,0.85,0.9,0,1,0,0.55,1,0,0,0.5,0.85,0.5,0.85,1,0,0.55,1],
                        },
                        'W':{
                            //vector: [ 0.0,0.0, 0.1,0.0, 0.1,0.85, 0.5,0.4, 0.9,0.85, 0.9,0.0, 1.0,0.0, 1.0,1.0, 0.9,1.0, 0.5,0.55, 0.1,1.0, 0.0,1.0 ]
                            vector:[0.1,1,0,1,0,0,0,0,0.1,0,0.1,0.85,0.9,0.85,0.9,0,1,0,1,0,1,1,0.9,1,0.1,1,0,0,0.1,0.85,0.9,0.85,1,0,0.9,1,0.5,0.55,0.1,1,0.1,0.85,0.5,0.4,0.9,0.85,0.9,1,0.5,0.55,0.1,0.85,0.5,0.4,0.5,0.4,0.9,1,0.5,0.55],
                        },
                        'X':{
                            //vector: [ 0.0,0.0, 0.12,0.0, 0.5,0.44, 0.88,0.0, 1.0,0.0, 0.56,0.5, 1.0,1.0, 0.88,1.0, 0.5,0.56, 0.12,1.0, 0.0,1.0, 0.44,0.5 ]
                            vector:[0.44,0.5,0,0,0.12,0,0.5,0.44,0.88,0,1,0,0.56,0.5,1,1,0.88,1,0.5,0.56,0.12,1,0,1,0.44,0.5,0.12,0,0.5,0.44,0.5,0.44,1,0,0.56,0.5,0.56,0.5,0.88,1,0.5,0.56,0.5,0.56,0,1,0.44,0.5,0.44,0.5,0.5,0.44,0.56,0.5,0.56,0.5,0.5,0.56,0.44,0.5],
                        },
                        'Y':{
                            //vector: [ 0.0,0.0, 0.15,0.0, 0.5,0.35, 0.85,0.0, 1.0,0.0, 0.0,1.0, 0.0,0.85, 0.42,0.42 ]
                            vector:[0.42,0.42,0,0,0.15,0,0.5,0.35,0.85,0,1,0,1,0,0,1,0,0.85,0.42,0.42,0.15,0,0.5,0.35,0.5,0.35,1,0,0,0.85,0,0.85,0.42,0.42,0.5,0.35],
                        },
                        'Z':{
                            //vector: [ 0.0,0.0, 1.0,0.0, 1.0,0.1, 0.15,0.9, 1.0,0.9, 1.0,1.0, 0.0,1.0, 0.0,0.9, 0.85,0.1, 0.0,0.1 ]
                            vector:[0.85,0.1,0,0.1,0,0,0,0,1,0,1,0.1,0.15,0.9,1,0.9,1,1,1,1,0,1,0,0.9,0.85,0.1,0,0,1,0.1,0.15,0.9,1,1,0,0.9,0,0.9,0.85,0.1,1,0.1,1,0.1,0.15,0.9,0,0.9],
                        },
                    
                        'a':{
                            //vector: [ 0.2/0.7,0.0/0.6, 0.4/0.7,0.0/0.6, 0.6/0.7,0.2/0.6, 0.6/0.7,0.5/0.6, 0.7/0.7,0.6/0.6, 0.5/0.7,0.6/0.6, 0.5/0.7,0.25/0.6, 0.35/0.7,0.1/0.6, 0.25/0.7,0.1/0.6, 0.1/0.7,0.25/0.6, 0.1/0.7,0.35/0.6, 0.25/0.7,0.5/0.6, 0.5/0.7,0.5/0.6, 0.5/0.7,0.6/0.6, 0.2/0.7,0.6/0.6, 0.0/0.7,0.4/0.6, 0.0/0.7,0.2/0.6 ]
                            vector:[0,0.6666666666666667,0,0.33333333333333337,0.28571428571428575,0,0.28571428571428575,0,0.5714285714285715,0,0.8571428571428572,0.33333333333333337,0.8571428571428572,0.8333333333333334,1,1,0.7142857142857143,1,0.35714285714285715,0.8333333333333334,0.7142857142857143,0.8333333333333334,0.7142857142857143,1,0.8571428571428572,0.33333333333333337,0.8571428571428572,0.8333333333333334,0.7142857142857143,1,0.35714285714285715,0.8333333333333334,0.7142857142857143,1,0.28571428571428575,1,0.8571428571428572,0.33333333333333337,0.7142857142857143,1,0.7142857142857143,0.4166666666666667,0.14285714285714288,0.5833333333333334,0.35714285714285715,0.8333333333333334,0.28571428571428575,1,0.8571428571428572,0.33333333333333337,0.7142857142857143,0.4166666666666667,0.5,0.16666666666666669,0.14285714285714288,0.5833333333333334,0.28571428571428575,1,0,0.6666666666666667,0.28571428571428575,0,0.8571428571428572,0.33333333333333337,0.5,0.16666666666666669,0.14285714285714288,0.4166666666666667,0.14285714285714288,0.5833333333333334,0,0.6666666666666667,0.28571428571428575,0,0.5,0.16666666666666669,0.35714285714285715,0.16666666666666669,0.14285714285714288,0.4166666666666667,0,0.6666666666666667,0.28571428571428575,0,0.28571428571428575,0,0.35714285714285715,0.16666666666666669,0.14285714285714288,0.4166666666666667],
                            ratio:{x:0.7,y:0.6}, offset:{y:0.4},
                            encroach:{'f':1},
                        },
                        'b':{
                            //vector: [ 0.0/0.6,0.0, 0.1/0.6,0.0, 0.1/0.6,0.9, 0.35/0.6,0.9, 0.5/0.6,0.75, 0.5/0.6,0.65, 0.35/0.6,0.5, 0.1/0.6,0.5, 0.1/0.6,0.4, 0.4/0.6,0.4, 0.6/0.6,0.6, 0.6/0.6,0.8, 0.4/0.6,1.0, 0.0/0.6,1.0 ]
                            vector:[0,1,0,0,0.16666666666666669,0,0.5833333333333334,0.5,0.16666666666666669,0.5,0.16666666666666669,0.4,0.6666666666666667,0.4,1,0.6,1,0.8,0,1,0.16666666666666669,0,0.16666666666666669,0.9,0.5833333333333334,0.5,0.16666666666666669,0.4,0.6666666666666667,0.4,0.6666666666666667,1,0,1,0.16666666666666669,0.9,0.8333333333333334,0.65,0.5833333333333334,0.5,0.6666666666666667,0.4,0.6666666666666667,1,0.16666666666666669,0.9,0.5833333333333334,0.9,0.8333333333333334,0.65,0.6666666666666667,0.4,1,0.8,1,0.8,0.6666666666666667,1,0.5833333333333334,0.9,0.8333333333333334,0.75,0.8333333333333334,0.65,1,0.8,1,0.8,0.5833333333333334,0.9,0.8333333333333334,0.75],
                            ratio:{x:0.6},
                        },
                        'c':{
                            //vector: [ 0.2/0.6,0.0/0.6, 0.6/0.6,0.0/0.6, 0.6/0.6,0.1/0.6, 0.25/0.6,0.1/0.6, 0.1/0.6,0.25/0.6, 0.1/0.6,0.35/0.6, 0.25/0.6,0.5/0.6, 0.6/0.6,0.5/0.6, 0.6/0.6,0.6/0.6, 0.2/0.6,0.6/0.6, 0.0/0.6,0.4/0.6, 0.0/0.6,0.2/0.6 ]
                            vector:[0,0.6666666666666667,0,0.33333333333333337,0.33333333333333337,0,0.33333333333333337,0,1,0,1,0.16666666666666669,0.4166666666666667,0.8333333333333334,1,0.8333333333333334,1,1,0.33333333333333337,0,1,0.16666666666666669,0.4166666666666667,0.16666666666666669,0.4166666666666667,0.8333333333333334,1,1,0.33333333333333337,1,0.33333333333333337,0,0.4166666666666667,0.16666666666666669,0.16666666666666669,0.4166666666666667,0.16666666666666669,0.5833333333333334,0.4166666666666667,0.8333333333333334,0.33333333333333337,1,0,0.6666666666666667,0.33333333333333337,0,0.16666666666666669,0.4166666666666667,0.16666666666666669,0.5833333333333334,0.33333333333333337,1,0,0.6666666666666667,0,0.6666666666666667,0.16666666666666669,0.4166666666666667,0.16666666666666669,0.5833333333333334],
                            ratio:{x:0.6,y:0.6}, offset:{y:0.4},
                        },
                        'd':{
                            //vector: [ 0.5/0.6,0.0, 0.6/0.6,0.0, 0.6/0.6,1.0, 0.2/0.6,1.0, 0.0/0.6,0.8, 0.0/0.6,0.6, 0.2/0.6,0.4, 0.5/0.6,0.4, 0.5/0.6,0.5, 0.25/0.6,0.5, 0.1/0.6,0.65, 0.1/0.6,0.75, 0.25/0.6,0.9, 0.5/0.6,0.9 ]
                            vector:[0.8333333333333334,0.9,0.8333333333333334,0,1,0,0.33333333333333337,1,0,0.8,0,0.6,0.33333333333333337,0.4,0.8333333333333334,0.4,0.8333333333333334,0.5,0.8333333333333334,0.9,1,0,1,1,0.33333333333333337,0.4,0.8333333333333334,0.5,0.4166666666666667,0.5,0.4166666666666667,0.9,0.8333333333333334,0.9,1,1,0,0.6,0.33333333333333337,0.4,0.4166666666666667,0.5,0.4166666666666667,0.9,1,1,0.33333333333333337,1,0,0.6,0.4166666666666667,0.5,0.16666666666666669,0.65,0.16666666666666669,0.75,0.4166666666666667,0.9,0.33333333333333337,1,0,0.6,0.16666666666666669,0.65,0.16666666666666669,0.75,0.16666666666666669,0.75,0.33333333333333337,1,0,0.6],
                            ratio:{x:0.6},
                            encroach:{'c':1},
                        },
                        'e':{
                            //vector: [ 0.15/0.6,0.0/0.6, 0.45/0.6,0.0/0.6, 0.6/0.6,0.15/0.6, 0.6/0.6,0.35/0.6, 0.1/0.6,0.35/0.6, 0.1/0.6,0.25/0.6, 0.5/0.6,0.25/0.6, 0.5/0.6,0.2/0.6, 0.4/0.6,0.1/0.6, 0.2/0.6,0.1/0.6, 0.1/0.6,0.2/0.6, 0.1/0.6,0.4/0.6, 0.2/0.6,0.5/0.6, 0.4/0.6,0.5/0.6, 0.45/0.6,0.45/0.6, 0.6/0.6,0.45/0.6, 0.45/0.6,0.6/0.6, 0.15/0.6,0.6/0.6, 0.0/0.6,0.45/0.6, 0.0/0.6,0.15/0.6 ]
                            vector:[0,0.75,0,0.25,0.25,0,0.25,0,0.75,0,1,0.25,1,0.5833333333333334,0.16666666666666669,0.5833333333333334,0.16666666666666669,0.4166666666666667,0.6666666666666667,0.8333333333333334,0.75,0.75,1,0.75,1,0.75,0.75,1,0.25,1,1,0.5833333333333334,0.16666666666666669,0.4166666666666667,0.8333333333333334,0.4166666666666667,0.6666666666666667,0.8333333333333334,1,0.75,0.25,1,1,0.25,1,0.5833333333333334,0.8333333333333334,0.4166666666666667,0.33333333333333337,0.8333333333333334,0.6666666666666667,0.8333333333333334,0.25,1,1,0.25,0.8333333333333334,0.4166666666666667,0.8333333333333334,0.33333333333333337,0.16666666666666669,0.6666666666666667,0.33333333333333337,0.8333333333333334,0.25,1,1,0.25,0.8333333333333334,0.33333333333333337,0.6666666666666667,0.16666666666666669,0.16666666666666669,0.6666666666666667,0.25,1,0,0.75,0.25,0,1,0.25,0.6666666666666667,0.16666666666666669,0.16666666666666669,0.33333333333333337,0.16666666666666669,0.6666666666666667,0,0.75,0.25,0,0.6666666666666667,0.16666666666666669,0.33333333333333337,0.16666666666666669,0.16666666666666669,0.33333333333333337,0,0.75,0.25,0,0.25,0,0.33333333333333337,0.16666666666666669,0.16666666666666669,0.33333333333333337],
                            ratio:{x:0.6,y:0.6}, offset:{y:0.4},
                        },
                        'f':{
                            //vector: [ 0.35/0.5,0.0, 0.5/0.5,0.0, 0.5/0.5,0.1, 0.4/0.5,0.1, 0.3/0.5,0.2, 0.3/0.5,0.4, 0.5/0.5,0.4, 0.5/0.5,0.5, 0.3/0.5,0.5, 0.3/0.5,1.0, 0.2/0.5,1.0, 0.2/0.5,0.5, 0.0/0.5,0.5, 0.0/0.5,0.4, 0.2/0.5,0.4, 0.2/0.5,0.15 ]
                            vector:[0.4,0.4,0.4,0.15,0.7,0,0.7,0,1,0,1,0.1,0.6,0.4,1,0.4,1,0.5,0.6,0.5,0.6,1,0.4,1,0.4,0.5,0,0.5,0,0.4,0.7,0,1,0.1,0.8,0.1,0.6,0.4,1,0.5,0.6,0.5,0.6,0.5,0.4,1,0.4,0.5,0.4,0.5,0,0.4,0.4,0.4,0.7,0,0.8,0.1,0.6,0.2,0.6,0.4,0.6,0.5,0.4,0.5,0.4,0.5,0.4,0.4,0.7,0,0.6,0.2,0.6,0.4,0.4,0.5,0.4,0.5,0.7,0,0.6,0.2],
                            ratio:{x:0.5},
                            encroach:{'e':1},
                        },
                        'g':{
                            //vector: [ 0.2/0.6,0.0/1.1, 0.4/0.6,0.0/1.1, 0.6/0.6,0.2/1.1, 0.6/0.6,0.9/1.1, 0.4/0.6,1.1/1.1, 0.2/0.6,1.1/1.1, 0.0/0.6,0.9/1.1, 0.0/0.6,0.8/1.1, 0.1/0.6,0.8/1.1, 0.1/0.6,0.85/1.1, 0.25/0.6,1.0/1.1, 0.35/0.6,1.0/1.1, 0.5/0.6,0.85/1.1, 0.5/0.6,0.25/1.1, 0.35/0.6,0.1/1.1, 0.25/0.6,0.1/1.1, 0.1/0.6,0.25/1.1, 0.1/0.6,0.35/1.1, 0.25/0.6,0.5/1.1, 0.5/0.6,0.5/1.1, 0.5/0.6,0.6/1.1, 0.2/0.6,0.6/1.1, 0.0/0.6,0.4/1.1, 0.0/0.6,0.2/1.1 ],'flatArray'),
                            vector:[0,0.364,0,0.182,0.333,0,0.333,0,0.667,0,1,0.182,1,0.818,0.667,1,0.333,1,0.333,1,0,0.818,0,0.727,0,0.727,0.167,0.727,0.167,0.773,0.417,0.455,0.833,0.455,0.833,0.545,0.333,1,0,0.727,0.167,0.773,0.417,0.455,0.833,0.545,0.333,0.545,0.333,1,0.167,0.773,0.417,0.909,0.167,0.318,0.417,0.455,0.333,0.545,0.333,1,0.417,0.909,0.583,0.909,0.167,0.318,0.333,0.545,0,0.364,1,0.818,0.333,1,0.583,0.909,0.167,0.227,0.167,0.318,0,0.364,1,0.818,0.583,0.909,0.833,0.773,0.167,0.227,0,0.364,0.333,0,1,0.182,1,0.818,0.833,0.773,0.417,0.091,0.167,0.227,0.333,0,1,0.182,0.833,0.773,0.833,0.227,0.583,0.091,0.417,0.091,0.333,0,1,0.182,0.833,0.227,0.583,0.091,0.583,0.091,0.333,0,1,0.182],
                            ratio:{x:0.6,y:1.1}, offset:{y:0.4},
                            encroach:{'f':1},
                        },
                        'h':{
                            //vector: [ 0.0/0.6,0.0, 0.1/0.6,0.0, 0.1/0.6,0.4, 0.4/0.6,0.4, 0.6/0.6,0.6, 0.6/0.6,1.0, 0.5/0.6,1.0, 0.5/0.6,0.65, 0.35/0.6,0.5, 0.1/0.6,0.5, 0.1/0.6,1.0, 0.0/0.6,1.0 ]
                            vector:[0.16666666666666669,1,0,1,0,0,0,0,0.16666666666666669,0,0.16666666666666669,0.4,1,0.6,1,1,0.8333333333333334,1,0.16666666666666669,0.5,0.16666666666666669,1,0,0,1,0.6,0.8333333333333334,1,0.8333333333333334,0.65,0.16666666666666669,0.5,0,0,0.16666666666666669,0.4,0.6666666666666667,0.4,1,0.6,0.8333333333333334,0.65,0.5833333333333334,0.5,0.16666666666666669,0.5,0.16666666666666669,0.4,0.6666666666666667,0.4,0.8333333333333334,0.65,0.5833333333333334,0.5,0.5833333333333334,0.5,0.16666666666666669,0.4,0.6666666666666667,0.4],
                            ratio:{x:0.6},
                        },
                        'i':{
                            //vector: [ 0.0/0.1,0.0/0.9, 0.1/0.1,0.0/0.9, 0.1/0.1,0.2/0.9, 0.0/0.1,0.2/0.9, 0.0/0.1,0.3/0.9, 0.1/0.1,0.3/0.9, 0.1/0.1,0.9/0.9, 0.0/0.1,0.9/0.9 ]
                            vector:[0,0,1,0,1,0.22222222222222224,0,0.3333333333333333,1,0.3333333333333333,1,1,0,0,1,0.22222222222222224,0,0.22222222222222224,0,0.3333333333333333,1,1,0,1],
                            ratio:{x:0.1,y:0.9}, offset:{y:0.1},
                        },
                        'j':{
                            //vector: [ 0.2/0.3,0.0/1.1, 0.3/0.3,0.0/1.1, 0.3/0.3,0.2/1.1, 0.2/0.3,0.2/1.1, 0.2/0.3,0.3/1.1, 0.3/0.3,0.3/1.1, 0.3/0.3,0.95/1.1, 0.15/0.3,1.1/1.1,  0.0/0.3,1.1/1.1, 0.0/0.3,1.0/1.1,  0.1/0.3,1.0/1.1, 0.2/0.3,0.9/1.1 ]
                            vector:[0.6666666666666667,0,1,0,1,0.18181818181818182,0.6666666666666667,0.2727272727272727,1,0.2727272727272727,1,0.8636363636363635,1,0.8636363636363635,0.5,1,0,1,0,1,0,0.9090909090909091,0.33333333333333337,0.9090909090909091,0.6666666666666667,0,1,0.18181818181818182,0.6666666666666667,0.18181818181818182,1,0.8636363636363635,0,1,0.33333333333333337,0.9090909090909091,1,0.8636363636363635,0.33333333333333337,0.9090909090909091,0.6666666666666667,0.8181818181818181,0.6666666666666667,0.2727272727272727,1,0.8636363636363635,0.6666666666666667,0.8181818181818181],
                            ratio:{x:0.3,y:1.1}, offset:{y:0.1},
                            encroach:{
                                'A':1,'B':1,'C':1,'D':1,'E':1,'F':1,'G':1,'H':1,'I':1,'J':1,'L':1,'K':1,'M':1,'N':1,'O':1,'P':1,'Q':1,'R':1,'S':1,'T':1,'U':1,'V':1,'W':1,'X':1,'Y':1,'Z':1,
                                'a':2,'b':1,'c':1,'d':1,'e':1,'f':1,'h':1,'i':1,'k':1,'l':1,'n':1,'m':1,'o':1,'p':1,'r':1,'s':1,'t':1,'u':1,'v':1,'w':1,'x':1,'z':1,
                            },
                        },
                        'k':{
                            //vector: [ 0.0/0.6,0.0, 0.1/0.6,0.0, 0.1/0.6,0.4, 0.6/0.6,0.4, 0.6/0.6,0.5, 0.4/0.6,0.5, 0.6/0.6,1.0, 0.5/0.6,1.0, 0.3/0.6,0.5, 0.1/0.6,0.5, 0.1/0.6,1.0, 0.0/0.6,1.0 ]
                            vector:[0.16666666666666669,1,0,1,0,0,0,0,0.16666666666666669,0,0.16666666666666669,0.4,0.16666666666666669,0.4,1,0.4,1,0.5,0.6666666666666667,0.5,1,1,0.8333333333333334,1,0.16666666666666669,0.5,0.16666666666666669,1,0,0,0.16666666666666669,0.4,1,0.5,0.6666666666666667,0.5,0.6666666666666667,0.5,0.8333333333333334,1,0.5,0.5,0.16666666666666669,0.5,0,0,0.16666666666666669,0.4,0.16666666666666669,0.4,0.6666666666666667,0.5,0.5,0.5,0.5,0.5,0.16666666666666669,0.5,0.16666666666666669,0.4],
                            ratio:{x:0.6},
                        },
                        'l':{
                            //vector: [ 0.0/0.4,0.0, 0.1/0.4,0.0, 0.1/0.4,0.75, 0.25/0.4,0.9, 0.4/0.4,0.9, 0.4/0.4,1.0, 0.2/0.4,1.0, 0.0/0.4,0.8 ]
                            vector:[0,0.8,0,0,0.25,0,0.625,0.9,1,0.9,1,1,1,1,0.5,1,0,0.8,0,0.8,0.25,0,0.25,0.75,0.625,0.9,1,1,0,0.8,0,0.8,0.25,0.75,0.625,0.9],
                            ratio:{x:0.4},
                        },
                        'm':{
                            //vector: [ 0.0/1.1,0.0/0.6, 0.4/1.1,0.0/0.6,0.5/1.1,0.1/0.6, 0.5/1.1,0.0/0.6, 0.9/1.1,0.0/0.6, 1.1/1.1,0.2/0.6, 1.1/1.1,0.6/0.6, 1.0/1.1,0.6/0.6, 1.0/1.1,0.25/0.6, 0.85/1.1,0.1/0.6, 0.6/1.1,0.1/0.6, 0.6/1.1,0.6/0.6, 0.5/1.1,0.6/0.6, 0.5/1.1,0.25/0.6, 0.35/1.1,0.1/0.6, 0.1/1.1,0.1/0.6, 0.1/1.1,0.6/0.6, 0.0/1.1,0.6/0.6 ]
                            vector:[0.09090909090909091,1,0,1,0,0,0,0,0.36363636363636365,0,0.45454545454545453,0.16666666666666669,0.45454545454545453,0.16666666666666669,0.45454545454545453,0,0.8181818181818181,0,1,0.33333333333333337,1,1,0.9090909090909091,1,0.5454545454545454,0.16666666666666669,0.5454545454545454,1,0.45454545454545453,1,0.09090909090909091,0.16666666666666669,0.09090909090909091,1,0,0,1,0.33333333333333337,0.9090909090909091,1,0.9090909090909091,0.4166666666666667,0.5454545454545454,0.16666666666666669,0.45454545454545453,1,0.45454545454545453,0.4166666666666667,0.3181818181818181,0.16666666666666669,0.09090909090909091,0.16666666666666669,0,0,0.8181818181818181,0,1,0.33333333333333337,0.9090909090909091,0.4166666666666667,0.3181818181818181,0.16666666666666669,0,0,0.45454545454545453,0.16666666666666669,0.8181818181818181,0,0.9090909090909091,0.4166666666666667,0.7727272727272726,0.16666666666666669,0.45454545454545453,0.4166666666666667,0.3181818181818181,0.16666666666666669,0.45454545454545453,0.16666666666666669,0.8181818181818181,0,0.7727272727272726,0.16666666666666669,0.5454545454545454,0.16666666666666669,0.5454545454545454,0.16666666666666669,0.45454545454545453,0.4166666666666667,0.45454545454545453,0.16666666666666669,0.45454545454545453,0.16666666666666669,0.8181818181818181,0,0.5454545454545454,0.16666666666666669],
                            ratio:{x:1.1,y:0.6}, offset:{y:0.4},
                        },
                        'n':{
                            //vector: [ 0.0/0.6,0.0/0.6, 0.4/0.6,0.0/0.6, 0.6/0.6,0.2/0.6, 0.6/0.6,0.6/0.6, 0.5/0.6,0.6/0.6, 0.5/0.6,0.25/0.6, 0.35/0.6,0.1/0.6, 0.1/0.6,0.1/0.6, 0.1/0.6,0.6/0.6, 0.0/0.6,0.6/0.6 ]
                            vector:[0.16666666666666669,1,0,1,0,0,1,0.33333333333333337,1,1,0.8333333333333334,1,0.16666666666666669,0.16666666666666669,0.16666666666666669,1,0,0,1,0.33333333333333337,0.8333333333333334,1,0.8333333333333334,0.4166666666666667,0.5833333333333334,0.16666666666666669,0.16666666666666669,0.16666666666666669,0,0,0.6666666666666667,0,1,0.33333333333333337,0.8333333333333334,0.4166666666666667,0.5833333333333334,0.16666666666666669,0,0,0.6666666666666667,0,0.6666666666666667,0,0.8333333333333334,0.4166666666666667,0.5833333333333334,0.16666666666666669],
                            ratio:{x:0.6,y:0.6}, offset:{y:0.4},
                        },
                        'o':{
                            //vector: [ 0.2/0.6,0.0/0.6, 0.4/0.6,0.0/0.6, 0.6/0.6,0.2/0.6, 0.6/0.6,0.4/0.6, 0.4/0.6,0.6/0.6, 0.2/0.6,0.6/0.6, 0.0/0.6,0.4/0.6, 0.0/0.6,0.2/0.6, 0.2/0.6,0.0/0.6, 0.25/0.6,0.1/0.6, 0.1/0.6,0.25/0.6, 0.1/0.6,0.35/0.6, 0.25/0.6,0.5/0.6, 0.35/0.6,0.5/0.6, 0.5/0.6,0.35/0.6, 0.5/0.6,0.25/0.6, 0.35/0.6,0.1/0.6, 0.25/0.6,0.1/0.6 ]
                            vector:[0.5833333333333334,0.16666666666666669,0.4166666666666667,0.16666666666666669,0.33333333333333337,0,0.33333333333333337,0,0.6666666666666667,0,1,0.33333333333333337,1,0.33333333333333337,1,0.6666666666666667,0.6666666666666667,1,0.6666666666666667,1,0.33333333333333337,1,0,0.6666666666666667,0,0.6666666666666667,0,0.33333333333333337,0.33333333333333337,0,0.33333333333333337,0,0.4166666666666667,0.16666666666666669,0.16666666666666669,0.4166666666666667,0.5833333333333334,0.16666666666666669,0.33333333333333337,0,1,0.33333333333333337,0,0.6666666666666667,0.33333333333333337,0,0.16666666666666669,0.4166666666666667,0.8333333333333334,0.4166666666666667,0.5833333333333334,0.16666666666666669,1,0.33333333333333337,0,0.6666666666666667,0.16666666666666669,0.4166666666666667,0.16666666666666669,0.5833333333333334,0.8333333333333334,0.5833333333333334,0.8333333333333334,0.4166666666666667,1,0.33333333333333337,0,0.6666666666666667,0.16666666666666669,0.5833333333333334,0.4166666666666667,0.8333333333333334,0.8333333333333334,0.5833333333333334,1,0.33333333333333337,0.6666666666666667,1,0.6666666666666667,1,0,0.6666666666666667,0.4166666666666667,0.8333333333333334,0.5833333333333334,0.8333333333333334,0.8333333333333334,0.5833333333333334,0.6666666666666667,1,0.6666666666666667,1,0.4166666666666667,0.8333333333333334,0.5833333333333334,0.8333333333333334],
                            ratio:{x:0.6,y:0.6}, offset:{y:0.4},
                        },
                        'p':{
                            //vector: [ 0.0/0.6,0.0, 0.4/0.6,0.0, 0.6/0.6,0.2, 0.6/0.6,0.4, 0.4/0.6,0.6, 0.1/0.6,0.6, 0.1/0.6,0.5, 0.35/0.6,0.5, 0.5/0.6,0.35, 0.5/0.6,0.25, 0.35/0.6,0.1, 0.1/0.6,0.1, 0.1/0.6,1.0, 0.0/0.6,1.0 ]
                            vector:[0.16666666666666669,1,0,1,0,0,0.6666666666666667,0,1,0.2,1,0.4,0.6666666666666667,0.6,0.16666666666666669,0.6,0.16666666666666669,0.5,0.16666666666666669,0.1,0.16666666666666669,1,0,0,0.6666666666666667,0.6,0.16666666666666669,0.5,0.5833333333333334,0.5,0.5833333333333334,0.1,0.16666666666666669,0.1,0,0,1,0.4,0.6666666666666667,0.6,0.5833333333333334,0.5,0.5833333333333334,0.1,0,0,0.6666666666666667,0,1,0.4,0.5833333333333334,0.5,0.8333333333333334,0.35,0.8333333333333334,0.25,0.5833333333333334,0.1,0.6666666666666667,0,1,0.4,0.8333333333333334,0.35,0.8333333333333334,0.25,0.8333333333333334,0.25,0.6666666666666667,0,1,0.4],
                            ratio:{x:0.6}, offset:{y:0.4},
                        },
                        'q':{
                            //vector: [ 0.6/0.6,0.0, 0.2/0.6,0.0, 0.0/0.6,0.2, 0.0/0.6,0.4, 0.2/0.6,0.6, 0.5/0.6,0.6, 0.5/0.6,0.5, 0.25/0.6,0.5, 0.1/0.6,0.35, 0.1/0.6,0.25, 0.25/0.6,0.1, 0.5/0.6,0.1, 0.5/0.6,1.0, 0.6/0.6,1.0 ]
                            vector:[1,0,1,1,0.8333333333333334,1,0.4166666666666667,0.5,0.8333333333333334,0.5,0.8333333333333334,0.6,0.33333333333333337,0.6,0,0.4,0,0.2,1,0,0.8333333333333334,1,0.8333333333333334,0.1,0.4166666666666667,0.5,0.8333333333333334,0.6,0.33333333333333337,0.6,0.33333333333333337,0,1,0,0.8333333333333334,0.1,0.16666666666666669,0.35,0.4166666666666667,0.5,0.33333333333333337,0.6,0.33333333333333337,0,0.8333333333333334,0.1,0.4166666666666667,0.1,0.16666666666666669,0.35,0.33333333333333337,0.6,0,0.2,0,0.2,0.33333333333333337,0,0.4166666666666667,0.1,0.16666666666666669,0.25,0.16666666666666669,0.35,0,0.2,0,0.2,0.4166666666666667,0.1,0.16666666666666669,0.25],
                            ratio:{x:0.6}, offset:{y:0.4},
                        },
                        'r':{
                            //vector: [ 0.0/0.6,0.0/0.6, 0.1/0.6,0.0/0.6, 0.1/0.6,0.1/0.6, 0.2/0.6,0.0/0.6, 0.6/0.6,0.0/0.6, 0.6/0.6,0.1/0.6, 0.25/0.6,0.1/0.6, 0.1/0.6,0.25/0.6, 0.1/0.6,0.6/0.6, 0.0/0.6,0.6/0.6 ]
                            vector:[0.16666666666666669,1,0,1,0,0,0,0,0.16666666666666669,0,0.16666666666666669,0.16666666666666669,0.16666666666666669,0.16666666666666669,0.33333333333333337,0,1,0,1,0,1,0.16666666666666669,0.4166666666666667,0.16666666666666669,0.16666666666666669,0.4166666666666667,0.16666666666666669,1,0,0,0.16666666666666669,0.16666666666666669,1,0,0.4166666666666667,0.16666666666666669,0.16666666666666669,0.4166666666666667,0,0,0.16666666666666669,0.16666666666666669,0.16666666666666669,0.16666666666666669,0.4166666666666667,0.16666666666666669,0.16666666666666669,0.4166666666666667],
                            ratio:{x:0.6,y:0.6}, offset:{y:0.4},
                        },
                        's':{
                            //vector: [ 0.2/0.6,0.0/0.6, 0.6/0.6,0.0/0.6, 0.6/0.6,0.1/0.6, 0.25/0.6,0.1/0.6, 0.1/0.6,0.25/0.6, 0.6/0.6,0.25/0.6, 0.6/0.6,0.4/0.6, 0.4/0.6,0.6/0.6, 0.0/0.6,0.6/0.6, 0.0/0.6,0.5/0.6, 0.35/0.6,0.5/0.6, 0.5/0.6,0.35/0.6, 0.0/0.6,0.35/0.6, 0.0/0.6,0.2/0.6 ]
                            vector:[0,0.5833333333333334,0,0.33333333333333337,0.33333333333333337,0,0.33333333333333337,0,1,0,1,0.16666666666666669,1,0.4166666666666667,1,0.6666666666666667,0.6666666666666667,1,0.6666666666666667,1,0,1,0,0.8333333333333334,0.33333333333333337,0,1,0.16666666666666669,0.4166666666666667,0.16666666666666669,0.6666666666666667,1,0,0.8333333333333334,0.5833333333333334,0.8333333333333334,0.33333333333333337,0,0.4166666666666667,0.16666666666666669,0.16666666666666669,0.4166666666666667,0.6666666666666667,1,0.5833333333333334,0.8333333333333334,0.8333333333333334,0.5833333333333334,0,0.5833333333333334,0.33333333333333337,0,0.16666666666666669,0.4166666666666667,1,0.4166666666666667,0.6666666666666667,1,0.8333333333333334,0.5833333333333334,0.8333333333333334,0.5833333333333334,0,0.5833333333333334,0.16666666666666669,0.4166666666666667,0.16666666666666669,0.4166666666666667,1,0.4166666666666667,0.8333333333333334,0.5833333333333334],
                            ratio:{x:0.6,y:0.6}, offset:{y:0.4},
                            encroach:{'r':1},
                        },
                        't':{
                            //vector: [ 0.2/0.5,0.0, 0.3/0.5,0.0, 0.3/0.5,0.4, 0.5/0.5,0.4, 0.5/0.5,0.5, 0.3/0.5,0.5, 0.3/0.5,1.0, 0.2/0.5,1.0, 0.2/0.5,0.5, 0.0/0.5,0.5, 0.0/0.5,0.4, 0.2/0.5,0.4 ]
                            vector:[0.4,0.4,0.4,0,0.6,0,0.6,0.4,1,0.4,1,0.5,0.6,0.5,0.6,1,0.4,1,0.4,0.5,0,0.5,0,0.4,0.4,0.4,0.6,0,0.6,0.4,0.6,0.4,1,0.5,0.6,0.5,0.6,0.5,0.4,1,0.4,0.5,0.4,0.5,0,0.4,0.4,0.4,0.4,0.4,0.6,0.4,0.6,0.5,0.6,0.5,0.4,0.5,0.4,0.4],
                            ratio:{x:0.5},
                            encroach:{'l':1},
                        },
                        'u':{
                            //vector: [ 0.0/0.6,0.0/0.6, 0.1/0.6,0.0/0.6, 0.1/0.6,0.35/0.6, 0.25/0.6,0.5/0.6, 0.5/0.6,0.5/0.6, 0.5/0.6,0.0/0.6, 0.6/0.6,0.0/0.6, 0.6/0.6,0.6/0.6, 0.2/0.6,0.6/0.6, 0.0/0.6,0.4/0.6 ]
                            vector:[0,0.6666666666666667,0,0,0.16666666666666669,0,0.8333333333333334,0.8333333333333334,0.8333333333333334,0,1,0,0,0.6666666666666667,0.16666666666666669,0,0.16666666666666669,0.5833333333333334,0.8333333333333334,0.8333333333333334,1,0,1,1,0.33333333333333337,1,0,0.6666666666666667,0.16666666666666669,0.5833333333333334,0.4166666666666667,0.8333333333333334,0.8333333333333334,0.8333333333333334,1,1,0.33333333333333337,1,0.16666666666666669,0.5833333333333334,0.4166666666666667,0.8333333333333334,0.4166666666666667,0.8333333333333334,1,1,0.33333333333333337,1],
                            ratio:{x:0.6,y:0.6}, offset:{y:0.4},
                            encroach:{'a':1},
                        },
                        'v':{
                            //vector: [ 0.0/0.6,0.0/0.6, 0.1/0.6,0.0/0.6, 0.3/0.6,0.45/0.6, 0.5/0.6,0.0/0.6, 0.6/0.6,0.0/0.6, 0.35/0.6,0.6/0.6, 0.25/0.6,0.6/0.6 ]
                            vector:[0.5833333333333334,1,0.4166666666666667,1,0,0,0,0,0.16666666666666669,0,0.5,0.75,0.5,0.75,0.8333333333333334,0,1,0,0.5833333333333334,1,0,0,0.5,0.75,0.5,0.75,1,0,0.5833333333333334,1],
                            ratio:{x:0.6,y:0.6}, offset:{y:0.4},
                        },
                        'w':{
                            //vector: [ 0.0/1.1,0.0/0.6, 0.1/1.1,0.0/0.6, 0.1/1.1,0.35/0.6, 0.25/1.1,0.5/0.6, 0.5/1.1,0.5/0.6, 0.5/1.1,0.0/0.6, 0.6/1.1,0.0/0.6, 0.6/1.1,0.35/0.6, 0.75/1.1,0.5/0.6, 1.0/1.1,0.5/0.6, 1.0/1.1,0.0/0.6, 1.1/1.1,0.0/0.6, 1.1/1.1,0.6/0.6, 0.7/1.1,0.6/0.6, 0.6/1.1,0.5/0.6, 0.6/1.1,0.6/0.6, 0.2/1.1,0.6/0.6, 0.0/1.1,0.4/0.6 ]
                            vector:[0,0.6666666666666667,0,0,0.09090909090909091,0,0.45454545454545453,0.8333333333333334,0.45454545454545453,0,0.5454545454545454,0,0.9090909090909091,0.8333333333333334,0.9090909090909091,0,1,0,1,1,0.6363636363636362,1,0.5454545454545454,0.8333333333333334,0.5454545454545454,0.8333333333333334,0.5454545454545454,1,0.18181818181818182,1,0,0.6666666666666667,0.09090909090909091,0,0.09090909090909091,0.5833333333333334,0.45454545454545453,0.8333333333333334,0.5454545454545454,0,0.5454545454545454,0.5833333333333334,0.9090909090909091,0.8333333333333334,1,0,1,1,0.18181818181818182,1,0,0.6666666666666667,0.09090909090909091,0.5833333333333334,0.6818181818181818,0.8333333333333334,0.9090909090909091,0.8333333333333334,1,1,0.18181818181818182,1,0.09090909090909091,0.5833333333333334,0.22727272727272727,0.8333333333333334,0.6818181818181818,0.8333333333333334,1,1,0.5454545454545454,0.8333333333333334,0.18181818181818182,1,0.22727272727272727,0.8333333333333334,0.45454545454545453,0.8333333333333334,0.5454545454545454,0.5833333333333334,0.6818181818181818,0.8333333333333334,0.5454545454545454,0.8333333333333334,0.5454545454545454,0.8333333333333334,0.18181818181818182,1,0.45454545454545453,0.8333333333333334,0.45454545454545453,0.8333333333333334,0.5454545454545454,0.5833333333333334,0.5454545454545454,0.8333333333333334],
                            ratio:{x:1.1,y:0.6}, offset:{y:0.4},
                        },
                        'x':{
                            //vector: [ 0.0/0.6,0.0/0.6, 0.125/0.6,0.0/0.6, 0.3/0.6,0.225/0.6, 0.475/0.6,0.0/0.6, 0.6/0.6,0.0/0.6, 0.366/0.6,0.3/0.6, 0.6/0.6,0.6/0.6, 0.475/0.6,0.6/0.6, 0.3/0.6,0.375/0.6, 0.125/0.6,0.6/0.6, 0.0/0.6,0.6/0.6, 0.233/0.6,0.3/0.6 ]
                            vector:[0.38833333333333336,0.5,0,0,0.20833333333333334,0,0.5,0.375,0.7916666666666666,0,1,0,0.61,0.5,1,1,0.7916666666666666,1,0.5,0.625,0.20833333333333334,1,0,1,0.38833333333333336,0.5,0.20833333333333334,0,0.5,0.375,0.5,0.375,1,0,0.61,0.5,0.61,0.5,0.7916666666666666,1,0.5,0.625,0.5,0.625,0,1,0.38833333333333336,0.5,0.38833333333333336,0.5,0.5,0.375,0.61,0.5,0.61,0.5,0.5,0.625,0.38833333333333336,0.5],
                            ratio:{x:0.6,y:0.6}, offset:{y:0.4},
                        },
                        'y':{
                            //vector: [ 0.0/0.6,0.0/1.1, 0.1/0.6,0.0/1.1, 0.1/0.6,0.35/1.1, 0.25/0.6,0.5/1.1, 0.5/0.6,0.5/1.1, 0.5/0.6,0.0/1.1, 0.6/0.6,0.0/1.1, 0.6/0.6,0.9/1.1, 0.4/0.6,1.1/1.1, 0.2/0.6,1.1/1.1, 0.0/0.6,0.9/1.1, 0.0/0.6,0.8/1.1, 0.1/0.6,0.8/1.1, 0.1/0.6,0.85/1.1, 0.25/0.6,1.0/1.1, 0.35/0.6,1.0/1.1, 0.5/0.6,0.85/1.1, 0.5/0.6,0.6/1.1,0.2/0.6,0.6/1.1, 0.0/0.6,0.4/1.1 ]
                            vector:[0,0.36363636363636365,0,0,0.16666666666666669,0,0.8333333333333334,0.45454545454545453,0.8333333333333334,0,1,0,1,0.8181818181818181,0.6666666666666667,1,0.33333333333333337,1,0.33333333333333337,1,0,0.8181818181818181,0,0.7272727272727273,0,0.7272727272727273,0.16666666666666669,0.7272727272727273,0.16666666666666669,0.7727272727272726,0,0.36363636363636365,0.16666666666666669,0,0.16666666666666669,0.3181818181818181,0.8333333333333334,0.45454545454545453,1,0,1,0.8181818181818181,0.33333333333333337,1,0,0.7272727272727273,0.16666666666666669,0.7727272727272726,0.33333333333333337,0.5454545454545454,0,0.36363636363636365,0.16666666666666669,0.3181818181818181,0.33333333333333337,1,0.16666666666666669,0.7727272727272726,0.4166666666666667,0.9090909090909091,0.33333333333333337,0.5454545454545454,0.16666666666666669,0.3181818181818181,0.4166666666666667,0.45454545454545453,0.33333333333333337,1,0.4166666666666667,0.9090909090909091,0.5833333333333334,0.9090909090909091,0.8333333333333334,0.5454545454545454,0.33333333333333337,0.5454545454545454,0.4166666666666667,0.45454545454545453,1,0.8181818181818181,0.33333333333333337,1,0.5833333333333334,0.9090909090909091,0.8333333333333334,0.5454545454545454,0.4166666666666667,0.45454545454545453,0.8333333333333334,0.45454545454545453,1,0.8181818181818181,0.5833333333333334,0.9090909090909091,0.8333333333333334,0.7727272727272726,0.8333333333333334,0.5454545454545454,0.8333333333333334,0.45454545454545453,1,0.8181818181818181,1,0.8181818181818181,0.8333333333333334,0.7727272727272726,0.8333333333333334,0.5454545454545454],
                            ratio:{x:0.6,y:1.1}, offset:{y:0.4},
                        },
                        'z':{
                            //vector: [ 0.0/0.6,0.0/0.6, 0.6/0.6,0.0/0.6, 0.6/0.6,0.1/0.6, 0.15/0.6,0.5/0.6, 0.6/0.6,0.5/0.6, 0.6/0.6,0.6/0.6, 0.0/0.6,0.6/0.6, 0.0/0.6,0.5/0.6, 0.45/0.6,0.1/0.6, 0.0/0.6,0.1/0.6 ]
                            vector:[0.75,0.16666666666666669,0,0.16666666666666669,0,0,0,0,1,0,1,0.16666666666666669,0.25,0.8333333333333334,1,0.8333333333333334,1,1,1,1,0,1,0,0.8333333333333334,0.75,0.16666666666666669,0,0,1,0.16666666666666669,0.25,0.8333333333333334,1,1,0,0.8333333333333334,0,0.8333333333333334,0.75,0.16666666666666669,1,0.16666666666666669,1,0.16666666666666669,0.25,0.8333333333333334,0,0.8333333333333334],
                            ratio:{x:0.6,y:0.6}, offset:{y:0.4},
                        },
                    
                        '0':{
                            //vector: [ 0.2/0.8,0.0, 0.6/0.8,0.0, 0.8/0.8,0.2, 0.8/0.8,0.8, 0.6/0.8,1.0, 0.2/0.8,1.0, 0.0/0.8,0.8, 0.0/0.8,0.2, 0.2/0.8,0.0, 0.25/0.8,0.1, 0.1/0.8,0.25, 0.1/0.8,0.75, 0.25/0.8,0.9, 0.55/0.8,0.9, 0.7/0.8,0.75, 0.7/0.8,0.25, 0.55/0.8,0.1, 0.25/0.8,0.1 ]
                            vector:[0.6875,0.1,0.3125,0.1,0.25,0,0,0.2,0.25,0,0.3125,0.1,0.6875,0.1,0.25,0,0.7499999999999999,0,0,0.2,0.3125,0.1,0.125,0.25,0.8749999999999999,0.25,0.6875,0.1,0.7499999999999999,0,0,0.8,0,0.2,0.125,0.25,0.8749999999999999,0.25,0.7499999999999999,0,1,0.2,0,0.8,0.125,0.25,0.125,0.75,0.8749999999999999,0.75,0.8749999999999999,0.25,1,0.2,0.25,1,0,0.8,0.125,0.75,0.8749999999999999,0.75,1,0.2,1,0.8,0.25,1,0.125,0.75,0.3125,0.9,0.6875,0.9,0.8749999999999999,0.75,1,0.8,0.7499999999999999,1,0.25,1,0.3125,0.9,0.6875,0.9,1,0.8,0.7499999999999999,1,0.7499999999999999,1,0.3125,0.9,0.6875,0.9],
                            ratio:{x:0.8},
                        },
                        '1':{
                            //vector: [ 0.0/0.5,0.0, 0.3/0.5,0.0, 0.3/0.5,0.9, 0.5/0.5,0.9, 0.5/0.5,1.0, 0.0/0.5,1.0, 0.0/0.5,0.9, 0.2/0.5,0.9, 0.2/0.5,0.1, 0.0/0.5,0.1 ]
                            vector:[0.4,0.1,0,0.1,0,0,0.6,0.9,1,0.9,1,1,1,1,0,1,0,0.9,0.4,0.1,0,0,0.6,0,1,1,0,0.9,0.4,0.9,0.4,0.9,0.4,0.1,0.6,0,0.6,0.9,1,1,0.4,0.9,0.4,0.9,0.6,0,0.6,0.9],
                            ratio:{x:0.5},
                        },
                        '2':{
                            //vector: [ 0.2/0.8,0.0, 0.6/0.8,0.0, 0.8/0.8,0.2, 0.8/0.8,0.5, 0.2/0.8,0.9, 0.8/0.8,0.9, 0.8/0.8,1.0, 0.0/0.8,1.0, 0.0/0.8,0.9, 0.7/0.8,0.45, 0.7/0.8,0.25, 0.55/0.8,0.1, 0.25/0.8,0.1, 0.08/0.8,0.26, 0.0/0.8,0.2 ]
                            vector:[0.09999999999999999,0.26,0,0.2,0.25,0,0.7499999999999999,0,1,0.2,1,0.5,0.25,0.9,1,0.9,1,1,1,1,0,1,0,0.9,0.3125,0.1,0.09999999999999999,0.26,0.25,0,0.25,0.9,1,1,0,0.9,0.6875,0.1,0.3125,0.1,0.25,0,1,0.5,0.25,0.9,0,0.9,0.6875,0.1,0.25,0,0.7499999999999999,0,1,0.5,0,0.9,0.8749999999999999,0.45,0.8749999999999999,0.25,0.6875,0.1,0.7499999999999999,0,1,0.5,0.8749999999999999,0.45,0.8749999999999999,0.25,0.8749999999999999,0.25,0.7499999999999999,0,1,0.5],
                            ratio:{x:0.8},
                        },
                        '3':{
                            //vector: [ 0.0/0.8,0.2, 0.2/0.8,0.0, 0.6/0.8,0.0, 0.8/0.8,0.2, 0.8/0.8,0.4, 0.7/0.8,0.5, 0.8/0.8,0.6, 0.8/0.8,0.8, 0.6/0.8,1.0, 0.2/0.8,1.0, 0.0/0.8,0.8, 0.08/0.8,0.74, 0.25/0.8,0.9, 0.55/0.8,0.9, 0.7/0.8,0.75, 0.7/0.8,0.65, 0.6/0.8,0.55, 0.3/0.8,0.55, 0.3/0.8,0.45, 0.6/0.8,0.45, 0.7/0.8,0.35, 0.7/0.8,0.25, 0.55/0.8,0.1, 0.25/0.8,0.1, 0.08/0.8,0.26 ]
                            vector:[0.3125,0.1,0.09999999999999999,0.26,0,0.2,0.7499999999999999,0,1,0.2,1,0.4,0.8749999999999999,0.5,1,0.6,1,0.8,0.25,1,0,0.8,0.09999999999999999,0.74,0.7499999999999999,0.55,0.37499999999999994,0.55,0.37499999999999994,0.45,0.3125,0.1,0,0.2,0.25,0,0.25,1,0.09999999999999999,0.74,0.3125,0.9,0.7499999999999999,0.55,0.37499999999999994,0.45,0.7499999999999999,0.45,0.6875,0.1,0.3125,0.1,0.25,0,0.7499999999999999,1,0.25,1,0.3125,0.9,0.8749999999999999,0.65,0.7499999999999999,0.55,0.7499999999999999,0.45,0.6875,0.1,0.25,0,0.7499999999999999,0,0.7499999999999999,1,0.3125,0.9,0.6875,0.9,0.8749999999999999,0.25,0.6875,0.1,0.7499999999999999,0,1,0.8,0.7499999999999999,1,0.6875,0.9,0.8749999999999999,0.25,0.7499999999999999,0,1,0.4,1,0.8,0.6875,0.9,0.8749999999999999,0.75,0.8749999999999999,0.35,0.8749999999999999,0.25,1,0.4,1,0.8,0.8749999999999999,0.75,0.8749999999999999,0.65,0.7499999999999999,0.45,0.8749999999999999,0.35,1,0.4,0.8749999999999999,0.5,1,0.8,0.8749999999999999,0.65,0.7499999999999999,0.45,1,0.4,0.8749999999999999,0.5,0.8749999999999999,0.5,0.8749999999999999,0.65,0.7499999999999999,0.45],
                            ratio:{x:0.8},
                        },
                        '4':{
                            //vector: [ 0.0/0.8,0.0, 0.1/0.8,0.0, 0.1/0.8,0.25, 0.25/0.8,0.4, 0.7/0.8,0.4, 0.7/0.8,0.0, 0.8/0.8,0.0, 0.8/0.8,1.0, 0.7/0.8,1.0, 0.7/0.8,0.5, 0.2/0.8,0.5, 0.0/0.8,0.3 ]
                            vector:[0,0.3,0,0,0.125,0,0.8749999999999999,0.4,0.8749999999999999,0,1,0,1,0,1,1,0.8749999999999999,1,0,0.3,0.125,0,0.125,0.25,1,0,0.8749999999999999,1,0.8749999999999999,0.5,0.25,0.5,0,0.3,0.125,0.25,0.8749999999999999,0.4,1,0,0.8749999999999999,0.5,0.25,0.5,0.125,0.25,0.3125,0.4,0.3125,0.4,0.8749999999999999,0.4,0.8749999999999999,0.5,0.8749999999999999,0.5,0.25,0.5,0.3125,0.4],
                            ratio:{x:0.8},
                        },
                        '5':{
                            //vector: [ 0.0/0.8,0.0, 0.8/0.8,0.0, 0.8/0.8,0.1, 0.1/0.8,0.1, 0.1/0.8,0.4, 0.7/0.8,0.4, 0.8/0.8,0.5, 0.8/0.8,0.8, 0.6/0.8,1.0, 0.0/0.8,1.0, 0.0/0.8,0.9, 0.55/0.8,0.9, 0.7/0.8,0.75, 0.7/0.8,0.55, 0.65/0.8,0.5, 0.0/0.8,0.5 ]
                            vector:[0,0,1,0,1,0.1,0.125,0.4,0.8749999999999999,0.4,1,0.5,1,0.5,1,0.8,0.7499999999999999,1,0.7499999999999999,1,0,1,0,0.9,0,0,1,0.1,0.125,0.1,0.7499999999999999,1,0,0.9,0.6875,0.9,0,0.5,0,0,0.125,0.1,0.7499999999999999,1,0.6875,0.9,0.8749999999999999,0.75,0,0.5,0.125,0.1,0.125,0.4,1,0.5,0.7499999999999999,1,0.8749999999999999,0.75,0.8125,0.5,0,0.5,0.125,0.4,1,0.5,0.8749999999999999,0.75,0.8749999999999999,0.55,0.8125,0.5,0.125,0.4,1,0.5,1,0.5,0.8749999999999999,0.55,0.8125,0.5],
                            ratio:{x:0.8},
                        },
                        '6':{
                            //vector: [ 0.2/0.8,0.0, 0.8/0.8,0.0, 0.8/0.8,0.1, 0.25/0.8,0.1, 0.1/0.8,0.25, 0.1/0.8,0.75, 0.25/0.8,0.9, 0.55/0.8,0.9, 0.7/0.8,0.75, 0.7/0.8,0.55, 0.65/0.8,0.5, 0.1/0.8,0.5, 0.1/0.8,0.4, 0.7/0.8,0.4, 0.8/0.8,0.5, 0.8/0.8,0.8, 0.6/0.8,1.0, 0.2/0.8,1.0, 0.0/0.8,0.8, 0.0/0.8,0.2 ]
                            vector:[0.25,0,1,0,1,0.1,0.8125,0.5,0.125,0.5,0.125,0.4,0.125,0.4,0.8749999999999999,0.4,1,0.5,1,0.5,1,0.8,0.7499999999999999,1,0.25,0,1,0.1,0.3125,0.1,0.8125,0.5,0.125,0.4,1,0.5,0,0.2,0.25,0,0.3125,0.1,0.8749999999999999,0.55,0.8125,0.5,1,0.5,0,0.2,0.3125,0.1,0.125,0.25,0.8749999999999999,0.75,0.8749999999999999,0.55,1,0.5,0,0.8,0,0.2,0.125,0.25,0.8749999999999999,0.75,1,0.5,0.7499999999999999,1,0,0.8,0.125,0.25,0.125,0.75,0.6875,0.9,0.8749999999999999,0.75,0.7499999999999999,1,0.25,1,0,0.8,0.125,0.75,0.3125,0.9,0.6875,0.9,0.7499999999999999,1,0.25,1,0.125,0.75,0.3125,0.9,0.3125,0.9,0.7499999999999999,1,0.25,1],
                            ratio:{x:0.8},
                        },
                        '7':{
                            //vector: [ 0.0/0.8,0.0, 0.8/0.8,0.0, 0.8/0.8,0.1, 0.12/0.8,1.0, 0.0/0.8,1.0, 0.66/0.8,0.1, 0.0/0.8,0.1 ]
                            vector:[0.825,0.1,0,0.1,0,0,0,0,1,0,1,0.1,1,0.1,0.15,1,0,1,0.825,0.1,0,0,1,0.1,1,0.1,0,1,0.825,0.1],
                            ratio:{x:0.8},
                        },
                        '8':{
                            //vector: [ 0.1/0.8,0.0, 0.7/0.8,0.0, 0.8/0.8,0.1, 0.8/0.8,0.35, 0.7/0.8,0.45, 0.8/0.8,0.55, 0.8/0.8,0.8, 0.6/0.8,1.0, 0.2/0.8,1.0, 0.0/0.8,0.8, 0.0/0.8,0.55, 0.1/0.8,0.45, 0.2/0.8,0.5, 0.1/0.8,0.6, 0.1/0.8,0.75, 0.25/0.8,0.9, 0.55/0.8,0.9, 0.7/0.8,0.75, 0.7/0.8,0.6, 0.6/0.8,0.5, 0.2/0.8,0.5, 0.1/0.8,0.45, 0.0/0.8,0.35, 0.0/0.8,0.1, 0.1/0.8,0.0, 0.15/0.8,0.1, 0.1/0.8,0.15, 0.1/0.8,0.3, 0.2/0.8,0.4, 0.6/0.8,0.4, 0.7/0.8,0.3, 0.7/0.8,0.15, 0.65/0.8,0.1, 0.15/0.8,0.1 ]
                            vector:[0.8125,0.1,0.18749999999999997,0.1,0.125,0,0.125,0,0.8749999999999999,0,1,0.1,1,0.1,1,0.35,0.8749999999999999,0.45,0.8749999999999999,0.45,1,0.55,1,0.8,0.25,1,0,0.8,0,0.55,0,0.55,0.125,0.45,0.25,0.5,0.7499999999999999,0.5,0.25,0.5,0.125,0.45,0.125,0.45,0,0.35,0,0.1,0,0.1,0.125,0,0.18749999999999997,0.1,0.8125,0.1,0.125,0,1,0.1,0,0.55,0.25,0.5,0.125,0.6,0,0.1,0.18749999999999997,0.1,0.125,0.15,0.8749999999999999,0.15,0.8125,0.1,1,0.1,0,0.55,0.125,0.6,0.125,0.75,0,0.1,0.125,0.15,0.125,0.3,0.8749999999999999,0.3,0.8749999999999999,0.15,1,0.1,0.25,1,0,0.55,0.125,0.75,0.125,0.45,0,0.1,0.125,0.3,0.8749999999999999,0.3,1,0.1,0.8749999999999999,0.45,0.25,1,0.125,0.75,0.3125,0.9,0.125,0.45,0.125,0.3,0.25,0.4,0.7499999999999999,0.4,0.8749999999999999,0.3,0.8749999999999999,0.45,0.7499999999999999,1,0.25,1,0.3125,0.9,0.7499999999999999,0.5,0.125,0.45,0.25,0.4,0.25,0.4,0.7499999999999999,0.4,0.8749999999999999,0.45,0.7499999999999999,1,0.3125,0.9,0.6875,0.9,0.7499999999999999,0.5,0.25,0.4,0.8749999999999999,0.45,1,0.8,0.7499999999999999,1,0.6875,0.9,0.8749999999999999,0.6,0.7499999999999999,0.5,0.8749999999999999,0.45,1,0.8,0.6875,0.9,0.8749999999999999,0.75,0.8749999999999999,0.6,0.8749999999999999,0.45,1,0.8,1,0.8,0.8749999999999999,0.75,0.8749999999999999,0.6],
                            ratio:{x:0.8},
                        },
                        '9':{
                            //vector: [ 0.2/0.8,0.0, 0.6/0.8,0.0, 0.8/0.8,0.2, 0.8/0.8,0.7, 0.5/0.8,1.0, 0.0/0.8,1.0, 0.0/0.8,0.9, 0.45/0.8,0.9, 0.7/0.8,0.65, 0.7/0.8,0.25, 0.55/0.8,0.1, 0.25/0.8,0.1, 0.1/0.8,0.25, 0.1/0.8,0.35, 0.12/0.8,0.4, 0.7/0.8,0.4, 0.7/0.8,0.5, 0.1/0.8,0.5, 0.0/0.8,0.4, 0.0/0.8,0.2 ]
                            vector:[0,0.4,0,0.2,0.25,0,0.625,1,0,1,0,0.9,0.15,0.4,0.8749999999999999,0.4,0.8749999999999999,0.5,0.8749999999999999,0.5,0.125,0.5,0,0.4,0.625,1,0,0.9,0.5625,0.9,0.15,0.4,0.8749999999999999,0.5,0,0.4,1,0.7,0.625,1,0.5625,0.9,0.125,0.35,0.15,0.4,0,0.4,1,0.7,0.5625,0.9,0.8749999999999999,0.65,0.125,0.25,0.125,0.35,0,0.4,1,0.2,1,0.7,0.8749999999999999,0.65,0.125,0.25,0,0.4,0.25,0,1,0.2,0.8749999999999999,0.65,0.8749999999999999,0.25,0.3125,0.1,0.125,0.25,0.25,0,0.7499999999999999,0,1,0.2,0.8749999999999999,0.25,0.6875,0.1,0.3125,0.1,0.25,0,0.7499999999999999,0,0.8749999999999999,0.25,0.6875,0.1,0.6875,0.1,0.25,0,0.7499999999999999,0],
                            ratio:{x:0.8},
                        },
                    
                        '.':{
                            //vector: [ 0,0, 1,0, 1,1, 0,1 ]
                            vector:[1,1,0,1,0,0,0,0,1,0,1,1],
                            ratio:{x:0.1, y:0.1}, offset:{y:0.9},
                        },
                        ',':{
                            //vector: [ 0,0, 1,0, 1,1, 0,1 ]
                            vector:[1,1,0,1,0,0,0,0,1,0,1,1],
                            ratio:{x:0.1, y:0.2}, offset:{y:0.9},
                        },
                        ':':{
                            //vector: [ 0.0/0.2,0.0/0.8, 0.2/0.2,0.0/0.8, 0.2/0.2,0.2/0.8, 0.0/0.2,0.2/0.8, 0.0/0.2,0.4/0.8, 0.2/0.2,0.4/0.8, 0.2/0.2,0.6/0.8, 0.0/0.2,0.6/0.8 ]
                            vector:[0,0,1,0,1,0.25,0,0.5,1,0.5,1,0.7499999999999999,0,0,1,0.25,0,0.25,0,0.5,1,0.7499999999999999,0,0.7499999999999999],
                            ratio:{x:0.1, y:0.8}, offset:{y:0.2},
                        },
                        ';':{
                            //vector: [ 0.0,0.0, 1.0,0.0, 1.0,0.2, 0.0,0.2, 0.0,0.7, 1.0,0.7, 1.0,0.9, 0.0,0.9 ]
                            vector:[0,0,1,0,1,0.2,0,0.7,1,0.7,1,0.9,0,0,1,0.2,0,0.2,0,0.7,1,0.9,0,0.9],
                            ratio:{x:0.1}, offset:{y:0.2},
                        },
                        '?':{
                            //vector: [ 0.2/0.7,0.0, 0.5/0.7,0.0, 0.7/0.7,0.2, 0.7/0.7,0.4, 0.5/0.7,0.6, 0.4/0.7,0.6, 0.4/0.7,0.7, 0.3/0.7,0.7, 0.3/0.7,0.8, 0.4/0.7,0.8, 0.4/0.7,1.0, 0.3/0.7,1.0, 0.3/0.7,0.5, 0.45/0.7,0.5, 0.6/0.7,0.35, 0.6/0.7,0.25, 0.45/0.7,0.1, 0.25/0.7,0.1, 0.08/0.7,0.25, 0.0/0.7,0.2 ]
                            vector:[0.1142857142857143,0.25,0,0.2,0.28571428571428575,0,0.7142857142857143,0,1,0.2,1,0.4,1,0.4,0.7142857142857143,0.6,0.5714285714285715,0.6,0.5714285714285715,0.6,0.5714285714285715,0.7,0.4285714285714286,0.7,0.4285714285714286,0.8,0.5714285714285715,0.8,0.5714285714285715,1,0.35714285714285715,0.1,0.1142857142857143,0.25,0.28571428571428575,0,0.4285714285714286,0.8,0.5714285714285715,1,0.4285714285714286,1,0.6428571428571429,0.1,0.35714285714285715,0.1,0.28571428571428575,0,0.6428571428571429,0.1,0.28571428571428575,0,0.7142857142857143,0,0.8571428571428572,0.25,0.6428571428571429,0.1,0.7142857142857143,0,0.8571428571428572,0.25,0.7142857142857143,0,1,0.4,0.8571428571428572,0.35,0.8571428571428572,0.25,1,0.4,0.6428571428571429,0.5,0.8571428571428572,0.35,1,0.4,0.6428571428571429,0.5,1,0.4,0.5714285714285715,0.6,0.4285714285714286,0.5,0.6428571428571429,0.5,0.5714285714285715,0.6,0.4285714285714286,0.5,0.5714285714285715,0.6,0.4285714285714286,0.7],
                            ratio:{x:0.7},
                        },
                        '!':{
                            //vector: [ 0.0,0.0, 1.0,0.0,1.0,0.7, 0.0,0.7, 0.0,0.8, 1.0,0.8, 1.0,1.0, 0.0,1.0 ]
                            vector:[0,0,1,0,1,0.7,0,0.8,1,0.8,1,1,0,0,1,0.7,0,0.7,0,0.8,1,1,0,1],
                            ratio:{x:0.1},
                        },
                        '/':{
                            //vector: [ 0.48/0.6,0.0, 0.6/0.6,0.0, 0.12/0.6,1.0, 0.0/0.6,1.0 ]
                            vector:[0.2,1,0,1,0.8,0,0.8,0,1,0,0.2,1],
                            ratio:{x:0.6},
                        },
                        '\\':{
                            //vector: [ 0.0/0.6,0.0, 0.12/0.6,0.0, 0.6/0.6,1.0, 0.48/0.6,1.0 ]
                            vector:[1,1,0.8,1,0,0,0,0,0.2,0,1,1],
                            ratio:{x:0.6},
                        },
                        '(':{
                            //vector: [ 0.2/0.3,0.0, 0.3/0.3,0.0, 0.3/0.3,0.1, 0.25/0.3,0.1, 0.1/0.3,0.25, 0.1/0.3,0.75, 0.25/0.3,0.9, 0.3/0.3,0.9, 0.3/0.3,1.0, 0.2/0.3,1.0, 0.0/0.3,0.8, 0.0/0.3,0.2 ]
                            vector:[0,0.2,0.6666666666666667,0,1,0,1,0,1,0.1,0.8333333333333334,0.1,0.8333333333333334,0.9,1,0.9,1,1,1,1,0.6666666666666667,1,0,0.8,0,0.2,1,0,0.8333333333333334,0.1,0.33333333333333337,0.75,0.8333333333333334,0.9,1,1,0,0.2,0.8333333333333334,0.1,0.33333333333333337,0.25,0.33333333333333337,0.75,1,1,0,0.8,0,0.8,0,0.2,0.33333333333333337,0.25,0.33333333333333337,0.25,0.33333333333333337,0.75,0,0.8],
                            ratio:{x:0.3},
                        },
                        ')':{
                            //vector: [ 0.1/0.3,0.0, 0.0/0.3,0.0, 0.0/0.3,0.1, 0.05/0.3,0.1, 0.2/0.3,0.25, 0.2/0.3,0.75, 0.05/0.3,0.9, 0.0/0.3,0.9, 0.0/0.3,1.0, 0.1/0.3,1.0, 0.3/0.3,0.8, 0.3/0.3,0.2 ]
                            vector:[0,0,0.33333333333333337,0,1,0.2,1,0.8,0.33333333333333337,1,0,1,0,1,0,0.9,0.16666666666666669,0.9,0.16666666666666669,0.1,0,0.1,0,0,1,0.8,0,1,0.16666666666666669,0.9,0.6666666666666667,0.25,0.16666666666666669,0.1,0,0,1,0.8,0.16666666666666669,0.9,0.6666666666666667,0.75,0.6666666666666667,0.25,0,0,1,0.2,1,0.2,1,0.8,0.6666666666666667,0.75,0.6666666666666667,0.75,0.6666666666666667,0.25,1,0.2],
                            ratio:{x:0.3},
                            encroach:{'p':1},
                        },
                        '[':{
                            //vector: [ 0.0/0.3,0.0, 0.3/0.3,0.0, 0.3/0.3,0.1, 0.1/0.3,0.1, 0.1/0.3,0.9, 0.3/0.3,0.9, 0.3/0.3,1.0, 0.0/0.3,1.0 ]
                            vector:[0,0,1,0,1,0.1,0.33333333333333337,0.9,1,0.9,1,1,0,0,1,0.1,0.33333333333333337,0.1,0.33333333333333337,0.9,1,1,0,1,0,1,0,0,0.33333333333333337,0.1,0.33333333333333337,0.1,0.33333333333333337,0.9,0,1],
                            ratio:{x:0.3},
                        },
                        ']':{
                            //vector: [ 0.3/0.3,0.0, 0.0/0.3,0.0, 0.0/0.3,0.1, 0.2/0.3,0.1, 0.2/0.3,0.9, 0.0/0.3,0.9, 0.0/0.3,1.0, 0.3/0.3,1.0 ]
                            vector:[1,1,0,1,0,0.9,0.6666666666666667,0.1,0,0.1,0,0,1,1,0,0.9,0.6666666666666667,0.9,0.6666666666666667,0.1,0,0,1,0,1,0,1,1,0.6666666666666667,0.9,0.6666666666666667,0.9,0.6666666666666667,0.1,1,0],
                            ratio:{x:0.3},
                        },
                    
                        '{':{
                            //vector: [ 0.3/0.4,0.0, 0.4/0.4,0.0, 0.4/0.4,0.1, 0.35/0.4,0.1, 0.2/0.4,0.25, 0.2/0.4,0.45, 0.15/0.4,0.5, 0.2/0.4,0.55, 0.2/0.4,0.75, 0.35/0.4,0.9, 0.4/0.4,0.9, 0.4/0.4,1.0, 0.3/0.4,1.0, 0.1/0.4,0.8, 0.1/0.4,0.6, 0.0/0.4,0.55, 0.0/0.4,0.45, 0.1/0.4,0.4, 0.1/0.4,0.2 ]
                            vector:[0.25,0.4,0.25,0.2,0.7499999999999999,0,0.7499999999999999,0,1,0,1,0.1,0.5,0.25,0.5,0.45,0.37499999999999994,0.5,0.37499999999999994,0.5,0.5,0.55,0.5,0.75,0.8749999999999999,0.9,1,0.9,1,1,1,1,0.7499999999999999,1,0.25,0.8,0.25,0.6,0,0.55,0,0.45,0.7499999999999999,0,1,0.1,0.8749999999999999,0.1,0.5,0.75,0.8749999999999999,0.9,1,1,0.25,0.6,0,0.45,0.25,0.4,0.7499999999999999,0,0.8749999999999999,0.1,0.5,0.25,0.5,0.75,1,1,0.25,0.8,0.25,0.4,0.7499999999999999,0,0.5,0.25,0.37499999999999994,0.5,0.5,0.75,0.25,0.8,0.25,0.6,0.25,0.4,0.5,0.25,0.37499999999999994,0.5,0.25,0.8,0.25,0.6,0.25,0.6,0.5,0.25,0.37499999999999994,0.5],
                            ratio:{x:0.4},
                        },
                        '}':{
                            //vector: [ 0.1/0.4,0.0, 0.0/0.4,0.0, 0.0/0.4,0.1, 0.05/0.4,0.1, 0.2/0.4,0.25, 0.2/0.4,0.45, 0.25/0.4,0.5, 0.2/0.4,0.55, 0.2/0.4,0.75, 0.05/0.4,0.9, 0.0/0.4,0.9, 0.0/0.4,1.0, 0.1/0.4,1.0, 0.3/0.4,0.8, 0.3/0.4,0.6, 0.4/0.4,0.55, 0.4/0.4,0.45, 0.3/0.4,0.4, 0.3/0.4,0.2 ]
                            vector:[0,0,0.25,0,0.7499999999999999,0.2,0.7499999999999999,0.4,1,0.45,1,0.55,0.7499999999999999,0.6,0.7499999999999999,0.8,0.25,1,0.25,1,0,1,0,0.9,0.5,0.75,0.5,0.55,0.625,0.5,0.625,0.5,0.5,0.45,0.5,0.25,0.125,0.1,0,0.1,0,0,0.7499999999999999,0.4,1,0.55,0.7499999999999999,0.6,0.25,1,0,0.9,0.125,0.9,0.5,0.25,0.125,0.1,0,0,0.25,1,0.125,0.9,0.5,0.75,0.5,0.25,0,0,0.7499999999999999,0.2,0.7499999999999999,0.6,0.25,1,0.5,0.75,0.625,0.5,0.5,0.25,0.7499999999999999,0.2,0.7499999999999999,0.4,0.7499999999999999,0.6,0.5,0.75,0.625,0.5,0.7499999999999999,0.2,0.7499999999999999,0.4,0.7499999999999999,0.4,0.5,0.75,0.625,0.5],
                            ratio:{x:0.4},
                        },
                        '#':{
                            //vector: [ 0.3,0.0, 0.4,0.0, 0.375,0.25, 0.675,0.25, 0.7,0.0, 0.8,0.0, 0.775,0.25, 1.0,0.25, 1.0,0.35, 0.765,0.35, 0.735,0.65, 1.0,0.65,1.0,0.75, 0.725,0.75,0.7,1.0,0.6,1.0, 0.625,0.75, 0.325,0.75, 0.3,1.0, 0.2,1.0, 0.225,0.75,0.0,0.75,0.0,0.65,0.235,0.65,0.265,0.35,0.0,0.35,0.0,0.25,0.275,0.25,0.3,0.0, 0.365,0.35,0.335,0.65,0.635,0.65,0.665,0.35,0.365,0.35 ])
                            vector:[0.365,0.35,0.3,0,0.4,0,0.675,0.25,0.7,0,0.8,0,0.775,0.25,1,0.25,1,0.35,0.735,0.65,1,0.65,1,0.75,0.725,0.75,0.7,1,0.6,1,0.325,0.75,0.3,1,0.2,1,0.225,0.75,0,0.75,0,0.65,0.265,0.35,0,0.35,0,0.25,0.275,0.25,0.3,0,0.365,0.35,0.675,0.25,0.8,0,0.775,0.25,0.775,0.25,1,0.35,0.765,0.35,0.735,0.65,1,0.75,0.725,0.75,0.725,0.75,0.6,1,0.625,0.75,0.325,0.75,0.2,1,0.225,0.75,0.225,0.75,0,0.65,0.235,0.65,0.265,0.35,0,0.25,0.275,0.25,0.275,0.25,0.365,0.35,0.335,0.65,0.675,0.25,0.775,0.25,0.765,0.35,0.765,0.35,0.735,0.65,0.725,0.75,0.325,0.75,0.225,0.75,0.235,0.65,0.235,0.65,0.265,0.35,0.275,0.25,0.375,0.25,0.675,0.25,0.765,0.35,0.765,0.35,0.725,0.75,0.625,0.75,0.625,0.75,0.325,0.75,0.235,0.65,0.235,0.65,0.275,0.25,0.335,0.65,0.625,0.75,0.235,0.65,0.335,0.65,0.625,0.75,0.335,0.65,0.635,0.65,0.765,0.35,0.625,0.75,0.635,0.65,0.765,0.35,0.635,0.65,0.665,0.35,0.375,0.25,0.765,0.35,0.665,0.35,0.375,0.25,0.665,0.35,0.365,0.35,0.4,0,0.375,0.25,0.365,0.35],
                        },
                        '-':{
                            //vector: [ 0,0, 1,0, 1,1, 0,1 ]
                            vector:[1,1,0,1,0,0,0,0,1,0,1,1],
                            ratio:{x:0.6, y:0.1}, offset:{y:0.45},
                        },
                        '_':{
                            //vector: [ 0,0, 1,0, 1,1, 0,1 ]
                            vector:[1,1,0,1,0,0,0,0,1,0,1,1],
                            ratio:{x:0.8,y:0.1}, offset:{y:1},
                        },
                        "'":{
                            //vector: [ 0,0, 1,0, 1,1, 0,1 ]
                            vector:[1,1,0,1,0,0,0,0,1,0,1,1],
                            ratio:{x:0.1, y:0.2},
                        },
                        '"':{
                            //vector: [ 0.4,0, 0,0, 0,1, 0.4,1, 0.4,0, 0.6,0, 0.6,1, 1,1, 1,0 ]
                            vector:[1,0,1,1,0.6,1,0.4,1,0,1,0,0,1,0,0.6,1,0.6,0,0.4,1,0,0,0.4,0],
                            ratio:{x:0.25, y:0.2},
                        },
                        '|':{
                            //vector: [ 0,0, 1,0, 1,1, 0,1  ]
                            vector:[1,1,0,1,0,0,0,0,1,0,1,1],
                            ratio:{x:0.1},
                        },
                        '>':{
                            //vector: [ 0.0,0.0, 1.0,0.45, 1.0,0.55, 0.0,1.0, 0.0,0.9, 0.85,0.5, 0.0,0.1 ])
                            vector:[0.85,0.5,0,0.1,0,0,0,0,1,0.45,1,0.55,1,0.55,0,1,0,0.9,0.85,0.5,0,0,1,0.55,1,0.55,0,0.9,0.85,0.5],
                        },
                        '<':{
                            //vector: [ 1.0,0.0, 0.0,0.45, 0.0,0.55, 1.0,1.0, 1.0,0.9, 0.15,0.5, 1.0,0.1 ])
                            vector:[0,0.45,1,0,1,0.1,0.15,0.5,1,0.9,1,1,1,1,0,0.55,0,0.45,0,0.45,1,0.1,0.15,0.5,0.15,0.5,1,1,0,0.45],
                        },
                        '+':{
                            //vector: [ 0.35/0.8,0.0/0.8, 0.45/0.8,0.0/0.8, 0.45/0.8,0.35/0.8, 0.8/0.8,0.35/0.8, 0.8/0.8,0.45/0.8, 0.45/0.8,0.45/0.8, 0.45/0.8,0.8/0.8, 0.35/0.8,0.8/0.8, 0.35/0.8,0.45/0.8, 0.0/0.8,0.45/0.8, 0.0/0.8,0.35/0.8, 0.35/0.8,0.35/0.8 ]
                            vector:[0.43749999999999994,0.43749999999999994,0.43749999999999994,0,0.5625,0,0.5625,0.43749999999999994,1,0.43749999999999994,1,0.5625,0.5625,0.5625,0.5625,1,0.43749999999999994,1,0.43749999999999994,0.5625,0,0.5625,0,0.43749999999999994,0.43749999999999994,0.43749999999999994,0.5625,0,0.5625,0.43749999999999994,0.5625,0.43749999999999994,1,0.5625,0.5625,0.5625,0.5625,0.5625,0.43749999999999994,1,0.43749999999999994,0.5625,0.43749999999999994,0.5625,0,0.43749999999999994,0.43749999999999994,0.43749999999999994,0.43749999999999994,0.43749999999999994,0.5625,0.43749999999999994,0.5625,0.5625,0.5625,0.5625,0.43749999999999994,0.5625,0.43749999999999994,0.43749999999999994],
                            ratio:{x:0.8,y:0.8}, offset:{y:0.1},
                        },
                        '=':{
                            //vector: [ 0.0/0.8,0.0/0.5, 0.8/0.8,0.0/0.5, 0.8/0.8,0.1/0.5, 0.0/0.8,0.1/0.5, 0.0/0.8,0.4/0.5, 0.8/0.8,0.4/0.5, 0.8/0.8,0.5/0.5, 0.0/0.8,0.5/0.5 ]
                            vector:[0,0,1,0,1,0.2,0,0.8,1,0.8,1,1,0,0,1,0.2,0,0.2,0,0.8,1,1,0,1],
                            ratio:{x:0.8,y:0.5}, offset:{y:0.25},
                        },
                        '&':{
                            //vector: [ 0.2/0.9,0.0, 0.5/0.9,0.0, 0.7/0.9,0.2, 0.7/0.9,0.4, 0.425/0.9,0.675, 0.35/0.9,0.6, 0.6/0.9,0.35, 0.6/0.9,0.25, 0.45/0.9,0.1, 0.25/0.9,0.1, 0.1/0.9,0.25, 0.1/0.9,0.35, 0.525/0.9,0.775, 0.82/0.9,0.48, 0.9/0.9,0.55, 0.6/0.9,0.85, 0.65/0.9,0.9, 0.9/0.9,0.9, 0.9/0.9,1.0, 0.6/0.9,1.0, 0.525/0.9,0.925, 0.45/0.9,1.0, 0.1/0.9,1.0, 0.0/0.9,0.9, 0.0/0.9,0.6, 0.1/0.9,0.5, 0.175/0.9,0.575, 0.1/0.9,0.65, 0.1/0.9,0.85, 0.15/0.9,0.9, 0.4/0.9,0.9, 0.45/0.9,0.85, 0.0/0.9,0.4, 0.0/0.9,0.2 ]
                            vector:[0,0.4,0,0.2,0.222,0,0.556,0,0.778,0.2,0.778,0.4,0.778,0.4,0.472,0.675,0.389,0.6,0.583,0.775,0.911,0.48,1,0.55,0.722,0.9,1,0.9,1,1,1,1,0.667,1,0.583,0.925,0.583,0.925,0.5,1,0.111,1,0.111,1,0,0.9,0,0.6,0,0.6,0.111,0.5,0.194,0.575,0.778,0.4,0.389,0.6,0.667,0.35,0.583,0.775,1,0.55,0.667,0.85,0.722,0.9,1,1,0.583,0.925,0,0.6,0.194,0.575,0.111,0.65,0.778,0.4,0.667,0.35,0.667,0.25,0.111,0.35,0.583,0.775,0.667,0.85,0.667,0.85,0.722,0.9,0.583,0.925,0,0.6,0.111,0.65,0.111,0.85,0.556,0,0.778,0.4,0.667,0.25,0.111,0.35,0.667,0.85,0.583,0.925,0.111,1,0,0.6,0.111,0.85,0.556,0,0.667,0.25,0.5,0.1,0.111,1,0.111,0.85,0.167,0.9,0.222,0,0.556,0,0.5,0.1,0.583,0.925,0.111,1,0.167,0.9,0.222,0,0.5,0.1,0.278,0.1,0.583,0.925,0.167,0.9,0.444,0.9,0.222,0,0.278,0.1,0.111,0.25,0.583,0.925,0.444,0.9,0.5,0.85,0,0.4,0.222,0,0.111,0.25,0.111,0.35,0.583,0.925,0.5,0.85,0,0.4,0.111,0.25,0.111,0.35,0.111,0.35,0.5,0.85,0,0.4],
                            ratio:{x:0.9}
                        },
                        '*':{
                            //vector: [ 0.25/0.6,0.0/0.6, 0.35/0.6,0.0/0.6, 0.35/0.6,0.175/0.6,0.475/0.6,0.05/0.6, 0.55/0.6,0.125/0.6,0.425/0.6,0.25/0.6,0.6/0.6,0.25/0.6, 0.6/0.6,0.35/0.6, 0.425/0.6,0.35/0.6,0.55/0.6,0.475/0.6, 0.475/0.6,0.55/0.6, 0.35/0.6,0.425/0.6,0.35/0.6,0.6/0.6, 0.25/0.6,0.6/0.6, 0.25/0.6,0.425/0.6,0.125/0.6,0.55/0.6, 0.05/0.6,0.475/0.6, 0.175/0.6,0.35/0.6,0.0/0.6,0.35/0.6, 0.0/0.6,0.25/0.6, 0.175/0.6,0.25/0.6,0.05/0.6,0.125/0.6, 0.125/0.6,0.05/0.6,0.25/0.6,0.175/0.6 ],'flatArray'),
                            vector:[0.417,0.292,0.417,0,0.583,0,0.583,0.292,0.792,0.083,0.917,0.208,0.708,0.417,1,0.417,1,0.583,0.708,0.583,0.917,0.792,0.792,0.917,0.583,0.708,0.583,1,0.417,1,0.417,0.708,0.208,0.917,0.083,0.792,0.292,0.583,0,0.583,0,0.417,0.292,0.417,0.083,0.208,0.208,0.083,0.417,0.292,0.583,0,0.583,0.292,0.583,0.292,0.917,0.208,0.708,0.417,0.708,0.417,1,0.583,0.708,0.583,0.708,0.583,0.792,0.917,0.583,0.708,0.583,0.708,0.417,1,0.417,0.708,0.417,0.708,0.083,0.792,0.292,0.583,0.292,0.583,0,0.417,0.292,0.417,0.292,0.417,0.208,0.083,0.417,0.292,0.417,0.292,0.583,0.292,0.708,0.417,0.708,0.417,0.708,0.583,0.583,0.708,0.583,0.708,0.417,0.708,0.292,0.583,0.292,0.583,0.292,0.417,0.417,0.292,0.417,0.292,0.708,0.417,0.583,0.708,0.583,0.708,0.292,0.583,0.417,0.292],
                            ratio:{x:0.6,y:0.6}, offset:{y:0.2},
                        },
                        '~':{
                            //vector: [ 0.0,0.1/0.3, 0.15,0.0/0.3, 0.35,0.0/0.3, 0.675,0.2/0.3, 0.825,0.2/0.3, 1.0,0.1/0.3, 1.0,0.2/0.3, 0.85,0.3/0.3, 0.65,0.3/0.3, 0.325,0.1/0.3, 0.175,0.1/0.3, 0.0,0.2/0.3 ]
                            vector:[0.175,0.33333333333333337,0,0.6666666666666667,0,0.33333333333333337,0,0.33333333333333337,0.15,0,0.35,0,0.825,0.6666666666666667,1,0.33333333333333337,1,0.6666666666666667,1,0.6666666666666667,0.85,1,0.65,1,0.175,0.33333333333333337,0,0.33333333333333337,0.35,0,0.825,0.6666666666666667,1,0.6666666666666667,0.65,1,0.325,0.33333333333333337,0.175,0.33333333333333337,0.35,0,0.675,0.6666666666666667,0.825,0.6666666666666667,0.65,1,0.65,1,0.325,0.33333333333333337,0.35,0,0.35,0,0.675,0.6666666666666667,0.65,1],
                            ratio:{x:0.9,y:0.3}, offset:{y:0.35},
                        },
                        '%':{
                            //vector: [ 0.0,0.1, 0.1,0.0, 0.3,0.0, 0.4,0.1, 0.4,0.3, 0.3,0.4, 0.1,0.4, 0.0,0.3, 0.1,0.25, 0.15,0.3, 0.25,0.3, 0.3,0.25, 0.3,0.15, 0.25,0.1, 0.15,0.1, 0.1,0.15, 0.1,0.25, 0.0,0.3, 0.02,0.9, 0.92,0.0, 1.0,0.08, 0.08,0.98, 0.7,1.0, 0.6,0.9, 0.6,0.7, 0.7,0.6, 0.9,0.6, 1.0,0.7, 1.0,0.9, 0.9,1.0, 0.7,1.0, 0.75,0.9, 0.85,0.9, 0.9,0.85, 0.9,0.75, 0.85,0.7, 0.75,0.7, 0.7,0.75, 0.7,0.85, 0.75,0.9, 0.7,1.0, 0.08,0.98, 0.02,0.9 ]
                            vector:[0,0.1,0.1,0,0.3,0,0.3,0,0.4,0.1,0.4,0.3,0.4,0.3,0.3,0.4,0.1,0.4,0.1,0.15,0.1,0.25,0,0.3,0.02,0.9,0.92,0,1,0.08,0.7,1,0.6,0.9,0.6,0.7,0.6,0.7,0.7,0.6,0.9,0.6,0.9,0.6,1,0.7,1,0.9,0.02,0.9,1,0.08,0.08,0.98,0.7,1,0.7,0.85,0.75,0.9,0.1,0.15,0,0.3,0,0.1,0.1,0.4,0,0.3,0.1,0.25,0.15,0.1,0.1,0.15,0,0.1,0.1,0.4,0.1,0.25,0.15,0.3,0.15,0.1,0,0.1,0.3,0,0.1,0.4,0.15,0.3,0.25,0.3,0.25,0.1,0.15,0.1,0.3,0,0.4,0.3,0.1,0.4,0.25,0.3,0.3,0.15,0.25,0.1,0.3,0,0.4,0.3,0.25,0.3,0.3,0.25,0.3,0.15,0.3,0,0.4,0.3,0.4,0.3,0.3,0.25,0.3,0.15,0.7,0.75,0.7,1,0.6,0.7,1,0.9,0.9,1,0.7,1,0.7,1,0.75,0.9,0.85,0.9,0.75,0.7,0.7,0.75,0.6,0.7,1,0.9,0.7,1,0.85,0.9,0.75,0.7,0.6,0.7,0.9,0.6,1,0.9,0.85,0.9,0.9,0.85,0.85,0.7,0.75,0.7,0.9,0.6,1,0.9,0.9,0.85,0.9,0.75,0.9,0.75,0.85,0.7,0.9,0.6,0.9,0.6,1,0.9,0.9,0.75],
                        },
                        '^':{
                            //vector: [ 0.0/0.6,0.3/0.3, 0.3/0.6,0.0/0.3, 0.6/0.6,0.3/0.3, 0.45/0.6,0.3/0.3, 0.3/0.6,0.15/0.3, 0.15/0.6,0.3/0.3 ],'flatArray'),
                            vector:[0.5, 0.5, 0.25, 1, 0, 1, 0.5, 0, 1, 1, 0.75, 1, 0.5, 0.5, 0, 1, 0.5, 0, 0.5, 0, 0.75, 1, 0.5, 0.5],
                            ratio:{x:0.6,y:0.3},
                        },
                    };
                    
                    
                    //correct font to be compatible with the new way of fonting
                    reducedGlyphSet.concat(['default','']).forEach(key => {
                        if(vectorLibrary.defaultThin[key] == undefined){return;}
                        
                        //generate limits
                            vectorLibrary.defaultThin[key].top = vectorLibrary.defaultThin[key].ratio != undefined && vectorLibrary.defaultThin[key].ratio.y != undefined ? -vectorLibrary.defaultThin[key].ratio.y : -1;
                            vectorLibrary.defaultThin[key].right = vectorLibrary.defaultThin[key].ratio != undefined && vectorLibrary.defaultThin[key].ratio.x != undefined ? vectorLibrary.defaultThin[key].ratio.x + 0.1 : 1.1;
                            vectorLibrary.defaultThin[key].bottom = 0;
                            vectorLibrary.defaultThin[key].left = 0;
                    
                        //adjust for ratio and offset
                            for(let a = 0; a < vectorLibrary.defaultThin[key].vector.length; a+=2){
                                //ratio correction
                                    if( vectorLibrary.defaultThin[key].ratio != undefined ){
                                        if(vectorLibrary.defaultThin[key].ratio.x != undefined){
                                            vectorLibrary.defaultThin[key].vector[a] *= vectorLibrary.defaultThin[key].ratio.x;
                                        }
                                        if(vectorLibrary.defaultThin[key].ratio.y != undefined){
                                            vectorLibrary.defaultThin[key].vector[a+1] *= vectorLibrary.defaultThin[key].ratio.y;
                                        }
                                    }
                                //offset correction
                                    if( vectorLibrary.defaultThin[key].offset != undefined ){
                                        if(vectorLibrary.defaultThin[key].offset.x != undefined){
                                            vectorLibrary.defaultThin[key].vector[a] += vectorLibrary.defaultThin[key].offset.x;
                                        }
                                        if(vectorLibrary.defaultThin[key].offset.y != undefined){
                                            vectorLibrary.defaultThin[key].vector[a+1] += vectorLibrary.defaultThin[key].offset.y;
                                        }
                                    }
                            }
                    
                        //flip y axis
                            for(let a = 0; a < vectorLibrary.defaultThin[key].vector.length; a+=2){
                                vectorLibrary.defaultThin[key].vector[a+1] -= 1;
                            }
                    });
                    
                    
                    
                    
                    this.getLoadableFonts = function(){ 
                    
                        const defaultFontNames = ['defaultThick','defaultThin'];
                        const loadableFontNames = fontFileNames.map(a => a.split('.').slice(0,-1)[0].split('/').slice(1,2)[0]);
                        return defaultFontNames.concat(loadableFontNames);
                    };
                    this.getLoadedFonts = function(){
                    
                        const defaultFontNames = ['defaultThick','defaultThin'];
                        const loadedFontNames = fontFileNames.map(a => a.split('.').slice(0,-1)[0].split('/').slice(1,2)[0]).filter(name => vectorLibrary[name].isLoaded);
                        return defaultFontNames.concat(loadedFontNames);
                    };
                    
                    this.isApprovedFont = function(fontName){
                    
                        return vectorLibrary[fontName] != undefined;
                    };
                    this.isFontLoaded = function(fontName){
                    
                        if(vectorLibrary[fontName] == undefined){ console.warn('library.font.isFontLoaded : error : unknown font name:',fontName); return false;}
                        return vectorLibrary[fontName].isLoaded;
                    }
                    this.fontLoadAttempted = function(fontName){
                    
                        if(vectorLibrary[fontName] == undefined){ console.warn('library.font.fontLoadAttempted : error : unknown font name:',fontName); return false;}
                        return vectorLibrary[fontName].loadAttempted;
                    }
                    this.loadFont = function(fontName,onLoaded=()=>{}){
                    
                        if(vectorLibrary[fontName] == undefined){ console.warn('elementLibrary.character.loadFont : error : unknown font name:',fontName); return false;}
                    
                        //make sure font file is on the approved list
                            if( !this.isApprovedFont(fontName) ){
                                console.warn('library.font.loadFont error: attempting to load unapproved font:',fontName); 
                                return;
                            }
                    
                        //if font is already loaded, bail
                            if( this.isFontLoaded(fontName) ){return;}
                    
                        //set up library entry
                            vectorLibrary[fontName].loadAttempted = true;
                            vectorLibrary[fontName].isLoaded = false;
                            vectorLibrary[fontName]['default'] = {vector:[0,0, 1,0, 0,-1, 1,0, 0,-1, 1,-1]};
                    
                        //load file
                            const filename = vectorLibrary[fontName].fileName;
                            library.misc.loadFileFromURL(
                                fontFilesLocation+filename,
                                fontData => {
                                    const vectors = library.font.extractGlyphs(fontData.response,reducedGlyphSet);
                                    Object.keys(vectors).forEach(glyphName => vectorLibrary[fontName][glyphName] = vectors[glyphName] );
                                    vectorLibrary[fontName].isLoaded = true;
                                    onLoaded(true);
                                },
                                () => { onLoaded(false); },
                                'arraybuffer',
                            );
                    };
                    this.getVector = function(fontName,character){
                        return vectorLibrary[fontName][character];
                    }
                };
                this.misc = new function(){
                    this.padString = function(string,length,padding=' ',paddingSide='l'){
                    
                        if(padding.length<1){return string;}
                        string = ''+string;
                    
                        if(paddingSide == 'l'){
                            while(string.length < length){ string = padding + string; }
                        }else{
                            while(string.length < length){ string = string + padding; }
                        }
                    
                        return string;
                    };
                    this.compressString = function(string){
                    
                        return _thirdparty.lzString.compress(string);
                    };
                    this.decompressString = function(string){
                    
                        return _thirdparty.lzString.decompress(string);
                    };
                    this.serialize = function(data,compress=true){
                    
                        function getType(obj){
                            return ({}).toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase()
                        }
                    
                        data = JSON.stringify(data, function(key, value){
                    
                            //preserve types that JSON.stringify can't handle as "unique types"
                            switch(getType(value)){
                                case 'function':
                                    return {__uniqueType:'function', __value:value.toString(), __name:value.name};
                                case 'arraybuffer': 
                                    return {__uniqueType:'arraybuffer', __value:btoa(String.fromCharCode(new Uint8Array(value)))}
                                case 'audiobuffer':
                                    const channelData = [];
                                    for(let a = 0; a < value.numberOfChannels; a++){
                                        channelData.push( Array.from(value.getChannelData(a)) );
                                    }
                    
                                    return {
                                        __uniqueType:'audiobuffer', 
                                        __channelData:channelData, 
                                        __sampleRate:value.sampleRate,
                                        __numberOfChannels:value.numberOfChannels,
                                        __length:value.length
                                    };
                                break;
                                default: return value;
                            }
                    
                        });
                    
                        if(compress){ data = library.misc.compressString(data); }
                        return data;
                    };
                    this.unserialize = function(data,compressed=true){
                    
                        if(data === undefined){return undefined;}
                    
                        if(compressed){ data = library.misc.decompressString(data); }
                    
                        return JSON.parse(data, function(key, value){
                    
                            //recover unique types
                            if(typeof value == 'object' && value != null && '__uniqueType' in value){
                                switch(value.__uniqueType){
                                    case 'function':
                                        let functionHead = value.__value.substring(0,value.__value.indexOf('{'));
                                        functionHead = functionHead.substring(functionHead.indexOf('(')+1, functionHead.lastIndexOf(')'));
                                        const functionBody = value.__value.substring(value.__value.indexOf('{')+1, value.__value.lastIndexOf('}'));
                    
                                        value = Function(functionHead,functionBody);
                                    break;
                                    case 'arraybuffer':
                                        value = atob(value.__value);
                                        for(let a = 0; a < value.length; a++){ value[a] = value[a].charCodeAt(0); }
                                        value = new ArrayBuffer(value);
                                    break;
                                    case 'audiobuffer':
                                        const audioBuffer = library.audio.context.createBuffer(value.__numberOfChannels, value.__length, value.__sampleRate);
                    
                                        for(let a = 0; a < audioBuffer.numberOfChannels; a++){
                                            workingBuffer = audioBuffer.getChannelData(a);
                                            for(let i = 0; i < audioBuffer.length; i++){
                                                workingBuffer[i] = value.__channelData[a][i];
                                            }
                                        }
                    
                                        value = audioBuffer;
                                    break;
                                    default: value = value.__value;
                                }
                            }
                    
                            return value;
                        });
                    };
                    this.packData = function(data,compress=true){
                        return library.misc.serialize({ 
                            compressed:compress, 
                            data:library.misc.serialize(data,compress)
                        },false);
                    };
                    this.unpackData = function(data){
                    
                        //deserialize first layer
                            try{
                                data = library.misc.unserialize(data,false);
                            }catch(e){
                                console.error( "Major error unserializing first layer of file" );
                                console.error(e);
                                return null;
                            }
                    
                        //determine if this data is compressed or not
                            const compressed = data.compressed;
                    
                        //deserialize second layer (knowing now whether it's compressed or not)
                            try{
                                data = library.misc.unserialize(data.data,compressed);
                            }catch(e){
                                console.error( "Major error unserializing second layer of file" );
                                console.error(e);
                                return null;
                            }
                    
                        return data;
                    };
                    this.openFile = function(callback,readAsType='readAsBinaryString',fileType){
                    
                        const i = document.createElement('input');
                        i.type = 'file';
                        i.accept = fileType;
                        i.onchange = function(){
                            const f = new FileReader();
                            switch(readAsType){
                                case 'readAsArrayBuffer':           f.readAsArrayBuffer(this.files[0]);  break;
                                case 'readAsBinaryString': default: f.readAsBinaryString(this.files[0]); break;
                            }
                            f.onloadend = function(){ 
                                if(callback){callback(f.result,i.files[0]);}
                            }
                        };
                    
                        document.body.appendChild(i);
                        i.click();
                        setTimeout(() => {document.body.removeChild(i);},1000);
                    };
                    this.printFile = function(filename,data){
                    
                        const a = document.createElement('a');
                        a.href = URL.createObjectURL(new Blob([data]));
                        a.download = filename;
                        a.click();
                    };
                    this.argumentsToArray = function(argumentsObject){
                        const outputArray = [];
                        for(let a = 0; a < argumentsObject.length; a++){
                            outputArray.push( argumentsObject[a] );
                        }
                        return outputArray;
                    };
                    this.comparer = function(item1,item2){
                        function getType(obj){
                            return ({}).toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
                        }
                    
                        if(getType(item1) != getType(item2)){ return false; }
                        if(typeof item1 == 'boolean' || typeof item1 == 'string'){ return item1 === item2; }
                        if(typeof item1 == 'number'){
                            if( Math.abs(item1) < 1.0e-14 ){item1 = 0;}
                            if( Math.abs(item2) < 1.0e-14 ){item2 = 0;}
                            if( Math.abs(item1 - item2) < 1.0e-14 ){return true;}
                            return item1 === item2;
                        }
                        if(typeof item1 === 'undefined' || typeof item2 === 'undefined' || item1 === null || item2 === null){ return item1 === item2;  }
                        if(getType(item1) == 'function'){
                            item1 = item1.toString();
                            item2 = item2.toString();
                    
                            let item1_functionHead = item1.substring(0,item1.indexOf('{'));
                            item1_functionHead = item1_functionHead.substring(item1_functionHead.indexOf('(')+1, item1_functionHead.lastIndexOf(')'));
                            const item1_functionBody = item1.substring(item1.indexOf('{')+1, item1.lastIndexOf('}'));
                    
                            let item2_functionHead = item2.substring(0,item2.indexOf('{'));
                            item2_functionHead = item2_functionHead.substring(item2_functionHead.indexOf('(')+1, item2_functionHead.lastIndexOf(')'));
                            const item2_functionBody = item2.substring(item2.indexOf('{')+1, item2.lastIndexOf('}'));
                    
                            return item1_functionHead.trim() == item2_functionHead.trim() && item1_functionBody.trim() == item2_functionBody.trim();
                        }
                        if(typeof item1 == 'object'){
                            const keys1 = Object.keys(item1);
                            const keys2 = Object.keys(item2);
                            if(keys1.length != keys2.length){return false;}
                    
                            for(let a = 0; a < keys1.length; a++){ 
                                if( keys1.indexOf(keys2[a]) == -1 || !library.misc.comparer(item1[keys1[a]],item2[keys1[a]])){return false;}
                            }
                            return true;
                        }
                        return false;
                    };
                    this.removeThisFromThatArray = function(item,array){
                        const index = array.findIndex(a => library.misc.comparer(a,item))
                        if(index == -1){return;}
                        return array.splice(index,1);
                    };
                    this.removeTheseElementsFromThatArray = function(theseElements,thatArray){
                    
                        theseElements.forEach(a => library.misc.removeThisFromThatArray(a,thatArray) );
                        return thatArray;
                    };
                    this.getDifferenceOfArrays = function(array_a,array_b){
                    
                        if(array_a.length == 0 && array_b.length == 0){
                            return {a:[],b:[]};
                        }
                        if(array_a.length == 0){
                            return {a:[],b:array_b};
                        }
                        if(array_b.length == 0){
                            return {a:array_a,b:[]};
                        }
                    
                        function arrayRemovals(a,b){
                            a.forEach(item => {
                                let i = b.indexOf(item);
                                if(i != -1){ b.splice(i,1); }
                            });
                            return b;
                        }
                    
                        return {
                            a:arrayRemovals(array_b,array_a.slice()),
                            b:arrayRemovals(array_a,array_b.slice())
                        };
                    };
                    this.loadFileFromURL = function(url,callback,errorCallback,responseType='blob'){
                    
                        //responseType: text / arraybuffer / blob / document / json 
                    
                        const xhttp = new XMLHttpRequest();
                        xhttp.onloadend = a => {
                            if(a.target.status == 200){ 
                                if(callback != undefined){
                                    callback(a.target);
                                }else{
                                    console.log(a.target);
                                }
                            }else{ 
                                if(errorCallback != undefined){
                                    errorCallback(a.target);
                                }else{
                                    console.warn('library.misc.loadFileFromURL error: could not find the file',a.target.responseURL);
                                }
                            }
                        };
                        xhttp.open('get',url,true);
                        xhttp.responseType = responseType;
                        xhttp.send();
                    };
                    this.loadImageFromURL = function(url,callback,errorCallback,forceUpdate=false,scale=1){
                    
                        const dataStore = this.loadImageFromURL.loadedImageData;
                    
                        function getImageFromDataStoreByUrlWithScale(url,scale=1){
                            global = dataStore[url];
                            return dataStore[url].mipmap[1];
                        }
                    
                        if(dataStore[url] == undefined || forceUpdate && dataStore[url].state != 'requested' ){
                            dataStore[url] = { state:'requested', mipmap:{}, callbacks:[{success:callback,failure:errorCallback,scale:scale}], timestamp:undefined };
                    
                            library.misc.loadFileFromURL(
                                url,
                                response => {
                                    dataStore[url].response = response.response;
                                    createImageBitmap(response.response).then(bitmap => {
                                        dataStore[url].mipmap[1] = bitmap;
                                        dataStore[url].state = 'ready';
                                        dataStore[url].timestamp = Date.now();
                                        dataStore[url].callbacks.forEach(callbackBlock => {
                                            if(callbackBlock.success != undefined){callbackBlock.success( getImageFromDataStoreByUrlWithScale(url,callbackBlock.scale) );}
                                        } );
                                        dataStore[url].callbacks = [];
                                    }).catch(error => {
                                        dataStore[url].state = 'failed';
                                        dataStore[url].timestamp = Date.now();
                                        dataStore[url].callbacks.forEach(callbackBlock => {
                                            if(callbackBlock.failure != undefined){ callbackBlock.failure('imageDecodingError',response,error); }
                                        } );
                                        dataStore[url].callbacks = [];
                                    });
                                },
                                response => {
                                    dataStore[url].state = 'failed';
                                    dataStore[url].timestamp = Date.now();
                                    dataStore[url].callbacks.forEach(callbackBlock => {
                                        if(callbackBlock.failure != undefined){ callbackBlock.failure('badURL',response); }
                                    } );
                                    dataStore[url].callbacks = [];
                                },
                            );
                    
                        }else if( dataStore[url].state == 'ready' ){
                            if(callback != undefined){ callback( getImageFromDataStoreByUrlWithScale(url,scale) ); }
                        }else if( dataStore[url].state == 'requested' ){
                            dataStore[url].callbacks.push({success:callback,failure:errorCallback,scale:scale});
                        }else if( dataStore[url].state == 'failed' ){
                            if(errorCallback != undefined){ errorCallback('previousFailure'); }
                        }
                    };
                    this.loadImageFromURL.loadedImageData = {};
                };
                this.audio = new function(){
                    const audio = this;
                    
                    //master context
                        this.context = new (window.AudioContext || window.webkitAudioContext)();
                    
                    //destination
                        this.destination = this.context.createGain();
                        this.destination.connect(this.context.destination);
                        this.destination._gain = 1;
                        this.destination.masterGain = function(value){
                    
                            if(value == undefined){return this.destination._gain;}
                            this._gain = value;
                            library.audio.changeAudioParam(library.audio.context, this.gain, this._gain, 0.01, 'instant', true);
                        };
                    
                    //frequencies index
                        this.names_frequencies_split = {
                            0:{ 'C':16.35, 'C#':17.32, 'D':18.35, 'D#':19.45, 'E':20.60, 'F':21.83, 'F#':23.12, 'G':24.50, 'G#':25.96, 'A':27.50, 'A#':29.14, 'B':30.87  },
                            1:{ 'C':32.70, 'C#':34.65, 'D':36.71, 'D#':38.89, 'E':41.20, 'F':43.65, 'F#':46.25, 'G':49.00, 'G#':51.91, 'A':55.00, 'A#':58.27, 'B':61.74, },    
                            2:{ 'C':65.41, 'C#':69.30, 'D':73.42, 'D#':77.78, 'E':82.41, 'F':87.31, 'F#':92.50, 'G':98.00, 'G#':103.8, 'A':110.0, 'A#':116.5, 'B':123.5, },
                            3:{ 'C':130.8, 'C#':138.6, 'D':146.8, 'D#':155.6, 'E':164.8, 'F':174.6, 'F#':185.0, 'G':196.0, 'G#':207.7, 'A':220.0, 'A#':233.1, 'B':246.9, },    
                            4:{ 'C':261.6, 'C#':277.2, 'D':293.7, 'D#':311.1, 'E':329.6, 'F':349.2, 'F#':370.0, 'G':392.0, 'G#':415.3, 'A':440.0, 'A#':466.2, 'B':493.9, },
                            5:{ 'C':523.3, 'C#':554.4, 'D':587.3, 'D#':622.3, 'E':659.3, 'F':698.5, 'F#':740.0, 'G':784.0, 'G#':830.6, 'A':880.0, 'A#':932.3, 'B':987.8, },    
                            6:{ 'C':1047,  'C#':1109,  'D':1175,  'D#':1245,  'E':1319,  'F':1397,  'F#':1480,  'G':1568,  'G#':1661,  'A':1760,  'A#':1865,  'B':1976,  },
                            7:{ 'C':2093,  'C#':2217,  'D':2349,  'D#':2489,  'E':2637,  'F':2794,  'F#':2960,  'G':3136,  'G#':3322,  'A':3520,  'A#':3729,  'B':3951,  },    
                            8:{ 'C':4186,  'C#':4435,  'D':4699,  'D#':4978,  'E':5274,  'F':5588,  'F#':5920,  'G':6272,  'G#':6645,  'A':7040,  'A#':7459,  'B':7902   }, 
                        };
                        //generate forward index
                        // eg. {... '4C':261.6, '4C#':277.2 ...}
                            this.names_frequencies = {};
                            Object.entries(this.names_frequencies_split).forEach((octave,index) => {
                                Object.entries(this.names_frequencies_split[index]).forEach(name => {
                                    this.names_frequencies[ octave[0]+name[0] ] = name[1];
                                });
                            });
                    
                        //generate backward index
                        // eg. {... 261.6:'4C', 277.2:'4C#' ...}
                            this.frequencies_names = {};
                            Object.entries(this.names_frequencies).forEach(entry => {
                                this.frequencies_names[entry[1]] = entry[0];
                            });
                    
                    //midi notes index
                        const noteNames = [
                            '0C', '0C#', '0D', '0D#', '0E', '0F', '0F#', '0G', '0G#', '0A', '0A#', '0B',
                            '1C', '1C#', '1D', '1D#', '1E', '1F', '1F#', '1G', '1G#', '1A', '1A#', '1B',
                            '2C', '2C#', '2D', '2D#', '2E', '2F', '2F#', '2G', '2G#', '2A', '2A#', '2B',
                            '3C', '3C#', '3D', '3D#', '3E', '3F', '3F#', '3G', '3G#', '3A', '3A#', '3B',
                            '4C', '4C#', '4D', '4D#', '4E', '4F', '4F#', '4G', '4G#', '4A', '4A#', '4B',
                            '5C', '5C#', '5D', '5D#', '5E', '5F', '5F#', '5G', '5G#', '5A', '5A#', '5B',
                            '6C', '6C#', '6D', '6D#', '6E', '6F', '6F#', '6G', '6G#', '6A', '6A#', '6B',
                            '7C', '7C#', '7D', '7D#', '7E', '7F', '7F#', '7G', '7G#', '7A', '7A#', '7B',
                            '8C', '8C#', '8D', '8D#', '8E', '8F', '8F#', '8G', '8G#', '8A', '8A#', '8B',
                        ];
                        //generate forward index
                            this.midinumbers_names = {};
                            noteNames.forEach((entry,index) => {
                                this.midinumbers_names[index+24] = entry;
                            });
                        //generate backward index
                            this.names_midinumbers = {};
                            Object.entries(this.midinumbers_names).forEach(entry => {
                                this.names_midinumbers[entry[1]] = parseInt(entry[0]);
                            });
                    
                    //lead functions
                        this.num2name = function(num){ 
                    
                            return this.midinumbers_names[num];
                        };
                        this.num2freq = function(num){ 
                    
                            return this.names_frequencies[this.midinumbers_names[num]];
                        };
                    
                        this.name2num = function(name){ 
                    
                            return this.names_midinumbers[name];
                        };
                        this.name2freq = function(name){ 
                    
                            return this.names_frequencies[name];
                        };
                    
                        this.freq2num = function(freq){ 
                    
                            return this.names_midinumbers[this.frequencies_names[freq]];
                        };
                        this.freq2name = function(freq){ 
                    
                            return this.frequencies_names[freq];
                        };
                    this.changeAudioParam = function(context,audioParam,target,time,curve,cancelScheduledValues=true){
                    
                        if(target==null){return audioParam.value;}
                    
                        if(cancelScheduledValues){ audioParam.cancelScheduledValues(0); }
                    
                        try{
                            switch(curve){
                                case 'linear': 
                                    audioParam.linearRampToValueAtTime(target, context.currentTime+time);
                                break;
                                case 'exponential':
                                    console.warn('2018-4-18 - changeAudioParam:exponential doesn\'t work on chrome');
                                    if(target == 0){target = 1/10000;}
                                    audioParam.exponentialRampToValueAtTime(target, context.currentTime+time);
                                break;
                                case 's':
                                    const mux = target - audioParam.value;
                                    const array = library.math.curveGenerator.s(10);
                                    for(let a = 0; a < array.length; a++){
                                        array[a] = audioParam.value + array[a]*mux;
                                    }
                                    audioParam.setValueCurveAtTime(new Float32Array(array), context.currentTime, time);
                                break;
                                case 'instant': default:
                                    // audioParam.setTargetAtTime(target, context.currentTime, 0.01);
                                    audioParam.setValueAtTime(target, 0);
                                break;
                            }
                        }catch(e){
                            console.log('could not change param (possibly due to an overlap, or bad target value)');
                            console.log('audioParam:',audioParam,'target:',target,'time:',time,'curve:',curve,'cancelScheduledValues:',cancelScheduledValues);
                            console.log(e);
                        }
                    };
                    const loadedAudioFiles = {};
                    this.loadAudioFile = function(callback,type='file',url='',errorCallback,forceRequest=false){
                    
                        if(callback == undefined){
                            return;
                        }
                    
                        switch(type){
                            case 'url': 
                                if(!forceRequest && loadedAudioFiles[url] != undefined){
                                    callback(loadedAudioFiles[url]);
                                    break;
                                }
                    
                                library.misc.loadFileFromURL(
                                    url, 
                                    data => {
                                        library.audio.context.decodeAudioData(data.response, data => {
                                            loadedAudioFiles[url] = { buffer:data, name:(url.split('/')).pop(), duration:data.duration };
                                            callback(loadedAudioFiles[url]);
                                        });
                                    },
                                    errorCallback,
                                    'arraybuffer',
                                );
                            break;
                            case 'file': default:
                                library.misc.openFile(
                                    (data,file) => {
                                        library.audio.context.decodeAudioData(data, function(buffer){
                                            callback({ buffer:buffer, name:file.name, duration:buffer.duration });
                                        });
                                    },
                                    'readAsArrayBuffer'
                                );
                            break;
                        }
                    };
                    this.waveformSegment = function(audioBuffer, bounds={start:0,end:1}, resolution=10000){
                    
                        const waveform = audioBuffer.getChannelData(0);
                        // const channelCount = audioBuffer.numberOfChannels;
                    
                        bounds.start = bounds.start ? bounds.start : 0;
                        bounds.end = bounds.end ? bounds.end : 1;
                        const start = audioBuffer.length*bounds.start;
                        const end = audioBuffer.length*bounds.end;
                        const step = (end - start)/resolution;
                    
                        const outputArray = [];
                        for(let a = start; a < end; a+=Math.round(step)){
                            outputArray.push( 
                                library.math.largestValueFound(
                                    waveform.slice(a, a+Math.round(step))
                                )
                            );
                        }
                    
                        return outputArray;
                    };
                    this.loadBuffer = function(context, data, destination, onended){
                    
                        const temp = context.createBufferSource();
                        temp.buffer = data;
                        temp.connect(destination);
                        temp.onended = onended;
                        return temp;
                    };
                    this.audioWorklet = new function(){
                        function checkIfReady(){
                            if(worklets.length == 0){return true;}
                            return worklets.map(a => a.loaded).reduce((rolling,current) => {return rolling && current;});
                        };
                        this.checkIfReady = function(){ return checkIfReady(); };
                        this.nowReady = function(){};
                    
                        const worklets = [
                            {
                                name:'amplitudeModifier',
                                worklet:new Blob([`
                                    class amplitudeModifier extends AudioWorkletProcessor{
                                        static get parameterDescriptors(){
                                            return [
                                                {
                                                    name: 'invert',
                                                    defaultValue: 0,
                                                    minValue: 0,
                                                    maxValue: 1,
                                                    automationRate: 'k-rate',
                                                },{
                                                    name: 'offset',
                                                    defaultValue: 0,
                                                    minValue: -10,
                                                    maxValue: 10,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'divisor',
                                                    defaultValue: 1,
                                                    minValue: 1,
                                                    maxValue: 16,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'ceiling',
                                                    defaultValue: 10,
                                                    minValue: -10,
                                                    maxValue: 10,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'floor',
                                                    defaultValue: -10,
                                                    minValue: -10,
                                                    maxValue: 10,
                                                    automationRate: 'a-rate',
                                                }
                                            ];
                                        }
                                        
                                        constructor(options){
                                            super(options);
                                        }
                                    
                                        process(inputs, outputs, parameters){
                                            const input = inputs[0];
                                            const output = outputs[0];
                                            const sign = parameters.invert[0] == 1 ? -1 : 1;
                                    
                                            const divisor_useFirstOnly = parameters.divisor.length == 1;
                                            const offset_useFirstOnly = parameters.offset.length == 1;
                                            const floor_useFirstOnly = parameters.floor.length == 1;
                                            const ceiling_useFirstOnly = parameters.ceiling.length == 1;
                                    
                                            for(let channel = 0; channel < input.length; channel++){        
                                                for(let a = 0; a < input[channel].length; a++){
                                                    const divisor = divisor_useFirstOnly ? parameters.divisor[0] : parameters.divisor[a];
                                                    const offset = offset_useFirstOnly ? parameters.offset[0] : parameters.offset[a];
                                                    const floor = floor_useFirstOnly ? parameters.floor[0] : parameters.floor[a];
                                                    const ceiling = ceiling_useFirstOnly ? parameters.ceiling[0] : parameters.ceiling[a];
                                    
                                                    output[channel][a] = sign * (input[channel][a]/divisor) + offset;
                                    
                                                    if( output[channel][a] < floor ){
                                                        output[channel][a] = floor;
                                                    }else if( output[channel][a] > ceiling ){
                                                        output[channel][a] = ceiling;
                                                    }
                                                }
                                            }
                                    
                                            return true;
                                        }
                                    }
                                    registerProcessor('amplitudeModifier', amplitudeModifier);
                                `], { type: "text/javascript" }),
                                class:
                                    class amplitudeModifier extends AudioWorkletNode{
                                        constructor(context, options={}){
                                            options.numberOfInputs = 1;
                                            options.numberOfOutputs = 1;
                                            options.channelCount = 1;
                                            super(context, 'amplitudeModifier', options);
                                    
                                            this._invert = false;
                                        }
                                    
                                        get invert(){
                                            return this._invert;
                                        }
                                        set invert(value){
                                            this._invert = value;
                                            this.parameters.get('invert').setValueAtTime(this._invert?1:0,0);
                                        }
                                    
                                        get offset(){
                                            return this.parameters.get('offset');
                                        }
                                        get divisor(){
                                            return this.parameters.get('divisor');
                                        }
                                        get ceiling(){
                                            return this.parameters.get('ceiling');
                                        }
                                        get floor(){
                                            return this.parameters.get('floor');
                                        }
                                    }
                                ,
                            },
                            {
                                name:'bitcrusher',
                                worklet:new Blob([`
                                    class bitcrusher extends AudioWorkletProcessor{
                                        static get parameterDescriptors(){
                                            return [
                                                {
                                                    name: 'amplitudeResolution',
                                                    defaultValue: 10,
                                                    minValue: 1,
                                                    maxValue: 128,
                                                    automationRate: 'k-rate',
                                                },{
                                                    name: 'sampleFrequency',
                                                    defaultValue: 16,
                                                    minValue: 1,
                                                    maxValue: 128,
                                                    automationRate: 'k-rate',
                                                }
                                            ];
                                        }
                                        
                                        constructor(options){
                                            super(options);
                                        }
                                    
                                        process(inputs, outputs, parameters){
                                            const input = inputs[0];
                                            const output = outputs[0];
                                            const amplitudeResolution = parameters.amplitudeResolution[0];
                                            const sampleFrequency = parameters.sampleFrequency[0];
                                        
                                            for(let channel = 0; channel < input.length; channel++){    
                                                for(let a = 0; a < input[channel].length; a++){
                                                    output[channel][a] = a%sampleFrequency == 0 ? Math.round(input[channel][a]*amplitudeResolution)/amplitudeResolution : output[channel][a-1];
                                                }
                                            }
                                            return true;
                                        }
                                    }
                                    registerProcessor('bitcrusher', bitcrusher);
                                `], { type: "text/javascript" }),
                                class:
                                    class bitcrusher extends AudioWorkletNode{
                                        constructor(context, options={}){
                                            options.numberOfInputs = 1;
                                            options.numberOfOutputs = 1;
                                            options.channelCount = 1;
                                            super(context, 'bitcrusher', options);
                                            
                                            this._amplitudeResolution = 10;
                                            this._sampleFrequency = 16;
                                        }
                                    
                                        get amplitudeResolution(){
                                            return this._amplitudeResolution;
                                        }
                                        set amplitudeResolution(value){
                                            this._amplitudeResolution = value;
                                            this.parameters.get('amplitudeResolution').setValueAtTime(this._amplitudeResolution,0);
                                        }
                                    
                                        get sampleFrequency(){
                                            return this._sampleFrequency;
                                        }
                                        set sampleFrequency(value){
                                            this._sampleFrequency = value;
                                            this.parameters.get('sampleFrequency').setValueAtTime(this._sampleFrequency,0);
                                        }
                                    }
                                ,
                            },
                            {
                                name:'momentaryAmplitudeMeter',
                                worklet:new Blob([`
                                    class momentaryAmplitudeMeter extends AudioWorkletProcessor{
                                        static get parameterDescriptors(){
                                            return [
                                                {
                                                    name: 'active',
                                                    defaultValue: 1, // 0 - off / 1 - on
                                                    minValue: 0,
                                                    maxValue: 1,
                                                    automationRate: 'k-rate',
                                                },{
                                                    name: 'fullSample',
                                                    defaultValue: 0, // 0 - only use the current frame / 1 - collect and use all the data from every frame since the last time a value was returned
                                                    minValue: 0,
                                                    maxValue: 1,
                                                    automationRate: 'k-rate',
                                                },{
                                                    name: 'updateMode',
                                                    defaultValue: 0, // 0 - by timer / 1 - by request
                                                    minValue: 0,
                                                    maxValue: 1,
                                                    automationRate: 'k-rate',
                                                },{
                                                    name: 'updateDelay',
                                                    defaultValue: 100,
                                                    minValue: 1,
                                                    maxValue: 1000,
                                                    automationRate: 'k-rate',
                                                },{
                                                    name: 'calculationMode',
                                                    defaultValue: 3, //max, min, average, absMax, absMin, absAverage
                                                    minValue: 0,
                                                    maxValue: 5,
                                                    automationRate: 'k-rate',
                                                }
                                            ];
                                        }
                                    
                                        constructor(options){
                                            super(options);
                                            const self = this;
                                            this._lastUpdate = currentTime;
                                            this._dataArray = [];
                                            this._readingRequested = false;
                                            this._sync = false;
                                    
                                            this.port.onmessage = function(event){
                                                if(event.data == 'sync'){
                                                    self._sync = true;
                                                }
                                                if(event.data == 'readingRequest'){
                                                    self._readingRequested = true;
                                                }
                                            };
                                            this.port.start();
                                        }
                                    
                                        process(inputs, outputs, parameters){
                                            const input = inputs[0];
                                            const fullSample = parameters.fullSample[0];
                                            const updateDelay = parameters.updateDelay[0];
                                            const calculationMode = parameters.calculationMode[0];
                                    
                                            if( parameters.active[0] == 0 ){ return true; }
                                    
                                            if(fullSample){
                                                this._dataArray.push(...input[0]);
                                            }else{
                                                this._dataArray = new Array(...input[0]);
                                            }
                                    
                                            if( 
                                                this._sync ||
                                                (parameters.updateMode[0] == 0 && (currentTime - this._lastUpdate > updateDelay/1000)) ||
                                                (parameters.updateMode[0] == 1 && this._readingRequested)
                                            ){
                                                this._sync = false;
                                                this._readingRequested = false;
                                                this._lastUpdate = currentTime;
                                    
                                                switch(calculationMode[0]){
                                                    case 0: default:
                                                        this.port.postMessage( Math.max(...this._dataArray) );
                                                    break;
                                                    case 1:
                                                        this.port.postMessage( Math.min(...this._dataArray) );
                                                    break;
                                                    case 2:
                                                        this.port.postMessage( this._dataArray.reduce((a,b) => a + b, 0) / this._dataArray.length );
                                                    break;
                                                    case 3:
                                                        this.port.postMessage( Math.max(...(this._dataArray).map(a => Math.abs(a)) ) );
                                                    break;
                                                    case 4:
                                                        this.port.postMessage( Math.min(...(this._dataArray).map(a => Math.abs(a)) ) );
                                                    break;
                                                    case 5:
                                                        this.port.postMessage( this._dataArray.map(a => Math.abs(a)).reduce((a,b) => a + b, 0) / this._dataArray.length );
                                                    break;
                                                }
                                    
                                                if(fullSample){
                                                    this._dataArray = [];
                                                }
                                            }
                                    
                                            return true;
                                        }
                                    }
                                    registerProcessor('momentaryAmplitudeMeter', momentaryAmplitudeMeter);
                                `], { type: "text/javascript" }),
                                class:
                                    class momentaryAmplitudeMeter extends AudioWorkletNode{
                                        constructor(context, options={}){
                                            options.numberOfInputs = 1;
                                            options.numberOfOutputs = 0;
                                            options.channelCount = 1;
                                            super(context, 'momentaryAmplitudeMeter', options);
                                    
                                            const self = this;
                                    
                                            this._active = true;
                                            this._fullSample = false;
                                            this._updateMode = 0;
                                            this._updateDelay = 100;
                                            this._calculationMode = 3;
                                    
                                            this.reading = function(){};
                                            this.port.onmessage = function(event){
                                                try{
                                                    self.reading(event.data);
                                                }catch(error){}
                                            };
                                            this.port.start();
                                    
                                            this.requestReading = function(){
                                                this.port.postMessage('readingRequest');
                                            };
                                            this.sync = function(){
                                                this.port.postMessage('sync');
                                            };
                                        }
                                    
                                    
                                        get active(){
                                            return this._active;
                                        }
                                        set active(value){
                                            this._active = value;
                                            this.parameters.get('active').setValueAtTime(this._active?1:0,0);
                                        }
                                    
                                        get fullSample(){
                                            return this._fullSample;
                                        }
                                        set fullSample(value){
                                            this._fullSample = value;
                                            this.parameters.get('fullSample').setValueAtTime(this._fullSample?1:0,0);
                                        }
                                    
                                        get updateMode(){
                                            return this._updateMode;
                                        }
                                        set updateMode(value){
                                            this._updateMode = value;
                                            this.parameters.get('updateMode').setValueAtTime(this._updateMode,0);
                                        }
                                    
                                        get updateDelay(){
                                            return this._updateDelay;
                                        }
                                        set updateDelay(value){
                                            this._updateDelay = value;
                                            this.parameters.get('updateDelay').setValueAtTime(this._updateDelay,0);
                                        }
                                    
                                        get calculationMode(){
                                            return this._calculationMode;
                                        }
                                        set calculationMode(value){
                                            this._calculationMode = value;
                                            this.parameters.get('calculationMode').setValueAtTime(this._calculationMode,0);
                                        }
                                    }
                                ,
                            },
                            {
                                name:'whiteNoiseGenerator',
                                worklet:new Blob([`
                                    class whiteNoiseGenerator extends AudioWorkletProcessor{
                                        static get parameterDescriptors(){
                                            return [];
                                        }
                                        
                                        constructor(options){
                                            super(options);
                                        }
                                    
                                        process(inputs, outputs, parameters){
                                            const output = outputs[0];
                                    
                                            for(let channel = 0; channel < output.length; channel++){
                                                for(let a = 0; a < output[channel].length; a++){
                                                    output[channel][a] = Math.random()*2 - 1;
                                                }
                                            }
                                    
                                            return true;
                                        }
                                    }
                                    registerProcessor('whiteNoiseGenerator', whiteNoiseGenerator);
                                `], { type: "text/javascript" }),
                                class:
                                    class whiteNoiseGenerator extends AudioWorkletNode{
                                        constructor(context, options={}){
                                            options.numberOfInputs = 0;
                                            options.numberOfOutputs = 1;
                                            options.channelCount = 1;
                                            super(context, 'whiteNoiseGenerator', options);
                                        }
                                    }
                                ,
                            },
                            {
                                name:'sigmoid',
                                worklet:new Blob([`
                                    class sigmoid extends AudioWorkletProcessor{
                                        static get parameterDescriptors(){
                                            return [
                                                {
                                                    name: 'gain',
                                                    defaultValue: 1,
                                                    minValue: 0,
                                                    maxValue: 1,
                                                    automationRate: 'a-rate',
                                                },
                                                {
                                                    name: 'sharpness',
                                                    defaultValue: 0,
                                                    minValue: 0,
                                                    maxValue: 1,
                                                    automationRate: 'a-rate',
                                                }
                                            ];
                                        }
                                    
                                        constructor(options){
                                            super(options);
                                        }
                                    
                                        process(inputs, outputs, parameters){
                                            const input = inputs[0];
                                            const output = outputs[0];
                                            const gain_useFirstOnly = parameters.gain.length == 1;
                                            const sharpness_useFirstOnly = parameters.sharpness.length == 1;
                                        
                                            for(let channel = 0; channel < input.length; channel++){
                                                const inputChannel = input[channel];
                                                const outputChannel = output[channel];
                                        
                                                for(let a = 0; a < inputChannel.length; a++){
                                                    const gain = gain_useFirstOnly ? parameters.gain[0] : parameters.gain[a];
                                                    const sharpness = sharpness_useFirstOnly ? parameters.sharpness[0] : parameters.sharpness[a];
                                                    outputChannel[a] = gain * ( inputChannel[a] / ( 1 - sharpness + sharpness*Math.abs(inputChannel[a]) ) );
                                                }
                                            }
                                            return true;
                                        }
                                    }
                                    registerProcessor('sigmoid', sigmoid);
                                `], { type: "text/javascript" }),
                                class:
                                    class sigmoid extends AudioWorkletNode{
                                        constructor(context, options={}){
                                            options.numberOfInputs = 1;
                                            options.numberOfOutputs = 1;
                                            options.channelCount = 1;
                                            super(context, 'sigmoid', options);
                                        }
                                    
                                        get gain(){
                                            return this.parameters.get('gain');
                                        }
                                        get sharpness(){
                                            return this.parameters.get('sharpness');
                                        }
                                    }
                                ,
                            },
                            {
                                name:'lagProcessor',
                                worklet:new Blob([`
                                    class lagProcessor extends AudioWorkletProcessor{
                                        static get parameterDescriptors(){
                                            return [{
                                                    name: 'samples',
                                                    defaultValue: 1,
                                                    minValue: 1,
                                                    maxValue: 100,
                                                    automationRate: 'k-rate',
                                                }
                                            ];
                                        }
                                    
                                        constructor(options){
                                            super(options);
                                            this._dataArrayWorkingIndex = 0;
                                            this._dataArray = [];
                                        }
                                    
                                        process(inputs, outputs, parameters){
                                            const input = inputs[0];
                                            const output = outputs[0];
                                            const samples = parameters.samples[0];
                                            const _samplesMinusOne = samples-1;
                                    
                                            if( samples != this._dataArray.length ){
                                                while( samples > this._dataArray.length ){
                                                    this._dataArray.push(0);
                                                }
                                                while( samples < this._dataArray.length ){
                                                    this._dataArray.pop();
                                                }
                                            }
                                            
                                            for(let channel = 0; channel < input.length; channel++){ 
                                                for(let a = 0; a < input[channel].length; a++){
                                                    if(this._dataArrayWorkingIndex < _samplesMinusOne){
                                                        this._dataArrayWorkingIndex++;
                                                    }else{
                                                        this._dataArrayWorkingIndex = 0;
                                                    }
                                    
                                                    this._dataArray[this._dataArrayWorkingIndex] = input[channel][a];
                                                    output[channel][a] = this._dataArray.reduce((a,b) => a + b) / samples;
                                                    
                                                }
                                            }
                                            
                                            return true;
                                        }
                                    }
                                    registerProcessor('lagProcessor', lagProcessor);
                                `], { type: "text/javascript" }),
                                class:
                                    class lagProcessor extends AudioWorkletNode{
                                        constructor(context, options={}){
                                            options.numberOfInputs = 1;
                                            options.numberOfOutputs = 1;
                                            options.channelCount = 1;
                                            super(context, 'lagProcessor', options);
                                    
                                            this._samples = 1;
                                        }
                                    
                                        get samples(){
                                            return this._samples;
                                        }
                                        set samples(value){
                                            this._samples = Math.round(value);
                                            this.parameters.get('samples').setValueAtTime(this._samples,0);
                                        }
                                    }
                                ,
                            },
                            {
                                name:'stableAmplitudeGenerator',
                                worklet:new Blob([`
                                    class stableAmplitudeGenerator extends AudioWorkletProcessor{
                                        static get parameterDescriptors(){
                                            return [
                                                {
                                                    name: 'amplitude',
                                                    defaultValue: 0,
                                                    minValue: -1,
                                                    maxValue: 1,
                                                    automationRate: 'k-rate',
                                                }
                                            ];
                                        }
                                    
                                        constructor(options){
                                            super(options);
                                        }
                                    
                                        process(inputs, outputs, parameters){
                                            const output = outputs[0];
                                    
                                            for(let channel = 0; channel < output.length; channel++){
                                                for(let a = 0; a < output[channel].length; a++){
                                                    output[channel][a] = parameters.amplitude[0];
                                                }
                                            }
                                    
                                            return true;
                                        }
                                    }
                                    registerProcessor('stableAmplitudeGenerator', stableAmplitudeGenerator);
                                `], { type: "text/javascript" }),
                                class:
                                    class stableAmplitudeGenerator extends AudioWorkletNode{
                                        constructor(context, options={}){
                                            options.numberOfInputs = 0;
                                            options.numberOfOutputs = 1;
                                            options.channelCount = 1;
                                            super(context, 'stableAmplitudeGenerator', options);
                                        }
                                    
                                        get amplitude(){
                                            return this.parameters.get('amplitude');
                                        }
                                    }
                                ,
                            },
                            {
                                name:'gain',
                                worklet:new Blob([`
                                    class gain extends AudioWorkletProcessor{
                                        static get parameterDescriptors(){
                                            return [
                                                {
                                                    name: 'mode',
                                                    defaultValue: 0,
                                                    minValue: 0,
                                                    maxValue: 1,
                                                    automationRate: 'k-rate',
                                                },{
                                                    name: 'gain',
                                                    defaultValue: 1,
                                                    minValue: -100,
                                                    maxValue: 100,
                                                    automationRate: 'a-rate',
                                                }
                                            ];
                                        }
                                        
                                        constructor(options){
                                            super(options);
                                        }
                                    
                                        process(inputs, outputs, parameters){
                                            const input_1 = inputs[0];
                                            const input_2 = inputs[1];
                                            const output_1 = outputs[0];
                                    
                                            if( parameters.mode[0] == 1 ){
                                                //automatic
                                                for(let channel = 0; channel < input_1.length; channel++){    
                                                    for(let a = 0; a < output_1[channel].length; a++){
                                                        output_1[channel][a] = input_1[channel][a] * input_2[channel][a];
                                                    }
                                                }
                                            }else{
                                                //manual
                                                const gain_useFirstOnly = parameters.gain.length == 1;
                                                for(let channel = 0; channel < input_1.length; channel++){        
                                                    for(let a = 0; a < input_1[channel].length; a++){
                                                        const gain = gain_useFirstOnly ? parameters.gain[0] : parameters.gain[a];
                                                        output_1[channel][a] = input_1[channel][a] * gain;
                                                    }
                                                }
                                            }
                                    
                                            return true;
                                        }
                                    }
                                    registerProcessor('gain', gain);
                                `], { type: "text/javascript" }),
                                class:
                                    class gain extends AudioWorkletNode{
                                        constructor(context, options={}){
                                            options.numberOfInputs = 2;
                                            options.numberOfOutputs = 1;
                                            options.channelCount = 1;
                                            super(context, 'gain', options);
                                    
                                            this._mode = false;
                                        }
                                    
                                        get mode(){
                                            return this._mode;
                                        }
                                        set mode(value){
                                            this._mode = value;
                                            this.parameters.get('mode').setValueAtTime(this._mode?1:0,0);
                                        }
                                        get gain(){
                                            return this.parameters.get('gain');
                                        }
                                    }
                                ,
                            },
                            {
                                name:'nothing',
                                worklet:new Blob([`
                                    class nothing extends AudioWorkletProcessor{
                                        constructor(options){
                                            super(options);
                                        }
                                    
                                        process(inputs, outputs, parameters){
                                            const input = inputs[0];
                                            const output = outputs[0];
                                    
                                            for(let channel = 0; channel < input.length; channel++){
                                                for(let a = 0; a < input[channel].length; a++){
                                                    output[channel][a] = input[channel][a];
                                                }
                                            }
                                    
                                            return true;
                                        }
                                    }
                                    registerProcessor('nothing', nothing);
                                `], { type: "text/javascript" }),
                                class:
                                    class nothing extends AudioWorkletNode{
                                        constructor(context, options={}){
                                            options.numberOfInputs = 1;
                                            options.numberOfOutputs = 1;
                                            options.channelCount = 1;
                                            super(context, 'nothing', options);
                                        }
                                    }
                                ,
                            },
                            {
                                name:'oscillator',
                                worklet:new Blob([`
                                    // class oscillator extends AudioWorkletProcessor{
                                    //     static twoPI = Math.PI*2;
                                    //     static starterFrequency = 440;
                                    
                                    //     static get parameterDescriptors(){
                                    //         return [
                                    //             {
                                    //                 name: 'mode',
                                    //                 defaultValue: 0, // 0 - sine / 1 - square / 2 - triangle/sawtooth/ramp (use duty cycle)
                                    //                 minValue: 0,
                                    //                 maxValue: 3,
                                    //                 automationRate: 'a-rate',
                                    //             },{
                                    //                 name: 'frequency',
                                    //                 defaultValue: oscillator.starterFrequency,
                                    //                 minValue: 0,
                                    //                 maxValue: 20000,
                                    //                 automationRate: 'a-rate',
                                    //             },{
                                    //                 name: 'dutyCycle',
                                    //                 defaultValue: 0.5,
                                    //                 minValue: 0,
                                    //                 maxValue: 1,
                                    //                 automationRate: 'a-rate',
                                    //             }
                                    //         ];
                                    //     }
                                    
                                    //     constructor(options){
                                    //         super(options);
                                    //         this._wavePosition = 0;
                                    //         this._waveStep = oscillator.starterFrequency/44100;
                                    //     }
                                    
                                    //     process(inputs, outputs, parameters){
                                    //         const output = outputs[0];
                                    
                                    //         const frequency_useFirstOnly = parameters.frequency.length == 1;
                                    //         const dutyCycle_useFirstOnly = parameters.dutyCycle.length == 1;
                                    
                                    //         switch(parameters.mode[0]){
                                    //             case 0:
                                    //                 for(let channel = 0; channel < output.length; channel++){
                                    //                     for(let a = 0; a < output[channel].length; a++){
                                    //                         if( !frequency_useFirstOnly ){ this._waveStep = parameters.frequency[a]/sampleRate; }
                                    //                         this._wavePosition += this._waveStep;
                                    
                                    //                         const waveProgress = this._wavePosition - Math.trunc(this._wavePosition);
                                    //                         output[channel][a] = Math.sin( waveProgress * oscillator.twoPI );
                                    //                     }
                                    //                 }
                                    //             break;
                                    //             case 1:
                                    //                 for(let channel = 0; channel < output.length; channel++){
                                    //                     for(let a = 0; a < output[channel].length; a++){
                                    //                         if( !frequency_useFirstOnly ){ this._waveStep = parameters.frequency[a]/sampleRate; }
                                    //                         this._wavePosition += this._waveStep;
                                    
                                    //                         const waveProgress = this._wavePosition - Math.trunc(this._wavePosition);
                                    //                         const dutyCycle = dutyCycle_useFirstOnly ? parameters.dutyCycle[0] : parameters.dutyCycle[a];
                                    
                                    //                         output[channel][a] = waveProgress < dutyCycle ? 1 : -1;
                                    //                     }
                                    //                 }
                                    //             break;
                                    //             case 2:
                                    //                 for(let channel = 0; channel < output.length; channel++){
                                    //                     for(let a = 0; a < output[channel].length; a++){
                                    //                         if( !frequency_useFirstOnly ){ this._waveStep = parameters.frequency[a]/sampleRate; }
                                    //                         this._wavePosition += this._waveStep;
                                    
                                    //                         const waveProgress = this._wavePosition - Math.trunc(this._wavePosition);
                                    //                         const dutyCycle = dutyCycle_useFirstOnly ? parameters.dutyCycle[0] : parameters.dutyCycle[a];
                                    
                                    //                         if(waveProgress < dutyCycle/2){
                                    //                             output[channel][a] = 2*waveProgress / dutyCycle;
                                    //                         }else if(waveProgress >= 1 - dutyCycle/2){
                                    //                             output[channel][a] = (2*waveProgress - 2) / dutyCycle;
                                    //                         }else{
                                    //                             output[channel][a] = (2*waveProgress - 1) / (dutyCycle - 1);
                                    //                         }
                                    //                     }
                                    //                 }
                                    //             break;
                                    //         }
                                    
                                    //         return true;
                                    //     }
                                    // }
                                    // registerProcessor('oscillator', oscillator);
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    class oscillator extends AudioWorkletProcessor{
                                        static twoPI = Math.PI*2;
                                        static starterFrequency = 440;
                                        static maxFrequency = 20000;
                                        static detuneMux = 0.1;
                                        static detuneBounds = 1/oscillator.detuneMux;
                                    
                                        static get parameterDescriptors(){
                                            return [
                                                {
                                                    name: 'waveform',
                                                    defaultValue: 0, // 0 - sine / 1 - square / 2 - triangle / 3 - noise
                                                    minValue: 0,
                                                    maxValue: 3,
                                                    automationRate: 'k-rate',
                                                },{
                                                    name: 'frequency',
                                                    defaultValue: oscillator.starterFrequency,
                                                    minValue: 0,
                                                    maxValue: oscillator.maxFrequency,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'gain',
                                                    defaultValue: 1,
                                                    minValue: -1,
                                                    maxValue: 1,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'detune',
                                                    defaultValue: 0,
                                                    minValue: -oscillator.detuneBounds,
                                                    maxValue: oscillator.detuneBounds,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'dutyCycle',
                                                    defaultValue: 0.5,
                                                    minValue: 0,
                                                    maxValue: 1,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'gain_mode',
                                                    defaultValue: 0, // 0 - manual / 1 - automatic
                                                    minValue: 0,
                                                    maxValue: 1,
                                                    automationRate: 'k-rate',
                                                },{
                                                    name: 'detune_mode',
                                                    defaultValue: 0, // 0 - manual / 1 - automatic
                                                    minValue: 0,
                                                    maxValue: 1,
                                                    automationRate: 'k-rate',
                                                },{
                                                    name: 'dutyCycle_mode',
                                                    defaultValue: 0, // 0 - manual / 1 - automatic
                                                    minValue: 0,
                                                    maxValue: 1,
                                                    automationRate: 'k-rate',
                                                },
                                            ];
                                        }
                                    
                                        constructor(options){
                                            super(options);
                                            this._wavePosition = 0;
                                        }
                                    
                                        process(inputs, outputs, parameters){
                                            const output = outputs[0];
                                            const gainControl = inputs[0];
                                            const detuneControl = inputs[1];
                                            const dutyCycleControl = inputs[2];
                                    
                                            const frequency_useFirstOnly = parameters.frequency.length == 1;
                                            const dutyCycle_useFirstOnly = parameters.dutyCycle.length == 1;
                                            const detune_useFirstOnly = parameters.detune.length == 1;
                                            const gain_useFirstOnly = parameters.gain.length == 1;
                                    
                                            for(let channel = 0; channel < output.length; channel++){
                                                for(let a = 0; a < output[channel].length; a++){
                                                    const gain = parameters.gain_mode[0] == 0 ? (gain_useFirstOnly ? parameters.gain[0] : parameters.gain[a]) : gainControl[channel][a];
                                                    const frequency = frequency_useFirstOnly ? parameters.frequency[0] : parameters.frequency[a];
                                                    const detune = parameters.detune_mode[0] == 0 ? (detune_useFirstOnly ? parameters.detune[0] : parameters.detune[a]) : detuneControl[channel][a];
                                                    const dutyCycle = parameters.dutyCycle_mode[0] == 0 ? (dutyCycle_useFirstOnly ? parameters.dutyCycle[0] : parameters.dutyCycle[a]) : dutyCycleControl[channel][a];
                                    
                                                    this._wavePosition += (frequency*(detune*oscillator.detuneMux + 1))/sampleRate;
                                                    const localWavePosition = this._wavePosition % 1;
                                    
                                                    switch(parameters.waveform[0]){
                                                        case 0: //sin
                                                            output[channel][a] = gain*Math.sin( localWavePosition * oscillator.twoPI );
                                                        break;
                                                        case 1: //square
                                                            output[channel][a] = gain*(localWavePosition < dutyCycle ? 1 : -1);
                                                        break;
                                                        case 2: //triangle
                                                            if(localWavePosition < dutyCycle/2){
                                                                output[channel][a] = gain*(2*localWavePosition / dutyCycle);
                                                            }else if(localWavePosition >= 1 - dutyCycle/2){
                                                                output[channel][a] = gain*((2*localWavePosition - 2) / dutyCycle);
                                                            }else{
                                                                output[channel][a] = gain*((2*localWavePosition - 1) / (dutyCycle - 1));
                                                            }
                                                        break;
                                                        case 3: //noise
                                                            output[channel][a] = gain*(Math.random()*2 - 1);
                                                        break;
                                                    }
                                                }
                                            }
                                    
                                            return true;
                                        }
                                    }
                                    registerProcessor('oscillator', oscillator);
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    /*
                                    
                                    // Phase Modulation
                                    let x = 0;
                                    let freq = 1;
                                    let mux = [
                                        {pha:1,amp:1},
                                        {pha:1,amp:1},
                                        {pha:1,amp:1},
                                        {pha:1,amp:1},
                                    ];
                                    let accumulator = 0;
                                    mux.forEach(current => {
                                        accumulator = Math.sin(x*freq*current.pha + (Math.PI/2)*current.amp*accumulator);
                                    } );
                                    
                                    */
                                `], { type: "text/javascript" }),
                                class:
                                    class oscillator extends AudioWorkletNode{
                                        constructor(context, options={}){
                                            options.numberOfInputs = 3;
                                            options.numberOfOutputs = 1;
                                            options.channelCount = 1;
                                            super(context, 'oscillator', options);
                                    
                                            this._waveform = 0;
                                            this._gain_mode = 0;
                                            this._detune_mode = 0;
                                            this._dutyCycle_mode = 0;
                                        }
                                    
                                    
                                        get waveform(){
                                            return this._waveform;
                                        }
                                        set waveform(value){
                                            this._waveform = value;
                                            this.parameters.get('waveform').setValueAtTime(this._waveform,0);
                                        }
                                        get gain_mode(){
                                            return this._gain_mode;
                                        }
                                        set gain_mode(value){
                                            this._gain_mode = value;
                                            this.parameters.get('gain_mode').setValueAtTime(this._gain_mode,0);
                                        }
                                        get detune_mode(){
                                            return this._detune_mode;
                                        }
                                        set detune_mode(value){
                                            this._detune_mode = value;
                                            this.parameters.get('detune_mode').setValueAtTime(this._detune_mode,0);
                                        }
                                    
                                        get dutyCycle_mode(){
                                            return this._dutyCycle_mode;
                                        }
                                        set dutyCycle_mode(value){
                                            this._dutyCycle_mode = value;
                                            this.parameters.get('dutyCycle_mode').setValueAtTime(this._dutyCycle_mode,0);
                                        }
                                        get frequency(){
                                            return this.parameters.get('frequency');
                                        }
                                        get gain(){
                                            return this.parameters.get('gain');
                                        }
                                        get detune(){
                                            return this.parameters.get('detune');
                                        }
                                        get dutyCycle(){
                                            return this.parameters.get('dutyCycle');
                                        }
                                    }
                                ,
                            },
                            {
                                name:'oscillator2',
                                worklet:new Blob([`
                                    class oscillator2 extends AudioWorkletProcessor{
                                        static twoPI = Math.PI*2;
                                        static starterFrequency = 440;
                                        static maxFrequency = 20000;
                                        static detuneMux = 0.1;
                                        static detuneBounds = 1/oscillator2.detuneMux;
                                    
                                        static get parameterDescriptors(){
                                            return [
                                                {
                                                    name: 'frequency',
                                                    defaultValue: oscillator2.starterFrequency,
                                                    minValue: 0,
                                                    maxValue: oscillator2.maxFrequency,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'gain',
                                                    defaultValue: 1,
                                                    minValue: -1,
                                                    maxValue: 1,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'detune',
                                                    defaultValue: 0,
                                                    minValue: -oscillator2.detuneBounds,
                                                    maxValue: oscillator2.detuneBounds,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'dutyCycle',
                                                    defaultValue: 0.5,
                                                    minValue: 0,
                                                    maxValue: 1,
                                                    automationRate: 'a-rate',
                                                },
                                            ];
                                        }
                                    
                                        constructor(options){
                                            super(options);
                                            const self = this;
                                            this._wavePosition = 0;
                                    
                                            this._state = {
                                                waveform:'sine',
                                                gain_useControl:false,
                                                detune_useControl:false,
                                                dutyCycle_useControl:false,
                                            };
                                            this._envelope = {
                                                gain:{
                                                    phase:'off', // front - wait - back - off
                                                    requestedPhase:undefined,
                                    
                                                    step:0,
                                                    previous:0,
                                                    current:0,
                                    
                                                    procedure:{
                                                        index:0,
                                                        sample:0,
                                                        front:[ {destination:1, elapse:0, _elapseSamples:1} ],
                                                        back:[ {destination:0, elapse:0, _elapseSamples:1} ],
                                                    },
                                                    defaultProcedurePoint:{
                                                        front:{destination:1, elapse:0, _elapseSamples:1},
                                                        back:{destination:0, elapse:0, _elapseSamples:1},
                                                    },
                                                },
                                                detune:{
                                                    phase:'off', // front - wait - back - off
                                                    requestedPhase:undefined,
                                    
                                                    step:0,
                                                    previous:0,
                                                    current:0,
                                    
                                                    procedure:{
                                                        index:0,
                                                        sample:0,
                                                        front:[ {destination:0, elapse:0, _elapseSamples:1} ],
                                                        back:[ {destination:0, elapse:0, _elapseSamples:1} ],
                                                    },
                                                    defaultProcedurePoint:{
                                                        front:{destination:0, elapse:0, _elapseSamples:1},
                                                        back:{destination:0, elapse:0, _elapseSamples:1},
                                                    },
                                                },
                                                dutyCycle:{
                                                    phase:'off', // front - wait - back - off
                                                    requestedPhase:undefined,
                                    
                                                    step:0,
                                                    previous:0,
                                                    current:0,
                                    
                                                    procedure:{
                                                        index:0,
                                                        sample:0,
                                                        front:[ {destination:0.5, elapse:0, _elapseSamples:1} ],
                                                        back:[ {destination:0.5, elapse:0, _elapseSamples:1} ],
                                                    },
                                                    defaultProcedurePoint:{
                                                        front:{destination:0.5, elapse:0, _elapseSamples:1},
                                                        back:{destination:0.5, elapse:0, _elapseSamples:1},
                                                    },
                                                },
                                            };
                                    
                                            this.port.onmessage = function(event){
                                                Object.entries(event.data).forEach(([key,value]) => {
                                                    switch(key){
                                                        case 'command':
                                                            switch(value){
                                                                case 'start':
                                                                    Object.keys(self._envelope).forEach(aspect => {
                                                                        if(self._envelope[aspect].requestedPhase == 'back' || self._envelope[aspect].phase == 'back' || self._envelope[aspect].phase == 'off'){
                                                                            self._envelope[aspect].requestedPhase = 'front';
                                                                        }
                                                                    });
                                                                break;
                                                                case 'stop':
                                                                    Object.keys(self._envelope).forEach(aspect => {
                                                                        if(self._envelope[aspect].requestedPhase == 'front' || self._envelope[aspect].phase == 'front' || self._envelope[aspect].phase == 'wait'){
                                                                            self._envelope[aspect].requestedPhase = 'back';
                                                                        }
                                                                    });
                                                                break;
                                                            }
                                                        break;
                                                        case 'waveform': 
                                                            self._state.waveform = value;
                                                        break;
                                                        case 'gain_useControl': 
                                                            self._state.gain_useControl = value;
                                                        break;
                                                        case 'detune_useControl': 
                                                            self._state.detune_useControl = value;
                                                        break;
                                                        case 'dutyCycle_useControl': 
                                                            self._state.dutyCycle_useControl = value;
                                                        break;
                                                        case 'gain_envelope':
                                                            Object.entries(value).forEach(([phase,points]) => {
                                                                if( points != undefined && points.length != 0 ){
                                                                    self._envelope.gain.procedure[phase] = points.map(point => {
                                                                        return {
                                                                            destination:point.destination, 
                                                                            elapse:point.elapse, 
                                                                            _elapseSamples:point.elapse == 0 ? 1 : sampleRate*point.elapse
                                                                        };
                                                                    });
                                                                }else{
                                                                    self._envelope.gain.procedure[phase] = [self._envelope.gain.defaultProcedurePoint[phase]];
                                                                }
                                                            });
                                                        break;
                                                        case 'detune_envelope':
                                                            Object.entries(value).forEach(([phase,points]) => {
                                                                if( points != undefined && points.length != 0 ){
                                                                    self._envelope.detune.procedure[phase] = points.map(point => {
                                                                        return {
                                                                            destination:point.destination, 
                                                                            elapse:point.elapse, 
                                                                            _elapseSamples:point.elapse == 0 ? 1 : sampleRate*point.elapse
                                                                        };
                                                                    });
                                                                }else{
                                                                    self._envelope.detune.procedure[phase] = [self._envelope.detune.defaultProcedurePoint[phase]];
                                                                }
                                                            });
                                                        break;
                                                        case 'dutyCycle_envelope':
                                                            Object.entries(value).forEach(([phase,points]) => {
                                                                if( points != undefined && points.length != 0 ){
                                                                    self._envelope.dutyCycle.procedure[phase] = points.map(point => {
                                                                        return {
                                                                            destination:point.destination, 
                                                                            elapse:point.elapse, 
                                                                            _elapseSamples:point.elapse == 0 ? 1 : sampleRate*point.elapse
                                                                        };
                                                                    });
                                                                }else{
                                                                    self._envelope.dutyCycle.procedure[phase] = [self._envelope.dutyCycle.defaultProcedurePoint[phase]];
                                                                }
                                                            });
                                                        break;
                                                    }
                                                });
                                            };
                                            this.port.start();
                                        }
                                    
                                        process(inputs, outputs, parameters){
                                            //envelope activation
                                                this.activatePhase();
                                                if( this._envelope.gain.phase == 'off'){ return true; }
                                    
                                            //io
                                                const output = outputs[0];
                                                const gainControl = inputs[0]; 
                                                const detuneControl = inputs[1];
                                                const dutyCycleControl = inputs[2];
                                    
                                            //oscillation generation
                                                const frequency_useFirstOnly = parameters.frequency.length == 1;
                                                const dutyCycle_useFirstOnly = parameters.dutyCycle.length == 1;
                                                const detune_useFirstOnly = parameters.detune.length == 1;
                                                const gain_useFirstOnly = parameters.gain.length == 1;
                                    
                                                for(let channel = 0; channel < output.length; channel++){
                                                    for(let a = 0; a < output[channel].length; a++){
                                                        //envelope calculation
                                                            Object.keys(this._envelope).forEach(aspect => {
                                                                if(this._envelope[aspect].phase == 'front' || this._envelope[aspect].phase == 'back'){
                                                                    if( currentFrame+a - this._envelope[aspect].procedure.sample >= this._envelope[aspect].procedure[this._envelope[aspect].phase][this._envelope[aspect].procedure.index]._elapseSamples ){
                                                                        this._envelope[aspect].procedure.index++;
                                                                        this._envelope[aspect].procedure.sample = currentFrame+a;
                                                                        if( this._envelope[aspect].procedure.index >= this._envelope[aspect].procedure[this._envelope[aspect].phase].length){
                                                                            if(this._envelope[aspect].phase == 'front'){
                                                                                this._envelope[aspect].phase = 'wait';
                                                                                this.reportPhase(aspect);
                                                                                this._envelope[aspect].step = 0;
                                                                            }else if(this._envelope[aspect].phase == 'back'){
                                                                                this._envelope[aspect].phase = 'off';
                                                                                this.reportPhase(aspect);
                                                                                this._envelope[aspect].step = 0;
                                                                            }
                                                                        }else{
                                                                            this._envelope[aspect].previous = this._envelope[aspect].current;
                                                                            this._envelope[aspect].step = (this._envelope[aspect].procedure[this._envelope[aspect].phase][this._envelope[aspect].procedure.index].destination - this._envelope[aspect].previous)/this._envelope[aspect].procedure[this._envelope[aspect].phase][this._envelope[aspect].procedure.index]._elapseSamples;                    
                                                                        }
                                                                    }
                                                                }
                                                                this._envelope[aspect].current += this._envelope[aspect].step;
                                                            });
                                    
                                                        //aspect calculation
                                                            const gain = this._envelope.gain.current * (this._state.gain_useControl ? gainControl[channel][a] : (gain_useFirstOnly ? parameters.gain[0] : parameters.gain[a]));
                                                            const detune = this._envelope.detune.current + (this._state.detune_useControl ? detuneControl[channel][a] : (detune_useFirstOnly ? parameters.detune[0] : parameters.detune[a]));
                                                            const dutyCycle = this._envelope.dutyCycle.current + (this._state.dutyCycle_useControl ? dutyCycleControl[channel][a] : (dutyCycle_useFirstOnly ? parameters.dutyCycle[0] : parameters.dutyCycle[a]));
                                    
                                                        //wave calculation
                                                            const frequency = frequency_useFirstOnly ? parameters.frequency[0] : parameters.frequency[a];
                                                            this._wavePosition += (frequency*(detune*oscillator2.detuneMux + 1))/sampleRate;
                                                            const localWavePosition = this._wavePosition % 1;
                                    
                                                            switch(this._state.waveform){
                                                                case 'sine':
                                                                    output[channel][a] = gain*Math.sin( localWavePosition * oscillator2.twoPI );
                                                                break;
                                                                case 'square':
                                                                    output[channel][a] = gain*(localWavePosition < dutyCycle ? 1 : -1);
                                                                break;
                                                                case 'triangle':
                                                                    if(localWavePosition < dutyCycle/2){
                                                                        output[channel][a] = gain*(2*localWavePosition / dutyCycle);
                                                                    }else if(localWavePosition >= 1 - dutyCycle/2){
                                                                        output[channel][a] = gain*((2*localWavePosition - 2) / dutyCycle);
                                                                    }else{
                                                                        output[channel][a] = gain*((2*localWavePosition - 1) / (dutyCycle - 1));
                                                                    }
                                                                break;
                                                                case 'noise': default: 
                                                                    output[channel][a] = gain*(Math.random()*2 - 1);
                                                                break;
                                                            }
                                                    }
                                                }
                                    
                                            return true;
                                        }
                                    
                                        activatePhase(){
                                            Object.keys(this._envelope).forEach(aspect => {
                                                if( this._envelope[aspect].requestedPhase != undefined && this._envelope[aspect].requestedPhase != this._envelope[aspect].phase ){
                                                    this._envelope[aspect].phase = this._envelope[aspect].requestedPhase;
                                                    this.reportPhase(aspect);
                                                    this._envelope[aspect].requestedPhase = undefined;
                                                    this._envelope[aspect].procedure.sample = currentFrame;
                                                    this._envelope[aspect].procedure.index = 0;
                                                    this._envelope[aspect].previous = this._envelope[aspect].current;
                                                    this._envelope[aspect].step = (this._envelope[aspect].procedure[this._envelope[aspect].phase][this._envelope[aspect].procedure.index].destination - this._envelope[aspect].previous)/this._envelope[aspect].procedure[this._envelope[aspect].phase][this._envelope[aspect].procedure.index]._elapseSamples;
                                                    if( aspect == 'gain' && this._envelope.gain.phase == 'start' ){ this._wavePosition = 0; }
                                                }
                                            });
                                        }
                                    
                                        reportPhase(aspect){
                                            const self = this;
                                            this.port.postMessage(
                                                (() => {
                                                    const tmp = {};
                                                    tmp[aspect+'_phase'] = self._envelope[aspect].phase;
                                                    return tmp;
                                                })()
                                            );
                                        }
                                    }
                                    registerProcessor('oscillator2', oscillator2);
                                `], { type: "text/javascript" }),
                                class:
                                    class oscillator2 extends AudioWorkletNode{
                                        constructor(context, options={}){
                                            options.numberOfInputs = 3;
                                            options.numberOfOutputs = 1;
                                            options.channelCount = 1;
                                            super(context, 'oscillator2', options);
                                            const self = this;
                                    
                                            this._state = {
                                                waveform:'sine',
                                                gain_useControl:false,
                                                detune_useControl:false,
                                                dutyCycle_useControl:false,
                                            };
                                            this._gainEnvelope = {
                                                front:[ {destination:1, elapse:0} ],
                                                back:[ {destination:0, elapse:0} ],
                                            };
                                    
                                            this.port.onmessage = function(event){
                                                if(self.onEnvelopeEvent == undefined){ return; }
                                                self.onEnvelopeEvent(event.data.gain_phase);
                                            };
                                    
                                            this.start = function(){
                                                this.port.postMessage({command:'start'});
                                            };
                                            this.stop = function(){
                                                this.port.postMessage({command:'stop'});
                                            };
                                    
                                            this.onEnvelopeEvent = function(){};
                                        }
                                    
                                    
                                        get frequency(){
                                            return this.parameters.get('frequency');
                                        }
                                        get gain(){
                                            return this.parameters.get('gain');
                                        }
                                        get detune(){
                                            return this.parameters.get('detune');
                                        }
                                        get dutyCycle(){
                                            return this.parameters.get('dutyCycle');
                                        }
                                    
                                    
                                        get waveform(){
                                            return this._waveform;
                                        }
                                        set waveform(value){
                                            this._state.waveform = value;
                                            this.port.postMessage({waveform:value});
                                        }
                                        get gain_useControl(){
                                            return this._state.gain_useControl;
                                        }
                                        set gain_useControl(bool){
                                            this._state.gain_useControl = bool;
                                            this.port.postMessage({gain_useControl:bool});
                                        }
                                        get detune_useControl(){
                                            return this._state.detune_useControl;
                                        }
                                        set detune_useControl(bool){
                                            this._state.detune_useControl = bool;
                                            this.port.postMessage({detune_useControl:bool});
                                        }
                                        get dutyCycle_useControl(){
                                            return this._state.dutyCycle_useControl;
                                        }
                                        set dutyCycle_useControl(bool){
                                            this._state.dutyCycle_useControl = bool;
                                            this.port.postMessage({dutyCycle_useControl:bool});
                                        }
                                    
                                        
                                        get gain_envelope(){
                                            return JSON.parse(JSON.stringify(this.gain_envelope));
                                        }
                                        set gain_envelope(newEnvelope){
                                            this._gainEnvelope = newEnvelope;
                                            this.port.postMessage({gain_envelope:newEnvelope});
                                        }
                                        get detune_envelope(){
                                            return JSON.parse(JSON.stringify(this.detune_envelope));
                                        }
                                        set detune_envelope(newEnvelope){
                                            this._detuneEnvelope = newEnvelope;
                                            this.port.postMessage({detune_envelope:newEnvelope});
                                        }
                                        get dutyCycle_envelope(){
                                            return JSON.parse(JSON.stringify(this.dutyCycle_envelope));
                                        }
                                        set dutyCycle_envelope(newEnvelope){
                                            this._dutyCycleEnvelope = newEnvelope;
                                            this.port.postMessage({dutyCycle_envelope:newEnvelope});
                                        }
                                    }
                                ,
                            },
                            {
                                name:'streamAdder',
                                worklet:new Blob([`
                                    class streamAdder extends AudioWorkletProcessor{
                                        static get parameterDescriptors(){
                                            return [
                                                {
                                                    name: 'mode',
                                                    defaultValue: 0, // 0 - manual / 1 - automatic
                                                    minValue: 0,
                                                    maxValue: 1,
                                                    automationRate: 'k-rate',
                                                },{
                                                    name: 'mix',
                                                    defaultValue: 0,
                                                    minValue: 0,
                                                    maxValue: 1,
                                                    automationRate: 'a-rate',
                                                }
                                            ];
                                        }
                                        
                                        constructor(options){
                                            super(options);
                                        }
                                    
                                        process(inputs, outputs, parameters){
                                            const input_1 = inputs[0];
                                            const input_2 = inputs[1];
                                            const mixControl = inputs[2];
                                            const output = outputs[0];
                                    
                                            const mix_useFirstOnly = parameters.mix.length == 1;
                                    
                                            for(let channel = 0; channel < output.length; channel++){
                                                for(let a = 0; a < output[channel].length; a++){
                                                    const mix = parameters.mode[0] == 0 ? (mix_useFirstOnly ? parameters.mix[0] : parameters.mix[a]) : (mixControl[channel][a]+1)/2;
                                                    output[channel][a] = input_1[channel][a]*(1-mix) + input_2[channel][a]*mix;
                                                }
                                            }
                                    
                                            return true;
                                        }
                                    }
                                    registerProcessor('streamAdder', streamAdder);
                                `], { type: "text/javascript" }),
                                class:
                                    class streamAdder extends AudioWorkletNode{
                                        constructor(context, options={}){
                                            options.numberOfInputs = 3;
                                            options.numberOfOutputs = 1;
                                            options.channelCount = 1;
                                            super(context, 'streamAdder', options);
                                    
                                            this._mode = false;
                                        }
                                    
                                        get mode(){
                                            return this._mode;
                                        }
                                        set mode(value){
                                            this._mode = value;
                                            this.parameters.get('mode').setValueAtTime(this._mode?1:0,0);
                                        }
                                        get mix(){
                                            return this.parameters.get('mix');
                                        }
                                    }
                                ,
                            },
                            {
                                name:'frequencyAmplitudeResponseAnalyser',
                                worklet:new Blob([`
                                    // class frequencyAmplitudeResponseAnalyser extends AudioWorkletProcessor{
                                    //     static twoPI = Math.PI*2;
                                    
                                    //     static get parameterDescriptors(){
                                    //         return [];
                                    //     }
                                    
                                    //     #state = {
                                    //         signalGeneratorGain:1,
                                    //         waveform:0,
                                    //         dutyCycle:0.5,
                                    //         frequency:{
                                    //             current:100,
                                    //             range:{ start:100, end:1000 },
                                    //             stepSize:10,
                                    //             timePerStep:0.005
                                    //         },
                                    //         responseData: [],
                                    //     };
                                    //     #wavePosition = 0;
                                    //     #lastUpdate = 0;
                                    //     #start = false;
                                    //     #active = false;
                                    //     #stepData = [];
                                    
                                    //     constructor(options){
                                    //         super(options);
                                    //         const self = this;
                                    
                                    //         this.port.onmessage = function(event){
                                    //             if(event.data == 'stop'){
                                    //                 self._active = false;
                                    //                 return;
                                    //             }
                                    
                                    //             if(self._active){ return; }
                                    
                                    //             if(event.data == 'start'){
                                    //                 self._start = true;
                                    //                 self._active = true;
                                    //                 return;
                                    //             }
                                    //             if(event.data == 'clear'){
                                    //                 this._state.responseData = [];
                                    //                 this._stepData = [];
                                    //                 this._wavePosition = 0;
                                    //                 return;
                                    //             }
                                    
                                    //             Object.entries(event.data).forEach(([key,value]) => {
                                    //                 switch(key){
                                    //                     case 'waveform': self._state.waveform = value; break;
                                    //                     case 'signalGeneratorGain': self._state.signalGeneratorGain = value; break;
                                    //                     case 'dutyCycle': self._state.dutyCycle = value; break;
                                    
                                    //                     case 'range.start': self._state.frequency.range.start = value; break;
                                    //                     case 'range.end': self._state.frequency.range.end = value; break;
                                    //                     case 'stepSize': self._state.frequency.stepSize = value; break;
                                    //                     case 'timePerStep': self._state.frequency.timePerStep = value; break;
                                    //                 }
                                    //             });
                                    //         };
                                    //         this.port.start();
                                    //     }
                                    
                                    //     process(inputs, outputs, parameters){
                                    //         if(!this._active){ return true; }
                                    
                                    //         if(this._start){
                                    //             this._state.frequency.current = this._state.frequency.range.start;
                                    //             this._start = false;
                                    //             this._lastUpdate = currentTime;
                                    //         }
                                    
                                            
                                    
                                    //         //generator
                                    //             const output = outputs[0];
                                    
                                    //             const gain = this._state.signalGeneratorGain;
                                    //             const frequency = this._state.frequency.current;
                                    //             const dutyCycle = this._state.frequency.dutyCycle;
                                    
                                    //             for(let channel = 0; channel < output.length; channel++){
                                    //                 for(let a = 0; a < output[channel].length; a++){
                                    
                                    //                     this._wavePosition += frequency/sampleRate;
                                    //                     const localWavePosition = this._wavePosition % 1;
                                    
                                    //                     switch(this._state.waveform){
                                    //                         case 0: //sin
                                    //                             output[channel][a] = gain*Math.sin( localWavePosition * frequencyAmplitudeResponseAnalyser.twoPI );
                                    //                         break;
                                    //                         case 1: //square
                                    //                             output[channel][a] = gain*(localWavePosition < dutyCycle ? 1 : -1);
                                    //                         break;
                                    //                         case 2: //triangle
                                    //                             if(localWavePosition < dutyCycle/2){
                                    //                                 output[channel][a] = gain*(2*localWavePosition / dutyCycle);
                                    //                             }else if(localWavePosition >= 1 - dutyCycle/2){
                                    //                                 output[channel][a] = gain*((2*localWavePosition - 2) / dutyCycle);
                                    //                             }else{
                                    //                                 output[channel][a] = gain*((2*localWavePosition - 1) / (dutyCycle - 1));
                                    //                             }
                                    //                         break;
                                    //                     }
                                    //                 }
                                    //             }
                                    
                                    //         //collector
                                    //             const input = inputs[0];
                                    //             this._stepData.push(...input[0]);
                                                
                                    
                                    
                                    //         if( currentTime - this._lastUpdate > this._state.frequency.timePerStep ){
                                    //             this._lastUpdate = currentTime;
                                    
                                    //             const result = {
                                    //                 frequency:this._state.frequency.current,
                                    //                 response:Math.max(...(this._stepData).map(a => Math.abs(a)) )
                                    //             };
                                    //             this.port.postMessage({ onValue:result });
                                    //             this._state.responseData.push(result);
                                    //             this._stepData = [];
                                    
                                    //             this._state.frequency.current += this._state.frequency.stepSize;
                                    //             if( this._state.frequency.current > this._state.frequency.range.end ){
                                    //                 this.port.postMessage({ onCompletion:this._state.responseData });
                                    //                 this._active = false;
                                    //             }
                                    //         }
                                    
                                    //         return true;
                                    //     }
                                    // }
                                    // registerProcessor('frequencyAmplitudeResponseAnalyser', frequencyAmplitudeResponseAnalyser);
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    class frequencyAmplitudeResponseAnalyser extends AudioWorkletProcessor{
                                        static twoPI = Math.PI*2;
                                    
                                        static get parameterDescriptors(){
                                            return [];
                                        }
                                    
                                        constructor(options){
                                            super(options);
                                            const self = this;
                                    
                                            this._state = {
                                                signalGeneratorGain:1,
                                                waveform:'sine',
                                                dutyCycle:0.5,
                                                frequency:{
                                                    current:100,
                                                    range:{ start:100, end:1000 },
                                                    stepSize:10,
                                                    timePerStep:0.005
                                                },
                                                responseData: [],
                                            };
                                            this._wavePosition = 0;
                                            this._lastUpdate = 0;
                                            this._start = false;
                                            this._active = false;
                                            this._stepData = [];
                                    
                                            this.port.onmessage = function(event){
                                                if(event.data == 'stop'){
                                                    self.port.postMessage({ onCompletion:self._state.responseData });
                                                    self._active = false;
                                                    return;
                                                }
                                    
                                                if(self._active){ return; }
                                    
                                                if(event.data == 'start'){
                                                    self._start = true;
                                                    self._active = true;
                                                    return;
                                                }
                                                if(event.data == 'clear'){
                                                    self._state.responseData = [];
                                                    self._stepData = [];
                                                    self._wavePosition = 0;
                                                    return;
                                                }
                                    
                                                Object.entries(event.data).forEach(([key,value]) => {
                                                    switch(key){
                                                        case 'waveform': self._state.waveform = value; break;
                                                        case 'signalGeneratorGain': self._state.signalGeneratorGain = value; break;
                                                        case 'dutyCycle': self._state.dutyCycle = value; break;
                                    
                                                        case 'range.start': self._state.frequency.range.start = value; break;
                                                        case 'range.end': self._state.frequency.range.end = value; break;
                                                        case 'stepSize': self._state.frequency.stepSize = value; break;
                                                        case 'timePerStep': self._state.frequency.timePerStep = value; break;
                                                    }
                                                });
                                            };
                                            this.port.start();
                                        }
                                    
                                        process(inputs, outputs, parameters){
                                            if(!this._active){ return true; }
                                    
                                            if(this._start){
                                                this._state.frequency.current = this._state.frequency.range.start;
                                                this._start = false;
                                                this._lastUpdate = currentTime;
                                            }
                                    
                                            
                                    
                                            //generator
                                                const output = outputs[0];
                                    
                                                const gain = this._state.signalGeneratorGain;
                                                const frequency = this._state.frequency.current;
                                                const dutyCycle = this._state.dutyCycle;
                                    
                                                for(let channel = 0; channel < output.length; channel++){
                                                    for(let a = 0; a < output[channel].length; a++){
                                    
                                                        this._wavePosition += frequency/sampleRate;
                                                        const localWavePosition = this._wavePosition % 1;
                                    
                                                        switch(this._state.waveform){
                                                            case 'sine':
                                                                output[channel][a] = gain*Math.sin( localWavePosition * frequencyAmplitudeResponseAnalyser.twoPI );
                                                            break;
                                                            case 'square':
                                                                output[channel][a] = gain*(localWavePosition < dutyCycle ? 1 : -1);
                                                            break;
                                                            case 'triangle':
                                                                if(localWavePosition < dutyCycle/2){
                                                                    output[channel][a] = gain*(2*localWavePosition / dutyCycle);
                                                                }else if(localWavePosition >= 1 - dutyCycle/2){
                                                                    output[channel][a] = gain*((2*localWavePosition - 2) / dutyCycle);
                                                                }else{
                                                                    output[channel][a] = gain*((2*localWavePosition - 1) / (dutyCycle - 1));
                                                                }
                                                            break;
                                                        }
                                                    }
                                                }
                                    
                                            //collector
                                                const input = inputs[0];
                                                this._stepData.push(...input[0]);
                                                
                                    
                                    
                                            if( currentTime - this._lastUpdate > this._state.frequency.timePerStep ){
                                                this._lastUpdate = currentTime;
                                    
                                                const result = {
                                                    frequency:this._state.frequency.current,
                                                    response:Math.max(...(this._stepData).map(a => Math.abs(a)) )
                                                };
                                                this.port.postMessage({ onValue:result });
                                                this._state.responseData.push(result);
                                                this._stepData = [];
                                    
                                                this._state.frequency.current += this._state.frequency.stepSize;
                                                if( this._state.frequency.current > this._state.frequency.range.end ){
                                                    this.port.postMessage({ onCompletion:this._state.responseData });
                                                    this._active = false;
                                                }
                                            }
                                    
                                            return true;
                                        }
                                    }
                                    registerProcessor('frequencyAmplitudeResponseAnalyser', frequencyAmplitudeResponseAnalyser);
                                `], { type: "text/javascript" }),
                                class:
                                    // class frequencyAmplitudeResponseAnalyser extends AudioWorkletNode{
                                    //     #state = {
                                    //         waveform:0,
                                    //         signalGeneratorGain:1,
                                    //         dutyCycle:0.5,
                                    //         frequency:{
                                    //             range:{ start:100, end:1000 },
                                    //             stepSize:10,
                                    //             timePerStep:0.005,
                                    //         },
                                    //     };
                                    
                                    //     constructor(context, options={}){
                                    //         options.numberOfInputs = 1;
                                    //         options.numberOfOutputs = 1;
                                    //         options.channelCount = 1;
                                    //         super(context, 'frequencyAmplitudeResponseAnalyser', options);
                                    //         const self = this;
                                    
                                    //         this.port.onmessage = function(event){
                                    //             Object.entries(event.data).forEach(([key,value]) => {
                                    //                 switch(key){
                                    //                     case 'onValue':
                                    //                         if(self.onValue != undefined){ self.onValue(value); }
                                    //                     break;
                                    //                     case 'onCompletion':
                                    //                         if(self.onCompletion != undefined){ self.onCompletion(value); }
                                    //                     break;
                                    //                 }
                                    //             });
                                    //         };
                                    
                                    //         this.start = function(){
                                    //             this.port.postMessage('start');
                                    //         };
                                    //         this.stop = function(){
                                    //             this.port.postMessage('stop');
                                    //         };
                                    //         this.clear = function(){
                                    //             this.port.postMessage('clear');
                                    //         };
                                    
                                    //         this.onValue = function(){};
                                    //         this.onCompletion = function(){};
                                    //     }
                                    
                                    //     get waveform(){
                                    //         return this._state.waveform;
                                    //     }
                                    //     set waveform(value){
                                    //         this._state.waveform = value;
                                    //         this.port.postMessage({waveform:value});
                                    //     }
                                    
                                    //     get signalGeneratorGain(){
                                    //         return this._state.signalGeneratorGain;
                                    //     }
                                    //     set signalGeneratorGain(value){
                                    //         this._state.signalGeneratorGain = value;
                                    //         this.port.postMessage({signalGeneratorGain:value});
                                    //     }
                                    
                                    //     get dutyCycle(){
                                    //         return this._state.dutyCycle;
                                    //     }
                                    //     set dutyCycle(value){
                                    //         this._state.dutyCycle = value;
                                    //         this.port.postMessage({dutyCycle:value});
                                    //     }
                                    
                                    //     get range(){
                                    //         return this._state.frequency.range;
                                    //     }
                                    //     set range(value){
                                    //         if(value.start == undefined){
                                    //             value.start = this._state.frequency.range.start;
                                    //         }
                                    //         if(value.end == undefined){
                                    //             value.end = this._state.frequency.range.end;
                                    //         }
                                    
                                    //         this._state.frequency.range = value;
                                    //         this.port.postMessage({
                                    //             'range.start':this._state.frequency.range.start,
                                    //             'range.end':this._state.frequency.range.end,
                                    //         });
                                    //     }
                                    
                                    //     get stepSize(){ 
                                    //         return this._state.frequency.stepSize;
                                    //     }
                                    //     set stepSize(value){
                                    //         this._state.frequency.stepSize = value;
                                    //         this.port.postMessage({stepSize:value});
                                    //     }
                                    
                                    //     get timePerStep(){ 
                                    //         return this._state.frequency.timePerStep;
                                    //     }
                                    //     set timePerStep(value){
                                    //         this._state.frequency.timePerStep = value;
                                    //         this.port.postMessage({timePerStep:value});
                                    //     }
                                    // }
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    class frequencyAmplitudeResponseAnalyser extends AudioWorkletNode{
                                        constructor(context, options={}){
                                            options.numberOfInputs = 1;
                                            options.numberOfOutputs = 1;
                                            options.channelCount = 1;
                                            super(context, 'frequencyAmplitudeResponseAnalyser', options);
                                            const self = this;
                                    
                                            this._state = {
                                                waveform:'sine',
                                                signalGeneratorGain:1,
                                                dutyCycle:0.5,
                                                frequency:{
                                                    range:{ start:100, end:1000 },
                                                    stepSize:10,
                                                    timePerStep:0.005,
                                                },
                                            };
                                    
                                            this.port.onmessage = function(event){
                                                Object.entries(event.data).forEach(([key,value]) => {
                                                    switch(key){
                                                        case 'onValue':
                                                            if(self.onValue != undefined){ self.onValue(value); }
                                                        break;
                                                        case 'onCompletion':
                                                            if(self.onCompletion != undefined){ self.onCompletion(value); }
                                                        break;
                                                    }
                                                });
                                            };
                                    
                                            this.start = function(){
                                                this.port.postMessage('start');
                                            };
                                            this.stop = function(){
                                                this.port.postMessage('stop');
                                            };
                                            this.clear = function(){
                                                this.port.postMessage('clear');
                                            };
                                    
                                            this.onValue = function(){};
                                            this.onCompletion = function(){};
                                        }
                                    
                                        get waveform(){
                                            return this._state.waveform;
                                        }
                                        set waveform(value){
                                            this._state.waveform = value;
                                            this.port.postMessage({waveform:value});
                                        }
                                    
                                        get signalGeneratorGain(){
                                            return this._state.signalGeneratorGain;
                                        }
                                        set signalGeneratorGain(value){
                                            this._state.signalGeneratorGain = value;
                                            this.port.postMessage({signalGeneratorGain:value});
                                        }
                                    
                                        get dutyCycle(){
                                            return this._state.dutyCycle;
                                        }
                                        set dutyCycle(value){
                                            this._state.dutyCycle = value;
                                            this.port.postMessage({dutyCycle:value});
                                        }
                                    
                                        get range(){
                                            return this._state.frequency.range;
                                        }
                                        set range(value){
                                            if(value.start == undefined){
                                                value.start = this._state.frequency.range.start;
                                            }
                                            if(value.end == undefined){
                                                value.end = this._state.frequency.range.end;
                                            }
                                    
                                            this._state.frequency.range = value;
                                            this.port.postMessage({
                                                'range.start':this._state.frequency.range.start,
                                                'range.end':this._state.frequency.range.end,
                                            });
                                        }
                                    
                                        get stepSize(){ 
                                            return this._state.frequency.stepSize;
                                        }
                                        set stepSize(value){
                                            this._state.frequency.stepSize = value;
                                            this.port.postMessage({stepSize:value});
                                        }
                                    
                                        get timePerStep(){ 
                                            return this._state.frequency.timePerStep;
                                        }
                                        set timePerStep(value){
                                            this._state.frequency.timePerStep = value;
                                            this.port.postMessage({timePerStep:value});
                                        }
                                    }
                                ,
                            },

                            {
                                name:'testWorkerNode',
                                worklet:new Blob([`
                                    class testWorklet extends AudioWorkletProcessor{
                                        static MinimumValue = -10;
                                    
                                        #privateValue = 100;
                                    
                                        static get parameterDescriptors(){
                                            return [
                                                {
                                                    name: 'valueA',
                                                    defaultValue: 10,
                                                    minValue: 1,
                                                    maxValue: 100,
                                                    automationRate: 'a-rate', //you should use the array, it's the same length as the block
                                                },{
                                                    name: 'valueB',
                                                    defaultValue: 10,
                                                    minValue: 1,
                                                    maxValue: 100,
                                                    automationRate: 'k-rate', //you should use only the first value in the array
                                                }
                                            ];
                                        }
                                        
                                        constructor(options){
                                            super(options);
                                            console.log('<<< constructor >>>');
                                            console.log('options:',options);
                                    
                                            this._lastUpdate = currentTime;
                                            this._callCount = 0;
                                    
                                            this.port.onmessage = function(event){
                                                console.log('worklet.port.onmessage',event);
                                            };
                                        }
                                    
                                        process(inputs, outputs, parameters){
                                            this._callCount++;
                                            if( currentTime - this._lastUpdate >= 1 ){
                                                console.log('<<< process >>>');
                                                console.log('currentTime:',currentTime);
                                                console.log('currentFrame:',currentFrame);
                                                console.log('calls since last printing:',this._callCount);
                                                console.log('samples since last printing:',this._callCount*outputs[0][0].length);
                                                console.log(' - number of inputs:',inputs.length);
                                                inputs.forEach((input,index) => {
                                                    console.log('   '+index+' : streams:',input.length,': samples per stream:',input.map(a => a.length));
                                                });
                                                console.log(' - number of outputs:',outputs.length);
                                                outputs.forEach((output,index) => {
                                                    console.log('   '+index+' : streams:',output.length,': samples per stream:',output.map(a => a.length));
                                                });
                                    
                                                console.log( 'parameters:',parameters );
                                                console.log( 'parameters.valueA:',parameters.valueA );
                                                console.log( 'parameters.valueB:',parameters.valueB );
                                    
                                                // console.log( testWorklet.MinimumValue );
                                                // console.log( this.#privateValue );
                                    
                                                this._lastUpdate = currentTime;
                                                this._callCount = 0;
                                                return false;
                                            }
                                    
                                            const input = inputs[0];
                                            const output = outputs[0];
                                        
                                            for(let channel = 0; channel < input.length; channel++){
                                                const inputChannel = input[channel];
                                                const outputChannel = output[channel];
                                        
                                                for(let a = 0; a < inputChannel.length; a++){
                                                    outputChannel[a] = inputChannel[a];
                                                }
                                            }
                                            return true;
                                        }
                                    }
                                    registerProcessor('testWorklet', testWorklet);
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    // class squareWaveGenerator extends AudioWorkletProcessor{
                                    //     static get parameterDescriptors(){
                                    //         return [];
                                    //     }
                                    
                                    //     constructor(options){
                                    //         super(options);
                                    //         this._frequency = 440;
                                    //         this._phaseMux = (2*this._frequency) / sampleRate;
                                    //     }
                                    
                                    //     process(inputs, outputs, parameters){
                                    //         const output = outputs[0];
                                            
                                    //         for(let channel = 0; channel < output.length; channel++){
                                    //             for(let a = 0; a < output[channel].length; a++){
                                    //                 output[channel][a] = Math.sin( Math.PI * this._phaseMux * (currentFrame+a) );
                                    //             }
                                    //         }
                                    //         return true;
                                    //     }
                                    // }
                                    // registerProcessor('squareWaveGenerator', squareWaveGenerator);
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    // class squareWaveGenerator extends AudioWorkletProcessor{
                                    //     static get parameterDescriptors(){
                                    //         return [];
                                    //     }
                                    
                                    //     constructor(options){
                                    //         super(options);
                                    
                                    //         this._frequency = 440;
                                    //         this._dutyCycle = 0.5;
                                    //         this._frameCount = 0;
                                    
                                    //         this._flip = false;
                                    
                                    //         // this._data = [];
                                    //     }
                                    
                                    //     process(inputs, outputs, parameters){
                                    //         const samplingRate = sampleRate;
                                    //         const output = outputs[0];
                                            
                                    //         // for(let channel = 0; channel < output.length; channel++){
                                    //         //     for(let a = 0; a < output[channel].length; a++){
                                    //         //         if( this._sampleCount >= samplingRate / (this._frequency*2) ){
                                    //         //             this._sampleCount = 0;
                                    //         //             this._flip = !this._flip;
                                    //         //         }else{
                                    //         //             this._sampleCount++; 
                                    //         //         }
                                    //         //         output[channel][a] = (this._flip ? 1 : 0) * 0.25
                                    //         //     }
                                    //         // }
                                    
                                    
                                    
                                    //         const phaseMux = (2*this._frequency) / samplingRate;
                                    //         function sineWave(sampleNumber){
                                    //             return Math.sin( Math.PI * phaseMux * sampleNumber );
                                    //         }
                                    //         for(let channel = 0; channel < output.length; channel++){
                                    //             for(let a = 0; a < output[channel].length; a++){
                                    //                 output[channel][a] = sineWave(currentFrame+a);
                                    //             }
                                    //             // this._data.push(...output[channel]);
                                    
                                    //             // if( this._sampleCount >= samplingRate ){
                                    //             //     this._sampleCount = 0;
                                    //             //     // console.log(this._data);
                                    //             //     // return false;
                                    //             // }
                                    
                                    
                                    
                                    
                                    
                                    //             // if( this._sampleCount >= 500 ){
                                    //             //     console.log( JSON.stringify(this._data) );
                                    //             //     return false;
                                    //             // }
                                    //         }
                                    
                                    
                                    
                                    
                                    //         // // for(let a = 0; a < outputs[0][0].length; a++){
                                    //         // //     this._sampleCount++;
                                    //         // // }
                                    //         // // if( this._sampleCount%44160 == 0 ){
                                    //         // //     console.log( currentTime, this._sampleCount );
                                    //         // // }
                                    //         // if( this._frameCount%345 == 0 ){
                                    //         //     console.log( currentTime, this._frameCount, samplingRate );
                                    //         // }
                                    
                                    //         // for(let channel = 0; channel < output.length; channel++){
                                    //         //     for(let a = 0; a < output[channel].length/2; a++){
                                    //         //         output[channel][a] = 1;
                                    //         //     }
                                    //         //     for(let a = output[channel].length/2; a < output[channel].length; a++){
                                    //         //         output[channel][a] = -1;
                                    //         //     }
                                    //         // }
                                    
                                    //         this._frameCount++;
                                    //         return true;
                                    //     }
                                    // }
                                    // registerProcessor('squareWaveGenerator', squareWaveGenerator);
                                    
                                    
                                    
                                    
                                    
                                    // samplingRate = 44160
                                    //1hz = a complete waveform takes 44160 samples
                                    //2hz = a complete waveform takes 22080 samples
                                    //10hz = a complete waveform takes 4416 samples
                                    //80hz = a complete waveform takes 552 samples
                                    //100hz = a complete waveform takes 441.6 samples
                                    //400hz = a complete waveform takes 110.4 samples
                                    //440hz = a complete waveform takes 100.3636... samples
                                    //480hz = a complete waveform takes 92 samples
                                    
                                    // samples that a complete waveform takes = samplingRate / frequency of wave
                                    // frequency of wave = samplingRate / samples that a complete waveform takes
                                    // frequency of wave * samples that a complete waveform takes = samplingRate
                                    
                                    // 441.6hz = a complete waveform takes 100 samples
                                    // 437.2277227722772hz = a complete waveform takes 101 samples

                                `], { type: "text/javascript" }),
                                class:
                                    class testWorkerNode extends AudioWorkletNode{
                                        constructor(context, options={}){
                                            options.numberOfInputs = 6;
                                            options.numberOfOutputs = 6;
                                            options.channelCount = 1;
                                            super(context, 'testWorklet', options);
                                    
                                            this._superImportantValue = 'farts';
                                    
                                            this.port.onmessage = function(event){
                                                console.log('worklet.node.onmessage',event);
                                            };
                                            this.port.start();
                                        }
                                    
                                        get superImportantValue(){
                                            console.log('getting super important value, which happens to be "'+this._superImportantValue+'"');
                                            return this._superImportantValue;
                                        }
                                        set superImportantValue(newValue){
                                            console.log('the super important value is being changed to "'+newValue+'"');
                                            this._superImportantValue = newValue;
                                            this.port.postMessage({ superImportantValue: this._superImportantValue });
                                        }
                                        doubleTheSuperImportantValue(){
                                            console.log('doubling the super important value');
                                            this._superImportantValue = this._superImportantValue + this._superImportantValue ;
                                            this.port.postMessage({ superImportantValue: this._superImportantValue });
                                        }
                                    }
                                ,
                            },
                            {
                                name:'squareWaveGenerator',
                                worklet:new Blob([`
                                    class squareWaveGenerator extends AudioWorkletProcessor{
                                        static get parameterDescriptors(){
                                            return [
                                                {
                                                    name: 'frequency',
                                                    defaultValue: 440,
                                                    minValue: 0,
                                                    maxValue: 20000,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'dutyCycle',
                                                    defaultValue: 0.5,
                                                    minValue: 0,
                                                    maxValue: 1,
                                                    automationRate: 'a-rate',
                                                }
                                            ];
                                        }
                                    
                                        constructor(options){
                                            super(options);
                                        }
                                    
                                        process(inputs, outputs, parameters){
                                            const output = outputs[0];
                                    
                                            const frequency_useFirstOnly = parameters.frequency.length == 1;
                                            const dutyCycle_useFirstOnly = parameters.dutyCycle.length == 1;
                                    
                                            for(let channel = 0; channel < output.length; channel++){
                                                for(let a = 0; a < output[channel].length; a++){
                                                    const frequency = frequency_useFirstOnly ? parameters.frequency[0] : parameters.frequency[a];
                                                    const dutyCycle = dutyCycle_useFirstOnly ? parameters.dutyCycle[0] : parameters.dutyCycle[a];
                                    
                                                    const overallWaveProgressPercentage = (frequency/sampleRate) * (currentFrame+a);
                                                    const waveProgress = overallWaveProgressPercentage - Math.trunc(overallWaveProgressPercentage);
                                                    output[channel][a] = waveProgress < dutyCycle ? 1 : -1;
                                                }
                                            }
                                    
                                            return true;
                                        }
                                    }
                                    registerProcessor('squareWaveGenerator', squareWaveGenerator);
                                `], { type: "text/javascript" }),
                                class:
                                    class squareWaveGenerator extends AudioWorkletNode{
                                        constructor(context, options={}){
                                            options.numberOfInputs = 0;
                                            options.numberOfOutputs = 1;
                                            options.channelCount = 1;
                                            super(context, 'squareWaveGenerator', options);
                                        }
                                    
                                        get frequency(){
                                            return this.parameters.get('frequency');
                                        }
                                        get dutyCycle(){
                                            return this.parameters.get('dutyCycle');
                                        }
                                    }
                                ,
                            },
                            //oscillatorWithMultiLevelPhaseModulation
                            {
                                name:'osc_1',
                                worklet:new Blob([`
                                    class osc_1 extends AudioWorkletProcessor{
                                        static twoPI = Math.PI*2;
                                        static starterFrequency = 440;
                                        static maxFrequency = 20000;
                                        static detuneMux = 0.1;
                                        static detuneBounds = 1/osc_1.detuneMux;
                                        static modulationSettings = [
                                            {pha:4,amp:1},
                                            {pha:3,amp:1},
                                            {pha:2,amp:1},
                                            {pha:1,amp:1},
                                        ];
                                    
                                        static get parameterDescriptors(){
                                            return [
                                                {
                                                    name: 'frequency',
                                                    defaultValue: osc_1.starterFrequency,
                                                    minValue: 0,
                                                    maxValue: osc_1.maxFrequency,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'gain',
                                                    defaultValue: 1,
                                                    minValue: -1,
                                                    maxValue: 1,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'detune',
                                                    defaultValue: 0,
                                                    minValue: -osc_1.detuneBounds,
                                                    maxValue: osc_1.detuneBounds,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'gain_mode',
                                                    defaultValue: 0, // 0 - manual / 1 - automatic
                                                    minValue: 0,
                                                    maxValue: 1,
                                                    automationRate: 'k-rate',
                                                },{
                                                    name: 'detune_mode',
                                                    defaultValue: 0, // 0 - manual / 1 - automatic
                                                    minValue: 0,
                                                    maxValue: 1,
                                                    automationRate: 'k-rate',
                                                }
                                            ];
                                        }
                                    
                                        constructor(options){
                                            super(options);
                                            this._wavePosition = 0;
                                            // this._modulationSettings = [
                                            //     {pha:4,amp:1},
                                            //     {pha:3,amp:1},
                                            //     {pha:2,amp:1},
                                            //     {pha:1,amp:1},
                                            // ];
                                    
                                            this.port.onmessage = function(event){
                                                osc_1.modulationSettings = event.data;
                                                console.log( event.data, osc_1.modulationSettings );
                                            };
                                        }
                                    
                                        process(inputs, outputs, parameters){
                                            const output = outputs[0];
                                            const gainControl = inputs[0];
                                            const detuneControl = inputs[1];
                                    
                                            const frequency_useFirstOnly = parameters.frequency.length == 1;
                                            const detune_useFirstOnly = parameters.detune.length == 1;
                                            const gain_useFirstOnly = parameters.gain.length == 1;
                                    
                                            for(let channel = 0; channel < output.length; channel++){
                                                for(let a = 0; a < output[channel].length; a++){
                                                    const gain = parameters.gain_mode[0] == 0 ? (gain_useFirstOnly ? parameters.gain[0] : parameters.gain[a]) : gainControl[channel][a];
                                                    const frequency = frequency_useFirstOnly ? parameters.frequency[0] : parameters.frequency[a];
                                                    const detune = parameters.detune_mode[0] == 0 ? (detune_useFirstOnly ? parameters.detune[0] : parameters.detune[a]) : detuneControl[channel][a];
                                    
                                                    this._wavePosition += (frequency*(detune*osc_1.detuneMux + 1))/sampleRate;
                                                    const localWavePosition = this._wavePosition % 1;
                                    
                                                    osc_1.modulationSettings.forEach( setting => {
                                                        output[channel][a] = Math.sin( osc_1.twoPI*localWavePosition*setting.pha + (Math.PI/2)*setting.amp*output[channel][a] );
                                                    } );
                                                    output[channel][a] = gain*output[channel][a];
                                                }
                                            }
                                    
                                            return true;
                                        }
                                    }
                                    registerProcessor('osc_1', osc_1);
                                `], { type: "text/javascript" }),
                                class:
                                    class osc_1 extends AudioWorkletNode{
                                        constructor(context, options={}){
                                            options.numberOfInputs = 2;
                                            options.numberOfOutputs = 1;
                                            options.channelCount = 1;
                                            super(context, 'osc_1', options);
                                    
                                            this.data = function(value){
                                                this.port.postMessage(value);
                                            };
                                        }
                                    
                                        get frequency(){
                                            return this.parameters.get('frequency');
                                        }
                                        get gain(){
                                            return this.parameters.get('gain');
                                        }
                                        get detune(){
                                            return this.parameters.get('detune');
                                        }
                                    }
                                ,
                            },
                            //oscillatorWithMultiLevelPhaseModulation
                            {
                                name:'osc_2',
                                worklet:new Blob([`
                                    class osc_2 extends AudioWorkletProcessor{
                                        static twoPI = Math.PI*2;
                                        static starterFrequency = 440;
                                        static maxFrequency = 20000;
                                        static detuneMux = 0.1;
                                        static detuneBounds = 1/osc_2.detuneMux;
                                    
                                        static get parameterDescriptors(){
                                            return [
                                                {
                                                    name: 'frequency',
                                                    defaultValue: osc_2.starterFrequency,
                                                    minValue: 0,
                                                    maxValue: osc_2.maxFrequency,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'gain',
                                                    defaultValue: 1,
                                                    minValue: -1,
                                                    maxValue: 1,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'detune',
                                                    defaultValue: 0,
                                                    minValue: -osc_2.detuneBounds,
                                                    maxValue: osc_2.detuneBounds,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'gain_mode',
                                                    defaultValue: 0, // 0 - manual / 1 - automatic
                                                    minValue: 0,
                                                    maxValue: 1,
                                                    automationRate: 'k-rate',
                                                },{
                                                    name: 'detune_mode',
                                                    defaultValue: 0, // 0 - manual / 1 - automatic
                                                    minValue: 0,
                                                    maxValue: 1,
                                                    automationRate: 'k-rate',
                                                },
                                    
                                    
                                    
                                                {
                                                    name: 'harmonic_mux_1',
                                                    defaultValue: 1,
                                                    minValue: 0,
                                                    maxValue: 32,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'harmonic_mux_2',
                                                    defaultValue: 1,
                                                    minValue: 0,
                                                    maxValue: 32,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'harmonic_power_1',
                                                    defaultValue: 1,
                                                    minValue: 0,
                                                    maxValue: 32,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'harmonic_power_2',
                                                    defaultValue: 1,
                                                    minValue: 0,
                                                    maxValue: 32,
                                                    automationRate: 'a-rate',
                                                },
                                            ];
                                        }
                                    
                                        constructor(options){
                                            super(options);
                                            this._wavePosition = 0;
                                        }
                                    
                                        process(inputs, outputs, parameters){
                                            const output = outputs[0];
                                            const gainControl = inputs[0];
                                            const detuneControl = inputs[1];
                                    
                                            const frequency_useFirstOnly = parameters.frequency.length == 1;
                                            const detune_useFirstOnly = parameters.detune.length == 1;
                                            const gain_useFirstOnly = parameters.gain.length == 1;
                                    
                                            for(let channel = 0; channel < output.length; channel++){
                                                for(let a = 0; a < output[channel].length; a++){
                                                    const gain = parameters.gain_mode[0] == 0 ? (gain_useFirstOnly ? parameters.gain[0] : parameters.gain[a]) : gainControl[channel][a];
                                                    const frequency = frequency_useFirstOnly ? parameters.frequency[0] : parameters.frequency[a];
                                                    const detune = parameters.detune_mode[0] == 0 ? (detune_useFirstOnly ? parameters.detune[0] : parameters.detune[a]) : detuneControl[channel][a];
                                    
                                                    this._wavePosition += (frequency*(detune*osc_2.detuneMux + 1))/sampleRate;
                                                    const localWavePosition = this._wavePosition % 1;
                                    
                                                    output[channel][a] = gain*parameters.harmonic_power_1[0]*Math.sin(
                                                        osc_2.twoPI*localWavePosition*parameters.harmonic_mux_1[0] + (Math.PI/2)*parameters.harmonic_power_2[0]*Math.sin(
                                                            osc_2.twoPI*localWavePosition*parameters.harmonic_mux_2[0]
                                                        )
                                                    );
                                                }
                                            }
                                    
                                            return true;
                                        }
                                    }
                                    registerProcessor('osc_2', osc_2);
                                `], { type: "text/javascript" }),
                                class:
                                    class osc_2 extends AudioWorkletNode{
                                        constructor(context, options={}){
                                            options.numberOfInputs = 2;
                                            options.numberOfOutputs = 1;
                                            options.channelCount = 1;
                                            super(context, 'osc_2', options);
                                        }
                                    
                                        get frequency(){
                                            return this.parameters.get('frequency');
                                        }
                                        get gain(){
                                            return this.parameters.get('gain');
                                        }
                                        get detune(){
                                            return this.parameters.get('detune');
                                        }
                                    
                                        get harmonic_mux_1(){
                                            return this.parameters.get('harmonic_mux_1');
                                        }
                                        get harmonic_mux_2(){
                                            return this.parameters.get('harmonic_mux_2');
                                        }
                                        get harmonic_power_1(){
                                            return this.parameters.get('harmonic_power_1');
                                        }
                                        get harmonic_power_2(){
                                            return this.parameters.get('harmonic_power_2');
                                        }
                                    }
                                ,
                            },
                            //oscillatorWithMultiLevelPhaseModulation
                            {
                                name:'osc_3',
                                worklet:new Blob([`
                                    class osc_3 extends AudioWorkletProcessor{
                                        static twoPI = Math.PI*2;
                                        static starterFrequency = 440;
                                        static maxFrequency = 20000;
                                        static detuneMux = 0.1;
                                        static detuneBounds = 1/osc_3.detuneMux;
                                        static modulationSettings = [
                                            {mux:1,power:1},
                                            {mux:1,power:1},
                                        ];
                                    
                                        static get parameterDescriptors(){
                                            return [
                                                {
                                                    name: 'frequency',
                                                    defaultValue: osc_3.starterFrequency,
                                                    minValue: 0,
                                                    maxValue: osc_3.maxFrequency,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'gain',
                                                    defaultValue: 1,
                                                    minValue: -1,
                                                    maxValue: 1,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'detune',
                                                    defaultValue: 0,
                                                    minValue: -osc_3.detuneBounds,
                                                    maxValue: osc_3.detuneBounds,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'gain_mode',
                                                    defaultValue: 0, // 0 - manual / 1 - automatic
                                                    minValue: 0,
                                                    maxValue: 1,
                                                    automationRate: 'k-rate',
                                                },{
                                                    name: 'detune_mode',
                                                    defaultValue: 0, // 0 - manual / 1 - automatic
                                                    minValue: 0,
                                                    maxValue: 1,
                                                    automationRate: 'k-rate',
                                                },
                                            ];
                                        }
                                    
                                        constructor(options){
                                            super(options);
                                            this._wavePosition = 0;
                                    
                                            this.port.onmessage = function(event){
                                                osc_3.modulationSettings = event.data;
                                                // console.log( JSON.stringify(osc_3.modulationSettings) );
                                            };
                                        }
                                    
                                        process(inputs, outputs, parameters){
                                            const output = outputs[0];
                                            const gainControl = inputs[0];
                                            const detuneControl = inputs[1];
                                    
                                            const frequency_useFirstOnly = parameters.frequency.length == 1;
                                            const detune_useFirstOnly = parameters.detune.length == 1;
                                            const gain_useFirstOnly = parameters.gain.length == 1;
                                    
                                            for(let channel = 0; channel < output.length; channel++){
                                                for(let a = 0; a < output[channel].length; a++){
                                                    const gain = parameters.gain_mode[0] == 0 ? (gain_useFirstOnly ? parameters.gain[0] : parameters.gain[a]) : gainControl[channel][a];
                                                    const frequency = frequency_useFirstOnly ? parameters.frequency[0] : parameters.frequency[a];
                                                    const detune = parameters.detune_mode[0] == 0 ? (detune_useFirstOnly ? parameters.detune[0] : parameters.detune[a]) : detuneControl[channel][a];
                                    
                                                    this._wavePosition += (frequency*(detune*osc_3.detuneMux + 1))/sampleRate;
                                                    const localWavePosition = this._wavePosition % 1;
                                    
                                                    for(let b = 0; b < osc_3.modulationSettings.length; b++){
                                                        output[channel][a] = osc_3.modulationSettings[b].power*Math.sin(
                                                            osc_3.twoPI*localWavePosition*osc_3.modulationSettings[b].mux + (Math.PI/2)*output[channel][a]
                                                        );
                                                    }
                                                    output[channel][a] = gain*output[channel][a];
                                                }
                                            }
                                    
                                            return true;
                                        }
                                    }
                                    registerProcessor('osc_3', osc_3);
                                `], { type: "text/javascript" }),
                                class:
                                    class osc_3 extends AudioWorkletNode{
                                        constructor(context, options={}){
                                            options.numberOfInputs = 3;
                                            options.numberOfOutputs = 1;
                                            options.channelCount = 1;
                                            super(context, 'osc_3', options);
                                    
                                            this._modulationSettings = [
                                                {mux:1,power:1},
                                                {mux:1,power:1},
                                            ];
                                    
                                            this.modulationSettings = function(value){
                                                if(value == undefined){ return this._modulationSettings; }
                                                this._modulationSettings = value;
                                                this.port.postMessage(value);
                                            };
                                        }
                                    
                                        get frequency(){
                                            return this.parameters.get('frequency');
                                        }
                                        get gain(){
                                            return this.parameters.get('gain');
                                        }
                                        get detune(){
                                            return this.parameters.get('detune');
                                        }
                                    }
                                ,
                            },
                            //oscillator with ASR
                            {
                                name:'osc_4',
                                worklet:new Blob([`
                                    class osc_4 extends AudioWorkletProcessor{
                                        static twoPI = Math.PI*2;
                                        static starterFrequency = 440;
                                        static maxFrequency = 20000;
                                        static detuneMux = 0.1;
                                        static detuneBounds = 1/osc_4.detuneMux;
                                    
                                        static get parameterDescriptors(){
                                            return [
                                                {
                                                    name: 'frequency',
                                                    defaultValue: osc_4.starterFrequency,
                                                    minValue: 0,
                                                    maxValue: osc_4.maxFrequency,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'gain',
                                                    defaultValue: 1,
                                                    minValue: -1,
                                                    maxValue: 1,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'detune',
                                                    defaultValue: 0,
                                                    minValue: -osc_4.detuneBounds,
                                                    maxValue: osc_4.detuneBounds,
                                                    automationRate: 'a-rate',
                                                },{
                                                    name: 'dutyCycle',
                                                    defaultValue: 0.5,
                                                    minValue: 0,
                                                    maxValue: 1,
                                                    automationRate: 'a-rate',
                                                },
                                            ];
                                        }
                                    
                                        constructor(options){
                                            super(options);
                                            const self = this;
                                            this._wavePosition = 0;
                                    
                                            this._state = {
                                                waveform:'sin',
                                                gain_useControl:false,
                                                detune_useControl:false,
                                                dutyCycle_useControl:false,
                                            };
                                            this._envelope = {
                                                phase:'off', // front - wait - back - off
                                                requestedPhase:undefined,
                                    
                                                gainStep:0,
                                                previousGain:0,
                                                currentGain:0,
                                    
                                                procedure:{
                                                    index:0,
                                                    sample:0,
                                                    front:[ {destination:1, elapse:0, _elapseSamples:1} ],
                                                    back:[ {destination:0, elapse:0, _elapseSamples:1} ],
                                                },
                                                defaultProcedurePoint:{
                                                    front:{destination:1, elapse:0, _elapseSamples:1},
                                                    back:{destination:0, elapse:0, _elapseSamples:1},
                                                },
                                            };
                                    
                                            this.port.onmessage = function(event){
                                                Object.entries(event.data).forEach(([key,value]) => {
                                                    switch(key){
                                                        case 'command':
                                                            switch(value){
                                                                case 'start':
                                                                    if(self._envelope.requestedPhase == 'back' || self._envelope.phase == 'back' || self._envelope.phase == 'off'){
                                                                        self._envelope.requestedPhase = 'front';
                                                                    }
                                                                break;
                                                                case 'stop':
                                                                    if(self._envelope.requestedPhase == 'front' || self._envelope.phase == 'front' || self._envelope.phase == 'wait'){
                                                                        self._envelope.requestedPhase = 'back';
                                                                    }
                                                                break;
                                                            }
                                                        break;
                                                        case 'waveform': 
                                                            self._state.waveform = value;
                                                        break;
                                                        case 'gain_useControl': 
                                                            self._state.gain_useControl = value;
                                                        break;
                                                        case 'detune_useControl': 
                                                            self._state.detune_useControl = value;
                                                        break;
                                                        case 'dutyCycle_useControl': 
                                                            self._state.dutyCycle_useControl = value;
                                                        break;
                                                        case 'envelope':
                                                            Object.entries(value).forEach(([phase,points]) => {
                                                                if( points != undefined && points.length != 0 ){
                                                                    self._envelope.procedure[phase] = points.map(point => {
                                                                        return {
                                                                            destination:point.destination, 
                                                                            elapse:point.elapse, 
                                                                            _elapseSamples:point.elapse == 0 ? 1 : sampleRate*point.elapse
                                                                        };
                                                                    });
                                                                }else{
                                                                    self._envelope.procedure[phase] = [self._envelope.defaultProcedurePoint[phase]];
                                                                }
                                                            });
                                                        break;
                                                    }
                                                });
                                            };
                                            this.port.start();
                                        }
                                    
                                        process(inputs, outputs, parameters){
                                            //envelope calculation
                                                this.activatePhase();
                                                if( this._envelope.phase == 'off'){ return true; }
                                    
                                            //io
                                                const output = outputs[0];
                                                const gainControl = inputs[0];
                                                const detuneControl = inputs[1];
                                                const dutyCycleControl = inputs[2];
                                    
                                            //oscillation gerneration
                                                const frequency_useFirstOnly = parameters.frequency.length == 1;
                                                const dutyCycle_useFirstOnly = parameters.dutyCycle.length == 1;
                                                const detune_useFirstOnly = parameters.detune.length == 1;
                                                const gain_useFirstOnly = parameters.gain.length == 1;
                                    
                                                for(let channel = 0; channel < output.length; channel++){
                                                    for(let a = 0; a < output[channel].length; a++){
                                                        if(this._envelope.phase == 'front' || this._envelope.phase == 'back'){
                                                            if( currentFrame+a - this._envelope.procedure.sample >= this._envelope.procedure[this._envelope.phase][this._envelope.procedure.index]._elapseSamples ){
                                                                this._envelope.procedure.index++;
                                                                this._envelope.procedure.sample = currentFrame+a;
                                                                if( this._envelope.procedure.index >= this._envelope.procedure[this._envelope.phase].length){
                                                                    if(this._envelope.phase == 'front'){
                                                                        this._envelope.phase = 'wait';
                                                                        this.port.postMessage({phase:'wait'});
                                                                        this._envelope.gainStep = 0;
                                                                    }else if(this._envelope.phase == 'back'){
                                                                        this._envelope.phase = 'off';
                                                                        this.port.postMessage({phase:'off'});
                                                                        this._envelope.gainStep = 0;
                                                                    }
                                                                }else{
                                                                    this._envelope.previousGain = this._envelope.currentGain;
                                                                    this._envelope.gainStep = (this._envelope.procedure[this._envelope.phase][this._envelope.procedure.index].destination - this._envelope.previousGain)/this._envelope.procedure[this._envelope.phase][this._envelope.procedure.index]._elapseSamples;                    
                                                                }
                                                            }
                                                        }
                                    
                                                        this._envelope.currentGain += this._envelope.gainStep;
                                    
                                                        const gain = this._envelope.currentGain * (this._state.gain_useControl ? gainControl[channel][a] : (gain_useFirstOnly ? parameters.gain[0] : parameters.gain[a]));
                                                        const frequency = frequency_useFirstOnly ? parameters.frequency[0] : parameters.frequency[a];
                                                        const detune = this._state.detune_useControl ? detuneControl[channel][a] : (detune_useFirstOnly ? parameters.detune[0] : parameters.detune[a]);
                                                        const dutyCycle = this._state.dutyCycle_useControl ? dutyCycleControl[channel][a] : (dutyCycle_useFirstOnly ? parameters.dutyCycle[0] : parameters.dutyCycle[a]);
                                    
                                                        this._wavePosition += (frequency*(detune*osc_4.detuneMux + 1))/sampleRate;
                                                        const localWavePosition = this._wavePosition % 1;
                                    
                                                        switch(this._state.waveform){
                                                            case 'sin':
                                                                output[channel][a] = gain*Math.sin( localWavePosition * osc_4.twoPI );
                                                            break;
                                                            case 'square':
                                                                output[channel][a] = gain*(localWavePosition < dutyCycle ? 1 : -1);
                                                            break;
                                                            case 'triangle':
                                                                if(localWavePosition < dutyCycle/2){
                                                                    output[channel][a] = gain*(2*localWavePosition / dutyCycle);
                                                                }else if(localWavePosition >= 1 - dutyCycle/2){
                                                                    output[channel][a] = gain*((2*localWavePosition - 2) / dutyCycle);
                                                                }else{
                                                                    output[channel][a] = gain*((2*localWavePosition - 1) / (dutyCycle - 1));
                                                                }
                                                            break;
                                                            case 'noise': default: 
                                                                output[channel][a] = gain*(Math.random()*2 - 1);
                                                            break;
                                                        }
                                                    }
                                                }
                                    
                                            return true;
                                        }
                                    
                                        activatePhase(){
                                            if( this._envelope.requestedPhase != undefined && this._envelope.requestedPhase != this._envelope.phase ){
                                                this._envelope.phase = this._envelope.requestedPhase;
                                                this.port.postMessage({phase:this._envelope.phase});
                                                this._envelope.requestedPhase = undefined;
                                                this._envelope.procedure.sample = currentFrame;
                                                this._envelope.procedure.index = 0;
                                                this._envelope.previousGain = this._envelope.currentGain;
                                                this._envelope.gainStep = (this._envelope.procedure[this._envelope.phase][this._envelope.procedure.index].destination - this._envelope.previousGain)/this._envelope.procedure[this._envelope.phase][this._envelope.procedure.index]._elapseSamples;
                                                if( this._envelope.phase == 'start' ){ this._wavePosition = 0; }
                                            }
                                        }
                                    }
                                    registerProcessor('osc_4', osc_4);
                                `], { type: "text/javascript" }),
                                class:
                                    class osc_4 extends AudioWorkletNode{
                                        constructor(context, options={}){
                                            options.numberOfInputs = 3;
                                            options.numberOfOutputs = 1;
                                            options.channelCount = 1;
                                            super(context, 'osc_4', options);
                                            const self = this;
                                    
                                            this._state = {
                                                waveform:'sin',
                                                gain_useControl:false,
                                                detune_useControl:false,
                                                dutyCycle_useControl:false,
                                            };
                                            this._envelope = {
                                                front:[
                                                    {elapse:0.5,gain:5},
                                                    {elapse:0.5,gain:1},
                                                ],
                                                back:[
                                                    {elapse:0.5,gain:5},
                                                    {elapse:0.5,gain:0}
                                                ],
                                            };
                                    
                                            this.port.onmessage = function(event){
                                                if(self.onEnvelopeEvent == undefined){ return; }
                                                self.onEnvelopeEvent(event.data.phase);
                                            };
                                    
                                            this.start = function(){
                                                this.port.postMessage({command:'start'});
                                            };
                                            this.stop = function(){
                                                this.port.postMessage({command:'stop'});
                                            };
                                    
                                            this.onEnvelopeEvent = function(data){console.log(data);};
                                        }
                                    
                                    
                                    
                                    
                                        get frequency(){
                                            return this.parameters.get('frequency');
                                        }
                                        get gain(){
                                            return this.parameters.get('gain');
                                        }
                                        get detune(){
                                            return this.parameters.get('detune');
                                        }
                                        get dutyCycle(){
                                            return this.parameters.get('dutyCycle');
                                        }
                                    
                                    
                                    
                                    
                                        get waveform(){
                                            return this._waveform;
                                        }
                                        set waveform(value){
                                            this._state.waveform = value;
                                            this.port.postMessage({waveform:value});
                                        }
                                        get gain_useControl(){
                                            return this._state.gain_useControl;
                                        }
                                        set gain_useControl(bool){
                                            this._state.gain_useControl = bool;
                                            this.port.postMessage({gain_useControl:bool});
                                        }
                                        get detune_useControl(){
                                            return this._state.detune_useControl;
                                        }
                                        set detune_useControl(bool){
                                            this._state.detune_useControl = bool;
                                            this.port.postMessage({detune_useControl:bool});
                                        }
                                        get dutyCycle_useControl(){
                                            return this._state.dutyCycle_useControl;
                                        }
                                        set dutyCycle_useControl(bool){
                                            this._state.dutyCycle_useControl = bool;
                                            this.port.postMessage({dutyCycle_useControl:bool});
                                        }
                                    
                                        get envelope(){
                                            return JSON.parse(JSON.stringify(this._envelope));
                                        }
                                        set envelope(newEnvelope){
                                            this._envelope = newEnvelope;
                                            this.port.postMessage({envelope:newEnvelope});
                                        }
                                    }
                                ,
                            },


                        ];
                            
                        worklets.forEach(worklet => {
                            worklet.loaded = false;
                    
                            audio.context.audioWorklet.addModule(window.URL.createObjectURL(worklet.worklet)).then( () => {
                                worklet.loaded = true;
                    
                                audio.audioWorklet[worklet.name] = worklet.class;
                    
                                if( checkIfReady() && this.nowReady != undefined ){
                                    this.nowReady();
                                }
                            } );
                        });
                    };
                    
                    
                    
                    
                    
                    
                    
                    
                    const readyCheckList = {
                        audioWorklet:false,
                    };
                    audio.nowReady = function(){};
                    
                    Object.keys(readyCheckList).forEach(item => {
                        audio[item].nowReady = function(){
                            readyCheckList[item] = true;
                            if( Object.values(readyCheckList).reduce((a,b) => a&&b) ){ audio.nowReady(); }
                        };
                        if( audio[item].checkIfReady() ){
                            audio[item].nowReady();
                        }
                    });
                };
                const _thirdparty = new function(){
                    const thirdparty = this;
                    /**
                     * martinez v0.5.0
                     * Martinez polygon clipping algorithm, does boolean operation on polygons (multipolygons, polygons with holes etc): intersection, union, difference, xor
                     *
                     * author Alex Milevski <info@w8r.name>
                     * license MIT
                     */
                    
                    (function (global, factory) {
                        typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
                        typeof define === 'function' && define.amd ? define(['exports'], factory) :
                        (factory((global.martinez = {})));
                      }(this, (function (exports) { 'use strict';
                      
                        function DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }
                      
                        var SplayTree = function SplayTree(compare, noDuplicates) {
                          if ( compare === void 0 ) compare = DEFAULT_COMPARE;
                          if ( noDuplicates === void 0 ) noDuplicates = false;
                      
                          this._compare = compare;
                          this._root = null;
                          this._size = 0;
                          this._noDuplicates = !!noDuplicates;
                        };
                      
                        var prototypeAccessors = { size: { configurable: true } };
                      
                      
                        SplayTree.prototype.rotateLeft = function rotateLeft (x) {
                          var y = x.right;
                          if (y) {
                            x.right = y.left;
                            if (y.left) { y.left.parent = x; }
                            y.parent = x.parent;
                          }
                      
                          if (!x.parent)              { this._root = y; }
                          else if (x === x.parent.left) { x.parent.left = y; }
                          else                        { x.parent.right = y; }
                          if (y) { y.left = x; }
                          x.parent = y;
                        };
                      
                      
                        SplayTree.prototype.rotateRight = function rotateRight (x) {
                          var y = x.left;
                          if (y) {
                            x.left = y.right;
                            if (y.right) { y.right.parent = x; }
                            y.parent = x.parent;
                          }
                      
                          if (!x.parent)             { this._root = y; }
                          else if(x === x.parent.left) { x.parent.left = y; }
                          else                       { x.parent.right = y; }
                          if (y) { y.right = x; }
                          x.parent = y;
                        };
                      
                      
                        SplayTree.prototype._splay = function _splay (x) {
                            var this$1 = this;
                      
                          while (x.parent) {
                            var p = x.parent;
                            if (!p.parent) {
                              if (p.left === x) { this$1.rotateRight(p); }
                              else            { this$1.rotateLeft(p); }
                            } else if (p.left === x && p.parent.left === p) {
                              this$1.rotateRight(p.parent);
                              this$1.rotateRight(p);
                            } else if (p.right === x && p.parent.right === p) {
                              this$1.rotateLeft(p.parent);
                              this$1.rotateLeft(p);
                            } else if (p.left === x && p.parent.right === p) {
                              this$1.rotateRight(p);
                              this$1.rotateLeft(p);
                            } else {
                              this$1.rotateLeft(p);
                              this$1.rotateRight(p);
                            }
                          }
                        };
                      
                      
                        SplayTree.prototype.splay = function splay (x) {
                            var this$1 = this;
                      
                          var p, gp, ggp, l, r;
                      
                          while (x.parent) {
                            p = x.parent;
                            gp = p.parent;
                      
                            if (gp && gp.parent) {
                              ggp = gp.parent;
                              if (ggp.left === gp) { ggp.left= x; }
                              else               { ggp.right = x; }
                              x.parent = ggp;
                            } else {
                              x.parent = null;
                              this$1._root = x;
                            }
                      
                            l = x.left; r = x.right;
                      
                            if (x === p.left) { // left
                              if (gp) {
                                if (gp.left === p) {
                                  /* zig-zig */
                                  if (p.right) {
                                    gp.left = p.right;
                                    gp.left.parent = gp;
                                  } else { gp.left = null; }
                      
                                  p.right = gp;
                                  gp.parent = p;
                                } else {
                                  /* zig-zag */
                                  if (l) {
                                    gp.right = l;
                                    l.parent = gp;
                                  } else { gp.right = null; }
                      
                                  x.left  = gp;
                                  gp.parent = x;
                                }
                              }
                              if (r) {
                                p.left = r;
                                r.parent = p;
                              } else { p.left = null; }
                      
                              x.right= p;
                              p.parent = x;
                            } else { // right
                              if (gp) {
                                if (gp.right === p) {
                                  /* zig-zig */
                                  if (p.left) {
                                    gp.right = p.left;
                                    gp.right.parent = gp;
                                  } else { gp.right = null; }
                      
                                  p.left = gp;
                                  gp.parent = p;
                                } else {
                                  /* zig-zag */
                                  if (r) {
                                    gp.left = r;
                                    r.parent = gp;
                                  } else { gp.left = null; }
                      
                                  x.right = gp;
                                  gp.parent = x;
                                }
                              }
                              if (l) {
                                p.right = l;
                                l.parent = p;
                              } else { p.right = null; }
                      
                              x.left = p;
                              p.parent = x;
                            }
                          }
                        };
                      
                      
                        SplayTree.prototype.replace = function replace (u, v) {
                          if (!u.parent) { this._root = v; }
                          else if (u === u.parent.left) { u.parent.left = v; }
                          else { u.parent.right = v; }
                          if (v) { v.parent = u.parent; }
                        };
                      
                      
                        SplayTree.prototype.minNode = function minNode (u) {
                            if ( u === void 0 ) u = this._root;
                      
                          if (u) { while (u.left) { u = u.left; } }
                          return u;
                        };
                      
                      
                        SplayTree.prototype.maxNode = function maxNode (u) {
                            if ( u === void 0 ) u = this._root;
                      
                          if (u) { while (u.right) { u = u.right; } }
                          return u;
                        };
                      
                      
                        SplayTree.prototype.insert = function insert (key, data) {
                          var z = this._root;
                          var p = null;
                          var comp = this._compare;
                          var cmp;
                      
                          if (this._noDuplicates) {
                            while (z) {
                              p = z;
                              cmp = comp(z.key, key);
                              if (cmp === 0) { return; }
                              else if (comp(z.key, key) < 0) { z = z.right; }
                              else { z = z.left; }
                            }
                          } else {
                            while (z) {
                              p = z;
                              if (comp(z.key, key) < 0) { z = z.right; }
                              else { z = z.left; }
                            }
                          }
                      
                          z = { key: key, data: data, left: null, right: null, parent: p };
                      
                          if (!p)                        { this._root = z; }
                          else if (comp(p.key, z.key) < 0) { p.right = z; }
                          else                           { p.left= z; }
                      
                          this.splay(z);
                          this._size++;
                          return z;
                        };
                      
                      
                        SplayTree.prototype.find = function find (key) {
                          var z  = this._root;
                          var comp = this._compare;
                          while (z) {
                            var cmp = comp(z.key, key);
                            if    (cmp < 0) { z = z.right; }
                            else if (cmp > 0) { z = z.left; }
                            else            { return z; }
                          }
                          return null;
                        };
                      
                        /**
                         * Whether the tree contains a node with the given key
                         * @param{Key} key
                         * @return {boolean} true/false
                         */
                        SplayTree.prototype.contains = function contains (key) {
                          var node     = this._root;
                          var comparator = this._compare;
                          while (node){
                            var cmp = comparator(key, node.key);
                            if    (cmp === 0) { return true; }
                            else if (cmp < 0) { node = node.left; }
                            else              { node = node.right; }
                          }
                      
                          return false;
                        };
                      
                      
                        SplayTree.prototype.remove = function remove (key) {
                          var z = this.find(key);
                      
                          if (!z) { return false; }
                      
                          this.splay(z);
                      
                          if (!z.left) { this.replace(z, z.right); }
                          else if (!z.right) { this.replace(z, z.left); }
                          else {
                            var y = this.minNode(z.right);
                            if (y.parent !== z) {
                              this.replace(y, y.right);
                              y.right = z.right;
                              y.right.parent = y;
                            }
                            this.replace(z, y);
                            y.left = z.left;
                            y.left.parent = y;
                          }
                      
                          this._size--;
                          return true;
                        };
                      
                      
                        SplayTree.prototype.removeNode = function removeNode (z) {
                          if (!z) { return false; }
                      
                          this.splay(z);
                      
                          if (!z.left) { this.replace(z, z.right); }
                          else if (!z.right) { this.replace(z, z.left); }
                          else {
                            var y = this.minNode(z.right);
                            if (y.parent !== z) {
                              this.replace(y, y.right);
                              y.right = z.right;
                              y.right.parent = y;
                            }
                            this.replace(z, y);
                            y.left = z.left;
                            y.left.parent = y;
                          }
                      
                          this._size--;
                          return true;
                        };
                      
                      
                        SplayTree.prototype.erase = function erase (key) {
                          var z = this.find(key);
                          if (!z) { return; }
                      
                          this.splay(z);
                      
                          var s = z.left;
                          var t = z.right;
                      
                          var sMax = null;
                          if (s) {
                            s.parent = null;
                            sMax = this.maxNode(s);
                            this.splay(sMax);
                            this._root = sMax;
                          }
                          if (t) {
                            if (s) { sMax.right = t; }
                            else { this._root = t; }
                            t.parent = sMax;
                          }
                      
                          this._size--;
                        };
                      
                        /**
                         * Removes and returns the node with smallest key
                         * @return {?Node}
                         */
                        SplayTree.prototype.pop = function pop () {
                          var node = this._root, returnValue = null;
                          if (node) {
                            while (node.left) { node = node.left; }
                            returnValue = { key: node.key, data: node.data };
                            this.remove(node.key);
                          }
                          return returnValue;
                        };
                      
                      
                        /* eslint-disable class-methods-use-this */
                      
                        /**
                         * Successor node
                         * @param{Node} node
                         * @return {?Node}
                         */
                        SplayTree.prototype.next = function next (node) {
                          var successor = node;
                          if (successor) {
                            if (successor.right) {
                              successor = successor.right;
                              while (successor && successor.left) { successor = successor.left; }
                            } else {
                              successor = node.parent;
                              while (successor && successor.right === node) {
                                node = successor; successor = successor.parent;
                              }
                            }
                          }
                          return successor;
                        };
                      
                      
                        /**
                         * Predecessor node
                         * @param{Node} node
                         * @return {?Node}
                         */
                        SplayTree.prototype.prev = function prev (node) {
                          var predecessor = node;
                          if (predecessor) {
                            if (predecessor.left) {
                              predecessor = predecessor.left;
                              while (predecessor && predecessor.right) { predecessor = predecessor.right; }
                            } else {
                              predecessor = node.parent;
                              while (predecessor && predecessor.left === node) {
                                node = predecessor;
                                predecessor = predecessor.parent;
                              }
                            }
                          }
                          return predecessor;
                        };
                        /* eslint-enable class-methods-use-this */
                      
                      
                        /**
                         * @param{forEachCallback} callback
                         * @return {SplayTree}
                         */
                        SplayTree.prototype.forEach = function forEach (callback) {
                          var current = this._root;
                          var s = [], done = false, i = 0;
                      
                          while (!done) {
                            // Reach the left most Node of the current Node
                            if (current) {
                              // Place pointer to a tree node on the stack
                              // before traversing the node's left subtree
                              s.push(current);
                              current = current.left;
                            } else {
                              // BackTrack from the empty subtree and visit the Node
                              // at the top of the stack; however, if the stack is
                              // empty you are done
                              if (s.length > 0) {
                                current = s.pop();
                                callback(current, i++);
                      
                                // We have visited the node and its left
                                // subtree. Now, it's right subtree's turn
                                current = current.right;
                              } else { done = true; }
                            }
                          }
                          return this;
                        };
                      
                      
                        /**
                         * Walk key range from `low` to `high`. Stops if `fn` returns a value.
                         * @param{Key}    low
                         * @param{Key}    high
                         * @param{Function} fn
                         * @param{*?}     ctx
                         * @return {SplayTree}
                         */
                        SplayTree.prototype.range = function range (low, high, fn, ctx) {
                            var this$1 = this;
                      
                          var Q = [];
                          var compare = this._compare;
                          var node = this._root, cmp;
                      
                          while (Q.length !== 0 || node) {
                            if (node) {
                              Q.push(node);
                              node = node.left;
                            } else {
                              node = Q.pop();
                              cmp = compare(node.key, high);
                              if (cmp > 0) {
                                break;
                              } else if (compare(node.key, low) >= 0) {
                                if (fn.call(ctx, node)) { return this$1; } // stop if smth is returned
                              }
                              node = node.right;
                            }
                          }
                          return this;
                        };
                      
                        /**
                         * Returns all keys in order
                         * @return {Array<Key>}
                         */
                        SplayTree.prototype.keys = function keys () {
                          var current = this._root;
                          var s = [], r = [], done = false;
                      
                          while (!done) {
                            if (current) {
                              s.push(current);
                              current = current.left;
                            } else {
                              if (s.length > 0) {
                                current = s.pop();
                                r.push(current.key);
                                current = current.right;
                              } else { done = true; }
                            }
                          }
                          return r;
                        };
                      
                      
                        /**
                         * Returns `data` fields of all nodes in order.
                         * @return {Array<Value>}
                         */
                        SplayTree.prototype.values = function values () {
                          var current = this._root;
                          var s = [], r = [], done = false;
                      
                          while (!done) {
                            if (current) {
                              s.push(current);
                              current = current.left;
                            } else {
                              if (s.length > 0) {
                                current = s.pop();
                                r.push(current.data);
                                current = current.right;
                              } else { done = true; }
                            }
                          }
                          return r;
                        };
                      
                      
                        /**
                         * Returns node at given index
                         * @param{number} index
                         * @return {?Node}
                         */
                        SplayTree.prototype.at = function at (index) {
                          // removed after a consideration, more misleading than useful
                          // index = index % this.size;
                          // if (index < 0) index = this.size - index;
                      
                          var current = this._root;
                          var s = [], done = false, i = 0;
                      
                          while (!done) {
                            if (current) {
                              s.push(current);
                              current = current.left;
                            } else {
                              if (s.length > 0) {
                                current = s.pop();
                                if (i === index) { return current; }
                                i++;
                                current = current.right;
                              } else { done = true; }
                            }
                          }
                          return null;
                        };
                      
                        /**
                         * Bulk-load items. Both array have to be same size
                         * @param{Array<Key>}  keys
                         * @param{Array<Value>}[values]
                         * @param{Boolean}     [presort=false] Pre-sort keys and values, using
                         *                                       tree's comparator. Sorting is done
                         *                                       in-place
                         * @return {AVLTree}
                         */
                        SplayTree.prototype.load = function load (keys, values, presort) {
                            if ( keys === void 0 ) keys = [];
                            if ( values === void 0 ) values = [];
                            if ( presort === void 0 ) presort = false;
                      
                          if (this._size !== 0) { throw new Error('bulk-load: tree is not empty'); }
                          var size = keys.length;
                          if (presort) { sort(keys, values, 0, size - 1, this._compare); }
                          this._root = loadRecursive(null, keys, values, 0, size);
                          this._size = size;
                          return this;
                        };
                      
                      
                        SplayTree.prototype.min = function min () {
                          var node = this.minNode(this._root);
                          if (node) { return node.key; }
                          else    { return null; }
                        };
                      
                      
                        SplayTree.prototype.max = function max () {
                          var node = this.maxNode(this._root);
                          if (node) { return node.key; }
                          else    { return null; }
                        };
                      
                        SplayTree.prototype.isEmpty = function isEmpty () { return this._root === null; };
                        prototypeAccessors.size.get = function () { return this._size; };
                      
                      
                        /**
                         * Create a tree and load it with items
                         * @param{Array<Key>}        keys
                         * @param{Array<Value>?}      [values]
                      
                         * @param{Function?}          [comparator]
                         * @param{Boolean?}           [presort=false] Pre-sort keys and values, using
                         *                                             tree's comparator. Sorting is done
                         *                                             in-place
                         * @param{Boolean?}           [noDuplicates=false] Allow duplicates
                         * @return {SplayTree}
                         */
                        SplayTree.createTree = function createTree (keys, values, comparator, presort, noDuplicates) {
                          return new SplayTree(comparator, noDuplicates).load(keys, values, presort);
                        };
                      
                        Object.defineProperties( SplayTree.prototype, prototypeAccessors );
                      
                      
                        function loadRecursive (parent, keys, values, start, end) {
                          var size = end - start;
                          if (size > 0) {
                            var middle = start + Math.floor(size / 2);
                            var key    = keys[middle];
                            var data   = values[middle];
                            var node   = { key: key, data: data, parent: parent };
                            node.left    = loadRecursive(node, keys, values, start, middle);
                            node.right   = loadRecursive(node, keys, values, middle + 1, end);
                            return node;
                          }
                          return null;
                        }
                      
                      
                        function sort(keys, values, left, right, compare) {
                          if (left >= right) { return; }
                      
                          var pivot = keys[(left + right) >> 1];
                          var i = left - 1;
                          var j = right + 1;
                      
                          while (true) {
                            do { i++; } while (compare(keys[i], pivot) < 0);
                            do { j--; } while (compare(keys[j], pivot) > 0);
                            if (i >= j) { break; }
                      
                            var tmp = keys[i];
                            keys[i] = keys[j];
                            keys[j] = tmp;
                      
                            tmp = values[i];
                            values[i] = values[j];
                            values[j] = tmp;
                          }
                      
                          sort(keys, values,  left,     j, compare);
                          sort(keys, values, j + 1, right, compare);
                        }
                      
                        var NORMAL               = 0;
                        var NON_CONTRIBUTING     = 1;
                        var SAME_TRANSITION      = 2;
                        var DIFFERENT_TRANSITION = 3;
                      
                        var INTERSECTION = 0;
                        var UNION        = 1;
                        var DIFFERENCE   = 2;
                        var XOR          = 3;
                      
                        /**
                         * @param  {SweepEvent} event
                         * @param  {SweepEvent} prev
                         * @param  {Operation} operation
                         */
                        function computeFields (event, prev, operation) {
                          // compute inOut and otherInOut fields
                          if (prev === null) {
                            event.inOut      = false;
                            event.otherInOut = true;
                      
                          // previous line segment in sweepline belongs to the same polygon
                          } else {
                            if (event.isSubject === prev.isSubject) {
                              event.inOut      = !prev.inOut;
                              event.otherInOut = prev.otherInOut;
                      
                            // previous line segment in sweepline belongs to the clipping polygon
                            } else {
                              event.inOut      = !prev.otherInOut;
                              event.otherInOut = prev.isVertical() ? !prev.inOut : prev.inOut;
                            }
                      
                            // compute prevInResult field
                            if (prev) {
                              event.prevInResult = (!inResult(prev, operation) || prev.isVertical())
                                ? prev.prevInResult : prev;
                            }
                          }
                      
                          // check if the line segment belongs to the Boolean operation
                          event.inResult = inResult(event, operation);
                        }
                      
                      
                        /* eslint-disable indent */
                        function inResult(event, operation) {
                          switch (event.type) {
                            case NORMAL:
                              switch (operation) {
                                case INTERSECTION:
                                  return !event.otherInOut;
                                case UNION:
                                  return event.otherInOut;
                                case DIFFERENCE:
                                  // return (event.isSubject && !event.otherInOut) ||
                                  //         (!event.isSubject && event.otherInOut);
                                  return (event.isSubject && event.otherInOut) ||
                                          (!event.isSubject && !event.otherInOut);
                                case XOR:
                                  return true;
                              }
                              break;
                            case SAME_TRANSITION:
                              return operation === INTERSECTION || operation === UNION;
                            case DIFFERENT_TRANSITION:
                              return operation === DIFFERENCE;
                            case NON_CONTRIBUTING:
                              return false;
                          }
                          return false;
                        }
                        /* eslint-enable indent */
                      
                        var SweepEvent = function SweepEvent (point, left, otherEvent, isSubject, edgeType) {
                      
                          /**
                           * Is left endpoint?
                           * @type {Boolean}
                           */
                          this.left = left;
                      
                          /**
                           * @type {Array.<Number>}
                           */
                          this.point = point;
                      
                          /**
                           * Other edge reference
                           * @type {SweepEvent}
                           */
                          this.otherEvent = otherEvent;
                      
                          /**
                           * Belongs to source or clipping polygon
                           * @type {Boolean}
                           */
                          this.isSubject = isSubject;
                      
                          /**
                           * Edge contribution type
                           * @type {Number}
                           */
                          this.type = edgeType || NORMAL;
                      
                      
                          /**
                           * In-out transition for the sweepline crossing polygon
                           * @type {Boolean}
                           */
                          this.inOut = false;
                      
                      
                          /**
                           * @type {Boolean}
                           */
                          this.otherInOut = false;
                      
                          /**
                           * Previous event in result?
                           * @type {SweepEvent}
                           */
                          this.prevInResult = null;
                      
                          /**
                           * Does event belong to result?
                           * @type {Boolean}
                           */
                          this.inResult = false;
                      
                      
                          // connection step
                      
                          /**
                           * @type {Boolean}
                           */
                          this.resultInOut = false;
                      
                          this.isExteriorRing = true;
                        };
                      
                      
                        /**
                         * @param{Array.<Number>}p
                         * @return {Boolean}
                         */
                        SweepEvent.prototype.isBelow = function isBelow (p) {
                          var p0 = this.point, p1 = this.otherEvent.point;
                          return this.left
                            ? (p0[0] - p[0]) * (p1[1] - p[1]) - (p1[0] - p[0]) * (p0[1] - p[1]) > 0
                            // signedArea(this.point, this.otherEvent.point, p) > 0 :
                            : (p1[0] - p[0]) * (p0[1] - p[1]) - (p0[0] - p[0]) * (p1[1] - p[1]) > 0;
                            //signedArea(this.otherEvent.point, this.point, p) > 0;
                        };
                      
                      
                        /**
                         * @param{Array.<Number>}p
                         * @return {Boolean}
                         */
                        SweepEvent.prototype.isAbove = function isAbove (p) {
                          return !this.isBelow(p);
                        };
                      
                      
                        /**
                         * @return {Boolean}
                         */
                        SweepEvent.prototype.isVertical = function isVertical () {
                          return this.point[0] === this.otherEvent.point[0];
                        };
                      
                      
                        SweepEvent.prototype.clone = function clone () {
                          var copy = new SweepEvent(
                            this.point, this.left, this.otherEvent, this.isSubject, this.type);
                      
                          copy.inResult     = this.inResult;
                          copy.prevInResult = this.prevInResult;
                          copy.isExteriorRing = this.isExteriorRing;
                          copy.inOut        = this.inOut;
                          copy.otherInOut   = this.otherInOut;
                      
                          return copy;
                        };
                      
                        function equals(p1, p2) {
                          if (p1[0] === p2[0]) {
                            if (p1[1] === p2[1]) {
                              return true;
                            } else {
                              return false;
                            }
                          }
                          return false;
                        }
                      
                        // const EPSILON = 1e-9;
                        // const abs = Math.abs;
                        // TODO https://github.com/w8r/martinez/issues/6#issuecomment-262847164
                        // Precision problem.
                        //
                        // module.exports = function equals(p1, p2) {
                        //   return abs(p1[0] - p2[0]) <= EPSILON && abs(p1[1] - p2[1]) <= EPSILON;
                        // };
                      
                        /**
                         * Signed area of the triangle (p0, p1, p2)
                         * @param  {Array.<Number>} p0
                         * @param  {Array.<Number>} p1
                         * @param  {Array.<Number>} p2
                         * @return {Number}
                         */
                        function signedArea(p0, p1, p2) {
                          return (p0[0] - p2[0]) * (p1[1] - p2[1]) - (p1[0] - p2[0]) * (p0[1] - p2[1]);
                        }
                      
                        /**
                         * @param  {SweepEvent} e1
                         * @param  {SweepEvent} e2
                         * @return {Number}
                         */
                        function compareEvents(e1, e2) {
                          var p1 = e1.point;
                          var p2 = e2.point;
                      
                          // Different x-coordinate
                          if (p1[0] > p2[0]) { return 1; }
                          if (p1[0] < p2[0]) { return -1; }
                      
                          // Different points, but same x-coordinate
                          // Event with lower y-coordinate is processed first
                          if (p1[1] !== p2[1]) { return p1[1] > p2[1] ? 1 : -1; }
                      
                          return specialCases(e1, e2, p1, p2);
                        }
                      
                      
                        /* eslint-disable no-unused-vars */
                        function specialCases(e1, e2, p1, p2) {
                          // Same coordinates, but one is a left endpoint and the other is
                          // a right endpoint. The right endpoint is processed first
                          if (e1.left !== e2.left)
                            { return e1.left ? 1 : -1; }
                      
                          // const p2 = e1.otherEvent.point, p3 = e2.otherEvent.point;
                          // const sa = (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])
                          // Same coordinates, both events
                          // are left endpoints or right endpoints.
                          // not collinear
                          if (signedArea(p1, e1.otherEvent.point, e2.otherEvent.point) !== 0) {
                            // the event associate to the bottom segment is processed first
                            return (!e1.isBelow(e2.otherEvent.point)) ? 1 : -1;
                          }
                      
                          return (!e1.isSubject && e2.isSubject) ? 1 : -1;
                        }
                        /* eslint-enable no-unused-vars */
                      
                        /**
                         * @param  {SweepEvent} se
                         * @param  {Array.<Number>} p
                         * @param  {Queue} queue
                         * @return {Queue}
                         */
                        function divideSegment(se, p, queue)  {
                          var r = new SweepEvent(p, false, se,            se.isSubject);
                          var l = new SweepEvent(p, true,  se.otherEvent, se.isSubject);
                      
                          /* eslint-disable no-console */
                          if (equals(se.point, se.otherEvent.point)) {
                      
                            console.warn('what is that, a collapsed segment?', se);
                          }
                          /* eslint-enable no-console */
                      
                          r.contourId = l.contourId = se.contourId;
                      
                          // avoid a rounding error. The left event would be processed after the right event
                          if (compareEvents(l, se.otherEvent) > 0) {
                            se.otherEvent.left = true;
                            l.left = false;
                          }
                      
                          // avoid a rounding error. The left event would be processed after the right event
                          // if (compareEvents(se, r) > 0) {}
                      
                          se.otherEvent.otherEvent = l;
                          se.otherEvent = r;
                      
                          queue.push(l);
                          queue.push(r);
                      
                          return queue;
                        }
                      
                        //const EPS = 1e-9;
                      
                        /**
                         * Finds the magnitude of the cross product of two vectors (if we pretend
                         * they're in three dimensions)
                         *
                         * @param {Object} a First vector
                         * @param {Object} b Second vector
                         * @private
                         * @returns {Number} The magnitude of the cross product
                         */
                        function crossProduct(a, b) {
                          return (a[0] * b[1]) - (a[1] * b[0]);
                        }
                      
                        /**
                         * Finds the dot product of two vectors.
                         *
                         * @param {Object} a First vector
                         * @param {Object} b Second vector
                         * @private
                         * @returns {Number} The dot product
                         */
                        function dotProduct(a, b) {
                          return (a[0] * b[0]) + (a[1] * b[1]);
                        }
                      
                        /**
                         * Finds the intersection (if any) between two line segments a and b, given the
                         * line segments' end points a1, a2 and b1, b2.
                         *
                         * This algorithm is based on Schneider and Eberly.
                         * http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf
                         * Page 244.
                         *
                         * @param {Array.<Number>} a1 point of first line
                         * @param {Array.<Number>} a2 point of first line
                         * @param {Array.<Number>} b1 point of second line
                         * @param {Array.<Number>} b2 point of second line
                         * @param {Boolean=}       noEndpointTouch whether to skip single touchpoints
                         *                                         (meaning connected segments) as
                         *                                         intersections
                         * @returns {Array.<Array.<Number>>|Null} If the lines intersect, the point of
                         * intersection. If they overlap, the two end points of the overlapping segment.
                         * Otherwise, null.
                         */
                        function intersection (a1, a2, b1, b2, noEndpointTouch) {
                          // The algorithm expects our lines in the form P + sd, where P is a point,
                          // s is on the interval [0, 1], and d is a vector.
                          // We are passed two points. P can be the first point of each pair. The
                          // vector, then, could be thought of as the distance (in x and y components)
                          // from the first point to the second point.
                          // So first, let's make our vectors:
                          var va = [a2[0] - a1[0], a2[1] - a1[1]];
                          var vb = [b2[0] - b1[0], b2[1] - b1[1]];
                          // We also define a function to convert back to regular point form:
                      
                          /* eslint-disable arrow-body-style */
                      
                          function toPoint(p, s, d) {
                            return [
                              p[0] + s * d[0],
                              p[1] + s * d[1]
                            ];
                          }
                      
                          /* eslint-enable arrow-body-style */
                      
                          // The rest is pretty much a straight port of the algorithm.
                          var e = [b1[0] - a1[0], b1[1] - a1[1]];
                          var kross    = crossProduct(va, vb);
                          var sqrKross = kross * kross;
                          var sqrLenA  = dotProduct(va, va);
                          //const sqrLenB  = dotProduct(vb, vb);
                      
                          // Check for line intersection. This works because of the properties of the
                          // cross product -- specifically, two vectors are parallel if and only if the
                          // cross product is the 0 vector. The full calculation involves relative error
                          // to account for possible very small line segments. See Schneider & Eberly
                          // for details.
                          if (sqrKross > 0/* EPS * sqrLenB * sqLenA */) {
                            // If they're not parallel, then (because these are line segments) they
                            // still might not actually intersect. This code checks that the
                            // intersection point of the lines is actually on both line segments.
                            var s = crossProduct(e, vb) / kross;
                            if (s < 0 || s > 1) {
                              // not on line segment a
                              return null;
                            }
                            var t = crossProduct(e, va) / kross;
                            if (t < 0 || t > 1) {
                              // not on line segment b
                              return null;
                            }
                            if (s === 0 || s === 1) {
                              // on an endpoint of line segment a
                              return noEndpointTouch ? null : [toPoint(a1, s, va)];
                            }
                            if (t === 0 || t === 1) {
                              // on an endpoint of line segment b
                              return noEndpointTouch ? null : [toPoint(b1, t, vb)];
                            }
                            return [toPoint(a1, s, va)];
                          }
                      
                          // If we've reached this point, then the lines are either parallel or the
                          // same, but the segments could overlap partially or fully, or not at all.
                          // So we need to find the overlap, if any. To do that, we can use e, which is
                          // the (vector) difference between the two initial points. If this is parallel
                          // with the line itself, then the two lines are the same line, and there will
                          // be overlap.
                          //const sqrLenE = dotProduct(e, e);
                          kross = crossProduct(e, va);
                          sqrKross = kross * kross;
                      
                          if (sqrKross > 0 /* EPS * sqLenB * sqLenE */) {
                          // Lines are just parallel, not the same. No overlap.
                            return null;
                          }
                      
                          var sa = dotProduct(va, e) / sqrLenA;
                          var sb = sa + dotProduct(va, vb) / sqrLenA;
                          var smin = Math.min(sa, sb);
                          var smax = Math.max(sa, sb);
                      
                          // this is, essentially, the FindIntersection acting on floats from
                          // Schneider & Eberly, just inlined into this function.
                          if (smin <= 1 && smax >= 0) {
                      
                            // overlap on an end point
                            if (smin === 1) {
                              return noEndpointTouch ? null : [toPoint(a1, smin > 0 ? smin : 0, va)];
                            }
                      
                            if (smax === 0) {
                              return noEndpointTouch ? null : [toPoint(a1, smax < 1 ? smax : 1, va)];
                            }
                      
                            if (noEndpointTouch && smin === 0 && smax === 1) { return null; }
                      
                            // There's overlap on a segment -- two points of intersection. Return both.
                            return [
                              toPoint(a1, smin > 0 ? smin : 0, va),
                              toPoint(a1, smax < 1 ? smax : 1, va)
                            ];
                          }
                      
                          return null;
                        }
                      
                        /**
                         * @param  {SweepEvent} se1
                         * @param  {SweepEvent} se2
                         * @param  {Queue}      queue
                         * @return {Number}
                         */
                        function possibleIntersection (se1, se2, queue) {
                          // that disallows self-intersecting polygons,
                          // did cost us half a day, so I'll leave it
                          // out of respect
                          // if (se1.isSubject === se2.isSubject) return;
                          var inter = intersection(
                            se1.point, se1.otherEvent.point,
                            se2.point, se2.otherEvent.point
                          );
                      
                          var nintersections = inter ? inter.length : 0;
                          if (nintersections === 0) { return 0; } // no intersection
                      
                          // the line segments intersect at an endpoint of both line segments
                          if ((nintersections === 1) &&
                              (equals(se1.point, se2.point) ||
                               equals(se1.otherEvent.point, se2.otherEvent.point))) {
                            return 0;
                          }
                      
                          if (nintersections === 2 && se1.isSubject === se2.isSubject) {
                            // if(se1.contourId === se2.contourId){
                            // console.warn('Edges of the same polygon overlap',
                            //   se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);
                            // }
                            //throw new Error('Edges of the same polygon overlap');
                            return 0;
                          }
                      
                          // The line segments associated to se1 and se2 intersect
                          if (nintersections === 1) {
                      
                            // if the intersection point is not an endpoint of se1
                            if (!equals(se1.point, inter[0]) && !equals(se1.otherEvent.point, inter[0])) {
                              divideSegment(se1, inter[0], queue);
                            }
                      
                            // if the intersection point is not an endpoint of se2
                            if (!equals(se2.point, inter[0]) && !equals(se2.otherEvent.point, inter[0])) {
                              divideSegment(se2, inter[0], queue);
                            }
                            return 1;
                          }
                      
                          // The line segments associated to se1 and se2 overlap
                          var events        = [];
                          var leftCoincide  = false;
                          var rightCoincide = false;
                      
                          if (equals(se1.point, se2.point)) {
                            leftCoincide = true; // linked
                          } else if (compareEvents(se1, se2) === 1) {
                            events.push(se2, se1);
                          } else {
                            events.push(se1, se2);
                          }
                      
                          if (equals(se1.otherEvent.point, se2.otherEvent.point)) {
                            rightCoincide = true;
                          } else if (compareEvents(se1.otherEvent, se2.otherEvent) === 1) {
                            events.push(se2.otherEvent, se1.otherEvent);
                          } else {
                            events.push(se1.otherEvent, se2.otherEvent);
                          }
                      
                          if ((leftCoincide && rightCoincide) || leftCoincide) {
                            // both line segments are equal or share the left endpoint
                            se2.type = NON_CONTRIBUTING;
                            se1.type = (se2.inOut === se1.inOut)
                              ? SAME_TRANSITION : DIFFERENT_TRANSITION;
                      
                            if (leftCoincide && !rightCoincide) {
                              // honestly no idea, but changing events selection from [2, 1]
                              // to [0, 1] fixes the overlapping self-intersecting polygons issue
                              divideSegment(events[1].otherEvent, events[0].point, queue);
                            }
                            return 2;
                          }
                      
                          // the line segments share the right endpoint
                          if (rightCoincide) {
                            divideSegment(events[0], events[1].point, queue);
                            return 3;
                          }
                      
                          // no line segment includes totally the other one
                          if (events[0] !== events[3].otherEvent) {
                            divideSegment(events[0], events[1].point, queue);
                            divideSegment(events[1], events[2].point, queue);
                            return 3;
                          }
                      
                          // one line segment includes the other one
                          divideSegment(events[0], events[1].point, queue);
                          divideSegment(events[3].otherEvent, events[2].point, queue);
                      
                          return 3;
                        }
                      
                        /**
                         * @param  {SweepEvent} le1
                         * @param  {SweepEvent} le2
                         * @return {Number}
                         */
                        function compareSegments(le1, le2) {
                          if (le1 === le2) { return 0; }
                      
                          // Segments are not collinear
                          if (signedArea(le1.point, le1.otherEvent.point, le2.point) !== 0 ||
                            signedArea(le1.point, le1.otherEvent.point, le2.otherEvent.point) !== 0) {
                      
                            // If they share their left endpoint use the right endpoint to sort
                            if (equals(le1.point, le2.point)) { return le1.isBelow(le2.otherEvent.point) ? -1 : 1; }
                      
                            // Different left endpoint: use the left endpoint to sort
                            if (le1.point[0] === le2.point[0]) { return le1.point[1] < le2.point[1] ? -1 : 1; }
                      
                            // has the line segment associated to e1 been inserted
                            // into S after the line segment associated to e2 ?
                            if (compareEvents(le1, le2) === 1) { return le2.isAbove(le1.point) ? -1 : 1; }
                      
                            // The line segment associated to e2 has been inserted
                            // into S after the line segment associated to e1
                            return le1.isBelow(le2.point) ? -1 : 1;
                          }
                      
                          if (le1.isSubject === le2.isSubject) { // same polygon
                            var p1 = le1.point, p2 = le2.point;
                            if (p1[0] === p2[0] && p1[1] === p2[1]/*equals(le1.point, le2.point)*/) {
                              p1 = le1.otherEvent.point; p2 = le2.otherEvent.point;
                              if (p1[0] === p2[0] && p1[1] === p2[1]) { return 0; }
                              else { return le1.contourId > le2.contourId ? 1 : -1; }
                            }
                          } else { // Segments are collinear, but belong to separate polygons
                            return le1.isSubject ? -1 : 1;
                          }
                      
                          return compareEvents(le1, le2) === 1 ? 1 : -1;
                        }
                      
                        function subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation) {
                          var sweepLine = new SplayTree(compareSegments);
                          var sortedEvents = [];
                      
                          var rightbound = Math.min(sbbox[2], cbbox[2]);
                      
                          var prev, next, begin;
                      
                          while (eventQueue.length !== 0) {
                            var event = eventQueue.pop();
                            sortedEvents.push(event);
                      
                            // optimization by bboxes for intersection and difference goes here
                            if ((operation === INTERSECTION && event.point[0] > rightbound) ||
                                (operation === DIFFERENCE   && event.point[0] > sbbox[2])) {
                              break;
                            }
                      
                            if (event.left) {
                              next  = prev = sweepLine.insert(event);
                              begin = sweepLine.minNode();
                      
                              if (prev !== begin) { prev = sweepLine.prev(prev); }
                              else                { prev = null; }
                      
                              next = sweepLine.next(next);
                      
                              var prevEvent = prev ? prev.key : null;
                              var prevprevEvent = (void 0);
                              computeFields(event, prevEvent, operation);
                              if (next) {
                                if (possibleIntersection(event, next.key, eventQueue) === 2) {
                                  computeFields(event, prevEvent, operation);
                                  computeFields(event, next.key, operation);
                                }
                              }
                      
                              if (prev) {
                                if (possibleIntersection(prev.key, event, eventQueue) === 2) {
                                  var prevprev = prev;
                                  if (prevprev !== begin) { prevprev = sweepLine.prev(prevprev); }
                                  else                    { prevprev = null; }
                      
                                  prevprevEvent = prevprev ? prevprev.key : null;
                                  computeFields(prevEvent, prevprevEvent, operation);
                                  computeFields(event,     prevEvent,     operation);
                                }
                              }
                            } else {
                              event = event.otherEvent;
                              next = prev = sweepLine.find(event);
                      
                              if (prev && next) {
                      
                                if (prev !== begin) { prev = sweepLine.prev(prev); }
                                else                { prev = null; }
                      
                                next = sweepLine.next(next);
                                sweepLine.remove(event);
                      
                                if (next && prev) {
                                  possibleIntersection(prev.key, next.key, eventQueue);
                                }
                              }
                            }
                          }
                          return sortedEvents;
                        }
                      
                        /**
                         * @param  {Array.<SweepEvent>} sortedEvents
                         * @return {Array.<SweepEvent>}
                         */
                        function orderEvents(sortedEvents) {
                          var event, i, len, tmp;
                          var resultEvents = [];
                          for (i = 0, len = sortedEvents.length; i < len; i++) {
                            event = sortedEvents[i];
                            if ((event.left && event.inResult) ||
                              (!event.left && event.otherEvent.inResult)) {
                              resultEvents.push(event);
                            }
                          }
                          // Due to overlapping edges the resultEvents array can be not wholly sorted
                          var sorted = false;
                          while (!sorted) {
                            sorted = true;
                            for (i = 0, len = resultEvents.length; i < len; i++) {
                              if ((i + 1) < len &&
                                compareEvents(resultEvents[i], resultEvents[i + 1]) === 1) {
                                tmp = resultEvents[i];
                                resultEvents[i] = resultEvents[i + 1];
                                resultEvents[i + 1] = tmp;
                                sorted = false;
                              }
                            }
                          }
                      
                      
                          for (i = 0, len = resultEvents.length; i < len; i++) {
                            event = resultEvents[i];
                            event.pos = i;
                          }
                      
                          // imagine, the right event is found in the beginning of the queue,
                          // when his left counterpart is not marked yet
                          for (i = 0, len = resultEvents.length; i < len; i++) {
                            event = resultEvents[i];
                            if (!event.left) {
                              tmp = event.pos;
                              event.pos = event.otherEvent.pos;
                              event.otherEvent.pos = tmp;
                            }
                          }
                      
                          return resultEvents;
                        }
                      
                      
                        /**
                         * @param  {Number} pos
                         * @param  {Array.<SweepEvent>} resultEvents
                         * @param  {Object>}    processed
                         * @return {Number}
                         */
                        function nextPos(pos, resultEvents, processed, origIndex) {
                          var p, p1;
                          var newPos = pos + 1;
                          var length = resultEvents.length;
                      
                          p  = resultEvents[pos].point;
                      
                          if (newPos < length)
                            { p1 = resultEvents[newPos].point; }
                      
                      
                          // while in range and not the current one by value
                          while (newPos < length && p1[0] === p[0] && p1[1] === p[1]) {
                            if (!processed[newPos]) {
                              return newPos;
                            } else   {
                              newPos++;
                            }
                            p1 = resultEvents[newPos].point;
                          }
                      
                          newPos = pos - 1;
                      
                          while (processed[newPos] && newPos >= origIndex) {
                            newPos--;
                          }
                          return newPos;
                        }
                      
                      
                        /**
                         * @param  {Array.<SweepEvent>} sortedEvents
                         * @return {Array.<*>} polygons
                         */
                        function connectEdges(sortedEvents, operation) {
                          var i, len;
                          var resultEvents = orderEvents(sortedEvents);
                      
                          // "false"-filled array
                          var processed = {};
                          var result = [];
                          var event;
                      
                          for (i = 0, len = resultEvents.length; i < len; i++) {
                            if (processed[i]) { continue; }
                            var contour = [[]];
                      
                            if (!resultEvents[i].isExteriorRing) {
                              if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length === 0) {
                                result.push(contour);
                              } else if (result.length === 0) {
                                result.push([[contour]]);
                              } else {
                                result[result.length - 1].push(contour[0]);
                              }
                            } else if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length > 1) {
                              result[result.length - 1].push(contour[0]);
                            } else {
                              result.push(contour);
                            }
                      
                            var ringId = result.length - 1;
                            var pos = i;
                      
                            var initial = resultEvents[i].point;
                            contour[0].push(initial);
                      
                            while (pos >= i) {
                              event = resultEvents[pos];
                              processed[pos] = true;
                      
                              if (event.left) {
                                event.resultInOut = false;
                                event.contourId   = ringId;
                              } else {
                                event.otherEvent.resultInOut = true;
                                event.otherEvent.contourId   = ringId;
                              }
                      
                              pos = event.pos;
                              processed[pos] = true;
                              contour[0].push(resultEvents[pos].point);
                              pos = nextPos(pos, resultEvents, processed, i);
                            }
                      
                            pos = pos === -1 ? i : pos;
                      
                            event = resultEvents[pos];
                            processed[pos] = processed[event.pos] = true;
                            event.otherEvent.resultInOut = true;
                            event.otherEvent.contourId   = ringId;
                          }
                      
                          // Handle if the result is a polygon (eg not multipoly)
                          // Commented it again, let's see what do we mean by that
                          // if (result.length === 1) result = result[0];
                          return result;
                        }
                      
                        var tinyqueue = TinyQueue;
                        var default_1 = TinyQueue;
                      
                        function TinyQueue(data, compare) {
                            var this$1 = this;
                      
                            if (!(this instanceof TinyQueue)) { return new TinyQueue(data, compare); }
                      
                            this.data = data || [];
                            this.length = this.data.length;
                            this.compare = compare || defaultCompare;
                      
                            if (this.length > 0) {
                                for (var i = (this.length >> 1) - 1; i >= 0; i--) { this$1._down(i); }
                            }
                        }
                      
                        function defaultCompare(a, b) {
                            return a < b ? -1 : a > b ? 1 : 0;
                        }
                      
                        TinyQueue.prototype = {
                      
                            push: function (item) {
                                this.data.push(item);
                                this.length++;
                                this._up(this.length - 1);
                            },
                      
                            pop: function () {
                                if (this.length === 0) { return undefined; }
                      
                                var top = this.data[0];
                                this.length--;
                      
                                if (this.length > 0) {
                                    this.data[0] = this.data[this.length];
                                    this._down(0);
                                }
                                this.data.pop();
                      
                                return top;
                            },
                      
                            peek: function () {
                                return this.data[0];
                            },
                      
                            _up: function (pos) {
                                var data = this.data;
                                var compare = this.compare;
                                var item = data[pos];
                      
                                while (pos > 0) {
                                    var parent = (pos - 1) >> 1;
                                    var current = data[parent];
                                    if (compare(item, current) >= 0) { break; }
                                    data[pos] = current;
                                    pos = parent;
                                }
                      
                                data[pos] = item;
                            },
                      
                            _down: function (pos) {
                                var this$1 = this;
                      
                                var data = this.data;
                                var compare = this.compare;
                                var halfLength = this.length >> 1;
                                var item = data[pos];
                      
                                while (pos < halfLength) {
                                    var left = (pos << 1) + 1;
                                    var right = left + 1;
                                    var best = data[left];
                      
                                    if (right < this$1.length && compare(data[right], best) < 0) {
                                        left = right;
                                        best = data[right];
                                    }
                                    if (compare(best, item) >= 0) { break; }
                      
                                    data[pos] = best;
                                    pos = left;
                                }
                      
                                data[pos] = item;
                            }
                        };
                        tinyqueue.default = default_1;
                      
                        var max = Math.max;
                        var min = Math.min;
                      
                        var contourId = 0;
                      
                      
                        function processPolygon(contourOrHole, isSubject, depth, Q, bbox, isExteriorRing) {
                          var i, len, s1, s2, e1, e2;
                          for (i = 0, len = contourOrHole.length - 1; i < len; i++) {
                            s1 = contourOrHole[i];
                            s2 = contourOrHole[i + 1];
                            e1 = new SweepEvent(s1, false, undefined, isSubject);
                            e2 = new SweepEvent(s2, false, e1,        isSubject);
                            e1.otherEvent = e2;
                      
                            if (s1[0] === s2[0] && s1[1] === s2[1]) {
                              continue; // skip collapsed edges, or it breaks
                            }
                      
                            e1.contourId = e2.contourId = depth;
                            if (!isExteriorRing) {
                              e1.isExteriorRing = false;
                              e2.isExteriorRing = false;
                            }
                            if (compareEvents(e1, e2) > 0) {
                              e2.left = true;
                            } else {
                              e1.left = true;
                            }
                      
                            var x = s1[0], y = s1[1];
                            bbox[0] = min(bbox[0], x);
                            bbox[1] = min(bbox[1], y);
                            bbox[2] = max(bbox[2], x);
                            bbox[3] = max(bbox[3], y);
                      
                            // Pushing it so the queue is sorted from left to right,
                            // with object on the left having the highest priority.
                            Q.push(e1);
                            Q.push(e2);
                          }
                        }
                      
                      
                        function fillQueue(subject, clipping, sbbox, cbbox, operation) {
                          var eventQueue = new tinyqueue(null, compareEvents);
                          var polygonSet, isExteriorRing, i, ii, j, jj; //, k, kk;
                      
                          for (i = 0, ii = subject.length; i < ii; i++) {
                            polygonSet = subject[i];
                            for (j = 0, jj = polygonSet.length; j < jj; j++) {
                              isExteriorRing = j === 0;
                              if (isExteriorRing) { contourId++; }
                              processPolygon(polygonSet[j], true, contourId, eventQueue, sbbox, isExteriorRing);
                            }
                          }
                      
                          for (i = 0, ii = clipping.length; i < ii; i++) {
                            polygonSet = clipping[i];
                            for (j = 0, jj = polygonSet.length; j < jj; j++) {
                              isExteriorRing = j === 0;
                              if (operation === DIFFERENCE) { isExteriorRing = false; }
                              if (isExteriorRing) { contourId++; }
                              processPolygon(polygonSet[j], false, contourId, eventQueue, cbbox, isExteriorRing);
                            }
                          }
                      
                          return eventQueue;
                        }
                      
                        var EMPTY = [];
                      
                      
                        function trivialOperation(subject, clipping, operation) {
                          var result = null;
                          if (subject.length * clipping.length === 0) {
                            if        (operation === INTERSECTION) {
                              result = EMPTY;
                            } else if (operation === DIFFERENCE) {
                              result = subject;
                            } else if (operation === UNION ||
                                       operation === XOR) {
                              result = (subject.length === 0) ? clipping : subject;
                            }
                          }
                          return result;
                        }
                      
                      
                        function compareBBoxes(subject, clipping, sbbox, cbbox, operation) {
                          var result = null;
                          if (sbbox[0] > cbbox[2] ||
                              cbbox[0] > sbbox[2] ||
                              sbbox[1] > cbbox[3] ||
                              cbbox[1] > sbbox[3]) {
                            if        (operation === INTERSECTION) {
                              result = EMPTY;
                            } else if (operation === DIFFERENCE) {
                              result = subject;
                            } else if (operation === UNION ||
                                       operation === XOR) {
                              result = subject.concat(clipping);
                            }
                          }
                          return result;
                        }
                      
                      
                        function boolean(subject, clipping, operation) {
                          if (typeof subject[0][0][0] === 'number') {
                            subject = [subject];
                          }
                          if (typeof clipping[0][0][0] === 'number') {
                            clipping = [clipping];
                          }
                          var trivial = trivialOperation(subject, clipping, operation);
                          if (trivial) {
                            return trivial === EMPTY ? null : trivial;
                          }
                          var sbbox = [Infinity, Infinity, -Infinity, -Infinity];
                          var cbbox = [Infinity, Infinity, -Infinity, -Infinity];
                      
                          //console.time('fill queue');
                          var eventQueue = fillQueue(subject, clipping, sbbox, cbbox, operation);
                          //console.timeEnd('fill queue');
                      
                          trivial = compareBBoxes(subject, clipping, sbbox, cbbox, operation);
                          if (trivial) {
                            return trivial === EMPTY ? null : trivial;
                          }
                          //console.time('subdivide edges');
                          var sortedEvents = subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation);
                          //console.timeEnd('subdivide edges');
                      
                          //console.time('connect vertices');
                          var result = connectEdges(sortedEvents, operation);
                          //console.timeEnd('connect vertices');
                          return result;
                        }
                      
                        function union (subject, clipping) {
                          return boolean(subject, clipping, UNION);
                        }
                      
                        function diff (subject, clipping) {
                          return boolean(subject, clipping, DIFFERENCE);
                        }
                      
                        function xor (subject, clipping){
                          return boolean(subject, clipping, XOR);
                        }
                      
                        function intersection$1 (subject, clipping) {
                          return boolean(subject, clipping, INTERSECTION);
                        }
                      
                        /**
                         * @enum {Number}
                         */
                        var operations = { UNION: UNION, DIFFERENCE: DIFFERENCE, INTERSECTION: INTERSECTION, XOR: XOR };
                      
                        exports.union = union;
                        exports.diff = diff;
                        exports.xor = xor;
                        exports.intersection = intersection$1;
                        exports.operations = operations;
                      
                        Object.defineProperty(exports, '__esModule', { value: true });
                      
                      })));
                    this.lzString = (function(){
                        // Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>
                        // This work is free. You can redistribute it and/or modify it
                        // under the terms of the WTFPL, Version 2
                        // For more information see LICENSE.txt or http://www.wtfpl.net/
                        //
                        // For more information, the home page:
                        // http://pieroxy.net/blog/pages/lz-string/testing.html
                        //
                        // LZ-based compression algorithm, version 1.4.4
                        //
                        // Modified by Metasophiea <metasophiea@gmail.com>
                        var f = String.fromCharCode;
                        var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
                        var baseReverseDic = {};
                        
                        function getBaseValue(alphabet, character) {
                            if(!baseReverseDic[alphabet]){
                                baseReverseDic[alphabet] = {};
                                for(var i = 0 ; i < alphabet.length; i++){
                                    baseReverseDic[alphabet][alphabet.charAt(i)] = i;
                                }
                            }	
                            return baseReverseDic[alphabet][character];
                        }
                        
                        var LZString = {
                            //compress into a string that is URI encoded
                            compress: function (input) {
                                if(input == null){return "";}
                                return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});
                            },
                            
                            //decompress from an output of compress which was URI encoded
                            decompress:function (input) {
                                if(input == null){return "";}
                                if(input == ""){return null;}
                                input = input.replace(/ /g, "+");
                                return LZString._decompress(input.length, 32, function(index){ return getBaseValue(keyStrUriSafe, input.charAt(index)); });
                            },
                            
                            _compress: function(uncompressed, bitsPerChar, getCharFromInt){
                                if (uncompressed == null) return "";
                                var i, value,
                                    context_dictionary= {},
                                    context_dictionaryToCreate= {},
                                    context_c="",
                                    context_wc="",
                                    context_w="",
                                    context_enlargeIn= 2, // Compensate for the first entry which should not count
                                    context_dictSize= 3,
                                    context_numBits= 2,
                                    context_data=[],
                                    context_data_val=0,
                                    context_data_position=0,
                                    ii;
                            
                                for (ii = 0; ii < uncompressed.length; ii += 1) {
                                context_c = uncompressed.charAt(ii);
                                if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {
                                    context_dictionary[context_c] = context_dictSize++;
                                    context_dictionaryToCreate[context_c] = true;
                                }
                            
                                context_wc = context_w + context_c;
                                if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {
                                    context_w = context_wc;
                                } else {
                                    if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
                                    if (context_w.charCodeAt(0)<256) {
                                        for (i=0 ; i<context_numBits ; i++) {
                                        context_data_val = (context_data_val << 1);
                                        if (context_data_position == bitsPerChar-1) {
                                            context_data_position = 0;
                                            context_data.push(getCharFromInt(context_data_val));
                                            context_data_val = 0;
                                        } else {
                                            context_data_position++;
                                        }
                                        }
                                        value = context_w.charCodeAt(0);
                                        for (i=0 ; i<8 ; i++) {
                                        context_data_val = (context_data_val << 1) | (value&1);
                                        if (context_data_position == bitsPerChar-1) {
                                            context_data_position = 0;
                                            context_data.push(getCharFromInt(context_data_val));
                                            context_data_val = 0;
                                        } else {
                                            context_data_position++;
                                        }
                                        value = value >> 1;
                                        }
                                    } else {
                                        value = 1;
                                        for (i=0 ; i<context_numBits ; i++) {
                                        context_data_val = (context_data_val << 1) | value;
                                        if (context_data_position ==bitsPerChar-1) {
                                            context_data_position = 0;
                                            context_data.push(getCharFromInt(context_data_val));
                                            context_data_val = 0;
                                        } else {
                                            context_data_position++;
                                        }
                                        value = 0;
                                        }
                                        value = context_w.charCodeAt(0);
                                        for (i=0 ; i<16 ; i++) {
                                        context_data_val = (context_data_val << 1) | (value&1);
                                        if (context_data_position == bitsPerChar-1) {
                                            context_data_position = 0;
                                            context_data.push(getCharFromInt(context_data_val));
                                            context_data_val = 0;
                                        } else {
                                            context_data_position++;
                                        }
                                        value = value >> 1;
                                        }
                                    }
                                    context_enlargeIn--;
                                    if (context_enlargeIn == 0) {
                                        context_enlargeIn = Math.pow(2, context_numBits);
                                        context_numBits++;
                                    }
                                    delete context_dictionaryToCreate[context_w];
                                    } else {
                                    value = context_dictionary[context_w];
                                    for (i=0 ; i<context_numBits ; i++) {
                                        context_data_val = (context_data_val << 1) | (value&1);
                                        if (context_data_position == bitsPerChar-1) {
                                        context_data_position = 0;
                                        context_data.push(getCharFromInt(context_data_val));
                                        context_data_val = 0;
                                        } else {
                                        context_data_position++;
                                        }
                                        value = value >> 1;
                                    }
                            
                            
                                    }
                                    context_enlargeIn--;
                                    if (context_enlargeIn == 0) {
                                    context_enlargeIn = Math.pow(2, context_numBits);
                                    context_numBits++;
                                    }
                                    // Add wc to the dictionary.
                                    context_dictionary[context_wc] = context_dictSize++;
                                    context_w = String(context_c);
                                }
                                }
                            
                                // Output the code for w.
                                if (context_w !== "") {
                                if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
                                    if (context_w.charCodeAt(0)<256) {
                                    for (i=0 ; i<context_numBits ; i++) {
                                        context_data_val = (context_data_val << 1);
                                        if (context_data_position == bitsPerChar-1) {
                                        context_data_position = 0;
                                        context_data.push(getCharFromInt(context_data_val));
                                        context_data_val = 0;
                                        } else {
                                        context_data_position++;
                                        }
                                    }
                                    value = context_w.charCodeAt(0);
                                    for (i=0 ; i<8 ; i++) {
                                        context_data_val = (context_data_val << 1) | (value&1);
                                        if (context_data_position == bitsPerChar-1) {
                                        context_data_position = 0;
                                        context_data.push(getCharFromInt(context_data_val));
                                        context_data_val = 0;
                                        } else {
                                        context_data_position++;
                                        }
                                        value = value >> 1;
                                    }
                                    } else {
                                    value = 1;
                                    for (i=0 ; i<context_numBits ; i++) {
                                        context_data_val = (context_data_val << 1) | value;
                                        if (context_data_position == bitsPerChar-1) {
                                        context_data_position = 0;
                                        context_data.push(getCharFromInt(context_data_val));
                                        context_data_val = 0;
                                        } else {
                                        context_data_position++;
                                        }
                                        value = 0;
                                    }
                                    value = context_w.charCodeAt(0);
                                    for (i=0 ; i<16 ; i++) {
                                        context_data_val = (context_data_val << 1) | (value&1);
                                        if (context_data_position == bitsPerChar-1) {
                                        context_data_position = 0;
                                        context_data.push(getCharFromInt(context_data_val));
                                        context_data_val = 0;
                                        } else {
                                        context_data_position++;
                                        }
                                        value = value >> 1;
                                    }
                                    }
                                    context_enlargeIn--;
                                    if (context_enlargeIn == 0) {
                                    context_enlargeIn = Math.pow(2, context_numBits);
                                    context_numBits++;
                                    }
                                    delete context_dictionaryToCreate[context_w];
                                } else {
                                    value = context_dictionary[context_w];
                                    for (i=0 ; i<context_numBits ; i++) {
                                    context_data_val = (context_data_val << 1) | (value&1);
                                    if (context_data_position == bitsPerChar-1) {
                                        context_data_position = 0;
                                        context_data.push(getCharFromInt(context_data_val));
                                        context_data_val = 0;
                                    } else {
                                        context_data_position++;
                                    }
                                    value = value >> 1;
                                    }
                            
                            
                                }
                                context_enlargeIn--;
                                if (context_enlargeIn == 0) {
                                    context_enlargeIn = Math.pow(2, context_numBits);
                                    context_numBits++;
                                }
                                }
                            
                                // Mark the end of the stream
                                value = 2;
                                for (i=0 ; i<context_numBits ; i++) {
                                context_data_val = (context_data_val << 1) | (value&1);
                                if (context_data_position == bitsPerChar-1) {
                                    context_data_position = 0;
                                    context_data.push(getCharFromInt(context_data_val));
                                    context_data_val = 0;
                                } else {
                                    context_data_position++;
                                }
                                value = value >> 1;
                                }
                            
                                // Flush the last char
                                while (true) {
                                context_data_val = (context_data_val << 1);
                                if (context_data_position == bitsPerChar-1) {
                                    context_data.push(getCharFromInt(context_data_val));
                                    break;
                                }
                                else context_data_position++;
                                }
                                return context_data.join('');
                            },
                            
                            _decompress: function(length, resetValue, getNextValue){
                                var dictionary = [],
                                    next,
                                    enlargeIn = 4,
                                    dictSize = 4,
                                    numBits = 3,
                                    entry = "",
                                    result = [],
                                    i,
                                    w,
                                    bits, resb, maxpower, power,
                                    c,
                                    data = {val:getNextValue(0), position:resetValue, index:1};
                            
                                for (i = 0; i < 3; i += 1) {
                                dictionary[i] = i;
                                }
                            
                                bits = 0;
                                maxpower = Math.pow(2,2);
                                power=1;
                                while (power!=maxpower) {
                                resb = data.val & data.position;
                                data.position >>= 1;
                                if (data.position == 0) {
                                    data.position = resetValue;
                                    data.val = getNextValue(data.index++);
                                }
                                bits |= (resb>0 ? 1 : 0) * power;
                                power <<= 1;
                                }
                            
                                switch (next = bits) {
                                case 0:
                                    bits = 0;
                                    maxpower = Math.pow(2,8);
                                    power=1;
                                    while (power!=maxpower) {
                                        resb = data.val & data.position;
                                        data.position >>= 1;
                                        if (data.position == 0) {
                                        data.position = resetValue;
                                        data.val = getNextValue(data.index++);
                                        }
                                        bits |= (resb>0 ? 1 : 0) * power;
                                        power <<= 1;
                                    }
                                    c = f(bits);
                                    break;
                                case 1:
                                    bits = 0;
                                    maxpower = Math.pow(2,16);
                                    power=1;
                                    while (power!=maxpower) {
                                        resb = data.val & data.position;
                                        data.position >>= 1;
                                        if (data.position == 0) {
                                        data.position = resetValue;
                                        data.val = getNextValue(data.index++);
                                        }
                                        bits |= (resb>0 ? 1 : 0) * power;
                                        power <<= 1;
                                    }
                                    c = f(bits);
                                    break;
                                case 2:
                                    return "";
                                }
                                dictionary[3] = c;
                                w = c;
                                result.push(c);
                                while (true) {
                                if (data.index > length) {
                                    return "";
                                }
                            
                                bits = 0;
                                maxpower = Math.pow(2,numBits);
                                power=1;
                                while (power!=maxpower) {
                                    resb = data.val & data.position;
                                    data.position >>= 1;
                                    if (data.position == 0) {
                                    data.position = resetValue;
                                    data.val = getNextValue(data.index++);
                                    }
                                    bits |= (resb>0 ? 1 : 0) * power;
                                    power <<= 1;
                                }
                            
                                switch (c = bits) {
                                    case 0:
                                    bits = 0;
                                    maxpower = Math.pow(2,8);
                                    power=1;
                                    while (power!=maxpower) {
                                        resb = data.val & data.position;
                                        data.position >>= 1;
                                        if (data.position == 0) {
                                        data.position = resetValue;
                                        data.val = getNextValue(data.index++);
                                        }
                                        bits |= (resb>0 ? 1 : 0) * power;
                                        power <<= 1;
                                    }
                            
                                    dictionary[dictSize++] = f(bits);
                                    c = dictSize-1;
                                    enlargeIn--;
                                    break;
                                    case 1:
                                    bits = 0;
                                    maxpower = Math.pow(2,16);
                                    power=1;
                                    while (power!=maxpower) {
                                        resb = data.val & data.position;
                                        data.position >>= 1;
                                        if (data.position == 0) {
                                        data.position = resetValue;
                                        data.val = getNextValue(data.index++);
                                        }
                                        bits |= (resb>0 ? 1 : 0) * power;
                                        power <<= 1;
                                    }
                                    dictionary[dictSize++] = f(bits);
                                    c = dictSize-1;
                                    enlargeIn--;
                                    break;
                                    case 2:
                                    return result.join('');
                                }
                            
                                if (enlargeIn == 0) {
                                    enlargeIn = Math.pow(2, numBits);
                                    numBits++;
                                }
                            
                                if (dictionary[c]) {
                                    entry = dictionary[c];
                                } else {
                                    if (c === dictSize) {
                                    entry = w + w.charAt(0);
                                    } else {
                                    return null;
                                    }
                                }
                                result.push(entry);
                            
                                // Add w+entry[0] to the dictionary.
                                dictionary[dictSize++] = w + entry.charAt(0);
                                enlargeIn--;
                            
                                w = entry;
                            
                                if (enlargeIn == 0) {
                                    enlargeIn = Math.pow(2, numBits);
                                    numBits++;
                                }
                            
                                }
                            }
                        };
                        return LZString;
                    })();
                    (function (global, factory) {
                    	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
                    	typeof define === 'function' && define.amd ? define(['exports'], factory) :
                        (factory((global.opentype = {})));
                    }(this, (function (exports) { 'use strict';
                        // https://github.com/opentypejs/opentype.js/blob/master/dist/opentype.js
                    
                        // https://opentype.js.org v0.11.0 | (c) Frederik De Bleser and other contributors | MIT License | 
                        // Uses tiny-inflate by Devon Govett and string.prototype.codepointat polyfill by Mathias Bynens
                    
                    	/* https://mths.be/codepointat v0.2.0 by @mathias */
                    	if (!String.prototype.codePointAt) {
                    		(function() {
                    			var defineProperty = (function() {
                    				// IE 8 only supports `Object.defineProperty` on DOM elements
                    				try {
                    					var object = {};
                    					var $defineProperty = Object.defineProperty;
                    					var result = $defineProperty(object, object, object) && $defineProperty;
                    				} catch(error) {}
                    				return result;
                    			}());
                    			var codePointAt = function(position) {
                    				if (this == null) {
                    					throw TypeError();
                    				}
                    				var string = String(this);
                    				var size = string.length;
                    				// `ToInteger`
                    				var index = position ? Number(position) : 0;
                    				if (index != index) { // better `isNaN`
                    					index = 0;
                    				}
                    				// Account for out-of-bounds indices:
                    				if (index < 0 || index >= size) {
                    					return undefined;
                    				}
                    				// Get the first code unit
                    				var first = string.charCodeAt(index);
                    				var second;
                    				if ( // check if it’s the start of a surrogate pair
                    					first >= 0xD800 && first <= 0xDBFF && // high surrogate
                    					size > index + 1 // there is a next code unit
                    				) {
                    					second = string.charCodeAt(index + 1);
                    					if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
                    						// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                    						return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
                    					}
                    				}
                    				return first;
                    			};
                    			if (defineProperty) {
                    				defineProperty(String.prototype, 'codePointAt', {
                    					'value': codePointAt,
                    					'configurable': true,
                    					'writable': true
                    				});
                    			} else {
                    				String.prototype.codePointAt = codePointAt;
                    			}
                    		}());
                    	}
                    
                    	var TINF_OK = 0;
                    	var TINF_DATA_ERROR = -3;
                    
                    	function Tree() {
                    	  this.table = new Uint16Array(16);   /* table of code length counts */
                    	  this.trans = new Uint16Array(288);  /* code -> symbol translation table */
                    	}
                    
                    	function Data(source, dest) {
                    	  this.source = source;
                    	  this.sourceIndex = 0;
                    	  this.tag = 0;
                    	  this.bitcount = 0;
                    	  
                    	  this.dest = dest;
                    	  this.destLen = 0;
                    	  
                    	  this.ltree = new Tree();  /* dynamic length/symbol tree */
                    	  this.dtree = new Tree();  /* dynamic distance tree */
                    	}
                    
                    	/* --------------------------------------------------- *
                    	 * -- uninitialized global data (static structures) -- *
                    	 * --------------------------------------------------- */
                    
                    	var sltree = new Tree();
                    	var sdtree = new Tree();
                    
                    	/* extra bits and base tables for length codes */
                    	var length_bits = new Uint8Array(30);
                    	var length_base = new Uint16Array(30);
                    
                    	/* extra bits and base tables for distance codes */
                    	var dist_bits = new Uint8Array(30);
                    	var dist_base = new Uint16Array(30);
                    
                    	/* special ordering of code length codes */
                    	var clcidx = new Uint8Array([
                    	  16, 17, 18, 0, 8, 7, 9, 6,
                    	  10, 5, 11, 4, 12, 3, 13, 2,
                    	  14, 1, 15
                    	]);
                    
                    	/* used by tinf_decode_trees, avoids allocations every call */
                    	var code_tree = new Tree();
                    	var lengths = new Uint8Array(288 + 32);
                    
                    	/* ----------------------- *
                    	 * -- utility functions -- *
                    	 * ----------------------- */
                    
                    	/* build extra bits and base tables */
                    	function tinf_build_bits_base(bits, base, delta, first) {
                    	  var i, sum;
                    
                    	  /* build bits table */
                    	  for (i = 0; i < delta; ++i) { bits[i] = 0; }
                    	  for (i = 0; i < 30 - delta; ++i) { bits[i + delta] = i / delta | 0; }
                    
                    	  /* build base table */
                    	  for (sum = first, i = 0; i < 30; ++i) {
                    	    base[i] = sum;
                    	    sum += 1 << bits[i];
                    	  }
                    	}
                    
                    	/* build the fixed huffman trees */
                    	function tinf_build_fixed_trees(lt, dt) {
                    	  var i;
                    
                    	  /* build fixed length tree */
                    	  for (i = 0; i < 7; ++i) { lt.table[i] = 0; }
                    
                    	  lt.table[7] = 24;
                    	  lt.table[8] = 152;
                    	  lt.table[9] = 112;
                    
                    	  for (i = 0; i < 24; ++i) { lt.trans[i] = 256 + i; }
                    	  for (i = 0; i < 144; ++i) { lt.trans[24 + i] = i; }
                    	  for (i = 0; i < 8; ++i) { lt.trans[24 + 144 + i] = 280 + i; }
                    	  for (i = 0; i < 112; ++i) { lt.trans[24 + 144 + 8 + i] = 144 + i; }
                    
                    	  /* build fixed distance tree */
                    	  for (i = 0; i < 5; ++i) { dt.table[i] = 0; }
                    
                    	  dt.table[5] = 32;
                    
                    	  for (i = 0; i < 32; ++i) { dt.trans[i] = i; }
                    	}
                    
                    	/* given an array of code lengths, build a tree */
                    	var offs = new Uint16Array(16);
                    
                    	function tinf_build_tree(t, lengths, off, num) {
                    	  var i, sum;
                    
                    	  /* clear code length count table */
                    	  for (i = 0; i < 16; ++i) { t.table[i] = 0; }
                    
                    	  /* scan symbol lengths, and sum code length counts */
                    	  for (i = 0; i < num; ++i) { t.table[lengths[off + i]]++; }
                    
                    	  t.table[0] = 0;
                    
                    	  /* compute offset table for distribution sort */
                    	  for (sum = 0, i = 0; i < 16; ++i) {
                    	    offs[i] = sum;
                    	    sum += t.table[i];
                    	  }
                    
                    	  /* create code->symbol translation table (symbols sorted by code) */
                    	  for (i = 0; i < num; ++i) {
                    	    if (lengths[off + i]) { t.trans[offs[lengths[off + i]]++] = i; }
                    	  }
                    	}
                    
                    	/* ---------------------- *
                    	 * -- decode functions -- *
                    	 * ---------------------- */
                    
                    	/* get one bit from source stream */
                    	function tinf_getbit(d) {
                    	  /* check if tag is empty */
                    	  if (!d.bitcount--) {
                    	    /* load next tag */
                    	    d.tag = d.source[d.sourceIndex++];
                    	    d.bitcount = 7;
                    	  }
                    
                    	  /* shift bit out of tag */
                    	  var bit = d.tag & 1;
                    	  d.tag >>>= 1;
                    
                    	  return bit;
                    	}
                    
                    	/* read a num bit value from a stream and add base */
                    	function tinf_read_bits(d, num, base) {
                    	  if (!num)
                    	    { return base; }
                    
                    	  while (d.bitcount < 24) {
                    	    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
                    	    d.bitcount += 8;
                    	  }
                    
                    	  var val = d.tag & (0xffff >>> (16 - num));
                    	  d.tag >>>= num;
                    	  d.bitcount -= num;
                    	  return val + base;
                    	}
                    
                    	/* given a data stream and a tree, decode a symbol */
                    	function tinf_decode_symbol(d, t) {
                    	  while (d.bitcount < 24) {
                    	    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
                    	    d.bitcount += 8;
                    	  }
                    	  
                    	  var sum = 0, cur = 0, len = 0;
                    	  var tag = d.tag;
                    
                    	  /* get more bits while code value is above sum */
                    	  do {
                    	    cur = 2 * cur + (tag & 1);
                    	    tag >>>= 1;
                    	    ++len;
                    
                    	    sum += t.table[len];
                    	    cur -= t.table[len];
                    	  } while (cur >= 0);
                    	  
                    	  d.tag = tag;
                    	  d.bitcount -= len;
                    
                    	  return t.trans[sum + cur];
                    	}
                    
                    	/* given a data stream, decode dynamic trees from it */
                    	function tinf_decode_trees(d, lt, dt) {
                    	  var hlit, hdist, hclen;
                    	  var i, num, length;
                    
                    	  /* get 5 bits HLIT (257-286) */
                    	  hlit = tinf_read_bits(d, 5, 257);
                    
                    	  /* get 5 bits HDIST (1-32) */
                    	  hdist = tinf_read_bits(d, 5, 1);
                    
                    	  /* get 4 bits HCLEN (4-19) */
                    	  hclen = tinf_read_bits(d, 4, 4);
                    
                    	  for (i = 0; i < 19; ++i) { lengths[i] = 0; }
                    
                    	  /* read code lengths for code length alphabet */
                    	  for (i = 0; i < hclen; ++i) {
                    	    /* get 3 bits code length (0-7) */
                    	    var clen = tinf_read_bits(d, 3, 0);
                    	    lengths[clcidx[i]] = clen;
                    	  }
                    
                    	  /* build code length tree */
                    	  tinf_build_tree(code_tree, lengths, 0, 19);
                    
                    	  /* decode code lengths for the dynamic trees */
                    	  for (num = 0; num < hlit + hdist;) {
                    	    var sym = tinf_decode_symbol(d, code_tree);
                    
                    	    switch (sym) {
                    	      case 16:
                    	        /* copy previous code length 3-6 times (read 2 bits) */
                    	        var prev = lengths[num - 1];
                    	        for (length = tinf_read_bits(d, 2, 3); length; --length) {
                    	          lengths[num++] = prev;
                    	        }
                    	        break;
                    	      case 17:
                    	        /* repeat code length 0 for 3-10 times (read 3 bits) */
                    	        for (length = tinf_read_bits(d, 3, 3); length; --length) {
                    	          lengths[num++] = 0;
                    	        }
                    	        break;
                    	      case 18:
                    	        /* repeat code length 0 for 11-138 times (read 7 bits) */
                    	        for (length = tinf_read_bits(d, 7, 11); length; --length) {
                    	          lengths[num++] = 0;
                    	        }
                    	        break;
                    	      default:
                    	        /* values 0-15 represent the actual code lengths */
                    	        lengths[num++] = sym;
                    	        break;
                    	    }
                    	  }
                    
                    	  /* build dynamic trees */
                    	  tinf_build_tree(lt, lengths, 0, hlit);
                    	  tinf_build_tree(dt, lengths, hlit, hdist);
                    	}
                    
                    	/* ----------------------------- *
                    	 * -- block inflate functions -- *
                    	 * ----------------------------- */
                    
                    	/* given a stream and two trees, inflate a block of data */
                    	function tinf_inflate_block_data(d, lt, dt) {
                    	  while (1) {
                    	    var sym = tinf_decode_symbol(d, lt);
                    
                    	    /* check for end of block */
                    	    if (sym === 256) {
                    	      return TINF_OK;
                    	    }
                    
                    	    if (sym < 256) {
                    	      d.dest[d.destLen++] = sym;
                    	    } else {
                    	      var length, dist, offs;
                    	      var i;
                    
                    	      sym -= 257;
                    
                    	      /* possibly get more bits from length code */
                    	      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);
                    
                    	      dist = tinf_decode_symbol(d, dt);
                    
                    	      /* possibly get more bits from distance code */
                    	      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);
                    
                    	      /* copy match */
                    	      for (i = offs; i < offs + length; ++i) {
                    	        d.dest[d.destLen++] = d.dest[i];
                    	      }
                    	    }
                    	  }
                    	}
                    
                    	/* inflate an uncompressed block of data */
                    	function tinf_inflate_uncompressed_block(d) {
                    	  var length, invlength;
                    	  var i;
                    	  
                    	  /* unread from bitbuffer */
                    	  while (d.bitcount > 8) {
                    	    d.sourceIndex--;
                    	    d.bitcount -= 8;
                    	  }
                    
                    	  /* get length */
                    	  length = d.source[d.sourceIndex + 1];
                    	  length = 256 * length + d.source[d.sourceIndex];
                    
                    	  /* get one's complement of length */
                    	  invlength = d.source[d.sourceIndex + 3];
                    	  invlength = 256 * invlength + d.source[d.sourceIndex + 2];
                    
                    	  /* check length */
                    	  if (length !== (~invlength & 0x0000ffff))
                    	    { return TINF_DATA_ERROR; }
                    
                    	  d.sourceIndex += 4;
                    
                    	  /* copy block */
                    	  for (i = length; i; --i)
                    	    { d.dest[d.destLen++] = d.source[d.sourceIndex++]; }
                    
                    	  /* make sure we start next block on a byte boundary */
                    	  d.bitcount = 0;
                    
                    	  return TINF_OK;
                    	}
                    
                    	/* inflate stream from source to dest */
                    	function tinf_uncompress(source, dest) {
                    	  var d = new Data(source, dest);
                    	  var bfinal, btype, res;
                    
                    	  do {
                    	    /* read final block flag */
                    	    bfinal = tinf_getbit(d);
                    
                    	    /* read block type (2 bits) */
                    	    btype = tinf_read_bits(d, 2, 0);
                    
                    	    /* decompress block */
                    	    switch (btype) {
                    	      case 0:
                    	        /* decompress uncompressed block */
                    	        res = tinf_inflate_uncompressed_block(d);
                    	        break;
                    	      case 1:
                    	        /* decompress block with fixed huffman trees */
                    	        res = tinf_inflate_block_data(d, sltree, sdtree);
                    	        break;
                    	      case 2:
                    	        /* decompress block with dynamic huffman trees */
                    	        tinf_decode_trees(d, d.ltree, d.dtree);
                    	        res = tinf_inflate_block_data(d, d.ltree, d.dtree);
                    	        break;
                    	      default:
                    	        res = TINF_DATA_ERROR;
                    	    }
                    
                    	    if (res !== TINF_OK)
                    	      { throw new Error('Data error'); }
                    
                    	  } while (!bfinal);
                    
                    	  if (d.destLen < d.dest.length) {
                    	    if (typeof d.dest.slice === 'function')
                    	      { return d.dest.slice(0, d.destLen); }
                    	    else
                    	      { return d.dest.subarray(0, d.destLen); }
                    	  }
                    	  
                    	  return d.dest;
                    	}
                    
                    	/* -------------------- *
                    	 * -- initialization -- *
                    	 * -------------------- */
                    
                    	/* build fixed huffman trees */
                    	tinf_build_fixed_trees(sltree, sdtree);
                    
                    	/* build extra bits and base tables */
                    	tinf_build_bits_base(length_bits, length_base, 4, 3);
                    	tinf_build_bits_base(dist_bits, dist_base, 2, 1);
                    
                    	/* fix a special case */
                    	length_bits[28] = 0;
                    	length_base[28] = 258;
                    
                    	var tinyInflate = tinf_uncompress;
                    
                    	// The Bounding Box object
                    
                    	function derive(v0, v1, v2, v3, t) {
                    	    return Math.pow(1 - t, 3) * v0 +
                    	        3 * Math.pow(1 - t, 2) * t * v1 +
                    	        3 * (1 - t) * Math.pow(t, 2) * v2 +
                    	        Math.pow(t, 3) * v3;
                    	}
                    	/**
                    	 * A bounding box is an enclosing box that describes the smallest measure within which all the points lie.
                    	 * It is used to calculate the bounding box of a glyph or text path.
                    	 *
                    	 * On initialization, x1/y1/x2/y2 will be NaN. Check if the bounding box is empty using `isEmpty()`.
                    	 *
                    	 * @exports opentype.BoundingBox
                    	 * @class
                    	 * @constructor
                    	 */
                    	function BoundingBox() {
                    	    this.x1 = Number.NaN;
                    	    this.y1 = Number.NaN;
                    	    this.x2 = Number.NaN;
                    	    this.y2 = Number.NaN;
                    	}
                    
                    	/**
                    	 * Returns true if the bounding box is empty, that is, no points have been added to the box yet.
                    	 */
                    	BoundingBox.prototype.isEmpty = function() {
                    	    return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
                    	};
                    
                    	/**
                    	 * Add the point to the bounding box.
                    	 * The x1/y1/x2/y2 coordinates of the bounding box will now encompass the given point.
                    	 * @param {number} x - The X coordinate of the point.
                    	 * @param {number} y - The Y coordinate of the point.
                    	 */
                    	BoundingBox.prototype.addPoint = function(x, y) {
                    	    if (typeof x === 'number') {
                    	        if (isNaN(this.x1) || isNaN(this.x2)) {
                    	            this.x1 = x;
                    	            this.x2 = x;
                    	        }
                    	        if (x < this.x1) {
                    	            this.x1 = x;
                    	        }
                    	        if (x > this.x2) {
                    	            this.x2 = x;
                    	        }
                    	    }
                    	    if (typeof y === 'number') {
                    	        if (isNaN(this.y1) || isNaN(this.y2)) {
                    	            this.y1 = y;
                    	            this.y2 = y;
                    	        }
                    	        if (y < this.y1) {
                    	            this.y1 = y;
                    	        }
                    	        if (y > this.y2) {
                    	            this.y2 = y;
                    	        }
                    	    }
                    	};
                    
                    	/**
                    	 * Add a X coordinate to the bounding box.
                    	 * This extends the bounding box to include the X coordinate.
                    	 * This function is used internally inside of addBezier.
                    	 * @param {number} x - The X coordinate of the point.
                    	 */
                    	BoundingBox.prototype.addX = function(x) {
                    	    this.addPoint(x, null);
                    	};
                    
                    	/**
                    	 * Add a Y coordinate to the bounding box.
                    	 * This extends the bounding box to include the Y coordinate.
                    	 * This function is used internally inside of addBezier.
                    	 * @param {number} y - The Y coordinate of the point.
                    	 */
                    	BoundingBox.prototype.addY = function(y) {
                    	    this.addPoint(null, y);
                    	};
                    
                    	/**
                    	 * Add a Bézier curve to the bounding box.
                    	 * This extends the bounding box to include the entire Bézier.
                    	 * @param {number} x0 - The starting X coordinate.
                    	 * @param {number} y0 - The starting Y coordinate.
                    	 * @param {number} x1 - The X coordinate of the first control point.
                    	 * @param {number} y1 - The Y coordinate of the first control point.
                    	 * @param {number} x2 - The X coordinate of the second control point.
                    	 * @param {number} y2 - The Y coordinate of the second control point.
                    	 * @param {number} x - The ending X coordinate.
                    	 * @param {number} y - The ending Y coordinate.
                    	 */
                    	BoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {
                    	    var this$1 = this;
                    
                    	    // This code is based on http://nishiohirokazu.blogspot.com/2009/06/how-to-calculate-bezier-curves-bounding.html
                    	    // and https://github.com/icons8/svg-path-bounding-box
                    
                    	    var p0 = [x0, y0];
                    	    var p1 = [x1, y1];
                    	    var p2 = [x2, y2];
                    	    var p3 = [x, y];
                    
                    	    this.addPoint(x0, y0);
                    	    this.addPoint(x, y);
                    
                    	    for (var i = 0; i <= 1; i++) {
                    	        var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
                    	        var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
                    	        var c = 3 * p1[i] - 3 * p0[i];
                    
                    	        if (a === 0) {
                    	            if (b === 0) { continue; }
                    	            var t = -c / b;
                    	            if (0 < t && t < 1) {
                    	                if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t)); }
                    	                if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t)); }
                    	            }
                    	            continue;
                    	        }
                    
                    	        var b2ac = Math.pow(b, 2) - 4 * c * a;
                    	        if (b2ac < 0) { continue; }
                    	        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
                    	        if (0 < t1 && t1 < 1) {
                    	            if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t1)); }
                    	            if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t1)); }
                    	        }
                    	        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
                    	        if (0 < t2 && t2 < 1) {
                    	            if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t2)); }
                    	            if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t2)); }
                    	        }
                    	    }
                    	};
                    
                    	/**
                    	 * Add a quadratic curve to the bounding box.
                    	 * This extends the bounding box to include the entire quadratic curve.
                    	 * @param {number} x0 - The starting X coordinate.
                    	 * @param {number} y0 - The starting Y coordinate.
                    	 * @param {number} x1 - The X coordinate of the control point.
                    	 * @param {number} y1 - The Y coordinate of the control point.
                    	 * @param {number} x - The ending X coordinate.
                    	 * @param {number} y - The ending Y coordinate.
                    	 */
                    	BoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {
                    	    var cp1x = x0 + 2 / 3 * (x1 - x0);
                    	    var cp1y = y0 + 2 / 3 * (y1 - y0);
                    	    var cp2x = cp1x + 1 / 3 * (x - x0);
                    	    var cp2y = cp1y + 1 / 3 * (y - y0);
                    	    this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);
                    	};
                    
                    	// Geometric objects
                    
                    	/**
                    	 * A bézier path containing a set of path commands similar to a SVG path.
                    	 * Paths can be drawn on a context using `draw`.
                    	 * @exports opentype.Path
                    	 * @class
                    	 * @constructor
                    	 */
                    	function Path() {
                    	    this.commands = [];
                    	    this.fill = 'black';
                    	    this.stroke = null;
                    	    this.strokeWidth = 1;
                    	}
                    
                    	/**
                    	 * @param  {number} x
                    	 * @param  {number} y
                    	 */
                    	Path.prototype.moveTo = function(x, y) {
                    	    this.commands.push({
                    	        type: 'M',
                    	        x: x,
                    	        y: y
                    	    });
                    	};
                    
                    	/**
                    	 * @param  {number} x
                    	 * @param  {number} y
                    	 */
                    	Path.prototype.lineTo = function(x, y) {
                    	    this.commands.push({
                    	        type: 'L',
                    	        x: x,
                    	        y: y
                    	    });
                    	};
                    
                    	/**
                    	 * Draws cubic curve
                    	 * @function
                    	 * curveTo
                    	 * @memberof opentype.Path.prototype
                    	 * @param  {number} x1 - x of control 1
                    	 * @param  {number} y1 - y of control 1
                    	 * @param  {number} x2 - x of control 2
                    	 * @param  {number} y2 - y of control 2
                    	 * @param  {number} x - x of path point
                    	 * @param  {number} y - y of path point
                    	 */
                    
                    	/**
                    	 * Draws cubic curve
                    	 * @function
                    	 * bezierCurveTo
                    	 * @memberof opentype.Path.prototype
                    	 * @param  {number} x1 - x of control 1
                    	 * @param  {number} y1 - y of control 1
                    	 * @param  {number} x2 - x of control 2
                    	 * @param  {number} y2 - y of control 2
                    	 * @param  {number} x - x of path point
                    	 * @param  {number} y - y of path point
                    	 * @see curveTo
                    	 */
                    	Path.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {
                    	    this.commands.push({
                    	        type: 'C',
                    	        x1: x1,
                    	        y1: y1,
                    	        x2: x2,
                    	        y2: y2,
                    	        x: x,
                    	        y: y
                    	    });
                    	};
                    
                    	/**
                    	 * Draws quadratic curve
                    	 * @function
                    	 * quadraticCurveTo
                    	 * @memberof opentype.Path.prototype
                    	 * @param  {number} x1 - x of control
                    	 * @param  {number} y1 - y of control
                    	 * @param  {number} x - x of path point
                    	 * @param  {number} y - y of path point
                    	 */
                    
                    	/**
                    	 * Draws quadratic curve
                    	 * @function
                    	 * quadTo
                    	 * @memberof opentype.Path.prototype
                    	 * @param  {number} x1 - x of control
                    	 * @param  {number} y1 - y of control
                    	 * @param  {number} x - x of path point
                    	 * @param  {number} y - y of path point
                    	 */
                    	Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {
                    	    this.commands.push({
                    	        type: 'Q',
                    	        x1: x1,
                    	        y1: y1,
                    	        x: x,
                    	        y: y
                    	    });
                    	};
                    
                    	/**
                    	 * Closes the path
                    	 * @function closePath
                    	 * @memberof opentype.Path.prototype
                    	 */
                    
                    	/**
                    	 * Close the path
                    	 * @function close
                    	 * @memberof opentype.Path.prototype
                    	 */
                    	Path.prototype.close = Path.prototype.closePath = function() {
                    	    this.commands.push({
                    	        type: 'Z'
                    	    });
                    	};
                    
                    	/**
                    	 * Add the given path or list of commands to the commands of this path.
                    	 * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.
                    	 */
                    	Path.prototype.extend = function(pathOrCommands) {
                    	    if (pathOrCommands.commands) {
                    	        pathOrCommands = pathOrCommands.commands;
                    	    } else if (pathOrCommands instanceof BoundingBox) {
                    	        var box = pathOrCommands;
                    	        this.moveTo(box.x1, box.y1);
                    	        this.lineTo(box.x2, box.y1);
                    	        this.lineTo(box.x2, box.y2);
                    	        this.lineTo(box.x1, box.y2);
                    	        this.close();
                    	        return;
                    	    }
                    
                    	    Array.prototype.push.apply(this.commands, pathOrCommands);
                    	};
                    
                    	/**
                    	 * Calculate the bounding box of the path.
                    	 * @returns {opentype.BoundingBox}
                    	 */
                    	Path.prototype.getBoundingBox = function() {
                    	    var this$1 = this;
                    
                    	    var box = new BoundingBox();
                    
                    	    var startX = 0;
                    	    var startY = 0;
                    	    var prevX = 0;
                    	    var prevY = 0;
                    	    for (var i = 0; i < this.commands.length; i++) {
                    	        var cmd = this$1.commands[i];
                    	        switch (cmd.type) {
                    	            case 'M':
                    	                box.addPoint(cmd.x, cmd.y);
                    	                startX = prevX = cmd.x;
                    	                startY = prevY = cmd.y;
                    	                break;
                    	            case 'L':
                    	                box.addPoint(cmd.x, cmd.y);
                    	                prevX = cmd.x;
                    	                prevY = cmd.y;
                    	                break;
                    	            case 'Q':
                    	                box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);
                    	                prevX = cmd.x;
                    	                prevY = cmd.y;
                    	                break;
                    	            case 'C':
                    	                box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                    	                prevX = cmd.x;
                    	                prevY = cmd.y;
                    	                break;
                    	            case 'Z':
                    	                prevX = startX;
                    	                prevY = startY;
                    	                break;
                    	            default:
                    	                throw new Error('Unexpected path command ' + cmd.type);
                    	        }
                    	    }
                    	    if (box.isEmpty()) {
                    	        box.addPoint(0, 0);
                    	    }
                    	    return box;
                    	};
                    
                    	/**
                    	 * Draw the path to a 2D context.
                    	 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context.
                    	 */
                    	Path.prototype.draw = function(ctx) {
                    	    var this$1 = this;
                    
                    	    ctx.beginPath();
                    	    for (var i = 0; i < this.commands.length; i += 1) {
                    	        var cmd = this$1.commands[i];
                    	        if (cmd.type === 'M') {
                    	            ctx.moveTo(cmd.x, cmd.y);
                    	        } else if (cmd.type === 'L') {
                    	            ctx.lineTo(cmd.x, cmd.y);
                    	        } else if (cmd.type === 'C') {
                    	            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                    	        } else if (cmd.type === 'Q') {
                    	            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
                    	        } else if (cmd.type === 'Z') {
                    	            ctx.closePath();
                    	        }
                    	    }
                    
                    	    if (this.fill) {
                    	        ctx.fillStyle = this.fill;
                    	        ctx.fill();
                    	    }
                    
                    	    if (this.stroke) {
                    	        ctx.strokeStyle = this.stroke;
                    	        ctx.lineWidth = this.strokeWidth;
                    	        ctx.stroke();
                    	    }
                    	};
                    
                    	/**
                    	 * Convert the Path to a string of path data instructions
                    	 * See http://www.w3.org/TR/SVG/paths.html#PathData
                    	 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
                    	 * @return {string}
                    	 */
                    	Path.prototype.toPathData = function(decimalPlaces) {
                    	    var this$1 = this;
                    
                    	    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;
                    
                    	    function floatToString(v) {
                    	        if (Math.round(v) === v) {
                    	            return '' + Math.round(v);
                    	        } else {
                    	            return v.toFixed(decimalPlaces);
                    	        }
                    	    }
                    
                    	    function packValues() {
                    	        var arguments$1 = arguments;
                    
                    	        var s = '';
                    	        for (var i = 0; i < arguments.length; i += 1) {
                    	            var v = arguments$1[i];
                    	            if (v >= 0 && i > 0) {
                    	                s += ' ';
                    	            }
                    
                    	            s += floatToString(v);
                    	        }
                    
                    	        return s;
                    	    }
                    
                    	    var d = '';
                    	    for (var i = 0; i < this.commands.length; i += 1) {
                    	        var cmd = this$1.commands[i];
                    	        if (cmd.type === 'M') {
                    	            d += 'M' + packValues(cmd.x, cmd.y);
                    	        } else if (cmd.type === 'L') {
                    	            d += 'L' + packValues(cmd.x, cmd.y);
                    	        } else if (cmd.type === 'C') {
                    	            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                    	        } else if (cmd.type === 'Q') {
                    	            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
                    	        } else if (cmd.type === 'Z') {
                    	            d += 'Z';
                    	        }
                    	    }
                    
                    	    return d;
                    	};
                    
                    	/**
                    	 * Convert the path to an SVG <path> element, as a string.
                    	 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
                    	 * @return {string}
                    	 */
                    	Path.prototype.toSVG = function(decimalPlaces) {
                    	    var svg = '<path d="';
                    	    svg += this.toPathData(decimalPlaces);
                    	    svg += '"';
                    	    if (this.fill && this.fill !== 'black') {
                    	        if (this.fill === null) {
                    	            svg += ' fill="none"';
                    	        } else {
                    	            svg += ' fill="' + this.fill + '"';
                    	        }
                    	    }
                    
                    	    if (this.stroke) {
                    	        svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
                    	    }
                    
                    	    svg += '/>';
                    	    return svg;
                    	};
                    
                    	/**
                    	 * Convert the path to a DOM element.
                    	 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
                    	 * @return {SVGPathElement}
                    	 */
                    	Path.prototype.toDOMElement = function(decimalPlaces) {
                    	    var temporaryPath = this.toPathData(decimalPlaces);
                    	    var newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    
                    	    newPath.setAttribute('d', temporaryPath);
                    
                    	    return newPath;
                    	};
                    
                    	// Run-time checking of preconditions.
                    
                    	function fail(message) {
                    	    throw new Error(message);
                    	}
                    
                    	// Precondition function that checks if the given predicate is true.
                    	// If not, it will throw an error.
                    	function argument(predicate, message) {
                    	    if (!predicate) {
                    	        fail(message);
                    	    }
                    	}
                    	var check = { fail: fail, argument: argument, assert: argument };
                    
                    	// Data types used in the OpenType font file.
                    
                    	var LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15
                    	var LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31
                    
                    	/**
                    	 * @exports opentype.decode
                    	 * @class
                    	 */
                    	var decode = {};
                    	/**
                    	 * @exports opentype.encode
                    	 * @class
                    	 */
                    	var encode = {};
                    	/**
                    	 * @exports opentype.sizeOf
                    	 * @class
                    	 */
                    	var sizeOf = {};
                    
                    	// Return a function that always returns the same value.
                    	function constant(v) {
                    	    return function() {
                    	        return v;
                    	    };
                    	}
                    
                    	// OpenType data types //////////////////////////////////////////////////////
                    
                    	/**
                    	 * Convert an 8-bit unsigned integer to a list of 1 byte.
                    	 * @param {number}
                    	 * @returns {Array}
                    	 */
                    	encode.BYTE = function(v) {
                    	    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');
                    	    return [v];
                    	};
                    	/**
                    	 * @constant
                    	 * @type {number}
                    	 */
                    	sizeOf.BYTE = constant(1);
                    
                    	/**
                    	 * Convert a 8-bit signed integer to a list of 1 byte.
                    	 * @param {string}
                    	 * @returns {Array}
                    	 */
                    	encode.CHAR = function(v) {
                    	    return [v.charCodeAt(0)];
                    	};
                    
                    	/**
                    	 * @constant
                    	 * @type {number}
                    	 */
                    	sizeOf.CHAR = constant(1);
                    
                    	/**
                    	 * Convert an ASCII string to a list of bytes.
                    	 * @param {string}
                    	 * @returns {Array}
                    	 */
                    	encode.CHARARRAY = function(v) {
                    	    var b = [];
                    	    for (var i = 0; i < v.length; i += 1) {
                    	        b[i] = v.charCodeAt(i);
                    	    }
                    
                    	    return b;
                    	};
                    
                    	/**
                    	 * @param {Array}
                    	 * @returns {number}
                    	 */
                    	sizeOf.CHARARRAY = function(v) {
                    	    return v.length;
                    	};
                    
                    	/**
                    	 * Convert a 16-bit unsigned integer to a list of 2 bytes.
                    	 * @param {number}
                    	 * @returns {Array}
                    	 */
                    	encode.USHORT = function(v) {
                    	    return [(v >> 8) & 0xFF, v & 0xFF];
                    	};
                    
                    	/**
                    	 * @constant
                    	 * @type {number}
                    	 */
                    	sizeOf.USHORT = constant(2);
                    
                    	/**
                    	 * Convert a 16-bit signed integer to a list of 2 bytes.
                    	 * @param {number}
                    	 * @returns {Array}
                    	 */
                    	encode.SHORT = function(v) {
                    	    // Two's complement
                    	    if (v >= LIMIT16) {
                    	        v = -(2 * LIMIT16 - v);
                    	    }
                    
                    	    return [(v >> 8) & 0xFF, v & 0xFF];
                    	};
                    
                    	/**
                    	 * @constant
                    	 * @type {number}
                    	 */
                    	sizeOf.SHORT = constant(2);
                    
                    	/**
                    	 * Convert a 24-bit unsigned integer to a list of 3 bytes.
                    	 * @param {number}
                    	 * @returns {Array}
                    	 */
                    	encode.UINT24 = function(v) {
                    	    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
                    	};
                    
                    	/**
                    	 * @constant
                    	 * @type {number}
                    	 */
                    	sizeOf.UINT24 = constant(3);
                    
                    	/**
                    	 * Convert a 32-bit unsigned integer to a list of 4 bytes.
                    	 * @param {number}
                    	 * @returns {Array}
                    	 */
                    	encode.ULONG = function(v) {
                    	    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
                    	};
                    
                    	/**
                    	 * @constant
                    	 * @type {number}
                    	 */
                    	sizeOf.ULONG = constant(4);
                    
                    	/**
                    	 * Convert a 32-bit unsigned integer to a list of 4 bytes.
                    	 * @param {number}
                    	 * @returns {Array}
                    	 */
                    	encode.LONG = function(v) {
                    	    // Two's complement
                    	    if (v >= LIMIT32) {
                    	        v = -(2 * LIMIT32 - v);
                    	    }
                    
                    	    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
                    	};
                    
                    	/**
                    	 * @constant
                    	 * @type {number}
                    	 */
                    	sizeOf.LONG = constant(4);
                    
                    	encode.FIXED = encode.ULONG;
                    	sizeOf.FIXED = sizeOf.ULONG;
                    
                    	encode.FWORD = encode.SHORT;
                    	sizeOf.FWORD = sizeOf.SHORT;
                    
                    	encode.UFWORD = encode.USHORT;
                    	sizeOf.UFWORD = sizeOf.USHORT;
                    
                    	/**
                    	 * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.
                    	 * @param {number}
                    	 * @returns {Array}
                    	 */
                    	encode.LONGDATETIME = function(v) {
                    	    return [0, 0, 0, 0, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
                    	};
                    
                    	/**
                    	 * @constant
                    	 * @type {number}
                    	 */
                    	sizeOf.LONGDATETIME = constant(8);
                    
                    	/**
                    	 * Convert a 4-char tag to a list of 4 bytes.
                    	 * @param {string}
                    	 * @returns {Array}
                    	 */
                    	encode.TAG = function(v) {
                    	    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');
                    	    return [v.charCodeAt(0),
                    	            v.charCodeAt(1),
                    	            v.charCodeAt(2),
                    	            v.charCodeAt(3)];
                    	};
                    
                    	/**
                    	 * @constant
                    	 * @type {number}
                    	 */
                    	sizeOf.TAG = constant(4);
                    
                    	// CFF data types ///////////////////////////////////////////////////////////
                    
                    	encode.Card8 = encode.BYTE;
                    	sizeOf.Card8 = sizeOf.BYTE;
                    
                    	encode.Card16 = encode.USHORT;
                    	sizeOf.Card16 = sizeOf.USHORT;
                    
                    	encode.OffSize = encode.BYTE;
                    	sizeOf.OffSize = sizeOf.BYTE;
                    
                    	encode.SID = encode.USHORT;
                    	sizeOf.SID = sizeOf.USHORT;
                    
                    	// Convert a numeric operand or charstring number to a variable-size list of bytes.
                    	/**
                    	 * Convert a numeric operand or charstring number to a variable-size list of bytes.
                    	 * @param {number}
                    	 * @returns {Array}
                    	 */
                    	encode.NUMBER = function(v) {
                    	    if (v >= -107 && v <= 107) {
                    	        return [v + 139];
                    	    } else if (v >= 108 && v <= 1131) {
                    	        v = v - 108;
                    	        return [(v >> 8) + 247, v & 0xFF];
                    	    } else if (v >= -1131 && v <= -108) {
                    	        v = -v - 108;
                    	        return [(v >> 8) + 251, v & 0xFF];
                    	    } else if (v >= -32768 && v <= 32767) {
                    	        return encode.NUMBER16(v);
                    	    } else {
                    	        return encode.NUMBER32(v);
                    	    }
                    	};
                    
                    	/**
                    	 * @param {number}
                    	 * @returns {number}
                    	 */
                    	sizeOf.NUMBER = function(v) {
                    	    return encode.NUMBER(v).length;
                    	};
                    
                    	/**
                    	 * Convert a signed number between -32768 and +32767 to a three-byte value.
                    	 * This ensures we always use three bytes, but is not the most compact format.
                    	 * @param {number}
                    	 * @returns {Array}
                    	 */
                    	encode.NUMBER16 = function(v) {
                    	    return [28, (v >> 8) & 0xFF, v & 0xFF];
                    	};
                    
                    	/**
                    	 * @constant
                    	 * @type {number}
                    	 */
                    	sizeOf.NUMBER16 = constant(3);
                    
                    	/**
                    	 * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.
                    	 * This is useful if you want to be sure you always use four bytes,
                    	 * at the expense of wasting a few bytes for smaller numbers.
                    	 * @param {number}
                    	 * @returns {Array}
                    	 */
                    	encode.NUMBER32 = function(v) {
                    	    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
                    	};
                    
                    	/**
                    	 * @constant
                    	 * @type {number}
                    	 */
                    	sizeOf.NUMBER32 = constant(5);
                    
                    	/**
                    	 * @param {number}
                    	 * @returns {Array}
                    	 */
                    	encode.REAL = function(v) {
                    	    var value = v.toString();
                    
                    	    // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)
                    	    // This code converts it back to a number without the epsilon.
                    	    var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
                    	    if (m) {
                    	        var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));
                    	        value = (Math.round(v * epsilon) / epsilon).toString();
                    	    }
                    
                    	    var nibbles = '';
                    	    for (var i = 0, ii = value.length; i < ii; i += 1) {
                    	        var c = value[i];
                    	        if (c === 'e') {
                    	            nibbles += value[++i] === '-' ? 'c' : 'b';
                    	        } else if (c === '.') {
                    	            nibbles += 'a';
                    	        } else if (c === '-') {
                    	            nibbles += 'e';
                    	        } else {
                    	            nibbles += c;
                    	        }
                    	    }
                    
                    	    nibbles += (nibbles.length & 1) ? 'f' : 'ff';
                    	    var out = [30];
                    	    for (var i$1 = 0, ii$1 = nibbles.length; i$1 < ii$1; i$1 += 2) {
                    	        out.push(parseInt(nibbles.substr(i$1, 2), 16));
                    	    }
                    
                    	    return out;
                    	};
                    
                    	/**
                    	 * @param {number}
                    	 * @returns {number}
                    	 */
                    	sizeOf.REAL = function(v) {
                    	    return encode.REAL(v).length;
                    	};
                    
                    	encode.NAME = encode.CHARARRAY;
                    	sizeOf.NAME = sizeOf.CHARARRAY;
                    
                    	encode.STRING = encode.CHARARRAY;
                    	sizeOf.STRING = sizeOf.CHARARRAY;
                    
                    	/**
                    	 * @param {DataView} data
                    	 * @param {number} offset
                    	 * @param {number} numBytes
                    	 * @returns {string}
                    	 */
                    	decode.UTF8 = function(data, offset, numBytes) {
                    	    var codePoints = [];
                    	    var numChars = numBytes;
                    	    for (var j = 0; j < numChars; j++, offset += 1) {
                    	        codePoints[j] = data.getUint8(offset);
                    	    }
                    
                    	    return String.fromCharCode.apply(null, codePoints);
                    	};
                    
                    	/**
                    	 * @param {DataView} data
                    	 * @param {number} offset
                    	 * @param {number} numBytes
                    	 * @returns {string}
                    	 */
                    	decode.UTF16 = function(data, offset, numBytes) {
                    	    var codePoints = [];
                    	    var numChars = numBytes / 2;
                    	    for (var j = 0; j < numChars; j++, offset += 2) {
                    	        codePoints[j] = data.getUint16(offset);
                    	    }
                    
                    	    return String.fromCharCode.apply(null, codePoints);
                    	};
                    
                    	/**
                    	 * Convert a JavaScript string to UTF16-BE.
                    	 * @param {string}
                    	 * @returns {Array}
                    	 */
                    	encode.UTF16 = function(v) {
                    	    var b = [];
                    	    for (var i = 0; i < v.length; i += 1) {
                    	        var codepoint = v.charCodeAt(i);
                    	        b[b.length] = (codepoint >> 8) & 0xFF;
                    	        b[b.length] = codepoint & 0xFF;
                    	    }
                    
                    	    return b;
                    	};
                    
                    	/**
                    	 * @param {string}
                    	 * @returns {number}
                    	 */
                    	sizeOf.UTF16 = function(v) {
                    	    return v.length * 2;
                    	};
                    
                    	// Data for converting old eight-bit Macintosh encodings to Unicode.
                    	// This representation is optimized for decoding; encoding is slower
                    	// and needs more memory. The assumption is that all opentype.js users
                    	// want to open fonts, but saving a font will be comparatively rare
                    	// so it can be more expensive. Keyed by IANA character set name.
                    	//
                    	// Python script for generating these strings:
                    	//
                    	//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])
                    	//     print(s.encode('utf-8'))
                    	/**
                    	 * @private
                    	 */
                    	var eightBitMacEncodings = {
                    	    'x-mac-croatian':  // Python: 'mac_croatian'
                    	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø' +
                    	    '¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ',
                    	    'x-mac-cyrillic':  // Python: 'mac_cyrillic'
                    	    'АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњ' +
                    	    'јЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю',
                    	    'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT
                    	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæø' +
                    	    'ṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ',
                    	    'x-mac-greek':  // Python: 'mac_greek'
                    	    'Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩ' +
                    	    'άΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ\u00AD',
                    	    'x-mac-icelandic':  // Python: 'mac_iceland'
                    	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +
                    	    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
                    	    'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT
                    	    'ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗ' +
                    	    'ᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł',
                    	    'x-mac-ce':  // Python: 'mac_latin2'
                    	    'ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅ' +
                    	    'ņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ',
                    	    macintosh:  // Python: 'mac_roman'
                    	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +
                    	    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
                    	    'x-mac-romanian':  // Python: 'mac_romanian'
                    	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș' +
                    	    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
                    	    'x-mac-turkish':  // Python: 'mac_turkish'
                    	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +
                    	    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ'
                    	};
                    
                    	/**
                    	 * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript
                    	 * string, or 'undefined' if the encoding is unsupported. For example, we do
                    	 * not support Chinese, Japanese or Korean because these would need large
                    	 * mapping tables.
                    	 * @param {DataView} dataView
                    	 * @param {number} offset
                    	 * @param {number} dataLength
                    	 * @param {string} encoding
                    	 * @returns {string}
                    	 */
                    	decode.MACSTRING = function(dataView, offset, dataLength, encoding) {
                    	    var table = eightBitMacEncodings[encoding];
                    	    if (table === undefined) {
                    	        return undefined;
                    	    }
                    
                    	    var result = '';
                    	    for (var i = 0; i < dataLength; i++) {
                    	        var c = dataView.getUint8(offset + i);
                    	        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
                    	        // mapped to U+0000..U+007F; we only need to look up the others.
                    	        if (c <= 0x7F) {
                    	            result += String.fromCharCode(c);
                    	        } else {
                    	            result += table[c & 0x7F];
                    	        }
                    	    }
                    
                    	    return result;
                    	};
                    
                    	// Helper function for encode.MACSTRING. Returns a dictionary for mapping
                    	// Unicode character codes to their 8-bit MacOS equivalent. This table
                    	// is not exactly a super cheap data structure, but we do not care because
                    	// encoding Macintosh strings is only rarely needed in typical applications.
                    	var macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap();
                    	var macEncodingCacheKeys;
                    	var getMacEncodingTable = function (encoding) {
                    	    // Since we use encoding as a cache key for WeakMap, it has to be
                    	    // a String object and not a literal. And at least on NodeJS 2.10.1,
                    	    // WeakMap requires that the same String instance is passed for cache hits.
                    	    if (!macEncodingCacheKeys) {
                    	        macEncodingCacheKeys = {};
                    	        for (var e in eightBitMacEncodings) {
                    	            /*jshint -W053 */  // Suppress "Do not use String as a constructor."
                    	            macEncodingCacheKeys[e] = new String(e);
                    	        }
                    	    }
                    
                    	    var cacheKey = macEncodingCacheKeys[encoding];
                    	    if (cacheKey === undefined) {
                    	        return undefined;
                    	    }
                    
                    	    // We can't do "if (cache.has(key)) {return cache.get(key)}" here:
                    	    // since garbage collection may run at any time, it could also kick in
                    	    // between the calls to cache.has() and cache.get(). In that case,
                    	    // we would return 'undefined' even though we do support the encoding.
                    	    if (macEncodingTableCache) {
                    	        var cachedTable = macEncodingTableCache.get(cacheKey);
                    	        if (cachedTable !== undefined) {
                    	            return cachedTable;
                    	        }
                    	    }
                    
                    	    var decodingTable = eightBitMacEncodings[encoding];
                    	    if (decodingTable === undefined) {
                    	        return undefined;
                    	    }
                    
                    	    var encodingTable = {};
                    	    for (var i = 0; i < decodingTable.length; i++) {
                    	        encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;
                    	    }
                    
                    	    if (macEncodingTableCache) {
                    	        macEncodingTableCache.set(cacheKey, encodingTable);
                    	    }
                    
                    	    return encodingTable;
                    	};
                    
                    	/**
                    	 * Encodes an old-style Macintosh string. Returns a byte array upon success.
                    	 * If the requested encoding is unsupported, or if the input string contains
                    	 * a character that cannot be expressed in the encoding, the function returns
                    	 * 'undefined'.
                    	 * @param {string} str
                    	 * @param {string} encoding
                    	 * @returns {Array}
                    	 */
                    	encode.MACSTRING = function(str, encoding) {
                    	    var table = getMacEncodingTable(encoding);
                    	    if (table === undefined) {
                    	        return undefined;
                    	    }
                    
                    	    var result = [];
                    	    for (var i = 0; i < str.length; i++) {
                    	        var c = str.charCodeAt(i);
                    
                    	        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
                    	        // mapped to U+0000..U+007F; we only need to look up the others.
                    	        if (c >= 0x80) {
                    	            c = table[c];
                    	            if (c === undefined) {
                    	                // str contains a Unicode character that cannot be encoded
                    	                // in the requested encoding.
                    	                return undefined;
                    	            }
                    	        }
                    	        result[i] = c;
                    	        // result.push(c);
                    	    }
                    
                    	    return result;
                    	};
                    
                    	/**
                    	 * @param {string} str
                    	 * @param {string} encoding
                    	 * @returns {number}
                    	 */
                    	sizeOf.MACSTRING = function(str, encoding) {
                    	    var b = encode.MACSTRING(str, encoding);
                    	    if (b !== undefined) {
                    	        return b.length;
                    	    } else {
                    	        return 0;
                    	    }
                    	};
                    
                    	// Helper for encode.VARDELTAS
                    	function isByteEncodable(value) {
                    	    return value >= -128 && value <= 127;
                    	}
                    
                    	// Helper for encode.VARDELTAS
                    	function encodeVarDeltaRunAsZeroes(deltas, pos, result) {
                    	    var runLength = 0;
                    	    var numDeltas = deltas.length;
                    	    while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {
                    	        ++pos;
                    	        ++runLength;
                    	    }
                    	    result.push(0x80 | (runLength - 1));
                    	    return pos;
                    	}
                    
                    	// Helper for encode.VARDELTAS
                    	function encodeVarDeltaRunAsBytes(deltas, offset, result) {
                    	    var runLength = 0;
                    	    var numDeltas = deltas.length;
                    	    var pos = offset;
                    	    while (pos < numDeltas && runLength < 64) {
                    	        var value = deltas[pos];
                    	        if (!isByteEncodable(value)) {
                    	            break;
                    	        }
                    
                    	        // Within a byte-encoded run of deltas, a single zero is best
                    	        // stored literally as 0x00 value. However, if we have two or
                    	        // more zeroes in a sequence, it is better to start a new run.
                    	        // Fore example, the sequence of deltas [15, 15, 0, 15, 15]
                    	        // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero
                    	        // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)
                    	        // when starting a new run.
                    	        if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {
                    	            break;
                    	        }
                    
                    	        ++pos;
                    	        ++runLength;
                    	    }
                    	    result.push(runLength - 1);
                    	    for (var i = offset; i < pos; ++i) {
                    	        result.push((deltas[i] + 256) & 0xff);
                    	    }
                    	    return pos;
                    	}
                    
                    	// Helper for encode.VARDELTAS
                    	function encodeVarDeltaRunAsWords(deltas, offset, result) {
                    	    var runLength = 0;
                    	    var numDeltas = deltas.length;
                    	    var pos = offset;
                    	    while (pos < numDeltas && runLength < 64) {
                    	        var value = deltas[pos];
                    
                    	        // Within a word-encoded run of deltas, it is easiest to start
                    	        // a new run (with a different encoding) whenever we encounter
                    	        // a zero value. For example, the sequence [0x6666, 0, 0x7777]
                    	        // needs 7 bytes when storing the zero inside the current run
                    	        // (42 66 66 00 00 77 77), and equally 7 bytes when starting a
                    	        // new run (40 66 66 80 40 77 77).
                    	        if (value === 0) {
                    	            break;
                    	        }
                    
                    	        // Within a word-encoded run of deltas, a single value in the
                    	        // range (-128..127) should be encoded within the current run
                    	        // because it is more compact. For example, the sequence
                    	        // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value
                    	        // literally (42 66 66 00 02 77 77), but 8 bytes when starting
                    	        // a new run (40 66 66 00 02 40 77 77).
                    	        if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {
                    	            break;
                    	        }
                    
                    	        ++pos;
                    	        ++runLength;
                    	    }
                    	    result.push(0x40 | (runLength - 1));
                    	    for (var i = offset; i < pos; ++i) {
                    	        var val = deltas[i];
                    	        result.push(((val + 0x10000) >> 8) & 0xff, (val + 0x100) & 0xff);
                    	    }
                    	    return pos;
                    	}
                    
                    	/**
                    	 * Encode a list of variation adjustment deltas.
                    	 *
                    	 * Variation adjustment deltas are used in ‘gvar’ and ‘cvar’ tables.
                    	 * They indicate how points (in ‘gvar’) or values (in ‘cvar’) get adjusted
                    	 * when generating instances of variation fonts.
                    	 *
                    	 * @see https://www.microsoft.com/typography/otspec/gvar.htm
                    	 * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html
                    	 * @param {Array}
                    	 * @return {Array}
                    	 */
                    	encode.VARDELTAS = function(deltas) {
                    	    var pos = 0;
                    	    var result = [];
                    	    while (pos < deltas.length) {
                    	        var value = deltas[pos];
                    	        if (value === 0) {
                    	            pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);
                    	        } else if (value >= -128 && value <= 127) {
                    	            pos = encodeVarDeltaRunAsBytes(deltas, pos, result);
                    	        } else {
                    	            pos = encodeVarDeltaRunAsWords(deltas, pos, result);
                    	        }
                    	    }
                    	    return result;
                    	};
                    
                    	// Convert a list of values to a CFF INDEX structure.
                    	// The values should be objects containing name / type / value.
                    	/**
                    	 * @param {Array} l
                    	 * @returns {Array}
                    	 */
                    	encode.INDEX = function(l) {
                    	    //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,
                    	    //    i, v;
                    	    // Because we have to know which data type to use to encode the offsets,
                    	    // we have to go through the values twice: once to encode the data and
                    	    // calculate the offsets, then again to encode the offsets using the fitting data type.
                    	    var offset = 1; // First offset is always 1.
                    	    var offsets = [offset];
                    	    var data = [];
                    	    for (var i = 0; i < l.length; i += 1) {
                    	        var v = encode.OBJECT(l[i]);
                    	        Array.prototype.push.apply(data, v);
                    	        offset += v.length;
                    	        offsets.push(offset);
                    	    }
                    
                    	    if (data.length === 0) {
                    	        return [0, 0];
                    	    }
                    
                    	    var encodedOffsets = [];
                    	    var offSize = (1 + Math.floor(Math.log(offset) / Math.log(2)) / 8) | 0;
                    	    var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];
                    	    for (var i$1 = 0; i$1 < offsets.length; i$1 += 1) {
                    	        var encodedOffset = offsetEncoder(offsets[i$1]);
                    	        Array.prototype.push.apply(encodedOffsets, encodedOffset);
                    	    }
                    
                    	    return Array.prototype.concat(encode.Card16(l.length),
                    	                           encode.OffSize(offSize),
                    	                           encodedOffsets,
                    	                           data);
                    	};
                    
                    	/**
                    	 * @param {Array}
                    	 * @returns {number}
                    	 */
                    	sizeOf.INDEX = function(v) {
                    	    return encode.INDEX(v).length;
                    	};
                    
                    	/**
                    	 * Convert an object to a CFF DICT structure.
                    	 * The keys should be numeric.
                    	 * The values should be objects containing name / type / value.
                    	 * @param {Object} m
                    	 * @returns {Array}
                    	 */
                    	encode.DICT = function(m) {
                    	    var d = [];
                    	    var keys = Object.keys(m);
                    	    var length = keys.length;
                    
                    	    for (var i = 0; i < length; i += 1) {
                    	        // Object.keys() return string keys, but our keys are always numeric.
                    	        var k = parseInt(keys[i], 0);
                    	        var v = m[k];
                    	        // Value comes before the key.
                    	        d = d.concat(encode.OPERAND(v.value, v.type));
                    	        d = d.concat(encode.OPERATOR(k));
                    	    }
                    
                    	    return d;
                    	};
                    
                    	/**
                    	 * @param {Object}
                    	 * @returns {number}
                    	 */
                    	sizeOf.DICT = function(m) {
                    	    return encode.DICT(m).length;
                    	};
                    
                    	/**
                    	 * @param {number}
                    	 * @returns {Array}
                    	 */
                    	encode.OPERATOR = function(v) {
                    	    if (v < 1200) {
                    	        return [v];
                    	    } else {
                    	        return [12, v - 1200];
                    	    }
                    	};
                    
                    	/**
                    	 * @param {Array} v
                    	 * @param {string}
                    	 * @returns {Array}
                    	 */
                    	encode.OPERAND = function(v, type) {
                    	    var d = [];
                    	    if (Array.isArray(type)) {
                    	        for (var i = 0; i < type.length; i += 1) {
                    	            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);
                    	            d = d.concat(encode.OPERAND(v[i], type[i]));
                    	        }
                    	    } else {
                    	        if (type === 'SID') {
                    	            d = d.concat(encode.NUMBER(v));
                    	        } else if (type === 'offset') {
                    	            // We make it easy for ourselves and always encode offsets as
                    	            // 4 bytes. This makes offset calculation for the top dict easier.
                    	            d = d.concat(encode.NUMBER32(v));
                    	        } else if (type === 'number') {
                    	            d = d.concat(encode.NUMBER(v));
                    	        } else if (type === 'real') {
                    	            d = d.concat(encode.REAL(v));
                    	        } else {
                    	            throw new Error('Unknown operand type ' + type);
                    	            // FIXME Add support for booleans
                    	        }
                    	    }
                    
                    	    return d;
                    	};
                    
                    	encode.OP = encode.BYTE;
                    	sizeOf.OP = sizeOf.BYTE;
                    
                    	// memoize charstring encoding using WeakMap if available
                    	var wmm = typeof WeakMap === 'function' && new WeakMap();
                    
                    	/**
                    	 * Convert a list of CharString operations to bytes.
                    	 * @param {Array}
                    	 * @returns {Array}
                    	 */
                    	encode.CHARSTRING = function(ops) {
                    	    // See encode.MACSTRING for why we don't do "if (wmm && wmm.has(ops))".
                    	    if (wmm) {
                    	        var cachedValue = wmm.get(ops);
                    	        if (cachedValue !== undefined) {
                    	            return cachedValue;
                    	        }
                    	    }
                    
                    	    var d = [];
                    	    var length = ops.length;
                    
                    	    for (var i = 0; i < length; i += 1) {
                    	        var op = ops[i];
                    	        d = d.concat(encode[op.type](op.value));
                    	    }
                    
                    	    if (wmm) {
                    	        wmm.set(ops, d);
                    	    }
                    
                    	    return d;
                    	};
                    
                    	/**
                    	 * @param {Array}
                    	 * @returns {number}
                    	 */
                    	sizeOf.CHARSTRING = function(ops) {
                    	    return encode.CHARSTRING(ops).length;
                    	};
                    
                    	// Utility functions ////////////////////////////////////////////////////////
                    
                    	/**
                    	 * Convert an object containing name / type / value to bytes.
                    	 * @param {Object}
                    	 * @returns {Array}
                    	 */
                    	encode.OBJECT = function(v) {
                    	    var encodingFunction = encode[v.type];
                    	    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);
                    	    return encodingFunction(v.value);
                    	};
                    
                    	/**
                    	 * @param {Object}
                    	 * @returns {number}
                    	 */
                    	sizeOf.OBJECT = function(v) {
                    	    var sizeOfFunction = sizeOf[v.type];
                    	    check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);
                    	    return sizeOfFunction(v.value);
                    	};
                    
                    	/**
                    	 * Convert a table object to bytes.
                    	 * A table contains a list of fields containing the metadata (name, type and default value).
                    	 * The table itself has the field values set as attributes.
                    	 * @param {opentype.Table}
                    	 * @returns {Array}
                    	 */
                    	encode.TABLE = function(table) {
                    	    var d = [];
                    	    var length = table.fields.length;
                    	    var subtables = [];
                    	    var subtableOffsets = [];
                    
                    	    for (var i = 0; i < length; i += 1) {
                    	        var field = table.fields[i];
                    	        var encodingFunction = encode[field.type];
                    	        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');
                    	        var value = table[field.name];
                    	        if (value === undefined) {
                    	            value = field.value;
                    	        }
                    
                    	        var bytes = encodingFunction(value);
                    
                    	        if (field.type === 'TABLE') {
                    	            subtableOffsets.push(d.length);
                    	            d = d.concat([0, 0]);
                    	            subtables.push(bytes);
                    	        } else {
                    	            d = d.concat(bytes);
                    	        }
                    	    }
                    
                    	    for (var i$1 = 0; i$1 < subtables.length; i$1 += 1) {
                    	        var o = subtableOffsets[i$1];
                    	        var offset = d.length;
                    	        check.argument(offset < 65536, 'Table ' + table.tableName + ' too big.');
                    	        d[o] = offset >> 8;
                    	        d[o + 1] = offset & 0xff;
                    	        d = d.concat(subtables[i$1]);
                    	    }
                    
                    	    return d;
                    	};
                    
                    	/**
                    	 * @param {opentype.Table}
                    	 * @returns {number}
                    	 */
                    	sizeOf.TABLE = function(table) {
                    	    var numBytes = 0;
                    	    var length = table.fields.length;
                    
                    	    for (var i = 0; i < length; i += 1) {
                    	        var field = table.fields[i];
                    	        var sizeOfFunction = sizeOf[field.type];
                    	        check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');
                    	        var value = table[field.name];
                    	        if (value === undefined) {
                    	            value = field.value;
                    	        }
                    
                    	        numBytes += sizeOfFunction(value);
                    
                    	        // Subtables take 2 more bytes for offsets.
                    	        if (field.type === 'TABLE') {
                    	            numBytes += 2;
                    	        }
                    	    }
                    
                    	    return numBytes;
                    	};
                    
                    	encode.RECORD = encode.TABLE;
                    	sizeOf.RECORD = sizeOf.TABLE;
                    
                    	// Merge in a list of bytes.
                    	encode.LITERAL = function(v) {
                    	    return v;
                    	};
                    
                    	sizeOf.LITERAL = function(v) {
                    	    return v.length;
                    	};
                    
                    	// Table metadata
                    
                    	/**
                    	 * @exports opentype.Table
                    	 * @class
                    	 * @param {string} tableName
                    	 * @param {Array} fields
                    	 * @param {Object} options
                    	 * @constructor
                    	 */
                    	function Table(tableName, fields, options) {
                    	    var this$1 = this;
                    
                    	    for (var i = 0; i < fields.length; i += 1) {
                    	        var field = fields[i];
                    	        this$1[field.name] = field.value;
                    	    }
                    
                    	    this.tableName = tableName;
                    	    this.fields = fields;
                    	    if (options) {
                    	        var optionKeys = Object.keys(options);
                    	        for (var i$1 = 0; i$1 < optionKeys.length; i$1 += 1) {
                    	            var k = optionKeys[i$1];
                    	            var v = options[k];
                    	            if (this$1[k] !== undefined) {
                    	                this$1[k] = v;
                    	            }
                    	        }
                    	    }
                    	}
                    
                    	/**
                    	 * Encodes the table and returns an array of bytes
                    	 * @return {Array}
                    	 */
                    	Table.prototype.encode = function() {
                    	    return encode.TABLE(this);
                    	};
                    
                    	/**
                    	 * Get the size of the table.
                    	 * @return {number}
                    	 */
                    	Table.prototype.sizeOf = function() {
                    	    return sizeOf.TABLE(this);
                    	};
                    
                    	/**
                    	 * @private
                    	 */
                    	function ushortList(itemName, list, count) {
                    	    if (count === undefined) {
                    	        count = list.length;
                    	    }
                    	    var fields = new Array(list.length + 1);
                    	    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
                    	    for (var i = 0; i < list.length; i++) {
                    	        fields[i + 1] = {name: itemName + i, type: 'USHORT', value: list[i]};
                    	    }
                    	    return fields;
                    	}
                    
                    	/**
                    	 * @private
                    	 */
                    	function tableList(itemName, records, itemCallback) {
                    	    var count = records.length;
                    	    var fields = new Array(count + 1);
                    	    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
                    	    for (var i = 0; i < count; i++) {
                    	        fields[i + 1] = {name: itemName + i, type: 'TABLE', value: itemCallback(records[i], i)};
                    	    }
                    	    return fields;
                    	}
                    
                    	/**
                    	 * @private
                    	 */
                    	function recordList(itemName, records, itemCallback) {
                    	    var count = records.length;
                    	    var fields = [];
                    	    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
                    	    for (var i = 0; i < count; i++) {
                    	        fields = fields.concat(itemCallback(records[i], i));
                    	    }
                    	    return fields;
                    	}
                    
                    	// Common Layout Tables
                    
                    	/**
                    	 * @exports opentype.Coverage
                    	 * @class
                    	 * @param {opentype.Table}
                    	 * @constructor
                    	 * @extends opentype.Table
                    	 */
                    	function Coverage(coverageTable) {
                    	    if (coverageTable.format === 1) {
                    	        Table.call(this, 'coverageTable',
                    	            [{name: 'coverageFormat', type: 'USHORT', value: 1}]
                    	            .concat(ushortList('glyph', coverageTable.glyphs))
                    	        );
                    	    } else {
                    	        check.assert(false, 'Can\'t create coverage table format 2 yet.');
                    	    }
                    	}
                    	Coverage.prototype = Object.create(Table.prototype);
                    	Coverage.prototype.constructor = Coverage;
                    
                    	function ScriptList(scriptListTable) {
                    	    Table.call(this, 'scriptListTable',
                    	        recordList('scriptRecord', scriptListTable, function(scriptRecord, i) {
                    	            var script = scriptRecord.script;
                    	            var defaultLangSys = script.defaultLangSys;
                    	            check.assert(!!defaultLangSys, 'Unable to write GSUB: script ' + scriptRecord.tag + ' has no default language system.');
                    	            return [
                    	                {name: 'scriptTag' + i, type: 'TAG', value: scriptRecord.tag},
                    	                {name: 'script' + i, type: 'TABLE', value: new Table('scriptTable', [
                    	                    {name: 'defaultLangSys', type: 'TABLE', value: new Table('defaultLangSys', [
                    	                        {name: 'lookupOrder', type: 'USHORT', value: 0},
                    	                        {name: 'reqFeatureIndex', type: 'USHORT', value: defaultLangSys.reqFeatureIndex}]
                    	                        .concat(ushortList('featureIndex', defaultLangSys.featureIndexes)))}
                    	                    ].concat(recordList('langSys', script.langSysRecords, function(langSysRecord, i) {
                    	                        var langSys = langSysRecord.langSys;
                    	                        return [
                    	                            {name: 'langSysTag' + i, type: 'TAG', value: langSysRecord.tag},
                    	                            {name: 'langSys' + i, type: 'TABLE', value: new Table('langSys', [
                    	                                {name: 'lookupOrder', type: 'USHORT', value: 0},
                    	                                {name: 'reqFeatureIndex', type: 'USHORT', value: langSys.reqFeatureIndex}
                    	                                ].concat(ushortList('featureIndex', langSys.featureIndexes)))}
                    	                        ];
                    	                    })))}
                    	            ];
                    	        })
                    	    );
                    	}
                    	ScriptList.prototype = Object.create(Table.prototype);
                    	ScriptList.prototype.constructor = ScriptList;
                    
                    	/**
                    	 * @exports opentype.FeatureList
                    	 * @class
                    	 * @param {opentype.Table}
                    	 * @constructor
                    	 * @extends opentype.Table
                    	 */
                    	function FeatureList(featureListTable) {
                    	    Table.call(this, 'featureListTable',
                    	        recordList('featureRecord', featureListTable, function(featureRecord, i) {
                    	            var feature = featureRecord.feature;
                    	            return [
                    	                {name: 'featureTag' + i, type: 'TAG', value: featureRecord.tag},
                    	                {name: 'feature' + i, type: 'TABLE', value: new Table('featureTable', [
                    	                    {name: 'featureParams', type: 'USHORT', value: feature.featureParams} ].concat(ushortList('lookupListIndex', feature.lookupListIndexes)))}
                    	            ];
                    	        })
                    	    );
                    	}
                    	FeatureList.prototype = Object.create(Table.prototype);
                    	FeatureList.prototype.constructor = FeatureList;
                    
                    	/**
                    	 * @exports opentype.LookupList
                    	 * @class
                    	 * @param {opentype.Table}
                    	 * @param {Object}
                    	 * @constructor
                    	 * @extends opentype.Table
                    	 */
                    	function LookupList(lookupListTable, subtableMakers) {
                    	    Table.call(this, 'lookupListTable', tableList('lookup', lookupListTable, function(lookupTable) {
                    	        var subtableCallback = subtableMakers[lookupTable.lookupType];
                    	        check.assert(!!subtableCallback, 'Unable to write GSUB lookup type ' + lookupTable.lookupType + ' tables.');
                    	        return new Table('lookupTable', [
                    	            {name: 'lookupType', type: 'USHORT', value: lookupTable.lookupType},
                    	            {name: 'lookupFlag', type: 'USHORT', value: lookupTable.lookupFlag}
                    	        ].concat(tableList('subtable', lookupTable.subtables, subtableCallback)));
                    	    }));
                    	}
                    	LookupList.prototype = Object.create(Table.prototype);
                    	LookupList.prototype.constructor = LookupList;
                    
                    	// Record = same as Table, but inlined (a Table has an offset and its data is further in the stream)
                    	// Don't use offsets inside Records (probable bug), only in Tables.
                    	var table = {
                    	    Table: Table,
                    	    Record: Table,
                    	    Coverage: Coverage,
                    	    ScriptList: ScriptList,
                    	    FeatureList: FeatureList,
                    	    LookupList: LookupList,
                    	    ushortList: ushortList,
                    	    tableList: tableList,
                    	    recordList: recordList,
                    	};
                    
                    	// Parsing utility functions
                    
                    	// Retrieve an unsigned byte from the DataView.
                    	function getByte(dataView, offset) {
                    	    return dataView.getUint8(offset);
                    	}
                    
                    	// Retrieve an unsigned 16-bit short from the DataView.
                    	// The value is stored in big endian.
                    	function getUShort(dataView, offset) {
                    	    return dataView.getUint16(offset, false);
                    	}
                    
                    	// Retrieve a signed 16-bit short from the DataView.
                    	// The value is stored in big endian.
                    	function getShort(dataView, offset) {
                    	    return dataView.getInt16(offset, false);
                    	}
                    
                    	// Retrieve an unsigned 32-bit long from the DataView.
                    	// The value is stored in big endian.
                    	function getULong(dataView, offset) {
                    	    return dataView.getUint32(offset, false);
                    	}
                    
                    	// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.
                    	// The value is stored in big endian.
                    	function getFixed(dataView, offset) {
                    	    var decimal = dataView.getInt16(offset, false);
                    	    var fraction = dataView.getUint16(offset + 2, false);
                    	    return decimal + fraction / 65535;
                    	}
                    
                    	// Retrieve a 4-character tag from the DataView.
                    	// Tags are used to identify tables.
                    	function getTag(dataView, offset) {
                    	    var tag = '';
                    	    for (var i = offset; i < offset + 4; i += 1) {
                    	        tag += String.fromCharCode(dataView.getInt8(i));
                    	    }
                    
                    	    return tag;
                    	}
                    
                    	// Retrieve an offset from the DataView.
                    	// Offsets are 1 to 4 bytes in length, depending on the offSize argument.
                    	function getOffset(dataView, offset, offSize) {
                    	    var v = 0;
                    	    for (var i = 0; i < offSize; i += 1) {
                    	        v <<= 8;
                    	        v += dataView.getUint8(offset + i);
                    	    }
                    
                    	    return v;
                    	}
                    
                    	// Retrieve a number of bytes from start offset to the end offset from the DataView.
                    	function getBytes(dataView, startOffset, endOffset) {
                    	    var bytes = [];
                    	    for (var i = startOffset; i < endOffset; i += 1) {
                    	        bytes.push(dataView.getUint8(i));
                    	    }
                    
                    	    return bytes;
                    	}
                    
                    	// Convert the list of bytes to a string.
                    	function bytesToString(bytes) {
                    	    var s = '';
                    	    for (var i = 0; i < bytes.length; i += 1) {
                    	        s += String.fromCharCode(bytes[i]);
                    	    }
                    
                    	    return s;
                    	}
                    
                    	var typeOffsets = {
                    	    byte: 1,
                    	    uShort: 2,
                    	    short: 2,
                    	    uLong: 4,
                    	    fixed: 4,
                    	    longDateTime: 8,
                    	    tag: 4
                    	};
                    
                    	// A stateful parser that changes the offset whenever a value is retrieved.
                    	// The data is a DataView.
                    	function Parser(data, offset) {
                    	    this.data = data;
                    	    this.offset = offset;
                    	    this.relativeOffset = 0;
                    	}
                    
                    	Parser.prototype.parseByte = function() {
                    	    var v = this.data.getUint8(this.offset + this.relativeOffset);
                    	    this.relativeOffset += 1;
                    	    return v;
                    	};
                    
                    	Parser.prototype.parseChar = function() {
                    	    var v = this.data.getInt8(this.offset + this.relativeOffset);
                    	    this.relativeOffset += 1;
                    	    return v;
                    	};
                    
                    	Parser.prototype.parseCard8 = Parser.prototype.parseByte;
                    
                    	Parser.prototype.parseUShort = function() {
                    	    var v = this.data.getUint16(this.offset + this.relativeOffset);
                    	    this.relativeOffset += 2;
                    	    return v;
                    	};
                    
                    	Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
                    	Parser.prototype.parseSID = Parser.prototype.parseUShort;
                    	Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;
                    
                    	Parser.prototype.parseShort = function() {
                    	    var v = this.data.getInt16(this.offset + this.relativeOffset);
                    	    this.relativeOffset += 2;
                    	    return v;
                    	};
                    
                    	Parser.prototype.parseF2Dot14 = function() {
                    	    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
                    	    this.relativeOffset += 2;
                    	    return v;
                    	};
                    
                    	Parser.prototype.parseULong = function() {
                    	    var v = getULong(this.data, this.offset + this.relativeOffset);
                    	    this.relativeOffset += 4;
                    	    return v;
                    	};
                    
                    	Parser.prototype.parseOffset32 = Parser.prototype.parseULong;
                    
                    	Parser.prototype.parseFixed = function() {
                    	    var v = getFixed(this.data, this.offset + this.relativeOffset);
                    	    this.relativeOffset += 4;
                    	    return v;
                    	};
                    
                    	Parser.prototype.parseString = function(length) {
                    	    var dataView = this.data;
                    	    var offset = this.offset + this.relativeOffset;
                    	    var string = '';
                    	    this.relativeOffset += length;
                    	    for (var i = 0; i < length; i++) {
                    	        string += String.fromCharCode(dataView.getUint8(offset + i));
                    	    }
                    
                    	    return string;
                    	};
                    
                    	Parser.prototype.parseTag = function() {
                    	    return this.parseString(4);
                    	};
                    
                    	// LONGDATETIME is a 64-bit integer.
                    	// JavaScript and unix timestamps traditionally use 32 bits, so we
                    	// only take the last 32 bits.
                    	// + Since until 2038 those bits will be filled by zeros we can ignore them.
                    	Parser.prototype.parseLongDateTime = function() {
                    	    var v = getULong(this.data, this.offset + this.relativeOffset + 4);
                    	    // Subtract seconds between 01/01/1904 and 01/01/1970
                    	    // to convert Apple Mac timestamp to Standard Unix timestamp
                    	    v -= 2082844800;
                    	    this.relativeOffset += 8;
                    	    return v;
                    	};
                    
                    	Parser.prototype.parseVersion = function(minorBase) {
                    	    var major = getUShort(this.data, this.offset + this.relativeOffset);
                    
                    	    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1
                    	    // Default returns the correct number if minor = 0xN000 where N is 0-9
                    	    // Set minorBase to 1 for tables that use minor = N where N is 0-9
                    	    var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);
                    	    this.relativeOffset += 4;
                    	    if (minorBase === undefined) { minorBase = 0x1000; }
                    	    return major + minor / minorBase / 10;
                    	};
                    
                    	Parser.prototype.skip = function(type, amount) {
                    	    if (amount === undefined) {
                    	        amount = 1;
                    	    }
                    
                    	    this.relativeOffset += typeOffsets[type] * amount;
                    	};
                    
                    	///// Parsing lists and records ///////////////////////////////
                    
                    	// Parse a list of 32 bit unsigned integers.
                    	Parser.prototype.parseULongList = function(count) {
                    	    if (count === undefined) { count = this.parseULong(); }
                    	    var offsets = new Array(count);
                    	    var dataView = this.data;
                    	    var offset = this.offset + this.relativeOffset;
                    	    for (var i = 0; i < count; i++) {
                    	        offsets[i] = dataView.getUint32(offset);
                    	        offset += 4;
                    	    }
                    
                    	    this.relativeOffset += count * 4;
                    	    return offsets;
                    	};
                    
                    	// Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream
                    	// or provided as an argument.
                    	Parser.prototype.parseOffset16List =
                    	Parser.prototype.parseUShortList = function(count) {
                    	    if (count === undefined) { count = this.parseUShort(); }
                    	    var offsets = new Array(count);
                    	    var dataView = this.data;
                    	    var offset = this.offset + this.relativeOffset;
                    	    for (var i = 0; i < count; i++) {
                    	        offsets[i] = dataView.getUint16(offset);
                    	        offset += 2;
                    	    }
                    
                    	    this.relativeOffset += count * 2;
                    	    return offsets;
                    	};
                    
                    	// Parses a list of 16 bit signed integers.
                    	Parser.prototype.parseShortList = function(count) {
                    	    var list = new Array(count);
                    	    var dataView = this.data;
                    	    var offset = this.offset + this.relativeOffset;
                    	    for (var i = 0; i < count; i++) {
                    	        list[i] = dataView.getInt16(offset);
                    	        offset += 2;
                    	    }
                    
                    	    this.relativeOffset += count * 2;
                    	    return list;
                    	};
                    
                    	// Parses a list of bytes.
                    	Parser.prototype.parseByteList = function(count) {
                    	    var list = new Array(count);
                    	    var dataView = this.data;
                    	    var offset = this.offset + this.relativeOffset;
                    	    for (var i = 0; i < count; i++) {
                    	        list[i] = dataView.getUint8(offset++);
                    	    }
                    
                    	    this.relativeOffset += count;
                    	    return list;
                    	};
                    
                    	/**
                    	 * Parse a list of items.
                    	 * Record count is optional, if omitted it is read from the stream.
                    	 * itemCallback is one of the Parser methods.
                    	 */
                    	Parser.prototype.parseList = function(count, itemCallback) {
                    	    var this$1 = this;
                    
                    	    if (!itemCallback) {
                    	        itemCallback = count;
                    	        count = this.parseUShort();
                    	    }
                    	    var list = new Array(count);
                    	    for (var i = 0; i < count; i++) {
                    	        list[i] = itemCallback.call(this$1);
                    	    }
                    	    return list;
                    	};
                    
                    	Parser.prototype.parseList32 = function(count, itemCallback) {
                    	    var this$1 = this;
                    
                    	    if (!itemCallback) {
                    	        itemCallback = count;
                    	        count = this.parseULong();
                    	    }
                    	    var list = new Array(count);
                    	    for (var i = 0; i < count; i++) {
                    	        list[i] = itemCallback.call(this$1);
                    	    }
                    	    return list;
                    	};
                    
                    	/**
                    	 * Parse a list of records.
                    	 * Record count is optional, if omitted it is read from the stream.
                    	 * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
                    	 */
                    	Parser.prototype.parseRecordList = function(count, recordDescription) {
                    	    var this$1 = this;
                    
                    	    // If the count argument is absent, read it in the stream.
                    	    if (!recordDescription) {
                    	        recordDescription = count;
                    	        count = this.parseUShort();
                    	    }
                    	    var records = new Array(count);
                    	    var fields = Object.keys(recordDescription);
                    	    for (var i = 0; i < count; i++) {
                    	        var rec = {};
                    	        for (var j = 0; j < fields.length; j++) {
                    	            var fieldName = fields[j];
                    	            var fieldType = recordDescription[fieldName];
                    	            rec[fieldName] = fieldType.call(this$1);
                    	        }
                    	        records[i] = rec;
                    	    }
                    	    return records;
                    	};
                    
                    	Parser.prototype.parseRecordList32 = function(count, recordDescription) {
                    	    var this$1 = this;
                    
                    	    // If the count argument is absent, read it in the stream.
                    	    if (!recordDescription) {
                    	        recordDescription = count;
                    	        count = this.parseULong();
                    	    }
                    	    var records = new Array(count);
                    	    var fields = Object.keys(recordDescription);
                    	    for (var i = 0; i < count; i++) {
                    	        var rec = {};
                    	        for (var j = 0; j < fields.length; j++) {
                    	            var fieldName = fields[j];
                    	            var fieldType = recordDescription[fieldName];
                    	            rec[fieldName] = fieldType.call(this$1);
                    	        }
                    	        records[i] = rec;
                    	    }
                    	    return records;
                    	};
                    
                    	// Parse a data structure into an object
                    	// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
                    	Parser.prototype.parseStruct = function(description) {
                    	    var this$1 = this;
                    
                    	    if (typeof description === 'function') {
                    	        return description.call(this);
                    	    } else {
                    	        var fields = Object.keys(description);
                    	        var struct = {};
                    	        for (var j = 0; j < fields.length; j++) {
                    	            var fieldName = fields[j];
                    	            var fieldType = description[fieldName];
                    	            struct[fieldName] = fieldType.call(this$1);
                    	        }
                    	        return struct;
                    	    }
                    	};
                    
                    	/**
                    	 * Parse a GPOS valueRecord
                    	 * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record
                    	 * valueFormat is optional, if omitted it is read from the stream.
                    	 */
                    	Parser.prototype.parseValueRecord = function(valueFormat) {
                    	    if (valueFormat === undefined) {
                    	        valueFormat = this.parseUShort();
                    	    }
                    	    if (valueFormat === 0) {
                    	        // valueFormat2 in kerning pairs is most often 0
                    	        // in this case return undefined instead of an empty object, to save space
                    	        return;
                    	    }
                    	    var valueRecord = {};
                    
                    	    if (valueFormat & 0x0001) { valueRecord.xPlacement = this.parseShort(); }
                    	    if (valueFormat & 0x0002) { valueRecord.yPlacement = this.parseShort(); }
                    	    if (valueFormat & 0x0004) { valueRecord.xAdvance = this.parseShort(); }
                    	    if (valueFormat & 0x0008) { valueRecord.yAdvance = this.parseShort(); }
                    
                    	    // Device table (non-variable font) / VariationIndex table (variable font) not supported
                    	    // https://docs.microsoft.com/fr-fr/typography/opentype/spec/chapter2#devVarIdxTbls
                    	    if (valueFormat & 0x0010) { valueRecord.xPlaDevice = undefined; this.parseShort(); }
                    	    if (valueFormat & 0x0020) { valueRecord.yPlaDevice = undefined; this.parseShort(); }
                    	    if (valueFormat & 0x0040) { valueRecord.xAdvDevice = undefined; this.parseShort(); }
                    	    if (valueFormat & 0x0080) { valueRecord.yAdvDevice = undefined; this.parseShort(); }
                    
                    	    return valueRecord;
                    	};
                    
                    	/**
                    	 * Parse a list of GPOS valueRecords
                    	 * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record
                    	 * valueFormat and valueCount are read from the stream.
                    	 */
                    	Parser.prototype.parseValueRecordList = function() {
                    	    var this$1 = this;
                    
                    	    var valueFormat = this.parseUShort();
                    	    var valueCount = this.parseUShort();
                    	    var values = new Array(valueCount);
                    	    for (var i = 0; i < valueCount; i++) {
                    	        values[i] = this$1.parseValueRecord(valueFormat);
                    	    }
                    	    return values;
                    	};
                    
                    	Parser.prototype.parsePointer = function(description) {
                    	    var structOffset = this.parseOffset16();
                    	    if (structOffset > 0) {
                    	        // NULL offset => return undefined
                    	        return new Parser(this.data, this.offset + structOffset).parseStruct(description);
                    	    }
                    	    return undefined;
                    	};
                    
                    	Parser.prototype.parsePointer32 = function(description) {
                    	    var structOffset = this.parseOffset32();
                    	    if (structOffset > 0) {
                    	        // NULL offset => return undefined
                    	        return new Parser(this.data, this.offset + structOffset).parseStruct(description);
                    	    }
                    	    return undefined;
                    	};
                    
                    	/**
                    	 * Parse a list of offsets to lists of 16-bit integers,
                    	 * or a list of offsets to lists of offsets to any kind of items.
                    	 * If itemCallback is not provided, a list of list of UShort is assumed.
                    	 * If provided, itemCallback is called on each item and must parse the item.
                    	 * See examples in tables/gsub.js
                    	 */
                    	Parser.prototype.parseListOfLists = function(itemCallback) {
                    	    var this$1 = this;
                    
                    	    var offsets = this.parseOffset16List();
                    	    var count = offsets.length;
                    	    var relativeOffset = this.relativeOffset;
                    	    var list = new Array(count);
                    	    for (var i = 0; i < count; i++) {
                    	        var start = offsets[i];
                    	        if (start === 0) {
                    	            // NULL offset
                    	            // Add i as owned property to list. Convenient with assert.
                    	            list[i] = undefined;
                    	            continue;
                    	        }
                    	        this$1.relativeOffset = start;
                    	        if (itemCallback) {
                    	            var subOffsets = this$1.parseOffset16List();
                    	            var subList = new Array(subOffsets.length);
                    	            for (var j = 0; j < subOffsets.length; j++) {
                    	                this$1.relativeOffset = start + subOffsets[j];
                    	                subList[j] = itemCallback.call(this$1);
                    	            }
                    	            list[i] = subList;
                    	        } else {
                    	            list[i] = this$1.parseUShortList();
                    	        }
                    	    }
                    	    this.relativeOffset = relativeOffset;
                    	    return list;
                    	};
                    
                    	///// Complex tables parsing //////////////////////////////////
                    
                    	// Parse a coverage table in a GSUB, GPOS or GDEF table.
                    	// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
                    	// parser.offset must point to the start of the table containing the coverage.
                    	Parser.prototype.parseCoverage = function() {
                    	    var this$1 = this;
                    
                    	    var startOffset = this.offset + this.relativeOffset;
                    	    var format = this.parseUShort();
                    	    var count = this.parseUShort();
                    	    if (format === 1) {
                    	        return {
                    	            format: 1,
                    	            glyphs: this.parseUShortList(count)
                    	        };
                    	    } else if (format === 2) {
                    	        var ranges = new Array(count);
                    	        for (var i = 0; i < count; i++) {
                    	            ranges[i] = {
                    	                start: this$1.parseUShort(),
                    	                end: this$1.parseUShort(),
                    	                index: this$1.parseUShort()
                    	            };
                    	        }
                    	        return {
                    	            format: 2,
                    	            ranges: ranges
                    	        };
                    	    }
                    	    throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');
                    	};
                    
                    	// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.
                    	// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
                    	Parser.prototype.parseClassDef = function() {
                    	    var startOffset = this.offset + this.relativeOffset;
                    	    var format = this.parseUShort();
                    	    if (format === 1) {
                    	        return {
                    	            format: 1,
                    	            startGlyph: this.parseUShort(),
                    	            classes: this.parseUShortList()
                    	        };
                    	    } else if (format === 2) {
                    	        return {
                    	            format: 2,
                    	            ranges: this.parseRecordList({
                    	                start: Parser.uShort,
                    	                end: Parser.uShort,
                    	                classId: Parser.uShort
                    	            })
                    	        };
                    	    }
                    	    throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');
                    	};
                    
                    	///// Static methods ///////////////////////////////////
                    	// These convenience methods can be used as callbacks and should be called with "this" context set to a Parser instance.
                    
                    	Parser.list = function(count, itemCallback) {
                    	    return function() {
                    	        return this.parseList(count, itemCallback);
                    	    };
                    	};
                    
                    	Parser.list32 = function(count, itemCallback) {
                    	    return function() {
                    	        return this.parseList32(count, itemCallback);
                    	    };
                    	};
                    
                    	Parser.recordList = function(count, recordDescription) {
                    	    return function() {
                    	        return this.parseRecordList(count, recordDescription);
                    	    };
                    	};
                    
                    	Parser.recordList32 = function(count, recordDescription) {
                    	    return function() {
                    	        return this.parseRecordList32(count, recordDescription);
                    	    };
                    	};
                    
                    	Parser.pointer = function(description) {
                    	    return function() {
                    	        return this.parsePointer(description);
                    	    };
                    	};
                    
                    	Parser.pointer32 = function(description) {
                    	    return function() {
                    	        return this.parsePointer32(description);
                    	    };
                    	};
                    
                    	Parser.tag = Parser.prototype.parseTag;
                    	Parser.byte = Parser.prototype.parseByte;
                    	Parser.uShort = Parser.offset16 = Parser.prototype.parseUShort;
                    	Parser.uShortList = Parser.prototype.parseUShortList;
                    	Parser.uLong = Parser.offset32 = Parser.prototype.parseULong;
                    	Parser.uLongList = Parser.prototype.parseULongList;
                    	Parser.struct = Parser.prototype.parseStruct;
                    	Parser.coverage = Parser.prototype.parseCoverage;
                    	Parser.classDef = Parser.prototype.parseClassDef;
                    
                    	///// Script, Feature, Lookup lists ///////////////////////////////////////////////
                    	// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
                    
                    	var langSysTable = {
                    	    reserved: Parser.uShort,
                    	    reqFeatureIndex: Parser.uShort,
                    	    featureIndexes: Parser.uShortList
                    	};
                    
                    	Parser.prototype.parseScriptList = function() {
                    	    return this.parsePointer(Parser.recordList({
                    	        tag: Parser.tag,
                    	        script: Parser.pointer({
                    	            defaultLangSys: Parser.pointer(langSysTable),
                    	            langSysRecords: Parser.recordList({
                    	                tag: Parser.tag,
                    	                langSys: Parser.pointer(langSysTable)
                    	            })
                    	        })
                    	    })) || [];
                    	};
                    
                    	Parser.prototype.parseFeatureList = function() {
                    	    return this.parsePointer(Parser.recordList({
                    	        tag: Parser.tag,
                    	        feature: Parser.pointer({
                    	            featureParams: Parser.offset16,
                    	            lookupListIndexes: Parser.uShortList
                    	        })
                    	    })) || [];
                    	};
                    
                    	Parser.prototype.parseLookupList = function(lookupTableParsers) {
                    	    return this.parsePointer(Parser.list(Parser.pointer(function() {
                    	        var lookupType = this.parseUShort();
                    	        check.argument(1 <= lookupType && lookupType <= 9, 'GPOS/GSUB lookup type ' + lookupType + ' unknown.');
                    	        var lookupFlag = this.parseUShort();
                    	        var useMarkFilteringSet = lookupFlag & 0x10;
                    	        return {
                    	            lookupType: lookupType,
                    	            lookupFlag: lookupFlag,
                    	            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),
                    	            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined
                    	        };
                    	    }))) || [];
                    	};
                    
                    	Parser.prototype.parseFeatureVariationsList = function() {
                    	    return this.parsePointer32(function() {
                    	        var majorVersion = this.parseUShort();
                    	        var minorVersion = this.parseUShort();
                    	        check.argument(majorVersion === 1 && minorVersion < 1, 'GPOS/GSUB feature variations table unknown.');
                    	        var featureVariations = this.parseRecordList32({
                    	            conditionSetOffset: Parser.offset32,
                    	            featureTableSubstitutionOffset: Parser.offset32
                    	        });
                    	        return featureVariations;
                    	    }) || [];
                    	};
                    
                    	var parse = {
                    	    getByte: getByte,
                    	    getCard8: getByte,
                    	    getUShort: getUShort,
                    	    getCard16: getUShort,
                    	    getShort: getShort,
                    	    getULong: getULong,
                    	    getFixed: getFixed,
                    	    getTag: getTag,
                    	    getOffset: getOffset,
                    	    getBytes: getBytes,
                    	    bytesToString: bytesToString,
                    	    Parser: Parser,
                    	};
                    
                    	// The `cmap` table stores the mappings from characters to glyphs.
                    
                    	function parseCmapTableFormat12(cmap, p) {
                    	    //Skip reserved.
                    	    p.parseUShort();
                    
                    	    // Length in bytes of the sub-tables.
                    	    cmap.length = p.parseULong();
                    	    cmap.language = p.parseULong();
                    
                    	    var groupCount;
                    	    cmap.groupCount = groupCount = p.parseULong();
                    	    cmap.glyphIndexMap = {};
                    
                    	    for (var i = 0; i < groupCount; i += 1) {
                    	        var startCharCode = p.parseULong();
                    	        var endCharCode = p.parseULong();
                    	        var startGlyphId = p.parseULong();
                    
                    	        for (var c = startCharCode; c <= endCharCode; c += 1) {
                    	            cmap.glyphIndexMap[c] = startGlyphId;
                    	            startGlyphId++;
                    	        }
                    	    }
                    	}
                    
                    	function parseCmapTableFormat4(cmap, p, data, start, offset) {
                    	    // Length in bytes of the sub-tables.
                    	    cmap.length = p.parseUShort();
                    	    cmap.language = p.parseUShort();
                    
                    	    // segCount is stored x 2.
                    	    var segCount;
                    	    cmap.segCount = segCount = p.parseUShort() >> 1;
                    
                    	    // Skip searchRange, entrySelector, rangeShift.
                    	    p.skip('uShort', 3);
                    
                    	    // The "unrolled" mapping from character codes to glyph indices.
                    	    cmap.glyphIndexMap = {};
                    	    var endCountParser = new parse.Parser(data, start + offset + 14);
                    	    var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);
                    	    var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);
                    	    var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);
                    	    var glyphIndexOffset = start + offset + 16 + segCount * 8;
                    	    for (var i = 0; i < segCount - 1; i += 1) {
                    	        var glyphIndex = (void 0);
                    	        var endCount = endCountParser.parseUShort();
                    	        var startCount = startCountParser.parseUShort();
                    	        var idDelta = idDeltaParser.parseShort();
                    	        var idRangeOffset = idRangeOffsetParser.parseUShort();
                    	        for (var c = startCount; c <= endCount; c += 1) {
                    	            if (idRangeOffset !== 0) {
                    	                // The idRangeOffset is relative to the current position in the idRangeOffset array.
                    	                // Take the current offset in the idRangeOffset array.
                    	                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);
                    
                    	                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.
                    	                glyphIndexOffset += idRangeOffset;
                    
                    	                // Then add the character index of the current segment, multiplied by 2 for USHORTs.
                    	                glyphIndexOffset += (c - startCount) * 2;
                    	                glyphIndex = parse.getUShort(data, glyphIndexOffset);
                    	                if (glyphIndex !== 0) {
                    	                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;
                    	                }
                    	            } else {
                    	                glyphIndex = (c + idDelta) & 0xFFFF;
                    	            }
                    
                    	            cmap.glyphIndexMap[c] = glyphIndex;
                    	        }
                    	    }
                    	}
                    
                    	// Parse the `cmap` table. This table stores the mappings from characters to glyphs.
                    	// There are many available formats, but we only support the Windows format 4 and 12.
                    	// This function returns a `CmapEncoding` object or null if no supported format could be found.
                    	function parseCmapTable(data, start) {
                    	    var cmap = {};
                    	    cmap.version = parse.getUShort(data, start);
                    	    check.argument(cmap.version === 0, 'cmap table version should be 0.');
                    
                    	    // The cmap table can contain many sub-tables, each with their own format.
                    	    // We're only interested in a "platform 0" (Unicode format) and "platform 3" (Windows format) table.
                    	    cmap.numTables = parse.getUShort(data, start + 2);
                    	    var offset = -1;
                    	    for (var i = cmap.numTables - 1; i >= 0; i -= 1) {
                    	        var platformId = parse.getUShort(data, start + 4 + (i * 8));
                    	        var encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);
                    	        if ((platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) ||
                    	            (platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 2 || encodingId === 3 || encodingId === 4))) {
                    	            offset = parse.getULong(data, start + 4 + (i * 8) + 4);
                    	            break;
                    	        }
                    	    }
                    
                    	    if (offset === -1) {
                    	        // There is no cmap table in the font that we support.
                    	        throw new Error('No valid cmap sub-tables found.');
                    	    }
                    
                    	    var p = new parse.Parser(data, start + offset);
                    	    cmap.format = p.parseUShort();
                    
                    	    if (cmap.format === 12) {
                    	        parseCmapTableFormat12(cmap, p);
                    	    } else if (cmap.format === 4) {
                    	        parseCmapTableFormat4(cmap, p, data, start, offset);
                    	    } else {
                    	        throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').');
                    	    }
                    
                    	    return cmap;
                    	}
                    
                    	function addSegment(t, code, glyphIndex) {
                    	    t.segments.push({
                    	        end: code,
                    	        start: code,
                    	        delta: -(code - glyphIndex),
                    	        offset: 0,
                    	        glyphIndex: glyphIndex
                    	    });
                    	}
                    
                    	function addTerminatorSegment(t) {
                    	    t.segments.push({
                    	        end: 0xFFFF,
                    	        start: 0xFFFF,
                    	        delta: 1,
                    	        offset: 0
                    	    });
                    	}
                    
                    	// Make cmap table, format 4 by default, 12 if needed only
                    	function makeCmapTable(glyphs) {
                    	    // Plan 0 is the base Unicode Plan but emojis, for example are on another plan, and needs cmap 12 format (with 32bit)
                    	    var isPlan0Only = true;
                    	    var i;
                    
                    	    // Check if we need to add cmap format 12 or if format 4 only is fine
                    	    for (i = glyphs.length - 1; i > 0; i -= 1) {
                    	        var g = glyphs.get(i);
                    	        if (g.unicode > 65535) {
                    	            console.log('Adding CMAP format 12 (needed!)');
                    	            isPlan0Only = false;
                    	            break;
                    	        }
                    	    }
                    
                    	    var cmapTable = [
                    	        {name: 'version', type: 'USHORT', value: 0},
                    	        {name: 'numTables', type: 'USHORT', value: isPlan0Only ? 1 : 2},
                    
                    	        // CMAP 4 header
                    	        {name: 'platformID', type: 'USHORT', value: 3},
                    	        {name: 'encodingID', type: 'USHORT', value: 1},
                    	        {name: 'offset', type: 'ULONG', value: isPlan0Only ? 12 : (12 + 8)}
                    	    ];
                    
                    	    if (!isPlan0Only)
                    	        { cmapTable = cmapTable.concat([
                    	            // CMAP 12 header
                    	            {name: 'cmap12PlatformID', type: 'USHORT', value: 3}, // We encode only for PlatformID = 3 (Windows) because it is supported everywhere
                    	            {name: 'cmap12EncodingID', type: 'USHORT', value: 10},
                    	            {name: 'cmap12Offset', type: 'ULONG', value: 0}
                    	        ]); }
                    
                    	    cmapTable = cmapTable.concat([
                    	        // CMAP 4 Subtable
                    	        {name: 'format', type: 'USHORT', value: 4},
                    	        {name: 'cmap4Length', type: 'USHORT', value: 0},
                    	        {name: 'language', type: 'USHORT', value: 0},
                    	        {name: 'segCountX2', type: 'USHORT', value: 0},
                    	        {name: 'searchRange', type: 'USHORT', value: 0},
                    	        {name: 'entrySelector', type: 'USHORT', value: 0},
                    	        {name: 'rangeShift', type: 'USHORT', value: 0}
                    	    ]);
                    
                    	    var t = new table.Table('cmap', cmapTable);
                    
                    	    t.segments = [];
                    	    for (i = 0; i < glyphs.length; i += 1) {
                    	        var glyph = glyphs.get(i);
                    	        for (var j = 0; j < glyph.unicodes.length; j += 1) {
                    	            addSegment(t, glyph.unicodes[j], i);
                    	        }
                    
                    	        t.segments = t.segments.sort(function (a, b) {
                    	            return a.start - b.start;
                    	        });
                    	    }
                    
                    	    addTerminatorSegment(t);
                    
                    	    var segCount = t.segments.length;
                    	    var segCountToRemove = 0;
                    
                    	    // CMAP 4
                    	    // Set up parallel segment arrays.
                    	    var endCounts = [];
                    	    var startCounts = [];
                    	    var idDeltas = [];
                    	    var idRangeOffsets = [];
                    	    var glyphIds = [];
                    
                    	    // CMAP 12
                    	    var cmap12Groups = [];
                    
                    	    // Reminder this loop is not following the specification at 100%
                    	    // The specification -> find suites of characters and make a group
                    	    // Here we're doing one group for each letter
                    	    // Doing as the spec can save 8 times (or more) space
                    	    for (i = 0; i < segCount; i += 1) {
                    	        var segment = t.segments[i];
                    
                    	        // CMAP 4
                    	        if (segment.end <= 65535 && segment.start <= 65535) {
                    	            endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});
                    	            startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});
                    	            idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});
                    	            idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});
                    	            if (segment.glyphId !== undefined) {
                    	                glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});
                    	            }
                    	        } else {
                    	            // Skip Unicode > 65535 (16bit unsigned max) for CMAP 4, will be added in CMAP 12
                    	            segCountToRemove += 1;
                    	        }
                    
                    	        // CMAP 12
                    	        // Skip Terminator Segment
                    	        if (!isPlan0Only && segment.glyphIndex !== undefined) {
                    	            cmap12Groups = cmap12Groups.concat({name: 'cmap12Start_' + i, type: 'ULONG', value: segment.start});
                    	            cmap12Groups = cmap12Groups.concat({name: 'cmap12End_' + i, type: 'ULONG', value: segment.end});
                    	            cmap12Groups = cmap12Groups.concat({name: 'cmap12Glyph_' + i, type: 'ULONG', value: segment.glyphIndex});
                    	        }
                    	    }
                    
                    	    // CMAP 4 Subtable
                    	    t.segCountX2 = (segCount - segCountToRemove) * 2;
                    	    t.searchRange = Math.pow(2, Math.floor(Math.log((segCount - segCountToRemove)) / Math.log(2))) * 2;
                    	    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);
                    	    t.rangeShift = t.segCountX2 - t.searchRange;
                    
                    	    t.fields = t.fields.concat(endCounts);
                    	    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});
                    	    t.fields = t.fields.concat(startCounts);
                    	    t.fields = t.fields.concat(idDeltas);
                    	    t.fields = t.fields.concat(idRangeOffsets);
                    	    t.fields = t.fields.concat(glyphIds);
                    
                    	    t.cmap4Length = 14 + // Subtable header
                    	        endCounts.length * 2 +
                    	        2 + // reservedPad
                    	        startCounts.length * 2 +
                    	        idDeltas.length * 2 +
                    	        idRangeOffsets.length * 2 +
                    	        glyphIds.length * 2;
                    
                    	    if (!isPlan0Only) {
                    	        // CMAP 12 Subtable
                    	        var cmap12Length = 16 + // Subtable header
                    	            cmap12Groups.length * 4;
                    
                    	        t.cmap12Offset = 12 + (2 * 2) + 4 + t.cmap4Length;
                    	        t.fields = t.fields.concat([
                    	            {name: 'cmap12Format', type: 'USHORT', value: 12},
                    	            {name: 'cmap12Reserved', type: 'USHORT', value: 0},
                    	            {name: 'cmap12Length', type: 'ULONG', value: cmap12Length},
                    	            {name: 'cmap12Language', type: 'ULONG', value: 0},
                    	            {name: 'cmap12nGroups', type: 'ULONG', value: cmap12Groups.length / 3}
                    	        ]);
                    
                    	        t.fields = t.fields.concat(cmap12Groups);
                    	    }
                    
                    	    return t;
                    	}
                    
                    	var cmap = { parse: parseCmapTable, make: makeCmapTable };
                    
                    	// Glyph encoding
                    
                    	var cffStandardStrings = [
                    	    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
                    	    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
                    	    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
                    	    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
                    	    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
                    	    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
                    	    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',
                    	    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',
                    	    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',
                    	    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',
                    	    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',
                    	    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',
                    	    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',
                    	    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',
                    	    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',
                    	    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',
                    	    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',
                    	    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',
                    	    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',
                    	    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',
                    	    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',
                    	    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',
                    	    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',
                    	    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',
                    	    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',
                    	    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',
                    	    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',
                    	    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
                    	    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
                    	    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
                    	    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',
                    	    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',
                    	    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',
                    	    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',
                    	    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',
                    	    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',
                    	    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',
                    	    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',
                    	    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',
                    	    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',
                    	    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',
                    	    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',
                    	    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];
                    
                    	var cffStandardEncoding = [
                    	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
                    	    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
                    	    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
                    	    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
                    	    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
                    	    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
                    	    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
                    	    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',
                    	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
                    	    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',
                    	    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',
                    	    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',
                    	    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',
                    	    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',
                    	    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',
                    	    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',
                    	    'lslash', 'oslash', 'oe', 'germandbls'];
                    
                    	var cffExpertEncoding = [
                    	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
                    	    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',
                    	    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',
                    	    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',
                    	    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',
                    	    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',
                    	    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',
                    	    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',
                    	    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
                    	    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
                    	    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
                    	    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',
                    	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
                    	    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',
                    	    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',
                    	    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',
                    	    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',
                    	    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',
                    	    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',
                    	    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',
                    	    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',
                    	    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',
                    	    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',
                    	    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',
                    	    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',
                    	    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];
                    
                    	var standardNames = [
                    	    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',
                    	    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',
                    	    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',
                    	    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
                    	    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',
                    	    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
                    	    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',
                    	    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',
                    	    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',
                    	    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',
                    	    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',
                    	    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',
                    	    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',
                    	    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',
                    	    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',
                    	    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',
                    	    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',
                    	    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',
                    	    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',
                    	    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',
                    	    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',
                    	    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',
                    	    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',
                    	    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',
                    	    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];
                    
                    	/**
                    	 * This is the encoding used for fonts created from scratch.
                    	 * It loops through all glyphs and finds the appropriate unicode value.
                    	 * Since it's linear time, other encodings will be faster.
                    	 * @exports opentype.DefaultEncoding
                    	 * @class
                    	 * @constructor
                    	 * @param {opentype.Font}
                    	 */
                    	function DefaultEncoding(font) {
                    	    this.font = font;
                    	}
                    
                    	DefaultEncoding.prototype.charToGlyphIndex = function(c) {
                    	    var code = c.codePointAt(0);
                    	    var glyphs = this.font.glyphs;
                    	    if (glyphs) {
                    	        for (var i = 0; i < glyphs.length; i += 1) {
                    	            var glyph = glyphs.get(i);
                    	            for (var j = 0; j < glyph.unicodes.length; j += 1) {
                    	                if (glyph.unicodes[j] === code) {
                    	                    return i;
                    	                }
                    	            }
                    	        }
                    	    }
                    	    return null;
                    	};
                    
                    	/**
                    	 * @exports opentype.CmapEncoding
                    	 * @class
                    	 * @constructor
                    	 * @param {Object} cmap - a object with the cmap encoded data
                    	 */
                    	function CmapEncoding(cmap) {
                    	    this.cmap = cmap;
                    	}
                    
                    	/**
                    	 * @param  {string} c - the character
                    	 * @return {number} The glyph index.
                    	 */
                    	CmapEncoding.prototype.charToGlyphIndex = function(c) {
                    	    return this.cmap.glyphIndexMap[c.codePointAt(0)] || 0;
                    	};
                    
                    	/**
                    	 * @exports opentype.CffEncoding
                    	 * @class
                    	 * @constructor
                    	 * @param {string} encoding - The encoding
                    	 * @param {Array} charset - The character set.
                    	 */
                    	function CffEncoding(encoding, charset) {
                    	    this.encoding = encoding;
                    	    this.charset = charset;
                    	}
                    
                    	/**
                    	 * @param  {string} s - The character
                    	 * @return {number} The index.
                    	 */
                    	CffEncoding.prototype.charToGlyphIndex = function(s) {
                    	    var code = s.codePointAt(0);
                    	    var charName = this.encoding[code];
                    	    return this.charset.indexOf(charName);
                    	};
                    
                    	/**
                    	 * @exports opentype.GlyphNames
                    	 * @class
                    	 * @constructor
                    	 * @param {Object} post
                    	 */
                    	function GlyphNames(post) {
                    	    var this$1 = this;
                    
                    	    switch (post.version) {
                    	        case 1:
                    	            this.names = standardNames.slice();
                    	            break;
                    	        case 2:
                    	            this.names = new Array(post.numberOfGlyphs);
                    	            for (var i = 0; i < post.numberOfGlyphs; i++) {
                    	                if (post.glyphNameIndex[i] < standardNames.length) {
                    	                    this$1.names[i] = standardNames[post.glyphNameIndex[i]];
                    	                } else {
                    	                    this$1.names[i] = post.names[post.glyphNameIndex[i] - standardNames.length];
                    	                }
                    	            }
                    
                    	            break;
                    	        case 2.5:
                    	            this.names = new Array(post.numberOfGlyphs);
                    	            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {
                    	                this$1.names[i$1] = standardNames[i$1 + post.glyphNameIndex[i$1]];
                    	            }
                    
                    	            break;
                    	        case 3:
                    	            this.names = [];
                    	            break;
                    	        default:
                    	            this.names = [];
                    	            break;
                    	    }
                    	}
                    
                    	/**
                    	 * Gets the index of a glyph by name.
                    	 * @param  {string} name - The glyph name
                    	 * @return {number} The index
                    	 */
                    	GlyphNames.prototype.nameToGlyphIndex = function(name) {
                    	    return this.names.indexOf(name);
                    	};
                    
                    	/**
                    	 * @param  {number} gid
                    	 * @return {string}
                    	 */
                    	GlyphNames.prototype.glyphIndexToName = function(gid) {
                    	    return this.names[gid];
                    	};
                    
                    	/**
                    	 * @alias opentype.addGlyphNames
                    	 * @param {opentype.Font}
                    	 */
                    	function addGlyphNames(font) {
                    	    var glyph;
                    	    var glyphIndexMap = font.tables.cmap.glyphIndexMap;
                    	    var charCodes = Object.keys(glyphIndexMap);
                    
                    	    for (var i = 0; i < charCodes.length; i += 1) {
                    	        var c = charCodes[i];
                    	        var glyphIndex = glyphIndexMap[c];
                    	        glyph = font.glyphs.get(glyphIndex);
                    	        glyph.addUnicode(parseInt(c));
                    	    }
                    
                    	    for (var i$1 = 0; i$1 < font.glyphs.length; i$1 += 1) {
                    	        glyph = font.glyphs.get(i$1);
                    	        if (font.cffEncoding) {
                    	            if (font.isCIDFont) {
                    	                glyph.name = 'gid' + i$1;
                    	            } else {
                    	                glyph.name = font.cffEncoding.charset[i$1];
                    	            }
                    	        } else if (font.glyphNames.names) {
                    	            glyph.name = font.glyphNames.glyphIndexToName(i$1);
                    	        }
                    	    }
                    	}
                    
                    	// Drawing utility functions.
                    
                    	// Draw a line on the given context from point `x1,y1` to point `x2,y2`.
                    	function line(ctx, x1, y1, x2, y2) {
                    	    ctx.beginPath();
                    	    ctx.moveTo(x1, y1);
                    	    ctx.lineTo(x2, y2);
                    	    ctx.stroke();
                    	}
                    
                    	var draw = { line: line };
                    
                    	// The Glyph object
                    	// import glyf from './tables/glyf' Can't be imported here, because it's a circular dependency
                    
                    	function getPathDefinition(glyph, path) {
                    	    var _path = path || new Path();
                    	    return {
                    	        configurable: true,
                    
                    	        get: function() {
                    	            if (typeof _path === 'function') {
                    	                _path = _path();
                    	            }
                    
                    	            return _path;
                    	        },
                    
                    	        set: function(p) {
                    	            _path = p;
                    	        }
                    	    };
                    	}
                    	/**
                    	 * @typedef GlyphOptions
                    	 * @type Object
                    	 * @property {string} [name] - The glyph name
                    	 * @property {number} [unicode]
                    	 * @property {Array} [unicodes]
                    	 * @property {number} [xMin]
                    	 * @property {number} [yMin]
                    	 * @property {number} [xMax]
                    	 * @property {number} [yMax]
                    	 * @property {number} [advanceWidth]
                    	 */
                    
                    	// A Glyph is an individual mark that often corresponds to a character.
                    	// Some glyphs, such as ligatures, are a combination of many characters.
                    	// Glyphs are the basic building blocks of a font.
                    	//
                    	// The `Glyph` class contains utility methods for drawing the path and its points.
                    	/**
                    	 * @exports opentype.Glyph
                    	 * @class
                    	 * @param {GlyphOptions}
                    	 * @constructor
                    	 */
                    	function Glyph(options) {
                    	    // By putting all the code on a prototype function (which is only declared once)
                    	    // we reduce the memory requirements for larger fonts by some 2%
                    	    this.bindConstructorValues(options);
                    	}
                    
                    	/**
                    	 * @param  {GlyphOptions}
                    	 */
                    	Glyph.prototype.bindConstructorValues = function(options) {
                    	    this.index = options.index || 0;
                    
                    	    // These three values cannot be deferred for memory optimization:
                    	    this.name = options.name || null;
                    	    this.unicode = options.unicode || undefined;
                    	    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];
                    
                    	    // But by binding these values only when necessary, we reduce can
                    	    // the memory requirements by almost 3% for larger fonts.
                    	    if (options.xMin) {
                    	        this.xMin = options.xMin;
                    	    }
                    
                    	    if (options.yMin) {
                    	        this.yMin = options.yMin;
                    	    }
                    
                    	    if (options.xMax) {
                    	        this.xMax = options.xMax;
                    	    }
                    
                    	    if (options.yMax) {
                    	        this.yMax = options.yMax;
                    	    }
                    
                    	    if (options.advanceWidth) {
                    	        this.advanceWidth = options.advanceWidth;
                    	    }
                    
                    	    // The path for a glyph is the most memory intensive, and is bound as a value
                    	    // with a getter/setter to ensure we actually do path parsing only once the
                    	    // path is actually needed by anything.
                    	    Object.defineProperty(this, 'path', getPathDefinition(this, options.path));
                    	};
                    
                    	/**
                    	 * @param {number}
                    	 */
                    	Glyph.prototype.addUnicode = function(unicode) {
                    	    if (this.unicodes.length === 0) {
                    	        this.unicode = unicode;
                    	    }
                    
                    	    this.unicodes.push(unicode);
                    	};
                    
                    	/**
                    	 * Calculate the minimum bounding box for this glyph.
                    	 * @return {opentype.BoundingBox}
                    	 */
                    	Glyph.prototype.getBoundingBox = function() {
                    	    return this.path.getBoundingBox();
                    	};
                    
                    	/**
                    	 * Convert the glyph to a Path we can draw on a drawing context.
                    	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
                    	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
                    	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
                    	 * @param  {Object=} options - xScale, yScale to stretch the glyph.
                    	 * @param  {opentype.Font} if hinting is to be used, the font
                    	 * @return {opentype.Path}
                    	 */
                    	Glyph.prototype.getPath = function(x, y, fontSize, options, font) {
                    	    x = x !== undefined ? x : 0;
                    	    y = y !== undefined ? y : 0;
                    	    fontSize = fontSize !== undefined ? fontSize : 72;
                    	    var commands;
                    	    var hPoints;
                    	    if (!options) { options = { }; }
                    	    var xScale = options.xScale;
                    	    var yScale = options.yScale;
                    
                    	    if (options.hinting && font && font.hinting) {
                    	        // in case of hinting, the hinting engine takes care
                    	        // of scaling the points (not the path) before hinting.
                    	        hPoints = this.path && font.hinting.exec(this, fontSize);
                    	        // in case the hinting engine failed hPoints is undefined
                    	        // and thus reverts to plain rending
                    	    }
                    
                    	    if (hPoints) {
                    	        // Call font.hinting.getCommands instead of `glyf.getPath(hPoints).commands` to avoid a circular dependency
                    	        commands = font.hinting.getCommands(hPoints);
                    	        x = Math.round(x);
                    	        y = Math.round(y);
                    	        // TODO in case of hinting xyScaling is not yet supported
                    	        xScale = yScale = 1;
                    	    } else {
                    	        commands = this.path.commands;
                    	        var scale = 1 / this.path.unitsPerEm * fontSize;
                    	        if (xScale === undefined) { xScale = scale; }
                    	        if (yScale === undefined) { yScale = scale; }
                    	    }
                    
                    	    var p = new Path();
                    	    for (var i = 0; i < commands.length; i += 1) {
                    	        var cmd = commands[i];
                    	        if (cmd.type === 'M') {
                    	            p.moveTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
                    	        } else if (cmd.type === 'L') {
                    	            p.lineTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
                    	        } else if (cmd.type === 'Q') {
                    	            p.quadraticCurveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
                    	                               x + (cmd.x * xScale), y + (-cmd.y * yScale));
                    	        } else if (cmd.type === 'C') {
                    	            p.curveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
                    	                      x + (cmd.x2 * xScale), y + (-cmd.y2 * yScale),
                    	                      x + (cmd.x * xScale), y + (-cmd.y * yScale));
                    	        } else if (cmd.type === 'Z') {
                    	            p.closePath();
                    	        }
                    	    }
                    
                    	    return p;
                    	};
                    
                    	/**
                    	 * Split the glyph into contours.
                    	 * This function is here for backwards compatibility, and to
                    	 * provide raw access to the TrueType glyph outlines.
                    	 * @return {Array}
                    	 */
                    	Glyph.prototype.getContours = function() {
                    	    var this$1 = this;
                    
                    	    if (this.points === undefined) {
                    	        return [];
                    	    }
                    
                    	    var contours = [];
                    	    var currentContour = [];
                    	    for (var i = 0; i < this.points.length; i += 1) {
                    	        var pt = this$1.points[i];
                    	        currentContour.push(pt);
                    	        if (pt.lastPointOfContour) {
                    	            contours.push(currentContour);
                    	            currentContour = [];
                    	        }
                    	    }
                    
                    	    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
                    	    return contours;
                    	};
                    
                    	/**
                    	 * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.
                    	 * @return {Object}
                    	 */
                    	Glyph.prototype.getMetrics = function() {
                    	    var commands = this.path.commands;
                    	    var xCoords = [];
                    	    var yCoords = [];
                    	    for (var i = 0; i < commands.length; i += 1) {
                    	        var cmd = commands[i];
                    	        if (cmd.type !== 'Z') {
                    	            xCoords.push(cmd.x);
                    	            yCoords.push(cmd.y);
                    	        }
                    
                    	        if (cmd.type === 'Q' || cmd.type === 'C') {
                    	            xCoords.push(cmd.x1);
                    	            yCoords.push(cmd.y1);
                    	        }
                    
                    	        if (cmd.type === 'C') {
                    	            xCoords.push(cmd.x2);
                    	            yCoords.push(cmd.y2);
                    	        }
                    	    }
                    
                    	    var metrics = {
                    	        xMin: Math.min.apply(null, xCoords),
                    	        yMin: Math.min.apply(null, yCoords),
                    	        xMax: Math.max.apply(null, xCoords),
                    	        yMax: Math.max.apply(null, yCoords),
                    	        leftSideBearing: this.leftSideBearing
                    	    };
                    
                    	    if (!isFinite(metrics.xMin)) {
                    	        metrics.xMin = 0;
                    	    }
                    
                    	    if (!isFinite(metrics.xMax)) {
                    	        metrics.xMax = this.advanceWidth;
                    	    }
                    
                    	    if (!isFinite(metrics.yMin)) {
                    	        metrics.yMin = 0;
                    	    }
                    
                    	    if (!isFinite(metrics.yMax)) {
                    	        metrics.yMax = 0;
                    	    }
                    
                    	    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
                    	    return metrics;
                    	};
                    
                    	/**
                    	 * Draw the glyph on the given context.
                    	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
                    	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
                    	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
                    	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
                    	 * @param  {Object=} options - xScale, yScale to stretch the glyph.
                    	 */
                    	Glyph.prototype.draw = function(ctx, x, y, fontSize, options) {
                    	    this.getPath(x, y, fontSize, options).draw(ctx);
                    	};
                    
                    	/**
                    	 * Draw the points of the glyph.
                    	 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
                    	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
                    	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
                    	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
                    	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
                    	 */
                    	Glyph.prototype.drawPoints = function(ctx, x, y, fontSize) {
                    	    function drawCircles(l, x, y, scale) {
                    	        var PI_SQ = Math.PI * 2;
                    	        ctx.beginPath();
                    	        for (var j = 0; j < l.length; j += 1) {
                    	            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));
                    	            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, PI_SQ, false);
                    	        }
                    
                    	        ctx.closePath();
                    	        ctx.fill();
                    	    }
                    
                    	    x = x !== undefined ? x : 0;
                    	    y = y !== undefined ? y : 0;
                    	    fontSize = fontSize !== undefined ? fontSize : 24;
                    	    var scale = 1 / this.path.unitsPerEm * fontSize;
                    
                    	    var blueCircles = [];
                    	    var redCircles = [];
                    	    var path = this.path;
                    	    for (var i = 0; i < path.commands.length; i += 1) {
                    	        var cmd = path.commands[i];
                    	        if (cmd.x !== undefined) {
                    	            blueCircles.push({x: cmd.x, y: -cmd.y});
                    	        }
                    
                    	        if (cmd.x1 !== undefined) {
                    	            redCircles.push({x: cmd.x1, y: -cmd.y1});
                    	        }
                    
                    	        if (cmd.x2 !== undefined) {
                    	            redCircles.push({x: cmd.x2, y: -cmd.y2});
                    	        }
                    	    }
                    
                    	    ctx.fillStyle = 'blue';
                    	    drawCircles(blueCircles, x, y, scale);
                    	    ctx.fillStyle = 'red';
                    	    drawCircles(redCircles, x, y, scale);
                    	};
                    
                    	/**
                    	 * Draw lines indicating important font measurements.
                    	 * Black lines indicate the origin of the coordinate system (point 0,0).
                    	 * Blue lines indicate the glyph bounding box.
                    	 * Green line indicates the advance width of the glyph.
                    	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
                    	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
                    	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
                    	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
                    	 */
                    	Glyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {
                    	    var scale;
                    	    x = x !== undefined ? x : 0;
                    	    y = y !== undefined ? y : 0;
                    	    fontSize = fontSize !== undefined ? fontSize : 24;
                    	    scale = 1 / this.path.unitsPerEm * fontSize;
                    	    ctx.lineWidth = 1;
                    
                    	    // Draw the origin
                    	    ctx.strokeStyle = 'black';
                    	    draw.line(ctx, x, -10000, x, 10000);
                    	    draw.line(ctx, -10000, y, 10000, y);
                    
                    	    // This code is here due to memory optimization: by not using
                    	    // defaults in the constructor, we save a notable amount of memory.
                    	    var xMin = this.xMin || 0;
                    	    var yMin = this.yMin || 0;
                    	    var xMax = this.xMax || 0;
                    	    var yMax = this.yMax || 0;
                    	    var advanceWidth = this.advanceWidth || 0;
                    
                    	    // Draw the glyph box
                    	    ctx.strokeStyle = 'blue';
                    	    draw.line(ctx, x + (xMin * scale), -10000, x + (xMin * scale), 10000);
                    	    draw.line(ctx, x + (xMax * scale), -10000, x + (xMax * scale), 10000);
                    	    draw.line(ctx, -10000, y + (-yMin * scale), 10000, y + (-yMin * scale));
                    	    draw.line(ctx, -10000, y + (-yMax * scale), 10000, y + (-yMax * scale));
                    
                    	    // Draw the advance width
                    	    ctx.strokeStyle = 'green';
                    	    draw.line(ctx, x + (advanceWidth * scale), -10000, x + (advanceWidth * scale), 10000);
                    	};
                    
                    	// The GlyphSet object
                    
                    	// Define a property on the glyph that depends on the path being loaded.
                    	function defineDependentProperty(glyph, externalName, internalName) {
                    	    Object.defineProperty(glyph, externalName, {
                    	        get: function() {
                    	            // Request the path property to make sure the path is loaded.
                    	            // glyph.path; // jshint ignore:line
                    	            return glyph[internalName];
                    	        },
                    	        set: function(newValue) {
                    	            glyph[internalName] = newValue;
                    	        },
                    	        enumerable: true,
                    	        configurable: true
                    	    });
                    	}
                    
                    	/**
                    	 * A GlyphSet represents all glyphs available in the font, but modelled using
                    	 * a deferred glyph loader, for retrieving glyphs only once they are absolutely
                    	 * necessary, to keep the memory footprint down.
                    	 * @exports opentype.GlyphSet
                    	 * @class
                    	 * @param {opentype.Font}
                    	 * @param {Array}
                    	 */
                    	function GlyphSet(font, glyphs) {
                    	    var this$1 = this;
                    
                    	    this.font = font;
                    	    this.glyphs = {};
                    	    if (Array.isArray(glyphs)) {
                    	        for (var i = 0; i < glyphs.length; i++) {
                    	            this$1.glyphs[i] = glyphs[i];
                    	        }
                    	    }
                    
                    	    this.length = (glyphs && glyphs.length) || 0;
                    	}
                    
                    	/**
                    	 * @param  {number} index
                    	 * @return {opentype.Glyph}
                    	 */
                    	GlyphSet.prototype.get = function(index) {
                    	    if (typeof this.glyphs[index] === 'function') {
                    	        this.glyphs[index] = this.glyphs[index]();
                    	    }
                    
                    	    return this.glyphs[index];
                    	};
                    
                    	/**
                    	 * @param  {number} index
                    	 * @param  {Object}
                    	 */
                    	GlyphSet.prototype.push = function(index, loader) {
                    	    this.glyphs[index] = loader;
                    	    this.length++;
                    	};
                    
                    	/**
                    	 * @alias opentype.glyphLoader
                    	 * @param  {opentype.Font} font
                    	 * @param  {number} index
                    	 * @return {opentype.Glyph}
                    	 */
                    	function glyphLoader(font, index) {
                    	    return new Glyph({index: index, font: font});
                    	}
                    
                    	/**
                    	 * Generate a stub glyph that can be filled with all metadata *except*
                    	 * the "points" and "path" properties, which must be loaded only once
                    	 * the glyph's path is actually requested for text shaping.
                    	 * @alias opentype.ttfGlyphLoader
                    	 * @param  {opentype.Font} font
                    	 * @param  {number} index
                    	 * @param  {Function} parseGlyph
                    	 * @param  {Object} data
                    	 * @param  {number} position
                    	 * @param  {Function} buildPath
                    	 * @return {opentype.Glyph}
                    	 */
                    	function ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {
                    	    return function() {
                    	        var glyph = new Glyph({index: index, font: font});
                    
                    	        glyph.path = function() {
                    	            parseGlyph(glyph, data, position);
                    	            var path = buildPath(font.glyphs, glyph);
                    	            path.unitsPerEm = font.unitsPerEm;
                    	            return path;
                    	        };
                    
                    	        defineDependentProperty(glyph, 'xMin', '_xMin');
                    	        defineDependentProperty(glyph, 'xMax', '_xMax');
                    	        defineDependentProperty(glyph, 'yMin', '_yMin');
                    	        defineDependentProperty(glyph, 'yMax', '_yMax');
                    
                    	        return glyph;
                    	    };
                    	}
                    	/**
                    	 * @alias opentype.cffGlyphLoader
                    	 * @param  {opentype.Font} font
                    	 * @param  {number} index
                    	 * @param  {Function} parseCFFCharstring
                    	 * @param  {string} charstring
                    	 * @return {opentype.Glyph}
                    	 */
                    	function cffGlyphLoader(font, index, parseCFFCharstring, charstring) {
                    	    return function() {
                    	        var glyph = new Glyph({index: index, font: font});
                    
                    	        glyph.path = function() {
                    	            var path = parseCFFCharstring(font, glyph, charstring);
                    	            path.unitsPerEm = font.unitsPerEm;
                    	            return path;
                    	        };
                    
                    	        return glyph;
                    	    };
                    	}
                    
                    	var glyphset = { GlyphSet: GlyphSet, glyphLoader: glyphLoader, ttfGlyphLoader: ttfGlyphLoader, cffGlyphLoader: cffGlyphLoader };
                    
                    	// The `CFF` table contains the glyph outlines in PostScript format.
                    
                    	// Custom equals function that can also check lists.
                    	function equals(a, b) {
                    	    if (a === b) {
                    	        return true;
                    	    } else if (Array.isArray(a) && Array.isArray(b)) {
                    	        if (a.length !== b.length) {
                    	            return false;
                    	        }
                    
                    	        for (var i = 0; i < a.length; i += 1) {
                    	            if (!equals(a[i], b[i])) {
                    	                return false;
                    	            }
                    	        }
                    
                    	        return true;
                    	    } else {
                    	        return false;
                    	    }
                    	}
                    
                    	// Subroutines are encoded using the negative half of the number space.
                    	// See type 2 chapter 4.7 "Subroutine operators".
                    	function calcCFFSubroutineBias(subrs) {
                    	    var bias;
                    	    if (subrs.length < 1240) {
                    	        bias = 107;
                    	    } else if (subrs.length < 33900) {
                    	        bias = 1131;
                    	    } else {
                    	        bias = 32768;
                    	    }
                    
                    	    return bias;
                    	}
                    
                    	// Parse a `CFF` INDEX array.
                    	// An index array consists of a list of offsets, then a list of objects at those offsets.
                    	function parseCFFIndex(data, start, conversionFn) {
                    	    var offsets = [];
                    	    var objects = [];
                    	    var count = parse.getCard16(data, start);
                    	    var objectOffset;
                    	    var endOffset;
                    	    if (count !== 0) {
                    	        var offsetSize = parse.getByte(data, start + 2);
                    	        objectOffset = start + ((count + 1) * offsetSize) + 2;
                    	        var pos = start + 3;
                    	        for (var i = 0; i < count + 1; i += 1) {
                    	            offsets.push(parse.getOffset(data, pos, offsetSize));
                    	            pos += offsetSize;
                    	        }
                    
                    	        // The total size of the index array is 4 header bytes + the value of the last offset.
                    	        endOffset = objectOffset + offsets[count];
                    	    } else {
                    	        endOffset = start + 2;
                    	    }
                    
                    	    for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {
                    	        var value = parse.getBytes(data, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1]);
                    	        if (conversionFn) {
                    	            value = conversionFn(value);
                    	        }
                    
                    	        objects.push(value);
                    	    }
                    
                    	    return {objects: objects, startOffset: start, endOffset: endOffset};
                    	}
                    
                    	// Parse a `CFF` DICT real value.
                    	function parseFloatOperand(parser) {
                    	    var s = '';
                    	    var eof = 15;
                    	    var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];
                    	    while (true) {
                    	        var b = parser.parseByte();
                    	        var n1 = b >> 4;
                    	        var n2 = b & 15;
                    
                    	        if (n1 === eof) {
                    	            break;
                    	        }
                    
                    	        s += lookup[n1];
                    
                    	        if (n2 === eof) {
                    	            break;
                    	        }
                    
                    	        s += lookup[n2];
                    	    }
                    
                    	    return parseFloat(s);
                    	}
                    
                    	// Parse a `CFF` DICT operand.
                    	function parseOperand(parser, b0) {
                    	    var b1;
                    	    var b2;
                    	    var b3;
                    	    var b4;
                    	    if (b0 === 28) {
                    	        b1 = parser.parseByte();
                    	        b2 = parser.parseByte();
                    	        return b1 << 8 | b2;
                    	    }
                    
                    	    if (b0 === 29) {
                    	        b1 = parser.parseByte();
                    	        b2 = parser.parseByte();
                    	        b3 = parser.parseByte();
                    	        b4 = parser.parseByte();
                    	        return b1 << 24 | b2 << 16 | b3 << 8 | b4;
                    	    }
                    
                    	    if (b0 === 30) {
                    	        return parseFloatOperand(parser);
                    	    }
                    
                    	    if (b0 >= 32 && b0 <= 246) {
                    	        return b0 - 139;
                    	    }
                    
                    	    if (b0 >= 247 && b0 <= 250) {
                    	        b1 = parser.parseByte();
                    	        return (b0 - 247) * 256 + b1 + 108;
                    	    }
                    
                    	    if (b0 >= 251 && b0 <= 254) {
                    	        b1 = parser.parseByte();
                    	        return -(b0 - 251) * 256 - b1 - 108;
                    	    }
                    
                    	    throw new Error('Invalid b0 ' + b0);
                    	}
                    
                    	// Convert the entries returned by `parseDict` to a proper dictionary.
                    	// If a value is a list of one, it is unpacked.
                    	function entriesToObject(entries) {
                    	    var o = {};
                    	    for (var i = 0; i < entries.length; i += 1) {
                    	        var key = entries[i][0];
                    	        var values = entries[i][1];
                    	        var value = (void 0);
                    	        if (values.length === 1) {
                    	            value = values[0];
                    	        } else {
                    	            value = values;
                    	        }
                    
                    	        if (o.hasOwnProperty(key) && !isNaN(o[key])) {
                    	            throw new Error('Object ' + o + ' already has key ' + key);
                    	        }
                    
                    	        o[key] = value;
                    	    }
                    
                    	    return o;
                    	}
                    
                    	// Parse a `CFF` DICT object.
                    	// A dictionary contains key-value pairs in a compact tokenized format.
                    	function parseCFFDict(data, start, size) {
                    	    start = start !== undefined ? start : 0;
                    	    var parser = new parse.Parser(data, start);
                    	    var entries = [];
                    	    var operands = [];
                    	    size = size !== undefined ? size : data.length;
                    
                    	    while (parser.relativeOffset < size) {
                    	        var op = parser.parseByte();
                    
                    	        // The first byte for each dict item distinguishes between operator (key) and operand (value).
                    	        // Values <= 21 are operators.
                    	        if (op <= 21) {
                    	            // Two-byte operators have an initial escape byte of 12.
                    	            if (op === 12) {
                    	                op = 1200 + parser.parseByte();
                    	            }
                    
                    	            entries.push([op, operands]);
                    	            operands = [];
                    	        } else {
                    	            // Since the operands (values) come before the operators (keys), we store all operands in a list
                    	            // until we encounter an operator.
                    	            operands.push(parseOperand(parser, op));
                    	        }
                    	    }
                    
                    	    return entriesToObject(entries);
                    	}
                    
                    	// Given a String Index (SID), return the value of the string.
                    	// Strings below index 392 are standard CFF strings and are not encoded in the font.
                    	function getCFFString(strings, index) {
                    	    if (index <= 390) {
                    	        index = cffStandardStrings[index];
                    	    } else {
                    	        index = strings[index - 391];
                    	    }
                    
                    	    return index;
                    	}
                    
                    	// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.
                    	// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.
                    	function interpretDict(dict, meta, strings) {
                    	    var newDict = {};
                    	    var value;
                    
                    	    // Because we also want to include missing values, we start out from the meta list
                    	    // and lookup values in the dict.
                    	    for (var i = 0; i < meta.length; i += 1) {
                    	        var m = meta[i];
                    
                    	        if (Array.isArray(m.type)) {
                    	            var values = [];
                    	            values.length = m.type.length;
                    	            for (var j = 0; j < m.type.length; j++) {
                    	                value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;
                    	                if (value === undefined) {
                    	                    value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;
                    	                }
                    	                if (m.type[j] === 'SID') {
                    	                    value = getCFFString(strings, value);
                    	                }
                    	                values[j] = value;
                    	            }
                    	            newDict[m.name] = values;
                    	        } else {
                    	            value = dict[m.op];
                    	            if (value === undefined) {
                    	                value = m.value !== undefined ? m.value : null;
                    	            }
                    
                    	            if (m.type === 'SID') {
                    	                value = getCFFString(strings, value);
                    	            }
                    	            newDict[m.name] = value;
                    	        }
                    	    }
                    
                    	    return newDict;
                    	}
                    
                    	// Parse the CFF header.
                    	function parseCFFHeader(data, start) {
                    	    var header = {};
                    	    header.formatMajor = parse.getCard8(data, start);
                    	    header.formatMinor = parse.getCard8(data, start + 1);
                    	    header.size = parse.getCard8(data, start + 2);
                    	    header.offsetSize = parse.getCard8(data, start + 3);
                    	    header.startOffset = start;
                    	    header.endOffset = start + 4;
                    	    return header;
                    	}
                    
                    	var TOP_DICT_META = [
                    	    {name: 'version', op: 0, type: 'SID'},
                    	    {name: 'notice', op: 1, type: 'SID'},
                    	    {name: 'copyright', op: 1200, type: 'SID'},
                    	    {name: 'fullName', op: 2, type: 'SID'},
                    	    {name: 'familyName', op: 3, type: 'SID'},
                    	    {name: 'weight', op: 4, type: 'SID'},
                    	    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},
                    	    {name: 'italicAngle', op: 1202, type: 'number', value: 0},
                    	    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},
                    	    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},
                    	    {name: 'paintType', op: 1205, type: 'number', value: 0},
                    	    {name: 'charstringType', op: 1206, type: 'number', value: 2},
                    	    {
                    	        name: 'fontMatrix',
                    	        op: 1207,
                    	        type: ['real', 'real', 'real', 'real', 'real', 'real'],
                    	        value: [0.001, 0, 0, 0.001, 0, 0]
                    	    },
                    	    {name: 'uniqueId', op: 13, type: 'number'},
                    	    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},
                    	    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},
                    	    {name: 'xuid', op: 14, type: [], value: null},
                    	    {name: 'charset', op: 15, type: 'offset', value: 0},
                    	    {name: 'encoding', op: 16, type: 'offset', value: 0},
                    	    {name: 'charStrings', op: 17, type: 'offset', value: 0},
                    	    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]},
                    	    {name: 'ros', op: 1230, type: ['SID', 'SID', 'number']},
                    	    {name: 'cidFontVersion', op: 1231, type: 'number', value: 0},
                    	    {name: 'cidFontRevision', op: 1232, type: 'number', value: 0},
                    	    {name: 'cidFontType', op: 1233, type: 'number', value: 0},
                    	    {name: 'cidCount', op: 1234, type: 'number', value: 8720},
                    	    {name: 'uidBase', op: 1235, type: 'number'},
                    	    {name: 'fdArray', op: 1236, type: 'offset'},
                    	    {name: 'fdSelect', op: 1237, type: 'offset'},
                    	    {name: 'fontName', op: 1238, type: 'SID'}
                    	];
                    
                    	var PRIVATE_DICT_META = [
                    	    {name: 'subrs', op: 19, type: 'offset', value: 0},
                    	    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},
                    	    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}
                    	];
                    
                    	// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.
                    	// The top dictionary contains the essential metadata for the font, together with the private dictionary.
                    	function parseCFFTopDict(data, strings) {
                    	    var dict = parseCFFDict(data, 0, data.byteLength);
                    	    return interpretDict(dict, TOP_DICT_META, strings);
                    	}
                    
                    	// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.
                    	function parseCFFPrivateDict(data, start, size, strings) {
                    	    var dict = parseCFFDict(data, start, size);
                    	    return interpretDict(dict, PRIVATE_DICT_META, strings);
                    	}
                    
                    	// Returns a list of "Top DICT"s found using an INDEX list.
                    	// Used to read both the usual high-level Top DICTs and also the FDArray
                    	// discovered inside CID-keyed fonts.  When a Top DICT has a reference to
                    	// a Private DICT that is read and saved into the Top DICT.
                    	//
                    	// In addition to the expected/optional values as outlined in TOP_DICT_META
                    	// the following values might be saved into the Top DICT.
                    	//
                    	//    _subrs []        array of local CFF subroutines from Private DICT
                    	//    _subrsBias       bias value computed from number of subroutines
                    	//                      (see calcCFFSubroutineBias() and parseCFFCharstring())
                    	//    _defaultWidthX   default widths for CFF characters
                    	//    _nominalWidthX   bias added to width embedded within glyph description
                    	//
                    	//    _privateDict     saved copy of parsed Private DICT from Top DICT
                    	function gatherCFFTopDicts(data, start, cffIndex, strings) {
                    	    var topDictArray = [];
                    	    for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {
                    	        var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);
                    	        var topDict = parseCFFTopDict(topDictData, strings);
                    	        topDict._subrs = [];
                    	        topDict._subrsBias = 0;
                    	        var privateSize = topDict.private[0];
                    	        var privateOffset = topDict.private[1];
                    	        if (privateSize !== 0 && privateOffset !== 0) {
                    	            var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);
                    	            topDict._defaultWidthX = privateDict.defaultWidthX;
                    	            topDict._nominalWidthX = privateDict.nominalWidthX;
                    	            if (privateDict.subrs !== 0) {
                    	                var subrOffset = privateOffset + privateDict.subrs;
                    	                var subrIndex = parseCFFIndex(data, subrOffset + start);
                    	                topDict._subrs = subrIndex.objects;
                    	                topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);
                    	            }
                    	            topDict._privateDict = privateDict;
                    	        }
                    	        topDictArray.push(topDict);
                    	    }
                    	    return topDictArray;
                    	}
                    
                    	// Parse the CFF charset table, which contains internal names for all the glyphs.
                    	// This function will return a list of glyph names.
                    	// See Adobe TN #5176 chapter 13, "Charsets".
                    	function parseCFFCharset(data, start, nGlyphs, strings) {
                    	    var sid;
                    	    var count;
                    	    var parser = new parse.Parser(data, start);
                    
                    	    // The .notdef glyph is not included, so subtract 1.
                    	    nGlyphs -= 1;
                    	    var charset = ['.notdef'];
                    
                    	    var format = parser.parseCard8();
                    	    if (format === 0) {
                    	        for (var i = 0; i < nGlyphs; i += 1) {
                    	            sid = parser.parseSID();
                    	            charset.push(getCFFString(strings, sid));
                    	        }
                    	    } else if (format === 1) {
                    	        while (charset.length <= nGlyphs) {
                    	            sid = parser.parseSID();
                    	            count = parser.parseCard8();
                    	            for (var i$1 = 0; i$1 <= count; i$1 += 1) {
                    	                charset.push(getCFFString(strings, sid));
                    	                sid += 1;
                    	            }
                    	        }
                    	    } else if (format === 2) {
                    	        while (charset.length <= nGlyphs) {
                    	            sid = parser.parseSID();
                    	            count = parser.parseCard16();
                    	            for (var i$2 = 0; i$2 <= count; i$2 += 1) {
                    	                charset.push(getCFFString(strings, sid));
                    	                sid += 1;
                    	            }
                    	        }
                    	    } else {
                    	        throw new Error('Unknown charset format ' + format);
                    	    }
                    
                    	    return charset;
                    	}
                    
                    	// Parse the CFF encoding data. Only one encoding can be specified per font.
                    	// See Adobe TN #5176 chapter 12, "Encodings".
                    	function parseCFFEncoding(data, start, charset) {
                    	    var code;
                    	    var enc = {};
                    	    var parser = new parse.Parser(data, start);
                    	    var format = parser.parseCard8();
                    	    if (format === 0) {
                    	        var nCodes = parser.parseCard8();
                    	        for (var i = 0; i < nCodes; i += 1) {
                    	            code = parser.parseCard8();
                    	            enc[code] = i;
                    	        }
                    	    } else if (format === 1) {
                    	        var nRanges = parser.parseCard8();
                    	        code = 1;
                    	        for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {
                    	            var first = parser.parseCard8();
                    	            var nLeft = parser.parseCard8();
                    	            for (var j = first; j <= first + nLeft; j += 1) {
                    	                enc[j] = code;
                    	                code += 1;
                    	            }
                    	        }
                    	    } else {
                    	        throw new Error('Unknown encoding format ' + format);
                    	    }
                    
                    	    return new CffEncoding(enc, charset);
                    	}
                    
                    	// Take in charstring code and return a Glyph object.
                    	// The encoding is described in the Type 2 Charstring Format
                    	// https://www.microsoft.com/typography/OTSPEC/charstr2.htm
                    	function parseCFFCharstring(font, glyph, code) {
                    	    var c1x;
                    	    var c1y;
                    	    var c2x;
                    	    var c2y;
                    	    var p = new Path();
                    	    var stack = [];
                    	    var nStems = 0;
                    	    var haveWidth = false;
                    	    var open = false;
                    	    var x = 0;
                    	    var y = 0;
                    	    var subrs;
                    	    var subrsBias;
                    	    var defaultWidthX;
                    	    var nominalWidthX;
                    	    if (font.isCIDFont) {
                    	        var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];
                    	        var fdDict = font.tables.cff.topDict._fdArray[fdIndex];
                    	        subrs = fdDict._subrs;
                    	        subrsBias = fdDict._subrsBias;
                    	        defaultWidthX = fdDict._defaultWidthX;
                    	        nominalWidthX = fdDict._nominalWidthX;
                    	    } else {
                    	        subrs = font.tables.cff.topDict._subrs;
                    	        subrsBias = font.tables.cff.topDict._subrsBias;
                    	        defaultWidthX = font.tables.cff.topDict._defaultWidthX;
                    	        nominalWidthX = font.tables.cff.topDict._nominalWidthX;
                    	    }
                    	    var width = defaultWidthX;
                    
                    	    function newContour(x, y) {
                    	        if (open) {
                    	            p.closePath();
                    	        }
                    
                    	        p.moveTo(x, y);
                    	        open = true;
                    	    }
                    
                    	    function parseStems() {
                    	        var hasWidthArg;
                    
                    	        // The number of stem operators on the stack is always even.
                    	        // If the value is uneven, that means a width is specified.
                    	        hasWidthArg = stack.length % 2 !== 0;
                    	        if (hasWidthArg && !haveWidth) {
                    	            width = stack.shift() + nominalWidthX;
                    	        }
                    
                    	        nStems += stack.length >> 1;
                    	        stack.length = 0;
                    	        haveWidth = true;
                    	    }
                    
                    	    function parse$$1(code) {
                    	        var b1;
                    	        var b2;
                    	        var b3;
                    	        var b4;
                    	        var codeIndex;
                    	        var subrCode;
                    	        var jpx;
                    	        var jpy;
                    	        var c3x;
                    	        var c3y;
                    	        var c4x;
                    	        var c4y;
                    
                    	        var i = 0;
                    	        while (i < code.length) {
                    	            var v = code[i];
                    	            i += 1;
                    	            switch (v) {
                    	                case 1: // hstem
                    	                    parseStems();
                    	                    break;
                    	                case 3: // vstem
                    	                    parseStems();
                    	                    break;
                    	                case 4: // vmoveto
                    	                    if (stack.length > 1 && !haveWidth) {
                    	                        width = stack.shift() + nominalWidthX;
                    	                        haveWidth = true;
                    	                    }
                    
                    	                    y += stack.pop();
                    	                    newContour(x, y);
                    	                    break;
                    	                case 5: // rlineto
                    	                    while (stack.length > 0) {
                    	                        x += stack.shift();
                    	                        y += stack.shift();
                    	                        p.lineTo(x, y);
                    	                    }
                    
                    	                    break;
                    	                case 6: // hlineto
                    	                    while (stack.length > 0) {
                    	                        x += stack.shift();
                    	                        p.lineTo(x, y);
                    	                        if (stack.length === 0) {
                    	                            break;
                    	                        }
                    
                    	                        y += stack.shift();
                    	                        p.lineTo(x, y);
                    	                    }
                    
                    	                    break;
                    	                case 7: // vlineto
                    	                    while (stack.length > 0) {
                    	                        y += stack.shift();
                    	                        p.lineTo(x, y);
                    	                        if (stack.length === 0) {
                    	                            break;
                    	                        }
                    
                    	                        x += stack.shift();
                    	                        p.lineTo(x, y);
                    	                    }
                    
                    	                    break;
                    	                case 8: // rrcurveto
                    	                    while (stack.length > 0) {
                    	                        c1x = x + stack.shift();
                    	                        c1y = y + stack.shift();
                    	                        c2x = c1x + stack.shift();
                    	                        c2y = c1y + stack.shift();
                    	                        x = c2x + stack.shift();
                    	                        y = c2y + stack.shift();
                    	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    	                    }
                    
                    	                    break;
                    	                case 10: // callsubr
                    	                    codeIndex = stack.pop() + subrsBias;
                    	                    subrCode = subrs[codeIndex];
                    	                    if (subrCode) {
                    	                        parse$$1(subrCode);
                    	                    }
                    
                    	                    break;
                    	                case 11: // return
                    	                    return;
                    	                case 12: // flex operators
                    	                    v = code[i];
                    	                    i += 1;
                    	                    switch (v) {
                    	                        case 35: // flex
                    	                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-
                    	                            c1x = x   + stack.shift();    // dx1
                    	                            c1y = y   + stack.shift();    // dy1
                    	                            c2x = c1x + stack.shift();    // dx2
                    	                            c2y = c1y + stack.shift();    // dy2
                    	                            jpx = c2x + stack.shift();    // dx3
                    	                            jpy = c2y + stack.shift();    // dy3
                    	                            c3x = jpx + stack.shift();    // dx4
                    	                            c3y = jpy + stack.shift();    // dy4
                    	                            c4x = c3x + stack.shift();    // dx5
                    	                            c4y = c3y + stack.shift();    // dy5
                    	                            x = c4x   + stack.shift();    // dx6
                    	                            y = c4y   + stack.shift();    // dy6
                    	                            stack.shift();                // flex depth
                    	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                    	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                    	                            break;
                    	                        case 34: // hflex
                    	                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-
                    	                            c1x = x   + stack.shift();    // dx1
                    	                            c1y = y;                      // dy1
                    	                            c2x = c1x + stack.shift();    // dx2
                    	                            c2y = c1y + stack.shift();    // dy2
                    	                            jpx = c2x + stack.shift();    // dx3
                    	                            jpy = c2y;                    // dy3
                    	                            c3x = jpx + stack.shift();    // dx4
                    	                            c3y = c2y;                    // dy4
                    	                            c4x = c3x + stack.shift();    // dx5
                    	                            c4y = y;                      // dy5
                    	                            x = c4x + stack.shift();      // dx6
                    	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                    	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                    	                            break;
                    	                        case 36: // hflex1
                    	                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-
                    	                            c1x = x   + stack.shift();    // dx1
                    	                            c1y = y   + stack.shift();    // dy1
                    	                            c2x = c1x + stack.shift();    // dx2
                    	                            c2y = c1y + stack.shift();    // dy2
                    	                            jpx = c2x + stack.shift();    // dx3
                    	                            jpy = c2y;                    // dy3
                    	                            c3x = jpx + stack.shift();    // dx4
                    	                            c3y = c2y;                    // dy4
                    	                            c4x = c3x + stack.shift();    // dx5
                    	                            c4y = c3y + stack.shift();    // dy5
                    	                            x = c4x + stack.shift();      // dx6
                    	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                    	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                    	                            break;
                    	                        case 37: // flex1
                    	                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-
                    	                            c1x = x   + stack.shift();    // dx1
                    	                            c1y = y   + stack.shift();    // dy1
                    	                            c2x = c1x + stack.shift();    // dx2
                    	                            c2y = c1y + stack.shift();    // dy2
                    	                            jpx = c2x + stack.shift();    // dx3
                    	                            jpy = c2y + stack.shift();    // dy3
                    	                            c3x = jpx + stack.shift();    // dx4
                    	                            c3y = jpy + stack.shift();    // dy4
                    	                            c4x = c3x + stack.shift();    // dx5
                    	                            c4y = c3y + stack.shift();    // dy5
                    	                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
                    	                                x = c4x + stack.shift();
                    	                            } else {
                    	                                y = c4y + stack.shift();
                    	                            }
                    
                    	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                    	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                    	                            break;
                    	                        default:
                    	                            console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);
                    	                            stack.length = 0;
                    	                    }
                    	                    break;
                    	                case 14: // endchar
                    	                    if (stack.length > 0 && !haveWidth) {
                    	                        width = stack.shift() + nominalWidthX;
                    	                        haveWidth = true;
                    	                    }
                    
                    	                    if (open) {
                    	                        p.closePath();
                    	                        open = false;
                    	                    }
                    
                    	                    break;
                    	                case 18: // hstemhm
                    	                    parseStems();
                    	                    break;
                    	                case 19: // hintmask
                    	                case 20: // cntrmask
                    	                    parseStems();
                    	                    i += (nStems + 7) >> 3;
                    	                    break;
                    	                case 21: // rmoveto
                    	                    if (stack.length > 2 && !haveWidth) {
                    	                        width = stack.shift() + nominalWidthX;
                    	                        haveWidth = true;
                    	                    }
                    
                    	                    y += stack.pop();
                    	                    x += stack.pop();
                    	                    newContour(x, y);
                    	                    break;
                    	                case 22: // hmoveto
                    	                    if (stack.length > 1 && !haveWidth) {
                    	                        width = stack.shift() + nominalWidthX;
                    	                        haveWidth = true;
                    	                    }
                    
                    	                    x += stack.pop();
                    	                    newContour(x, y);
                    	                    break;
                    	                case 23: // vstemhm
                    	                    parseStems();
                    	                    break;
                    	                case 24: // rcurveline
                    	                    while (stack.length > 2) {
                    	                        c1x = x + stack.shift();
                    	                        c1y = y + stack.shift();
                    	                        c2x = c1x + stack.shift();
                    	                        c2y = c1y + stack.shift();
                    	                        x = c2x + stack.shift();
                    	                        y = c2y + stack.shift();
                    	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    	                    }
                    
                    	                    x += stack.shift();
                    	                    y += stack.shift();
                    	                    p.lineTo(x, y);
                    	                    break;
                    	                case 25: // rlinecurve
                    	                    while (stack.length > 6) {
                    	                        x += stack.shift();
                    	                        y += stack.shift();
                    	                        p.lineTo(x, y);
                    	                    }
                    
                    	                    c1x = x + stack.shift();
                    	                    c1y = y + stack.shift();
                    	                    c2x = c1x + stack.shift();
                    	                    c2y = c1y + stack.shift();
                    	                    x = c2x + stack.shift();
                    	                    y = c2y + stack.shift();
                    	                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    	                    break;
                    	                case 26: // vvcurveto
                    	                    if (stack.length % 2) {
                    	                        x += stack.shift();
                    	                    }
                    
                    	                    while (stack.length > 0) {
                    	                        c1x = x;
                    	                        c1y = y + stack.shift();
                    	                        c2x = c1x + stack.shift();
                    	                        c2y = c1y + stack.shift();
                    	                        x = c2x;
                    	                        y = c2y + stack.shift();
                    	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    	                    }
                    
                    	                    break;
                    	                case 27: // hhcurveto
                    	                    if (stack.length % 2) {
                    	                        y += stack.shift();
                    	                    }
                    
                    	                    while (stack.length > 0) {
                    	                        c1x = x + stack.shift();
                    	                        c1y = y;
                    	                        c2x = c1x + stack.shift();
                    	                        c2y = c1y + stack.shift();
                    	                        x = c2x + stack.shift();
                    	                        y = c2y;
                    	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    	                    }
                    
                    	                    break;
                    	                case 28: // shortint
                    	                    b1 = code[i];
                    	                    b2 = code[i + 1];
                    	                    stack.push(((b1 << 24) | (b2 << 16)) >> 16);
                    	                    i += 2;
                    	                    break;
                    	                case 29: // callgsubr
                    	                    codeIndex = stack.pop() + font.gsubrsBias;
                    	                    subrCode = font.gsubrs[codeIndex];
                    	                    if (subrCode) {
                    	                        parse$$1(subrCode);
                    	                    }
                    
                    	                    break;
                    	                case 30: // vhcurveto
                    	                    while (stack.length > 0) {
                    	                        c1x = x;
                    	                        c1y = y + stack.shift();
                    	                        c2x = c1x + stack.shift();
                    	                        c2y = c1y + stack.shift();
                    	                        x = c2x + stack.shift();
                    	                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
                    	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    	                        if (stack.length === 0) {
                    	                            break;
                    	                        }
                    
                    	                        c1x = x + stack.shift();
                    	                        c1y = y;
                    	                        c2x = c1x + stack.shift();
                    	                        c2y = c1y + stack.shift();
                    	                        y = c2y + stack.shift();
                    	                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
                    	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    	                    }
                    
                    	                    break;
                    	                case 31: // hvcurveto
                    	                    while (stack.length > 0) {
                    	                        c1x = x + stack.shift();
                    	                        c1y = y;
                    	                        c2x = c1x + stack.shift();
                    	                        c2y = c1y + stack.shift();
                    	                        y = c2y + stack.shift();
                    	                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
                    	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    	                        if (stack.length === 0) {
                    	                            break;
                    	                        }
                    
                    	                        c1x = x;
                    	                        c1y = y + stack.shift();
                    	                        c2x = c1x + stack.shift();
                    	                        c2y = c1y + stack.shift();
                    	                        x = c2x + stack.shift();
                    	                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
                    	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    	                    }
                    
                    	                    break;
                    	                default:
                    	                    if (v < 32) {
                    	                        console.log('Glyph ' + glyph.index + ': unknown operator ' + v);
                    	                    } else if (v < 247) {
                    	                        stack.push(v - 139);
                    	                    } else if (v < 251) {
                    	                        b1 = code[i];
                    	                        i += 1;
                    	                        stack.push((v - 247) * 256 + b1 + 108);
                    	                    } else if (v < 255) {
                    	                        b1 = code[i];
                    	                        i += 1;
                    	                        stack.push(-(v - 251) * 256 - b1 - 108);
                    	                    } else {
                    	                        b1 = code[i];
                    	                        b2 = code[i + 1];
                    	                        b3 = code[i + 2];
                    	                        b4 = code[i + 3];
                    	                        i += 4;
                    	                        stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);
                    	                    }
                    	            }
                    	        }
                    	    }
                    
                    	    parse$$1(code);
                    
                    	    glyph.advanceWidth = width;
                    	    return p;
                    	}
                    
                    	function parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {
                    	    var fdSelect = [];
                    	    var fdIndex;
                    	    var parser = new parse.Parser(data, start);
                    	    var format = parser.parseCard8();
                    	    if (format === 0) {
                    	        // Simple list of nGlyphs elements
                    	        for (var iGid = 0; iGid < nGlyphs; iGid++) {
                    	            fdIndex = parser.parseCard8();
                    	            if (fdIndex >= fdArrayCount) {
                    	                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
                    	            }
                    	            fdSelect.push(fdIndex);
                    	        }
                    	    } else if (format === 3) {
                    	        // Ranges
                    	        var nRanges = parser.parseCard16();
                    	        var first = parser.parseCard16();
                    	        if (first !== 0) {
                    	            throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first);
                    	        }
                    	        var next;
                    	        for (var iRange = 0; iRange < nRanges; iRange++) {
                    	            fdIndex = parser.parseCard8();
                    	            next = parser.parseCard16();
                    	            if (fdIndex >= fdArrayCount) {
                    	                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
                    	            }
                    	            if (next > nGlyphs) {
                    	                throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next);
                    	            }
                    	            for (; first < next; first++) {
                    	                fdSelect.push(fdIndex);
                    	            }
                    	            first = next;
                    	        }
                    	        if (next !== nGlyphs) {
                    	            throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next);
                    	        }
                    	    } else {
                    	        throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format);
                    	    }
                    	    return fdSelect;
                    	}
                    
                    	// Parse the `CFF` table, which contains the glyph outlines in PostScript format.
                    	function parseCFFTable(data, start, font) {
                    	    font.tables.cff = {};
                    	    var header = parseCFFHeader(data, start);
                    	    var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);
                    	    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
                    	    var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);
                    	    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
                    	    font.gsubrs = globalSubrIndex.objects;
                    	    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);
                    
                    	    var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);
                    	    if (topDictArray.length !== 1) {
                    	        throw new Error('CFF table has too many fonts in \'FontSet\' - count of fonts NameIndex.length = ' + topDictArray.length);
                    	    }
                    
                    	    var topDict = topDictArray[0];
                    	    font.tables.cff.topDict = topDict;
                    
                    	    if (topDict._privateDict) {
                    	        font.defaultWidthX = topDict._privateDict.defaultWidthX;
                    	        font.nominalWidthX = topDict._privateDict.nominalWidthX;
                    	    }
                    
                    	    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {
                    	        font.isCIDFont = true;
                    	    }
                    
                    	    if (font.isCIDFont) {
                    	        var fdArrayOffset = topDict.fdArray;
                    	        var fdSelectOffset = topDict.fdSelect;
                    	        if (fdArrayOffset === 0 || fdSelectOffset === 0) {
                    	            throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing');
                    	        }
                    	        fdArrayOffset += start;
                    	        var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);
                    	        var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);
                    	        topDict._fdArray = fdArray;
                    	        fdSelectOffset += start;
                    	        topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);
                    	    }
                    
                    	    var privateDictOffset = start + topDict.private[1];
                    	    var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);
                    	    font.defaultWidthX = privateDict.defaultWidthX;
                    	    font.nominalWidthX = privateDict.nominalWidthX;
                    
                    	    if (privateDict.subrs !== 0) {
                    	        var subrOffset = privateDictOffset + privateDict.subrs;
                    	        var subrIndex = parseCFFIndex(data, subrOffset);
                    	        font.subrs = subrIndex.objects;
                    	        font.subrsBias = calcCFFSubroutineBias(font.subrs);
                    	    } else {
                    	        font.subrs = [];
                    	        font.subrsBias = 0;
                    	    }
                    
                    	    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.
                    	    var charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
                    	    font.nGlyphs = charStringsIndex.objects.length;
                    
                    	    var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
                    	    if (topDict.encoding === 0) {
                    	        // Standard encoding
                    	        font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);
                    	    } else if (topDict.encoding === 1) {
                    	        // Expert encoding
                    	        font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);
                    	    } else {
                    	        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
                    	    }
                    
                    	    // Prefer the CMAP encoding to the CFF encoding.
                    	    font.encoding = font.encoding || font.cffEncoding;
                    
                    	    font.glyphs = new glyphset.GlyphSet(font);
                    	    for (var i = 0; i < font.nGlyphs; i += 1) {
                    	        var charString = charStringsIndex.objects[i];
                    	        font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));
                    	    }
                    	}
                    
                    	// Convert a string to a String ID (SID).
                    	// The list of strings is modified in place.
                    	function encodeString(s, strings) {
                    	    var sid;
                    
                    	    // Is the string in the CFF standard strings?
                    	    var i = cffStandardStrings.indexOf(s);
                    	    if (i >= 0) {
                    	        sid = i;
                    	    }
                    
                    	    // Is the string already in the string index?
                    	    i = strings.indexOf(s);
                    	    if (i >= 0) {
                    	        sid = i + cffStandardStrings.length;
                    	    } else {
                    	        sid = cffStandardStrings.length + strings.length;
                    	        strings.push(s);
                    	    }
                    
                    	    return sid;
                    	}
                    
                    	function makeHeader() {
                    	    return new table.Record('Header', [
                    	        {name: 'major', type: 'Card8', value: 1},
                    	        {name: 'minor', type: 'Card8', value: 0},
                    	        {name: 'hdrSize', type: 'Card8', value: 4},
                    	        {name: 'major', type: 'Card8', value: 1}
                    	    ]);
                    	}
                    
                    	function makeNameIndex(fontNames) {
                    	    var t = new table.Record('Name INDEX', [
                    	        {name: 'names', type: 'INDEX', value: []}
                    	    ]);
                    	    t.names = [];
                    	    for (var i = 0; i < fontNames.length; i += 1) {
                    	        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});
                    	    }
                    
                    	    return t;
                    	}
                    
                    	// Given a dictionary's metadata, create a DICT structure.
                    	function makeDict(meta, attrs, strings) {
                    	    var m = {};
                    	    for (var i = 0; i < meta.length; i += 1) {
                    	        var entry = meta[i];
                    	        var value = attrs[entry.name];
                    	        if (value !== undefined && !equals(value, entry.value)) {
                    	            if (entry.type === 'SID') {
                    	                value = encodeString(value, strings);
                    	            }
                    
                    	            m[entry.op] = {name: entry.name, type: entry.type, value: value};
                    	        }
                    	    }
                    
                    	    return m;
                    	}
                    
                    	// The Top DICT houses the global font attributes.
                    	function makeTopDict(attrs, strings) {
                    	    var t = new table.Record('Top DICT', [
                    	        {name: 'dict', type: 'DICT', value: {}}
                    	    ]);
                    	    t.dict = makeDict(TOP_DICT_META, attrs, strings);
                    	    return t;
                    	}
                    
                    	function makeTopDictIndex(topDict) {
                    	    var t = new table.Record('Top DICT INDEX', [
                    	        {name: 'topDicts', type: 'INDEX', value: []}
                    	    ]);
                    	    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];
                    	    return t;
                    	}
                    
                    	function makeStringIndex(strings) {
                    	    var t = new table.Record('String INDEX', [
                    	        {name: 'strings', type: 'INDEX', value: []}
                    	    ]);
                    	    t.strings = [];
                    	    for (var i = 0; i < strings.length; i += 1) {
                    	        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});
                    	    }
                    
                    	    return t;
                    	}
                    
                    	function makeGlobalSubrIndex() {
                    	    // Currently we don't use subroutines.
                    	    return new table.Record('Global Subr INDEX', [
                    	        {name: 'subrs', type: 'INDEX', value: []}
                    	    ]);
                    	}
                    
                    	function makeCharsets(glyphNames, strings) {
                    	    var t = new table.Record('Charsets', [
                    	        {name: 'format', type: 'Card8', value: 0}
                    	    ]);
                    	    for (var i = 0; i < glyphNames.length; i += 1) {
                    	        var glyphName = glyphNames[i];
                    	        var glyphSID = encodeString(glyphName, strings);
                    	        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});
                    	    }
                    
                    	    return t;
                    	}
                    
                    	function glyphToOps(glyph) {
                    	    var ops = [];
                    	    var path = glyph.path;
                    	    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});
                    	    var x = 0;
                    	    var y = 0;
                    	    for (var i = 0; i < path.commands.length; i += 1) {
                    	        var dx = (void 0);
                    	        var dy = (void 0);
                    	        var cmd = path.commands[i];
                    	        if (cmd.type === 'Q') {
                    	            // CFF only supports bézier curves, so convert the quad to a bézier.
                    	            var _13 = 1 / 3;
                    	            var _23 = 2 / 3;
                    
                    	            // We're going to create a new command so we don't change the original path.
                    	            cmd = {
                    	                type: 'C',
                    	                x: cmd.x,
                    	                y: cmd.y,
                    	                x1: _13 * x + _23 * cmd.x1,
                    	                y1: _13 * y + _23 * cmd.y1,
                    	                x2: _13 * cmd.x + _23 * cmd.x1,
                    	                y2: _13 * cmd.y + _23 * cmd.y1
                    	            };
                    	        }
                    
                    	        if (cmd.type === 'M') {
                    	            dx = Math.round(cmd.x - x);
                    	            dy = Math.round(cmd.y - y);
                    	            ops.push({name: 'dx', type: 'NUMBER', value: dx});
                    	            ops.push({name: 'dy', type: 'NUMBER', value: dy});
                    	            ops.push({name: 'rmoveto', type: 'OP', value: 21});
                    	            x = Math.round(cmd.x);
                    	            y = Math.round(cmd.y);
                    	        } else if (cmd.type === 'L') {
                    	            dx = Math.round(cmd.x - x);
                    	            dy = Math.round(cmd.y - y);
                    	            ops.push({name: 'dx', type: 'NUMBER', value: dx});
                    	            ops.push({name: 'dy', type: 'NUMBER', value: dy});
                    	            ops.push({name: 'rlineto', type: 'OP', value: 5});
                    	            x = Math.round(cmd.x);
                    	            y = Math.round(cmd.y);
                    	        } else if (cmd.type === 'C') {
                    	            var dx1 = Math.round(cmd.x1 - x);
                    	            var dy1 = Math.round(cmd.y1 - y);
                    	            var dx2 = Math.round(cmd.x2 - cmd.x1);
                    	            var dy2 = Math.round(cmd.y2 - cmd.y1);
                    	            dx = Math.round(cmd.x - cmd.x2);
                    	            dy = Math.round(cmd.y - cmd.y2);
                    	            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});
                    	            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});
                    	            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});
                    	            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});
                    	            ops.push({name: 'dx', type: 'NUMBER', value: dx});
                    	            ops.push({name: 'dy', type: 'NUMBER', value: dy});
                    	            ops.push({name: 'rrcurveto', type: 'OP', value: 8});
                    	            x = Math.round(cmd.x);
                    	            y = Math.round(cmd.y);
                    	        }
                    
                    	        // Contours are closed automatically.
                    	    }
                    
                    	    ops.push({name: 'endchar', type: 'OP', value: 14});
                    	    return ops;
                    	}
                    
                    	function makeCharStringsIndex(glyphs) {
                    	    var t = new table.Record('CharStrings INDEX', [
                    	        {name: 'charStrings', type: 'INDEX', value: []}
                    	    ]);
                    
                    	    for (var i = 0; i < glyphs.length; i += 1) {
                    	        var glyph = glyphs.get(i);
                    	        var ops = glyphToOps(glyph);
                    	        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});
                    	    }
                    
                    	    return t;
                    	}
                    
                    	function makePrivateDict(attrs, strings) {
                    	    var t = new table.Record('Private DICT', [
                    	        {name: 'dict', type: 'DICT', value: {}}
                    	    ]);
                    	    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
                    	    return t;
                    	}
                    
                    	function makeCFFTable(glyphs, options) {
                    	    var t = new table.Table('CFF ', [
                    	        {name: 'header', type: 'RECORD'},
                    	        {name: 'nameIndex', type: 'RECORD'},
                    	        {name: 'topDictIndex', type: 'RECORD'},
                    	        {name: 'stringIndex', type: 'RECORD'},
                    	        {name: 'globalSubrIndex', type: 'RECORD'},
                    	        {name: 'charsets', type: 'RECORD'},
                    	        {name: 'charStringsIndex', type: 'RECORD'},
                    	        {name: 'privateDict', type: 'RECORD'}
                    	    ]);
                    
                    	    var fontScale = 1 / options.unitsPerEm;
                    	    // We use non-zero values for the offsets so that the DICT encodes them.
                    	    // This is important because the size of the Top DICT plays a role in offset calculation,
                    	    // and the size shouldn't change after we've written correct offsets.
                    	    var attrs = {
                    	        version: options.version,
                    	        fullName: options.fullName,
                    	        familyName: options.familyName,
                    	        weight: options.weightName,
                    	        fontBBox: options.fontBBox || [0, 0, 0, 0],
                    	        fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],
                    	        charset: 999,
                    	        encoding: 0,
                    	        charStrings: 999,
                    	        private: [0, 999]
                    	    };
                    
                    	    var privateAttrs = {};
                    
                    	    var glyphNames = [];
                    	    var glyph;
                    
                    	    // Skip first glyph (.notdef)
                    	    for (var i = 1; i < glyphs.length; i += 1) {
                    	        glyph = glyphs.get(i);
                    	        glyphNames.push(glyph.name);
                    	    }
                    
                    	    var strings = [];
                    
                    	    t.header = makeHeader();
                    	    t.nameIndex = makeNameIndex([options.postScriptName]);
                    	    var topDict = makeTopDict(attrs, strings);
                    	    t.topDictIndex = makeTopDictIndex(topDict);
                    	    t.globalSubrIndex = makeGlobalSubrIndex();
                    	    t.charsets = makeCharsets(glyphNames, strings);
                    	    t.charStringsIndex = makeCharStringsIndex(glyphs);
                    	    t.privateDict = makePrivateDict(privateAttrs, strings);
                    
                    	    // Needs to come at the end, to encode all custom strings used in the font.
                    	    t.stringIndex = makeStringIndex(strings);
                    
                    	    var startOffset = t.header.sizeOf() +
                    	        t.nameIndex.sizeOf() +
                    	        t.topDictIndex.sizeOf() +
                    	        t.stringIndex.sizeOf() +
                    	        t.globalSubrIndex.sizeOf();
                    	    attrs.charset = startOffset;
                    
                    	    // We use the CFF standard encoding; proper encoding will be handled in cmap.
                    	    attrs.encoding = 0;
                    	    attrs.charStrings = attrs.charset + t.charsets.sizeOf();
                    	    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();
                    
                    	    // Recreate the Top DICT INDEX with the correct offsets.
                    	    topDict = makeTopDict(attrs, strings);
                    	    t.topDictIndex = makeTopDictIndex(topDict);
                    
                    	    return t;
                    	}
                    
                    	var cff = { parse: parseCFFTable, make: makeCFFTable };
                    
                    	// The `head` table contains global information about the font.
                    
                    	// Parse the header `head` table
                    	function parseHeadTable(data, start) {
                    	    var head = {};
                    	    var p = new parse.Parser(data, start);
                    	    head.version = p.parseVersion();
                    	    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;
                    	    head.checkSumAdjustment = p.parseULong();
                    	    head.magicNumber = p.parseULong();
                    	    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');
                    	    head.flags = p.parseUShort();
                    	    head.unitsPerEm = p.parseUShort();
                    	    head.created = p.parseLongDateTime();
                    	    head.modified = p.parseLongDateTime();
                    	    head.xMin = p.parseShort();
                    	    head.yMin = p.parseShort();
                    	    head.xMax = p.parseShort();
                    	    head.yMax = p.parseShort();
                    	    head.macStyle = p.parseUShort();
                    	    head.lowestRecPPEM = p.parseUShort();
                    	    head.fontDirectionHint = p.parseShort();
                    	    head.indexToLocFormat = p.parseShort();
                    	    head.glyphDataFormat = p.parseShort();
                    	    return head;
                    	}
                    
                    	function makeHeadTable(options) {
                    	    // Apple Mac timestamp epoch is 01/01/1904 not 01/01/1970
                    	    var timestamp = Math.round(new Date().getTime() / 1000) + 2082844800;
                    	    var createdTimestamp = timestamp;
                    
                    	    if (options.createdTimestamp) {
                    	        createdTimestamp = options.createdTimestamp + 2082844800;
                    	    }
                    
                    	    return new table.Table('head', [
                    	        {name: 'version', type: 'FIXED', value: 0x00010000},
                    	        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},
                    	        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},
                    	        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},
                    	        {name: 'flags', type: 'USHORT', value: 0},
                    	        {name: 'unitsPerEm', type: 'USHORT', value: 1000},
                    	        {name: 'created', type: 'LONGDATETIME', value: createdTimestamp},
                    	        {name: 'modified', type: 'LONGDATETIME', value: timestamp},
                    	        {name: 'xMin', type: 'SHORT', value: 0},
                    	        {name: 'yMin', type: 'SHORT', value: 0},
                    	        {name: 'xMax', type: 'SHORT', value: 0},
                    	        {name: 'yMax', type: 'SHORT', value: 0},
                    	        {name: 'macStyle', type: 'USHORT', value: 0},
                    	        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},
                    	        {name: 'fontDirectionHint', type: 'SHORT', value: 2},
                    	        {name: 'indexToLocFormat', type: 'SHORT', value: 0},
                    	        {name: 'glyphDataFormat', type: 'SHORT', value: 0}
                    	    ], options);
                    	}
                    
                    	var head = { parse: parseHeadTable, make: makeHeadTable };
                    
                    	// The `hhea` table contains information for horizontal layout.
                    
                    	// Parse the horizontal header `hhea` table
                    	function parseHheaTable(data, start) {
                    	    var hhea = {};
                    	    var p = new parse.Parser(data, start);
                    	    hhea.version = p.parseVersion();
                    	    hhea.ascender = p.parseShort();
                    	    hhea.descender = p.parseShort();
                    	    hhea.lineGap = p.parseShort();
                    	    hhea.advanceWidthMax = p.parseUShort();
                    	    hhea.minLeftSideBearing = p.parseShort();
                    	    hhea.minRightSideBearing = p.parseShort();
                    	    hhea.xMaxExtent = p.parseShort();
                    	    hhea.caretSlopeRise = p.parseShort();
                    	    hhea.caretSlopeRun = p.parseShort();
                    	    hhea.caretOffset = p.parseShort();
                    	    p.relativeOffset += 8;
                    	    hhea.metricDataFormat = p.parseShort();
                    	    hhea.numberOfHMetrics = p.parseUShort();
                    	    return hhea;
                    	}
                    
                    	function makeHheaTable(options) {
                    	    return new table.Table('hhea', [
                    	        {name: 'version', type: 'FIXED', value: 0x00010000},
                    	        {name: 'ascender', type: 'FWORD', value: 0},
                    	        {name: 'descender', type: 'FWORD', value: 0},
                    	        {name: 'lineGap', type: 'FWORD', value: 0},
                    	        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},
                    	        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},
                    	        {name: 'minRightSideBearing', type: 'FWORD', value: 0},
                    	        {name: 'xMaxExtent', type: 'FWORD', value: 0},
                    	        {name: 'caretSlopeRise', type: 'SHORT', value: 1},
                    	        {name: 'caretSlopeRun', type: 'SHORT', value: 0},
                    	        {name: 'caretOffset', type: 'SHORT', value: 0},
                    	        {name: 'reserved1', type: 'SHORT', value: 0},
                    	        {name: 'reserved2', type: 'SHORT', value: 0},
                    	        {name: 'reserved3', type: 'SHORT', value: 0},
                    	        {name: 'reserved4', type: 'SHORT', value: 0},
                    	        {name: 'metricDataFormat', type: 'SHORT', value: 0},
                    	        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}
                    	    ], options);
                    	}
                    
                    	var hhea = { parse: parseHheaTable, make: makeHheaTable };
                    
                    	// The `hmtx` table contains the horizontal metrics for all glyphs.
                    
                    	// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.
                    	// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.
                    	function parseHmtxTable(data, start, numMetrics, numGlyphs, glyphs) {
                    	    var advanceWidth;
                    	    var leftSideBearing;
                    	    var p = new parse.Parser(data, start);
                    	    for (var i = 0; i < numGlyphs; i += 1) {
                    	        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.
                    	        if (i < numMetrics) {
                    	            advanceWidth = p.parseUShort();
                    	            leftSideBearing = p.parseShort();
                    	        }
                    
                    	        var glyph = glyphs.get(i);
                    	        glyph.advanceWidth = advanceWidth;
                    	        glyph.leftSideBearing = leftSideBearing;
                    	    }
                    	}
                    
                    	function makeHmtxTable(glyphs) {
                    	    var t = new table.Table('hmtx', []);
                    	    for (var i = 0; i < glyphs.length; i += 1) {
                    	        var glyph = glyphs.get(i);
                    	        var advanceWidth = glyph.advanceWidth || 0;
                    	        var leftSideBearing = glyph.leftSideBearing || 0;
                    	        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});
                    	        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});
                    	    }
                    
                    	    return t;
                    	}
                    
                    	var hmtx = { parse: parseHmtxTable, make: makeHmtxTable };
                    
                    	// The `ltag` table stores IETF BCP-47 language tags. It allows supporting
                    
                    	function makeLtagTable(tags) {
                    	    var result = new table.Table('ltag', [
                    	        {name: 'version', type: 'ULONG', value: 1},
                    	        {name: 'flags', type: 'ULONG', value: 0},
                    	        {name: 'numTags', type: 'ULONG', value: tags.length}
                    	    ]);
                    
                    	    var stringPool = '';
                    	    var stringPoolOffset = 12 + tags.length * 4;
                    	    for (var i = 0; i < tags.length; ++i) {
                    	        var pos = stringPool.indexOf(tags[i]);
                    	        if (pos < 0) {
                    	            pos = stringPool.length;
                    	            stringPool += tags[i];
                    	        }
                    
                    	        result.fields.push({name: 'offset ' + i, type: 'USHORT', value: stringPoolOffset + pos});
                    	        result.fields.push({name: 'length ' + i, type: 'USHORT', value: tags[i].length});
                    	    }
                    
                    	    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});
                    	    return result;
                    	}
                    
                    	function parseLtagTable(data, start) {
                    	    var p = new parse.Parser(data, start);
                    	    var tableVersion = p.parseULong();
                    	    check.argument(tableVersion === 1, 'Unsupported ltag table version.');
                    	    // The 'ltag' specification does not define any flags; skip the field.
                    	    p.skip('uLong', 1);
                    	    var numTags = p.parseULong();
                    
                    	    var tags = [];
                    	    for (var i = 0; i < numTags; i++) {
                    	        var tag = '';
                    	        var offset = start + p.parseUShort();
                    	        var length = p.parseUShort();
                    	        for (var j = offset; j < offset + length; ++j) {
                    	            tag += String.fromCharCode(data.getInt8(j));
                    	        }
                    
                    	        tags.push(tag);
                    	    }
                    
                    	    return tags;
                    	}
                    
                    	var ltag = { make: makeLtagTable, parse: parseLtagTable };
                    
                    	// The `maxp` table establishes the memory requirements for the font.
                    
                    	// Parse the maximum profile `maxp` table.
                    	function parseMaxpTable(data, start) {
                    	    var maxp = {};
                    	    var p = new parse.Parser(data, start);
                    	    maxp.version = p.parseVersion();
                    	    maxp.numGlyphs = p.parseUShort();
                    	    if (maxp.version === 1.0) {
                    	        maxp.maxPoints = p.parseUShort();
                    	        maxp.maxContours = p.parseUShort();
                    	        maxp.maxCompositePoints = p.parseUShort();
                    	        maxp.maxCompositeContours = p.parseUShort();
                    	        maxp.maxZones = p.parseUShort();
                    	        maxp.maxTwilightPoints = p.parseUShort();
                    	        maxp.maxStorage = p.parseUShort();
                    	        maxp.maxFunctionDefs = p.parseUShort();
                    	        maxp.maxInstructionDefs = p.parseUShort();
                    	        maxp.maxStackElements = p.parseUShort();
                    	        maxp.maxSizeOfInstructions = p.parseUShort();
                    	        maxp.maxComponentElements = p.parseUShort();
                    	        maxp.maxComponentDepth = p.parseUShort();
                    	    }
                    
                    	    return maxp;
                    	}
                    
                    	function makeMaxpTable(numGlyphs) {
                    	    return new table.Table('maxp', [
                    	        {name: 'version', type: 'FIXED', value: 0x00005000},
                    	        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}
                    	    ]);
                    	}
                    
                    	var maxp = { parse: parseMaxpTable, make: makeMaxpTable };
                    
                    	// The `name` naming table.
                    
                    	// NameIDs for the name table.
                    	var nameTableNames = [
                    	    'copyright',              // 0
                    	    'fontFamily',             // 1
                    	    'fontSubfamily',          // 2
                    	    'uniqueID',               // 3
                    	    'fullName',               // 4
                    	    'version',                // 5
                    	    'postScriptName',         // 6
                    	    'trademark',              // 7
                    	    'manufacturer',           // 8
                    	    'designer',               // 9
                    	    'description',            // 10
                    	    'manufacturerURL',        // 11
                    	    'designerURL',            // 12
                    	    'license',                // 13
                    	    'licenseURL',             // 14
                    	    'reserved',               // 15
                    	    'preferredFamily',        // 16
                    	    'preferredSubfamily',     // 17
                    	    'compatibleFullName',     // 18
                    	    'sampleText',             // 19
                    	    'postScriptFindFontName', // 20
                    	    'wwsFamily',              // 21
                    	    'wwsSubfamily'            // 22
                    	];
                    
                    	var macLanguages = {
                    	    0: 'en',
                    	    1: 'fr',
                    	    2: 'de',
                    	    3: 'it',
                    	    4: 'nl',
                    	    5: 'sv',
                    	    6: 'es',
                    	    7: 'da',
                    	    8: 'pt',
                    	    9: 'no',
                    	    10: 'he',
                    	    11: 'ja',
                    	    12: 'ar',
                    	    13: 'fi',
                    	    14: 'el',
                    	    15: 'is',
                    	    16: 'mt',
                    	    17: 'tr',
                    	    18: 'hr',
                    	    19: 'zh-Hant',
                    	    20: 'ur',
                    	    21: 'hi',
                    	    22: 'th',
                    	    23: 'ko',
                    	    24: 'lt',
                    	    25: 'pl',
                    	    26: 'hu',
                    	    27: 'es',
                    	    28: 'lv',
                    	    29: 'se',
                    	    30: 'fo',
                    	    31: 'fa',
                    	    32: 'ru',
                    	    33: 'zh',
                    	    34: 'nl-BE',
                    	    35: 'ga',
                    	    36: 'sq',
                    	    37: 'ro',
                    	    38: 'cz',
                    	    39: 'sk',
                    	    40: 'si',
                    	    41: 'yi',
                    	    42: 'sr',
                    	    43: 'mk',
                    	    44: 'bg',
                    	    45: 'uk',
                    	    46: 'be',
                    	    47: 'uz',
                    	    48: 'kk',
                    	    49: 'az-Cyrl',
                    	    50: 'az-Arab',
                    	    51: 'hy',
                    	    52: 'ka',
                    	    53: 'mo',
                    	    54: 'ky',
                    	    55: 'tg',
                    	    56: 'tk',
                    	    57: 'mn-CN',
                    	    58: 'mn',
                    	    59: 'ps',
                    	    60: 'ks',
                    	    61: 'ku',
                    	    62: 'sd',
                    	    63: 'bo',
                    	    64: 'ne',
                    	    65: 'sa',
                    	    66: 'mr',
                    	    67: 'bn',
                    	    68: 'as',
                    	    69: 'gu',
                    	    70: 'pa',
                    	    71: 'or',
                    	    72: 'ml',
                    	    73: 'kn',
                    	    74: 'ta',
                    	    75: 'te',
                    	    76: 'si',
                    	    77: 'my',
                    	    78: 'km',
                    	    79: 'lo',
                    	    80: 'vi',
                    	    81: 'id',
                    	    82: 'tl',
                    	    83: 'ms',
                    	    84: 'ms-Arab',
                    	    85: 'am',
                    	    86: 'ti',
                    	    87: 'om',
                    	    88: 'so',
                    	    89: 'sw',
                    	    90: 'rw',
                    	    91: 'rn',
                    	    92: 'ny',
                    	    93: 'mg',
                    	    94: 'eo',
                    	    128: 'cy',
                    	    129: 'eu',
                    	    130: 'ca',
                    	    131: 'la',
                    	    132: 'qu',
                    	    133: 'gn',
                    	    134: 'ay',
                    	    135: 'tt',
                    	    136: 'ug',
                    	    137: 'dz',
                    	    138: 'jv',
                    	    139: 'su',
                    	    140: 'gl',
                    	    141: 'af',
                    	    142: 'br',
                    	    143: 'iu',
                    	    144: 'gd',
                    	    145: 'gv',
                    	    146: 'ga',
                    	    147: 'to',
                    	    148: 'el-polyton',
                    	    149: 'kl',
                    	    150: 'az',
                    	    151: 'nn'
                    	};
                    
                    	// MacOS language ID → MacOS script ID
                    	//
                    	// Note that the script ID is not sufficient to determine what encoding
                    	// to use in TrueType files. For some languages, MacOS used a modification
                    	// of a mainstream script. For example, an Icelandic name would be stored
                    	// with smRoman in the TrueType naming table, but the actual encoding
                    	// is a special Icelandic version of the normal Macintosh Roman encoding.
                    	// As another example, Inuktitut uses an 8-bit encoding for Canadian Aboriginal
                    	// Syllables but MacOS had run out of available script codes, so this was
                    	// done as a (pretty radical) "modification" of Ethiopic.
                    	//
                    	// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
                    	var macLanguageToScript = {
                    	    0: 0,  // langEnglish → smRoman
                    	    1: 0,  // langFrench → smRoman
                    	    2: 0,  // langGerman → smRoman
                    	    3: 0,  // langItalian → smRoman
                    	    4: 0,  // langDutch → smRoman
                    	    5: 0,  // langSwedish → smRoman
                    	    6: 0,  // langSpanish → smRoman
                    	    7: 0,  // langDanish → smRoman
                    	    8: 0,  // langPortuguese → smRoman
                    	    9: 0,  // langNorwegian → smRoman
                    	    10: 5,  // langHebrew → smHebrew
                    	    11: 1,  // langJapanese → smJapanese
                    	    12: 4,  // langArabic → smArabic
                    	    13: 0,  // langFinnish → smRoman
                    	    14: 6,  // langGreek → smGreek
                    	    15: 0,  // langIcelandic → smRoman (modified)
                    	    16: 0,  // langMaltese → smRoman
                    	    17: 0,  // langTurkish → smRoman (modified)
                    	    18: 0,  // langCroatian → smRoman (modified)
                    	    19: 2,  // langTradChinese → smTradChinese
                    	    20: 4,  // langUrdu → smArabic
                    	    21: 9,  // langHindi → smDevanagari
                    	    22: 21,  // langThai → smThai
                    	    23: 3,  // langKorean → smKorean
                    	    24: 29,  // langLithuanian → smCentralEuroRoman
                    	    25: 29,  // langPolish → smCentralEuroRoman
                    	    26: 29,  // langHungarian → smCentralEuroRoman
                    	    27: 29,  // langEstonian → smCentralEuroRoman
                    	    28: 29,  // langLatvian → smCentralEuroRoman
                    	    29: 0,  // langSami → smRoman
                    	    30: 0,  // langFaroese → smRoman (modified)
                    	    31: 4,  // langFarsi → smArabic (modified)
                    	    32: 7,  // langRussian → smCyrillic
                    	    33: 25,  // langSimpChinese → smSimpChinese
                    	    34: 0,  // langFlemish → smRoman
                    	    35: 0,  // langIrishGaelic → smRoman (modified)
                    	    36: 0,  // langAlbanian → smRoman
                    	    37: 0,  // langRomanian → smRoman (modified)
                    	    38: 29,  // langCzech → smCentralEuroRoman
                    	    39: 29,  // langSlovak → smCentralEuroRoman
                    	    40: 0,  // langSlovenian → smRoman (modified)
                    	    41: 5,  // langYiddish → smHebrew
                    	    42: 7,  // langSerbian → smCyrillic
                    	    43: 7,  // langMacedonian → smCyrillic
                    	    44: 7,  // langBulgarian → smCyrillic
                    	    45: 7,  // langUkrainian → smCyrillic (modified)
                    	    46: 7,  // langByelorussian → smCyrillic
                    	    47: 7,  // langUzbek → smCyrillic
                    	    48: 7,  // langKazakh → smCyrillic
                    	    49: 7,  // langAzerbaijani → smCyrillic
                    	    50: 4,  // langAzerbaijanAr → smArabic
                    	    51: 24,  // langArmenian → smArmenian
                    	    52: 23,  // langGeorgian → smGeorgian
                    	    53: 7,  // langMoldavian → smCyrillic
                    	    54: 7,  // langKirghiz → smCyrillic
                    	    55: 7,  // langTajiki → smCyrillic
                    	    56: 7,  // langTurkmen → smCyrillic
                    	    57: 27,  // langMongolian → smMongolian
                    	    58: 7,  // langMongolianCyr → smCyrillic
                    	    59: 4,  // langPashto → smArabic
                    	    60: 4,  // langKurdish → smArabic
                    	    61: 4,  // langKashmiri → smArabic
                    	    62: 4,  // langSindhi → smArabic
                    	    63: 26,  // langTibetan → smTibetan
                    	    64: 9,  // langNepali → smDevanagari
                    	    65: 9,  // langSanskrit → smDevanagari
                    	    66: 9,  // langMarathi → smDevanagari
                    	    67: 13,  // langBengali → smBengali
                    	    68: 13,  // langAssamese → smBengali
                    	    69: 11,  // langGujarati → smGujarati
                    	    70: 10,  // langPunjabi → smGurmukhi
                    	    71: 12,  // langOriya → smOriya
                    	    72: 17,  // langMalayalam → smMalayalam
                    	    73: 16,  // langKannada → smKannada
                    	    74: 14,  // langTamil → smTamil
                    	    75: 15,  // langTelugu → smTelugu
                    	    76: 18,  // langSinhalese → smSinhalese
                    	    77: 19,  // langBurmese → smBurmese
                    	    78: 20,  // langKhmer → smKhmer
                    	    79: 22,  // langLao → smLao
                    	    80: 30,  // langVietnamese → smVietnamese
                    	    81: 0,  // langIndonesian → smRoman
                    	    82: 0,  // langTagalog → smRoman
                    	    83: 0,  // langMalayRoman → smRoman
                    	    84: 4,  // langMalayArabic → smArabic
                    	    85: 28,  // langAmharic → smEthiopic
                    	    86: 28,  // langTigrinya → smEthiopic
                    	    87: 28,  // langOromo → smEthiopic
                    	    88: 0,  // langSomali → smRoman
                    	    89: 0,  // langSwahili → smRoman
                    	    90: 0,  // langKinyarwanda → smRoman
                    	    91: 0,  // langRundi → smRoman
                    	    92: 0,  // langNyanja → smRoman
                    	    93: 0,  // langMalagasy → smRoman
                    	    94: 0,  // langEsperanto → smRoman
                    	    128: 0,  // langWelsh → smRoman (modified)
                    	    129: 0,  // langBasque → smRoman
                    	    130: 0,  // langCatalan → smRoman
                    	    131: 0,  // langLatin → smRoman
                    	    132: 0,  // langQuechua → smRoman
                    	    133: 0,  // langGuarani → smRoman
                    	    134: 0,  // langAymara → smRoman
                    	    135: 7,  // langTatar → smCyrillic
                    	    136: 4,  // langUighur → smArabic
                    	    137: 26,  // langDzongkha → smTibetan
                    	    138: 0,  // langJavaneseRom → smRoman
                    	    139: 0,  // langSundaneseRom → smRoman
                    	    140: 0,  // langGalician → smRoman
                    	    141: 0,  // langAfrikaans → smRoman
                    	    142: 0,  // langBreton → smRoman (modified)
                    	    143: 28,  // langInuktitut → smEthiopic (modified)
                    	    144: 0,  // langScottishGaelic → smRoman (modified)
                    	    145: 0,  // langManxGaelic → smRoman (modified)
                    	    146: 0,  // langIrishGaelicScript → smRoman (modified)
                    	    147: 0,  // langTongan → smRoman
                    	    148: 6,  // langGreekAncient → smRoman
                    	    149: 0,  // langGreenlandic → smRoman
                    	    150: 0,  // langAzerbaijanRoman → smRoman
                    	    151: 0   // langNynorsk → smRoman
                    	};
                    
                    	// While Microsoft indicates a region/country for all its language
                    	// IDs, we omit the region code if it's equal to the "most likely
                    	// region subtag" according to Unicode CLDR. For scripts, we omit
                    	// the subtag if it is equal to the Suppress-Script entry in the
                    	// IANA language subtag registry for IETF BCP 47.
                    	//
                    	// For example, Microsoft states that its language code 0x041A is
                    	// Croatian in Croatia. We transform this to the BCP 47 language code 'hr'
                    	// and not 'hr-HR' because Croatia is the default country for Croatian,
                    	// according to Unicode CLDR. As another example, Microsoft states
                    	// that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform
                    	// this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script
                    	// for the Croatian language, according to IANA.
                    	//
                    	// http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html
                    	// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry
                    	var windowsLanguages = {
                    	    0x0436: 'af',
                    	    0x041C: 'sq',
                    	    0x0484: 'gsw',
                    	    0x045E: 'am',
                    	    0x1401: 'ar-DZ',
                    	    0x3C01: 'ar-BH',
                    	    0x0C01: 'ar',
                    	    0x0801: 'ar-IQ',
                    	    0x2C01: 'ar-JO',
                    	    0x3401: 'ar-KW',
                    	    0x3001: 'ar-LB',
                    	    0x1001: 'ar-LY',
                    	    0x1801: 'ary',
                    	    0x2001: 'ar-OM',
                    	    0x4001: 'ar-QA',
                    	    0x0401: 'ar-SA',
                    	    0x2801: 'ar-SY',
                    	    0x1C01: 'aeb',
                    	    0x3801: 'ar-AE',
                    	    0x2401: 'ar-YE',
                    	    0x042B: 'hy',
                    	    0x044D: 'as',
                    	    0x082C: 'az-Cyrl',
                    	    0x042C: 'az',
                    	    0x046D: 'ba',
                    	    0x042D: 'eu',
                    	    0x0423: 'be',
                    	    0x0845: 'bn',
                    	    0x0445: 'bn-IN',
                    	    0x201A: 'bs-Cyrl',
                    	    0x141A: 'bs',
                    	    0x047E: 'br',
                    	    0x0402: 'bg',
                    	    0x0403: 'ca',
                    	    0x0C04: 'zh-HK',
                    	    0x1404: 'zh-MO',
                    	    0x0804: 'zh',
                    	    0x1004: 'zh-SG',
                    	    0x0404: 'zh-TW',
                    	    0x0483: 'co',
                    	    0x041A: 'hr',
                    	    0x101A: 'hr-BA',
                    	    0x0405: 'cs',
                    	    0x0406: 'da',
                    	    0x048C: 'prs',
                    	    0x0465: 'dv',
                    	    0x0813: 'nl-BE',
                    	    0x0413: 'nl',
                    	    0x0C09: 'en-AU',
                    	    0x2809: 'en-BZ',
                    	    0x1009: 'en-CA',
                    	    0x2409: 'en-029',
                    	    0x4009: 'en-IN',
                    	    0x1809: 'en-IE',
                    	    0x2009: 'en-JM',
                    	    0x4409: 'en-MY',
                    	    0x1409: 'en-NZ',
                    	    0x3409: 'en-PH',
                    	    0x4809: 'en-SG',
                    	    0x1C09: 'en-ZA',
                    	    0x2C09: 'en-TT',
                    	    0x0809: 'en-GB',
                    	    0x0409: 'en',
                    	    0x3009: 'en-ZW',
                    	    0x0425: 'et',
                    	    0x0438: 'fo',
                    	    0x0464: 'fil',
                    	    0x040B: 'fi',
                    	    0x080C: 'fr-BE',
                    	    0x0C0C: 'fr-CA',
                    	    0x040C: 'fr',
                    	    0x140C: 'fr-LU',
                    	    0x180C: 'fr-MC',
                    	    0x100C: 'fr-CH',
                    	    0x0462: 'fy',
                    	    0x0456: 'gl',
                    	    0x0437: 'ka',
                    	    0x0C07: 'de-AT',
                    	    0x0407: 'de',
                    	    0x1407: 'de-LI',
                    	    0x1007: 'de-LU',
                    	    0x0807: 'de-CH',
                    	    0x0408: 'el',
                    	    0x046F: 'kl',
                    	    0x0447: 'gu',
                    	    0x0468: 'ha',
                    	    0x040D: 'he',
                    	    0x0439: 'hi',
                    	    0x040E: 'hu',
                    	    0x040F: 'is',
                    	    0x0470: 'ig',
                    	    0x0421: 'id',
                    	    0x045D: 'iu',
                    	    0x085D: 'iu-Latn',
                    	    0x083C: 'ga',
                    	    0x0434: 'xh',
                    	    0x0435: 'zu',
                    	    0x0410: 'it',
                    	    0x0810: 'it-CH',
                    	    0x0411: 'ja',
                    	    0x044B: 'kn',
                    	    0x043F: 'kk',
                    	    0x0453: 'km',
                    	    0x0486: 'quc',
                    	    0x0487: 'rw',
                    	    0x0441: 'sw',
                    	    0x0457: 'kok',
                    	    0x0412: 'ko',
                    	    0x0440: 'ky',
                    	    0x0454: 'lo',
                    	    0x0426: 'lv',
                    	    0x0427: 'lt',
                    	    0x082E: 'dsb',
                    	    0x046E: 'lb',
                    	    0x042F: 'mk',
                    	    0x083E: 'ms-BN',
                    	    0x043E: 'ms',
                    	    0x044C: 'ml',
                    	    0x043A: 'mt',
                    	    0x0481: 'mi',
                    	    0x047A: 'arn',
                    	    0x044E: 'mr',
                    	    0x047C: 'moh',
                    	    0x0450: 'mn',
                    	    0x0850: 'mn-CN',
                    	    0x0461: 'ne',
                    	    0x0414: 'nb',
                    	    0x0814: 'nn',
                    	    0x0482: 'oc',
                    	    0x0448: 'or',
                    	    0x0463: 'ps',
                    	    0x0415: 'pl',
                    	    0x0416: 'pt',
                    	    0x0816: 'pt-PT',
                    	    0x0446: 'pa',
                    	    0x046B: 'qu-BO',
                    	    0x086B: 'qu-EC',
                    	    0x0C6B: 'qu',
                    	    0x0418: 'ro',
                    	    0x0417: 'rm',
                    	    0x0419: 'ru',
                    	    0x243B: 'smn',
                    	    0x103B: 'smj-NO',
                    	    0x143B: 'smj',
                    	    0x0C3B: 'se-FI',
                    	    0x043B: 'se',
                    	    0x083B: 'se-SE',
                    	    0x203B: 'sms',
                    	    0x183B: 'sma-NO',
                    	    0x1C3B: 'sms',
                    	    0x044F: 'sa',
                    	    0x1C1A: 'sr-Cyrl-BA',
                    	    0x0C1A: 'sr',
                    	    0x181A: 'sr-Latn-BA',
                    	    0x081A: 'sr-Latn',
                    	    0x046C: 'nso',
                    	    0x0432: 'tn',
                    	    0x045B: 'si',
                    	    0x041B: 'sk',
                    	    0x0424: 'sl',
                    	    0x2C0A: 'es-AR',
                    	    0x400A: 'es-BO',
                    	    0x340A: 'es-CL',
                    	    0x240A: 'es-CO',
                    	    0x140A: 'es-CR',
                    	    0x1C0A: 'es-DO',
                    	    0x300A: 'es-EC',
                    	    0x440A: 'es-SV',
                    	    0x100A: 'es-GT',
                    	    0x480A: 'es-HN',
                    	    0x080A: 'es-MX',
                    	    0x4C0A: 'es-NI',
                    	    0x180A: 'es-PA',
                    	    0x3C0A: 'es-PY',
                    	    0x280A: 'es-PE',
                    	    0x500A: 'es-PR',
                    
                    	    // Microsoft has defined two different language codes for
                    	    // “Spanish with modern sorting” and “Spanish with traditional
                    	    // sorting”. This makes sense for collation APIs, and it would be
                    	    // possible to express this in BCP 47 language tags via Unicode
                    	    // extensions (eg., es-u-co-trad is Spanish with traditional
                    	    // sorting). However, for storing names in fonts, the distinction
                    	    // does not make sense, so we give “es” in both cases.
                    	    0x0C0A: 'es',
                    	    0x040A: 'es',
                    
                    	    0x540A: 'es-US',
                    	    0x380A: 'es-UY',
                    	    0x200A: 'es-VE',
                    	    0x081D: 'sv-FI',
                    	    0x041D: 'sv',
                    	    0x045A: 'syr',
                    	    0x0428: 'tg',
                    	    0x085F: 'tzm',
                    	    0x0449: 'ta',
                    	    0x0444: 'tt',
                    	    0x044A: 'te',
                    	    0x041E: 'th',
                    	    0x0451: 'bo',
                    	    0x041F: 'tr',
                    	    0x0442: 'tk',
                    	    0x0480: 'ug',
                    	    0x0422: 'uk',
                    	    0x042E: 'hsb',
                    	    0x0420: 'ur',
                    	    0x0843: 'uz-Cyrl',
                    	    0x0443: 'uz',
                    	    0x042A: 'vi',
                    	    0x0452: 'cy',
                    	    0x0488: 'wo',
                    	    0x0485: 'sah',
                    	    0x0478: 'ii',
                    	    0x046A: 'yo'
                    	};
                    
                    	// Returns a IETF BCP 47 language code, for example 'zh-Hant'
                    	// for 'Chinese in the traditional script'.
                    	function getLanguageCode(platformID, languageID, ltag) {
                    	    switch (platformID) {
                    	        case 0:  // Unicode
                    	            if (languageID === 0xFFFF) {
                    	                return 'und';
                    	            } else if (ltag) {
                    	                return ltag[languageID];
                    	            }
                    
                    	            break;
                    
                    	        case 1:  // Macintosh
                    	            return macLanguages[languageID];
                    
                    	        case 3:  // Windows
                    	            return windowsLanguages[languageID];
                    	    }
                    
                    	    return undefined;
                    	}
                    
                    	var utf16 = 'utf-16';
                    
                    	// MacOS script ID → encoding. This table stores the default case,
                    	// which can be overridden by macLanguageEncodings.
                    	var macScriptEncodings = {
                    	    0: 'macintosh',           // smRoman
                    	    1: 'x-mac-japanese',      // smJapanese
                    	    2: 'x-mac-chinesetrad',   // smTradChinese
                    	    3: 'x-mac-korean',        // smKorean
                    	    6: 'x-mac-greek',         // smGreek
                    	    7: 'x-mac-cyrillic',      // smCyrillic
                    	    9: 'x-mac-devanagai',     // smDevanagari
                    	    10: 'x-mac-gurmukhi',     // smGurmukhi
                    	    11: 'x-mac-gujarati',     // smGujarati
                    	    12: 'x-mac-oriya',        // smOriya
                    	    13: 'x-mac-bengali',      // smBengali
                    	    14: 'x-mac-tamil',        // smTamil
                    	    15: 'x-mac-telugu',       // smTelugu
                    	    16: 'x-mac-kannada',      // smKannada
                    	    17: 'x-mac-malayalam',    // smMalayalam
                    	    18: 'x-mac-sinhalese',    // smSinhalese
                    	    19: 'x-mac-burmese',      // smBurmese
                    	    20: 'x-mac-khmer',        // smKhmer
                    	    21: 'x-mac-thai',         // smThai
                    	    22: 'x-mac-lao',          // smLao
                    	    23: 'x-mac-georgian',     // smGeorgian
                    	    24: 'x-mac-armenian',     // smArmenian
                    	    25: 'x-mac-chinesesimp',  // smSimpChinese
                    	    26: 'x-mac-tibetan',      // smTibetan
                    	    27: 'x-mac-mongolian',    // smMongolian
                    	    28: 'x-mac-ethiopic',     // smEthiopic
                    	    29: 'x-mac-ce',           // smCentralEuroRoman
                    	    30: 'x-mac-vietnamese',   // smVietnamese
                    	    31: 'x-mac-extarabic'     // smExtArabic
                    	};
                    
                    	// MacOS language ID → encoding. This table stores the exceptional
                    	// cases, which override macScriptEncodings. For writing MacOS naming
                    	// tables, we need to emit a MacOS script ID. Therefore, we cannot
                    	// merge macScriptEncodings into macLanguageEncodings.
                    	//
                    	// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
                    	var macLanguageEncodings = {
                    	    15: 'x-mac-icelandic',    // langIcelandic
                    	    17: 'x-mac-turkish',      // langTurkish
                    	    18: 'x-mac-croatian',     // langCroatian
                    	    24: 'x-mac-ce',           // langLithuanian
                    	    25: 'x-mac-ce',           // langPolish
                    	    26: 'x-mac-ce',           // langHungarian
                    	    27: 'x-mac-ce',           // langEstonian
                    	    28: 'x-mac-ce',           // langLatvian
                    	    30: 'x-mac-icelandic',    // langFaroese
                    	    37: 'x-mac-romanian',     // langRomanian
                    	    38: 'x-mac-ce',           // langCzech
                    	    39: 'x-mac-ce',           // langSlovak
                    	    40: 'x-mac-ce',           // langSlovenian
                    	    143: 'x-mac-inuit',       // langInuktitut
                    	    146: 'x-mac-gaelic'       // langIrishGaelicScript
                    	};
                    
                    	function getEncoding(platformID, encodingID, languageID) {
                    	    switch (platformID) {
                    	        case 0:  // Unicode
                    	            return utf16;
                    
                    	        case 1:  // Apple Macintosh
                    	            return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];
                    
                    	        case 3:  // Microsoft Windows
                    	            if (encodingID === 1 || encodingID === 10) {
                    	                return utf16;
                    	            }
                    
                    	            break;
                    	    }
                    
                    	    return undefined;
                    	}
                    
                    	// Parse the naming `name` table.
                    	// FIXME: Format 1 additional fields are not supported yet.
                    	// ltag is the content of the `ltag' table, such as ['en', 'zh-Hans', 'de-CH-1904'].
                    	function parseNameTable(data, start, ltag) {
                    	    var name = {};
                    	    var p = new parse.Parser(data, start);
                    	    var format = p.parseUShort();
                    	    var count = p.parseUShort();
                    	    var stringOffset = p.offset + p.parseUShort();
                    	    for (var i = 0; i < count; i++) {
                    	        var platformID = p.parseUShort();
                    	        var encodingID = p.parseUShort();
                    	        var languageID = p.parseUShort();
                    	        var nameID = p.parseUShort();
                    	        var property = nameTableNames[nameID] || nameID;
                    	        var byteLength = p.parseUShort();
                    	        var offset = p.parseUShort();
                    	        var language = getLanguageCode(platformID, languageID, ltag);
                    	        var encoding = getEncoding(platformID, encodingID, languageID);
                    	        if (encoding !== undefined && language !== undefined) {
                    	            var text = (void 0);
                    	            if (encoding === utf16) {
                    	                text = decode.UTF16(data, stringOffset + offset, byteLength);
                    	            } else {
                    	                text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);
                    	            }
                    
                    	            if (text) {
                    	                var translations = name[property];
                    	                if (translations === undefined) {
                    	                    translations = name[property] = {};
                    	                }
                    
                    	                translations[language] = text;
                    	            }
                    	        }
                    	    }
                    
                    	    var langTagCount = 0;
                    	    if (format === 1) {
                    	        // FIXME: Also handle Microsoft's 'name' table 1.
                    	        langTagCount = p.parseUShort();
                    	    }
                    
                    	    return name;
                    	}
                    
                    	// {23: 'foo'} → {'foo': 23}
                    	// ['bar', 'baz'] → {'bar': 0, 'baz': 1}
                    	function reverseDict(dict) {
                    	    var result = {};
                    	    for (var key in dict) {
                    	        result[dict[key]] = parseInt(key);
                    	    }
                    
                    	    return result;
                    	}
                    
                    	function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
                    	    return new table.Record('NameRecord', [
                    	        {name: 'platformID', type: 'USHORT', value: platformID},
                    	        {name: 'encodingID', type: 'USHORT', value: encodingID},
                    	        {name: 'languageID', type: 'USHORT', value: languageID},
                    	        {name: 'nameID', type: 'USHORT', value: nameID},
                    	        {name: 'length', type: 'USHORT', value: length},
                    	        {name: 'offset', type: 'USHORT', value: offset}
                    	    ]);
                    	}
                    
                    	// Finds the position of needle in haystack, or -1 if not there.
                    	// Like String.indexOf(), but for arrays.
                    	function findSubArray(needle, haystack) {
                    	    var needleLength = needle.length;
                    	    var limit = haystack.length - needleLength + 1;
                    
                    	    loop:
                    	    for (var pos = 0; pos < limit; pos++) {
                    	        // for (; pos < limit; pos++) {
                    	            for (var k = 0; k < needleLength; k++) {
                    	                if (haystack[pos + k] !== needle[k]) {
                    	                    continue loop;
                    	                }
                    	            }
                    
                    	            return pos;
                    	        // }
                    	    }
                    
                    	    return -1;
                    	}
                    
                    	function addStringToPool(s, pool) {
                    	    var offset = findSubArray(s, pool);
                    	    if (offset < 0) {
                    	        offset = pool.length;
                    	        var i = 0;
                    	        var len = s.length;
                    	        for (; i < len; ++i) {
                    	            pool.push(s[i]);
                    	        }
                    
                    	    }
                    
                    	    return offset;
                    	}
                    
                    	function makeNameTable(names, ltag) {
                    	    var nameID;
                    	    var nameIDs = [];
                    
                    	    var namesWithNumericKeys = {};
                    	    var nameTableIds = reverseDict(nameTableNames);
                    	    for (var key in names) {
                    	        var id = nameTableIds[key];
                    	        if (id === undefined) {
                    	            id = key;
                    	        }
                    
                    	        nameID = parseInt(id);
                    
                    	        if (isNaN(nameID)) {
                    	            throw new Error('Name table entry "' + key + '" does not exist, see nameTableNames for complete list.');
                    	        }
                    
                    	        namesWithNumericKeys[nameID] = names[key];
                    	        nameIDs.push(nameID);
                    	    }
                    
                    	    var macLanguageIds = reverseDict(macLanguages);
                    	    var windowsLanguageIds = reverseDict(windowsLanguages);
                    
                    	    var nameRecords = [];
                    	    var stringPool = [];
                    
                    	    for (var i = 0; i < nameIDs.length; i++) {
                    	        nameID = nameIDs[i];
                    	        var translations = namesWithNumericKeys[nameID];
                    	        for (var lang in translations) {
                    	            var text = translations[lang];
                    
                    	            // For MacOS, we try to emit the name in the form that was introduced
                    	            // in the initial version of the TrueType spec (in the late 1980s).
                    	            // However, this can fail for various reasons: the requested BCP 47
                    	            // language code might not have an old-style Mac equivalent;
                    	            // we might not have a codec for the needed character encoding;
                    	            // or the name might contain characters that cannot be expressed
                    	            // in the old-style Macintosh encoding. In case of failure, we emit
                    	            // the name in a more modern fashion (Unicode encoding with BCP 47
                    	            // language tags) that is recognized by MacOS 10.5, released in 2009.
                    	            // If fonts were only read by operating systems, we could simply
                    	            // emit all names in the modern form; this would be much easier.
                    	            // However, there are many applications and libraries that read
                    	            // 'name' tables directly, and these will usually only recognize
                    	            // the ancient form (silently skipping the unrecognized names).
                    	            var macPlatform = 1;  // Macintosh
                    	            var macLanguage = macLanguageIds[lang];
                    	            var macScript = macLanguageToScript[macLanguage];
                    	            var macEncoding = getEncoding(macPlatform, macScript, macLanguage);
                    	            var macName = encode.MACSTRING(text, macEncoding);
                    	            if (macName === undefined) {
                    	                macPlatform = 0;  // Unicode
                    	                macLanguage = ltag.indexOf(lang);
                    	                if (macLanguage < 0) {
                    	                    macLanguage = ltag.length;
                    	                    ltag.push(lang);
                    	                }
                    
                    	                macScript = 4;  // Unicode 2.0 and later
                    	                macName = encode.UTF16(text);
                    	            }
                    
                    	            var macNameOffset = addStringToPool(macName, stringPool);
                    	            nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage,
                    	                                            nameID, macName.length, macNameOffset));
                    
                    	            var winLanguage = windowsLanguageIds[lang];
                    	            if (winLanguage !== undefined) {
                    	                var winName = encode.UTF16(text);
                    	                var winNameOffset = addStringToPool(winName, stringPool);
                    	                nameRecords.push(makeNameRecord(3, 1, winLanguage,
                    	                                                nameID, winName.length, winNameOffset));
                    	            }
                    	        }
                    	    }
                    
                    	    nameRecords.sort(function(a, b) {
                    	        return ((a.platformID - b.platformID) ||
                    	                (a.encodingID - b.encodingID) ||
                    	                (a.languageID - b.languageID) ||
                    	                (a.nameID - b.nameID));
                    	    });
                    
                    	    var t = new table.Table('name', [
                    	        {name: 'format', type: 'USHORT', value: 0},
                    	        {name: 'count', type: 'USHORT', value: nameRecords.length},
                    	        {name: 'stringOffset', type: 'USHORT', value: 6 + nameRecords.length * 12}
                    	    ]);
                    
                    	    for (var r = 0; r < nameRecords.length; r++) {
                    	        t.fields.push({name: 'record_' + r, type: 'RECORD', value: nameRecords[r]});
                    	    }
                    
                    	    t.fields.push({name: 'strings', type: 'LITERAL', value: stringPool});
                    	    return t;
                    	}
                    
                    	var _name = { parse: parseNameTable, make: makeNameTable };
                    
                    	// The `OS/2` table contains metrics required in OpenType fonts.
                    
                    	var unicodeRanges = [
                    	    {begin: 0x0000, end: 0x007F}, // Basic Latin
                    	    {begin: 0x0080, end: 0x00FF}, // Latin-1 Supplement
                    	    {begin: 0x0100, end: 0x017F}, // Latin Extended-A
                    	    {begin: 0x0180, end: 0x024F}, // Latin Extended-B
                    	    {begin: 0x0250, end: 0x02AF}, // IPA Extensions
                    	    {begin: 0x02B0, end: 0x02FF}, // Spacing Modifier Letters
                    	    {begin: 0x0300, end: 0x036F}, // Combining Diacritical Marks
                    	    {begin: 0x0370, end: 0x03FF}, // Greek and Coptic
                    	    {begin: 0x2C80, end: 0x2CFF}, // Coptic
                    	    {begin: 0x0400, end: 0x04FF}, // Cyrillic
                    	    {begin: 0x0530, end: 0x058F}, // Armenian
                    	    {begin: 0x0590, end: 0x05FF}, // Hebrew
                    	    {begin: 0xA500, end: 0xA63F}, // Vai
                    	    {begin: 0x0600, end: 0x06FF}, // Arabic
                    	    {begin: 0x07C0, end: 0x07FF}, // NKo
                    	    {begin: 0x0900, end: 0x097F}, // Devanagari
                    	    {begin: 0x0980, end: 0x09FF}, // Bengali
                    	    {begin: 0x0A00, end: 0x0A7F}, // Gurmukhi
                    	    {begin: 0x0A80, end: 0x0AFF}, // Gujarati
                    	    {begin: 0x0B00, end: 0x0B7F}, // Oriya
                    	    {begin: 0x0B80, end: 0x0BFF}, // Tamil
                    	    {begin: 0x0C00, end: 0x0C7F}, // Telugu
                    	    {begin: 0x0C80, end: 0x0CFF}, // Kannada
                    	    {begin: 0x0D00, end: 0x0D7F}, // Malayalam
                    	    {begin: 0x0E00, end: 0x0E7F}, // Thai
                    	    {begin: 0x0E80, end: 0x0EFF}, // Lao
                    	    {begin: 0x10A0, end: 0x10FF}, // Georgian
                    	    {begin: 0x1B00, end: 0x1B7F}, // Balinese
                    	    {begin: 0x1100, end: 0x11FF}, // Hangul Jamo
                    	    {begin: 0x1E00, end: 0x1EFF}, // Latin Extended Additional
                    	    {begin: 0x1F00, end: 0x1FFF}, // Greek Extended
                    	    {begin: 0x2000, end: 0x206F}, // General Punctuation
                    	    {begin: 0x2070, end: 0x209F}, // Superscripts And Subscripts
                    	    {begin: 0x20A0, end: 0x20CF}, // Currency Symbol
                    	    {begin: 0x20D0, end: 0x20FF}, // Combining Diacritical Marks For Symbols
                    	    {begin: 0x2100, end: 0x214F}, // Letterlike Symbols
                    	    {begin: 0x2150, end: 0x218F}, // Number Forms
                    	    {begin: 0x2190, end: 0x21FF}, // Arrows
                    	    {begin: 0x2200, end: 0x22FF}, // Mathematical Operators
                    	    {begin: 0x2300, end: 0x23FF}, // Miscellaneous Technical
                    	    {begin: 0x2400, end: 0x243F}, // Control Pictures
                    	    {begin: 0x2440, end: 0x245F}, // Optical Character Recognition
                    	    {begin: 0x2460, end: 0x24FF}, // Enclosed Alphanumerics
                    	    {begin: 0x2500, end: 0x257F}, // Box Drawing
                    	    {begin: 0x2580, end: 0x259F}, // Block Elements
                    	    {begin: 0x25A0, end: 0x25FF}, // Geometric Shapes
                    	    {begin: 0x2600, end: 0x26FF}, // Miscellaneous Symbols
                    	    {begin: 0x2700, end: 0x27BF}, // Dingbats
                    	    {begin: 0x3000, end: 0x303F}, // CJK Symbols And Punctuation
                    	    {begin: 0x3040, end: 0x309F}, // Hiragana
                    	    {begin: 0x30A0, end: 0x30FF}, // Katakana
                    	    {begin: 0x3100, end: 0x312F}, // Bopomofo
                    	    {begin: 0x3130, end: 0x318F}, // Hangul Compatibility Jamo
                    	    {begin: 0xA840, end: 0xA87F}, // Phags-pa
                    	    {begin: 0x3200, end: 0x32FF}, // Enclosed CJK Letters And Months
                    	    {begin: 0x3300, end: 0x33FF}, // CJK Compatibility
                    	    {begin: 0xAC00, end: 0xD7AF}, // Hangul Syllables
                    	    {begin: 0xD800, end: 0xDFFF}, // Non-Plane 0 *
                    	    {begin: 0x10900, end: 0x1091F}, // Phoenicia
                    	    {begin: 0x4E00, end: 0x9FFF}, // CJK Unified Ideographs
                    	    {begin: 0xE000, end: 0xF8FF}, // Private Use Area (plane 0)
                    	    {begin: 0x31C0, end: 0x31EF}, // CJK Strokes
                    	    {begin: 0xFB00, end: 0xFB4F}, // Alphabetic Presentation Forms
                    	    {begin: 0xFB50, end: 0xFDFF}, // Arabic Presentation Forms-A
                    	    {begin: 0xFE20, end: 0xFE2F}, // Combining Half Marks
                    	    {begin: 0xFE10, end: 0xFE1F}, // Vertical Forms
                    	    {begin: 0xFE50, end: 0xFE6F}, // Small Form Variants
                    	    {begin: 0xFE70, end: 0xFEFF}, // Arabic Presentation Forms-B
                    	    {begin: 0xFF00, end: 0xFFEF}, // Halfwidth And Fullwidth Forms
                    	    {begin: 0xFFF0, end: 0xFFFF}, // Specials
                    	    {begin: 0x0F00, end: 0x0FFF}, // Tibetan
                    	    {begin: 0x0700, end: 0x074F}, // Syriac
                    	    {begin: 0x0780, end: 0x07BF}, // Thaana
                    	    {begin: 0x0D80, end: 0x0DFF}, // Sinhala
                    	    {begin: 0x1000, end: 0x109F}, // Myanmar
                    	    {begin: 0x1200, end: 0x137F}, // Ethiopic
                    	    {begin: 0x13A0, end: 0x13FF}, // Cherokee
                    	    {begin: 0x1400, end: 0x167F}, // Unified Canadian Aboriginal Syllabics
                    	    {begin: 0x1680, end: 0x169F}, // Ogham
                    	    {begin: 0x16A0, end: 0x16FF}, // Runic
                    	    {begin: 0x1780, end: 0x17FF}, // Khmer
                    	    {begin: 0x1800, end: 0x18AF}, // Mongolian
                    	    {begin: 0x2800, end: 0x28FF}, // Braille Patterns
                    	    {begin: 0xA000, end: 0xA48F}, // Yi Syllables
                    	    {begin: 0x1700, end: 0x171F}, // Tagalog
                    	    {begin: 0x10300, end: 0x1032F}, // Old Italic
                    	    {begin: 0x10330, end: 0x1034F}, // Gothic
                    	    {begin: 0x10400, end: 0x1044F}, // Deseret
                    	    {begin: 0x1D000, end: 0x1D0FF}, // Byzantine Musical Symbols
                    	    {begin: 0x1D400, end: 0x1D7FF}, // Mathematical Alphanumeric Symbols
                    	    {begin: 0xFF000, end: 0xFFFFD}, // Private Use (plane 15)
                    	    {begin: 0xFE00, end: 0xFE0F}, // Variation Selectors
                    	    {begin: 0xE0000, end: 0xE007F}, // Tags
                    	    {begin: 0x1900, end: 0x194F}, // Limbu
                    	    {begin: 0x1950, end: 0x197F}, // Tai Le
                    	    {begin: 0x1980, end: 0x19DF}, // New Tai Lue
                    	    {begin: 0x1A00, end: 0x1A1F}, // Buginese
                    	    {begin: 0x2C00, end: 0x2C5F}, // Glagolitic
                    	    {begin: 0x2D30, end: 0x2D7F}, // Tifinagh
                    	    {begin: 0x4DC0, end: 0x4DFF}, // Yijing Hexagram Symbols
                    	    {begin: 0xA800, end: 0xA82F}, // Syloti Nagri
                    	    {begin: 0x10000, end: 0x1007F}, // Linear B Syllabary
                    	    {begin: 0x10140, end: 0x1018F}, // Ancient Greek Numbers
                    	    {begin: 0x10380, end: 0x1039F}, // Ugaritic
                    	    {begin: 0x103A0, end: 0x103DF}, // Old Persian
                    	    {begin: 0x10450, end: 0x1047F}, // Shavian
                    	    {begin: 0x10480, end: 0x104AF}, // Osmanya
                    	    {begin: 0x10800, end: 0x1083F}, // Cypriot Syllabary
                    	    {begin: 0x10A00, end: 0x10A5F}, // Kharoshthi
                    	    {begin: 0x1D300, end: 0x1D35F}, // Tai Xuan Jing Symbols
                    	    {begin: 0x12000, end: 0x123FF}, // Cuneiform
                    	    {begin: 0x1D360, end: 0x1D37F}, // Counting Rod Numerals
                    	    {begin: 0x1B80, end: 0x1BBF}, // Sundanese
                    	    {begin: 0x1C00, end: 0x1C4F}, // Lepcha
                    	    {begin: 0x1C50, end: 0x1C7F}, // Ol Chiki
                    	    {begin: 0xA880, end: 0xA8DF}, // Saurashtra
                    	    {begin: 0xA900, end: 0xA92F}, // Kayah Li
                    	    {begin: 0xA930, end: 0xA95F}, // Rejang
                    	    {begin: 0xAA00, end: 0xAA5F}, // Cham
                    	    {begin: 0x10190, end: 0x101CF}, // Ancient Symbols
                    	    {begin: 0x101D0, end: 0x101FF}, // Phaistos Disc
                    	    {begin: 0x102A0, end: 0x102DF}, // Carian
                    	    {begin: 0x1F030, end: 0x1F09F}  // Domino Tiles
                    	];
                    
                    	function getUnicodeRange(unicode) {
                    	    for (var i = 0; i < unicodeRanges.length; i += 1) {
                    	        var range = unicodeRanges[i];
                    	        if (unicode >= range.begin && unicode < range.end) {
                    	            return i;
                    	        }
                    	    }
                    
                    	    return -1;
                    	}
                    
                    	// Parse the OS/2 and Windows metrics `OS/2` table
                    	function parseOS2Table(data, start) {
                    	    var os2 = {};
                    	    var p = new parse.Parser(data, start);
                    	    os2.version = p.parseUShort();
                    	    os2.xAvgCharWidth = p.parseShort();
                    	    os2.usWeightClass = p.parseUShort();
                    	    os2.usWidthClass = p.parseUShort();
                    	    os2.fsType = p.parseUShort();
                    	    os2.ySubscriptXSize = p.parseShort();
                    	    os2.ySubscriptYSize = p.parseShort();
                    	    os2.ySubscriptXOffset = p.parseShort();
                    	    os2.ySubscriptYOffset = p.parseShort();
                    	    os2.ySuperscriptXSize = p.parseShort();
                    	    os2.ySuperscriptYSize = p.parseShort();
                    	    os2.ySuperscriptXOffset = p.parseShort();
                    	    os2.ySuperscriptYOffset = p.parseShort();
                    	    os2.yStrikeoutSize = p.parseShort();
                    	    os2.yStrikeoutPosition = p.parseShort();
                    	    os2.sFamilyClass = p.parseShort();
                    	    os2.panose = [];
                    	    for (var i = 0; i < 10; i++) {
                    	        os2.panose[i] = p.parseByte();
                    	    }
                    
                    	    os2.ulUnicodeRange1 = p.parseULong();
                    	    os2.ulUnicodeRange2 = p.parseULong();
                    	    os2.ulUnicodeRange3 = p.parseULong();
                    	    os2.ulUnicodeRange4 = p.parseULong();
                    	    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
                    	    os2.fsSelection = p.parseUShort();
                    	    os2.usFirstCharIndex = p.parseUShort();
                    	    os2.usLastCharIndex = p.parseUShort();
                    	    os2.sTypoAscender = p.parseShort();
                    	    os2.sTypoDescender = p.parseShort();
                    	    os2.sTypoLineGap = p.parseShort();
                    	    os2.usWinAscent = p.parseUShort();
                    	    os2.usWinDescent = p.parseUShort();
                    	    if (os2.version >= 1) {
                    	        os2.ulCodePageRange1 = p.parseULong();
                    	        os2.ulCodePageRange2 = p.parseULong();
                    	    }
                    
                    	    if (os2.version >= 2) {
                    	        os2.sxHeight = p.parseShort();
                    	        os2.sCapHeight = p.parseShort();
                    	        os2.usDefaultChar = p.parseUShort();
                    	        os2.usBreakChar = p.parseUShort();
                    	        os2.usMaxContent = p.parseUShort();
                    	    }
                    
                    	    return os2;
                    	}
                    
                    	function makeOS2Table(options) {
                    	    return new table.Table('OS/2', [
                    	        {name: 'version', type: 'USHORT', value: 0x0003},
                    	        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},
                    	        {name: 'usWeightClass', type: 'USHORT', value: 0},
                    	        {name: 'usWidthClass', type: 'USHORT', value: 0},
                    	        {name: 'fsType', type: 'USHORT', value: 0},
                    	        {name: 'ySubscriptXSize', type: 'SHORT', value: 650},
                    	        {name: 'ySubscriptYSize', type: 'SHORT', value: 699},
                    	        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},
                    	        {name: 'ySubscriptYOffset', type: 'SHORT', value: 140},
                    	        {name: 'ySuperscriptXSize', type: 'SHORT', value: 650},
                    	        {name: 'ySuperscriptYSize', type: 'SHORT', value: 699},
                    	        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},
                    	        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 479},
                    	        {name: 'yStrikeoutSize', type: 'SHORT', value: 49},
                    	        {name: 'yStrikeoutPosition', type: 'SHORT', value: 258},
                    	        {name: 'sFamilyClass', type: 'SHORT', value: 0},
                    	        {name: 'bFamilyType', type: 'BYTE', value: 0},
                    	        {name: 'bSerifStyle', type: 'BYTE', value: 0},
                    	        {name: 'bWeight', type: 'BYTE', value: 0},
                    	        {name: 'bProportion', type: 'BYTE', value: 0},
                    	        {name: 'bContrast', type: 'BYTE', value: 0},
                    	        {name: 'bStrokeVariation', type: 'BYTE', value: 0},
                    	        {name: 'bArmStyle', type: 'BYTE', value: 0},
                    	        {name: 'bLetterform', type: 'BYTE', value: 0},
                    	        {name: 'bMidline', type: 'BYTE', value: 0},
                    	        {name: 'bXHeight', type: 'BYTE', value: 0},
                    	        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},
                    	        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},
                    	        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},
                    	        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},
                    	        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},
                    	        {name: 'fsSelection', type: 'USHORT', value: 0},
                    	        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},
                    	        {name: 'usLastCharIndex', type: 'USHORT', value: 0},
                    	        {name: 'sTypoAscender', type: 'SHORT', value: 0},
                    	        {name: 'sTypoDescender', type: 'SHORT', value: 0},
                    	        {name: 'sTypoLineGap', type: 'SHORT', value: 0},
                    	        {name: 'usWinAscent', type: 'USHORT', value: 0},
                    	        {name: 'usWinDescent', type: 'USHORT', value: 0},
                    	        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},
                    	        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},
                    	        {name: 'sxHeight', type: 'SHORT', value: 0},
                    	        {name: 'sCapHeight', type: 'SHORT', value: 0},
                    	        {name: 'usDefaultChar', type: 'USHORT', value: 0},
                    	        {name: 'usBreakChar', type: 'USHORT', value: 0},
                    	        {name: 'usMaxContext', type: 'USHORT', value: 0}
                    	    ], options);
                    	}
                    
                    	var os2 = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges: unicodeRanges, getUnicodeRange: getUnicodeRange };
                    
                    	// The `post` table stores additional PostScript information, such as glyph names.
                    
                    	// Parse the PostScript `post` table
                    	function parsePostTable(data, start) {
                    	    var post = {};
                    	    var p = new parse.Parser(data, start);
                    	    post.version = p.parseVersion();
                    	    post.italicAngle = p.parseFixed();
                    	    post.underlinePosition = p.parseShort();
                    	    post.underlineThickness = p.parseShort();
                    	    post.isFixedPitch = p.parseULong();
                    	    post.minMemType42 = p.parseULong();
                    	    post.maxMemType42 = p.parseULong();
                    	    post.minMemType1 = p.parseULong();
                    	    post.maxMemType1 = p.parseULong();
                    	    switch (post.version) {
                    	        case 1:
                    	            post.names = standardNames.slice();
                    	            break;
                    	        case 2:
                    	            post.numberOfGlyphs = p.parseUShort();
                    	            post.glyphNameIndex = new Array(post.numberOfGlyphs);
                    	            for (var i = 0; i < post.numberOfGlyphs; i++) {
                    	                post.glyphNameIndex[i] = p.parseUShort();
                    	            }
                    
                    	            post.names = [];
                    	            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {
                    	                if (post.glyphNameIndex[i$1] >= standardNames.length) {
                    	                    var nameLength = p.parseChar();
                    	                    post.names.push(p.parseString(nameLength));
                    	                }
                    	            }
                    
                    	            break;
                    	        case 2.5:
                    	            post.numberOfGlyphs = p.parseUShort();
                    	            post.offset = new Array(post.numberOfGlyphs);
                    	            for (var i$2 = 0; i$2 < post.numberOfGlyphs; i$2++) {
                    	                post.offset[i$2] = p.parseChar();
                    	            }
                    
                    	            break;
                    	    }
                    	    return post;
                    	}
                    
                    	function makePostTable() {
                    	    return new table.Table('post', [
                    	        {name: 'version', type: 'FIXED', value: 0x00030000},
                    	        {name: 'italicAngle', type: 'FIXED', value: 0},
                    	        {name: 'underlinePosition', type: 'FWORD', value: 0},
                    	        {name: 'underlineThickness', type: 'FWORD', value: 0},
                    	        {name: 'isFixedPitch', type: 'ULONG', value: 0},
                    	        {name: 'minMemType42', type: 'ULONG', value: 0},
                    	        {name: 'maxMemType42', type: 'ULONG', value: 0},
                    	        {name: 'minMemType1', type: 'ULONG', value: 0},
                    	        {name: 'maxMemType1', type: 'ULONG', value: 0}
                    	    ]);
                    	}
                    
                    	var post = { parse: parsePostTable, make: makePostTable };
                    
                    	// The `GSUB` table contains ligatures, among other things.
                    
                    	var subtableParsers = new Array(9);         // subtableParsers[0] is unused
                    
                    	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS
                    	subtableParsers[1] = function parseLookup1() {
                    	    var start = this.offset + this.relativeOffset;
                    	    var substFormat = this.parseUShort();
                    	    if (substFormat === 1) {
                    	        return {
                    	            substFormat: 1,
                    	            coverage: this.parsePointer(Parser.coverage),
                    	            deltaGlyphId: this.parseUShort()
                    	        };
                    	    } else if (substFormat === 2) {
                    	        return {
                    	            substFormat: 2,
                    	            coverage: this.parsePointer(Parser.coverage),
                    	            substitute: this.parseOffset16List()
                    	        };
                    	    }
                    	    check.assert(false, '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.');
                    	};
                    
                    	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS
                    	subtableParsers[2] = function parseLookup2() {
                    	    var substFormat = this.parseUShort();
                    	    check.argument(substFormat === 1, 'GSUB Multiple Substitution Subtable identifier-format must be 1');
                    	    return {
                    	        substFormat: substFormat,
                    	        coverage: this.parsePointer(Parser.coverage),
                    	        sequences: this.parseListOfLists()
                    	    };
                    	};
                    
                    	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS
                    	subtableParsers[3] = function parseLookup3() {
                    	    var substFormat = this.parseUShort();
                    	    check.argument(substFormat === 1, 'GSUB Alternate Substitution Subtable identifier-format must be 1');
                    	    return {
                    	        substFormat: substFormat,
                    	        coverage: this.parsePointer(Parser.coverage),
                    	        alternateSets: this.parseListOfLists()
                    	    };
                    	};
                    
                    	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS
                    	subtableParsers[4] = function parseLookup4() {
                    	    var substFormat = this.parseUShort();
                    	    check.argument(substFormat === 1, 'GSUB ligature table identifier-format must be 1');
                    	    return {
                    	        substFormat: substFormat,
                    	        coverage: this.parsePointer(Parser.coverage),
                    	        ligatureSets: this.parseListOfLists(function() {
                    	            return {
                    	                ligGlyph: this.parseUShort(),
                    	                components: this.parseUShortList(this.parseUShort() - 1)
                    	            };
                    	        })
                    	    };
                    	};
                    
                    	var lookupRecordDesc = {
                    	    sequenceIndex: Parser.uShort,
                    	    lookupListIndex: Parser.uShort
                    	};
                    
                    	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF
                    	subtableParsers[5] = function parseLookup5() {
                    	    var start = this.offset + this.relativeOffset;
                    	    var substFormat = this.parseUShort();
                    
                    	    if (substFormat === 1) {
                    	        return {
                    	            substFormat: substFormat,
                    	            coverage: this.parsePointer(Parser.coverage),
                    	            ruleSets: this.parseListOfLists(function() {
                    	                var glyphCount = this.parseUShort();
                    	                var substCount = this.parseUShort();
                    	                return {
                    	                    input: this.parseUShortList(glyphCount - 1),
                    	                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
                    	                };
                    	            })
                    	        };
                    	    } else if (substFormat === 2) {
                    	        return {
                    	            substFormat: substFormat,
                    	            coverage: this.parsePointer(Parser.coverage),
                    	            classDef: this.parsePointer(Parser.classDef),
                    	            classSets: this.parseListOfLists(function() {
                    	                var glyphCount = this.parseUShort();
                    	                var substCount = this.parseUShort();
                    	                return {
                    	                    classes: this.parseUShortList(glyphCount - 1),
                    	                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
                    	                };
                    	            })
                    	        };
                    	    } else if (substFormat === 3) {
                    	        var glyphCount = this.parseUShort();
                    	        var substCount = this.parseUShort();
                    	        return {
                    	            substFormat: substFormat,
                    	            coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),
                    	            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
                    	        };
                    	    }
                    	    check.assert(false, '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.');
                    	};
                    
                    	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC
                    	subtableParsers[6] = function parseLookup6() {
                    	    var start = this.offset + this.relativeOffset;
                    	    var substFormat = this.parseUShort();
                    	    if (substFormat === 1) {
                    	        return {
                    	            substFormat: 1,
                    	            coverage: this.parsePointer(Parser.coverage),
                    	            chainRuleSets: this.parseListOfLists(function() {
                    	                return {
                    	                    backtrack: this.parseUShortList(),
                    	                    input: this.parseUShortList(this.parseShort() - 1),
                    	                    lookahead: this.parseUShortList(),
                    	                    lookupRecords: this.parseRecordList(lookupRecordDesc)
                    	                };
                    	            })
                    	        };
                    	    } else if (substFormat === 2) {
                    	        return {
                    	            substFormat: 2,
                    	            coverage: this.parsePointer(Parser.coverage),
                    	            backtrackClassDef: this.parsePointer(Parser.classDef),
                    	            inputClassDef: this.parsePointer(Parser.classDef),
                    	            lookaheadClassDef: this.parsePointer(Parser.classDef),
                    	            chainClassSet: this.parseListOfLists(function() {
                    	                return {
                    	                    backtrack: this.parseUShortList(),
                    	                    input: this.parseUShortList(this.parseShort() - 1),
                    	                    lookahead: this.parseUShortList(),
                    	                    lookupRecords: this.parseRecordList(lookupRecordDesc)
                    	                };
                    	            })
                    	        };
                    	    } else if (substFormat === 3) {
                    	        return {
                    	            substFormat: 3,
                    	            backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
                    	            inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),
                    	            lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
                    	            lookupRecords: this.parseRecordList(lookupRecordDesc)
                    	        };
                    	    }
                    	    check.assert(false, '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.');
                    	};
                    
                    	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES
                    	subtableParsers[7] = function parseLookup7() {
                    	    // Extension Substitution subtable
                    	    var substFormat = this.parseUShort();
                    	    check.argument(substFormat === 1, 'GSUB Extension Substitution subtable identifier-format must be 1');
                    	    var extensionLookupType = this.parseUShort();
                    	    var extensionParser = new Parser(this.data, this.offset + this.parseULong());
                    	    return {
                    	        substFormat: 1,
                    	        lookupType: extensionLookupType,
                    	        extension: subtableParsers[extensionLookupType].call(extensionParser)
                    	    };
                    	};
                    
                    	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS
                    	subtableParsers[8] = function parseLookup8() {
                    	    var substFormat = this.parseUShort();
                    	    check.argument(substFormat === 1, 'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1');
                    	    return {
                    	        substFormat: substFormat,
                    	        coverage: this.parsePointer(Parser.coverage),
                    	        backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
                    	        lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
                    	        substitutes: this.parseUShortList()
                    	    };
                    	};
                    
                    	// https://www.microsoft.com/typography/OTSPEC/gsub.htm
                    	function parseGsubTable(data, start) {
                    	    start = start || 0;
                    	    var p = new Parser(data, start);
                    	    var tableVersion = p.parseVersion(1);
                    	    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GSUB table version.');
                    	    if (tableVersion === 1) {
                    	        return {
                    	            version: tableVersion,
                    	            scripts: p.parseScriptList(),
                    	            features: p.parseFeatureList(),
                    	            lookups: p.parseLookupList(subtableParsers)
                    	        };
                    	    } else {
                    	        return {
                    	            version: tableVersion,
                    	            scripts: p.parseScriptList(),
                    	            features: p.parseFeatureList(),
                    	            lookups: p.parseLookupList(subtableParsers),
                    	            variations: p.parseFeatureVariationsList()
                    	        };
                    	    }
                    
                    	}
                    
                    	// GSUB Writing //////////////////////////////////////////////
                    	var subtableMakers = new Array(9);
                    
                    	subtableMakers[1] = function makeLookup1(subtable) {
                    	    if (subtable.substFormat === 1) {
                    	        return new table.Table('substitutionTable', [
                    	            {name: 'substFormat', type: 'USHORT', value: 1},
                    	            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)},
                    	            {name: 'deltaGlyphID', type: 'USHORT', value: subtable.deltaGlyphId}
                    	        ]);
                    	    } else {
                    	        return new table.Table('substitutionTable', [
                    	            {name: 'substFormat', type: 'USHORT', value: 2},
                    	            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
                    	        ].concat(table.ushortList('substitute', subtable.substitute)));
                    	    }
                    	    // check.fail('Lookup type 1 substFormat must be 1 or 2.');
                    	};
                    
                    	subtableMakers[3] = function makeLookup3(subtable) {
                    	    check.assert(subtable.substFormat === 1, 'Lookup type 3 substFormat must be 1.');
                    	    return new table.Table('substitutionTable', [
                    	        {name: 'substFormat', type: 'USHORT', value: 1},
                    	        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
                    	    ].concat(table.tableList('altSet', subtable.alternateSets, function(alternateSet) {
                    	        return new table.Table('alternateSetTable', table.ushortList('alternate', alternateSet));
                    	    })));
                    	};
                    
                    	subtableMakers[4] = function makeLookup4(subtable) {
                    	    check.assert(subtable.substFormat === 1, 'Lookup type 4 substFormat must be 1.');
                    	    return new table.Table('substitutionTable', [
                    	        {name: 'substFormat', type: 'USHORT', value: 1},
                    	        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
                    	    ].concat(table.tableList('ligSet', subtable.ligatureSets, function(ligatureSet) {
                    	        return new table.Table('ligatureSetTable', table.tableList('ligature', ligatureSet, function(ligature) {
                    	            return new table.Table('ligatureTable',
                    	                [{name: 'ligGlyph', type: 'USHORT', value: ligature.ligGlyph}]
                    	                .concat(table.ushortList('component', ligature.components, ligature.components.length + 1))
                    	            );
                    	        }));
                    	    })));
                    	};
                    
                    	function makeGsubTable(gsub) {
                    	    return new table.Table('GSUB', [
                    	        {name: 'version', type: 'ULONG', value: 0x10000},
                    	        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gsub.scripts)},
                    	        {name: 'features', type: 'TABLE', value: new table.FeatureList(gsub.features)},
                    	        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gsub.lookups, subtableMakers)}
                    	    ]);
                    	}
                    
                    	var gsub = { parse: parseGsubTable, make: makeGsubTable };
                    
                    	// The `GPOS` table contains kerning pairs, among other things.
                    
                    	// Parse the metadata `meta` table.
                    	// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html
                    	function parseMetaTable(data, start) {
                    	    var p = new parse.Parser(data, start);
                    	    var tableVersion = p.parseULong();
                    	    check.argument(tableVersion === 1, 'Unsupported META table version.');
                    	    p.parseULong(); // flags - currently unused and set to 0
                    	    p.parseULong(); // tableOffset
                    	    var numDataMaps = p.parseULong();
                    
                    	    var tags = {};
                    	    for (var i = 0; i < numDataMaps; i++) {
                    	        var tag = p.parseTag();
                    	        var dataOffset = p.parseULong();
                    	        var dataLength = p.parseULong();
                    	        var text = decode.UTF8(data, start + dataOffset, dataLength);
                    
                    	        tags[tag] = text;
                    	    }
                    	    return tags;
                    	}
                    
                    	function makeMetaTable(tags) {
                    	    var numTags = Object.keys(tags).length;
                    	    var stringPool = '';
                    	    var stringPoolOffset = 16 + numTags * 12;
                    
                    	    var result = new table.Table('meta', [
                    	        {name: 'version', type: 'ULONG', value: 1},
                    	        {name: 'flags', type: 'ULONG', value: 0},
                    	        {name: 'offset', type: 'ULONG', value: stringPoolOffset},
                    	        {name: 'numTags', type: 'ULONG', value: numTags}
                    	    ]);
                    
                    	    for (var tag in tags) {
                    	        var pos = stringPool.length;
                    	        stringPool += tags[tag];
                    
                    	        result.fields.push({name: 'tag ' + tag, type: 'TAG', value: tag});
                    	        result.fields.push({name: 'offset ' + tag, type: 'ULONG', value: stringPoolOffset + pos});
                    	        result.fields.push({name: 'length ' + tag, type: 'ULONG', value: tags[tag].length});
                    	    }
                    
                    	    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});
                    
                    	    return result;
                    	}
                    
                    	var meta = { parse: parseMetaTable, make: makeMetaTable };
                    
                    	// The `sfnt` wrapper provides organization for the tables in the font.
                    
                    	function log2(v) {
                    	    return Math.log(v) / Math.log(2) | 0;
                    	}
                    
                    	function computeCheckSum(bytes) {
                    	    while (bytes.length % 4 !== 0) {
                    	        bytes.push(0);
                    	    }
                    
                    	    var sum = 0;
                    	    for (var i = 0; i < bytes.length; i += 4) {
                    	        sum += (bytes[i] << 24) +
                    	            (bytes[i + 1] << 16) +
                    	            (bytes[i + 2] << 8) +
                    	            (bytes[i + 3]);
                    	    }
                    
                    	    sum %= Math.pow(2, 32);
                    	    return sum;
                    	}
                    
                    	function makeTableRecord(tag, checkSum, offset, length) {
                    	    return new table.Record('Table Record', [
                    	        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},
                    	        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},
                    	        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},
                    	        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}
                    	    ]);
                    	}
                    
                    	function makeSfntTable(tables) {
                    	    var sfnt = new table.Table('sfnt', [
                    	        {name: 'version', type: 'TAG', value: 'OTTO'},
                    	        {name: 'numTables', type: 'USHORT', value: 0},
                    	        {name: 'searchRange', type: 'USHORT', value: 0},
                    	        {name: 'entrySelector', type: 'USHORT', value: 0},
                    	        {name: 'rangeShift', type: 'USHORT', value: 0}
                    	    ]);
                    	    sfnt.tables = tables;
                    	    sfnt.numTables = tables.length;
                    	    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));
                    	    sfnt.searchRange = 16 * highestPowerOf2;
                    	    sfnt.entrySelector = log2(highestPowerOf2);
                    	    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;
                    
                    	    var recordFields = [];
                    	    var tableFields = [];
                    
                    	    var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);
                    	    while (offset % 4 !== 0) {
                    	        offset += 1;
                    	        tableFields.push({name: 'padding', type: 'BYTE', value: 0});
                    	    }
                    
                    	    for (var i = 0; i < tables.length; i += 1) {
                    	        var t = tables[i];
                    	        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');
                    	        var tableLength = t.sizeOf();
                    	        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);
                    	        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'RECORD', value: tableRecord});
                    	        tableFields.push({name: t.tableName + ' table', type: 'RECORD', value: t});
                    	        offset += tableLength;
                    	        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');
                    	        while (offset % 4 !== 0) {
                    	            offset += 1;
                    	            tableFields.push({name: 'padding', type: 'BYTE', value: 0});
                    	        }
                    	    }
                    
                    	    // Table records need to be sorted alphabetically.
                    	    recordFields.sort(function(r1, r2) {
                    	        if (r1.value.tag > r2.value.tag) {
                    	            return 1;
                    	        } else {
                    	            return -1;
                    	        }
                    	    });
                    
                    	    sfnt.fields = sfnt.fields.concat(recordFields);
                    	    sfnt.fields = sfnt.fields.concat(tableFields);
                    	    return sfnt;
                    	}
                    
                    	// Get the metrics for a character. If the string has more than one character
                    	// this function returns metrics for the first available character.
                    	// You can provide optional fallback metrics if no characters are available.
                    	function metricsForChar(font, chars, notFoundMetrics) {
                    	    for (var i = 0; i < chars.length; i += 1) {
                    	        var glyphIndex = font.charToGlyphIndex(chars[i]);
                    	        if (glyphIndex > 0) {
                    	            var glyph = font.glyphs.get(glyphIndex);
                    	            return glyph.getMetrics();
                    	        }
                    	    }
                    
                    	    return notFoundMetrics;
                    	}
                    
                    	function average(vs) {
                    	    var sum = 0;
                    	    for (var i = 0; i < vs.length; i += 1) {
                    	        sum += vs[i];
                    	    }
                    
                    	    return sum / vs.length;
                    	}
                    
                    	// Convert the font object to a SFNT data structure.
                    	// This structure contains all the necessary tables and metadata to create a binary OTF file.
                    	function fontToSfntTable(font) {
                    	    var xMins = [];
                    	    var yMins = [];
                    	    var xMaxs = [];
                    	    var yMaxs = [];
                    	    var advanceWidths = [];
                    	    var leftSideBearings = [];
                    	    var rightSideBearings = [];
                    	    var firstCharIndex;
                    	    var lastCharIndex = 0;
                    	    var ulUnicodeRange1 = 0;
                    	    var ulUnicodeRange2 = 0;
                    	    var ulUnicodeRange3 = 0;
                    	    var ulUnicodeRange4 = 0;
                    
                    	    for (var i = 0; i < font.glyphs.length; i += 1) {
                    	        var glyph = font.glyphs.get(i);
                    	        var unicode = glyph.unicode | 0;
                    
                    	        if (isNaN(glyph.advanceWidth)) {
                    	            throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.');
                    	        }
                    
                    	        if (firstCharIndex > unicode || firstCharIndex === undefined) {
                    	            // ignore .notdef char
                    	            if (unicode > 0) {
                    	                firstCharIndex = unicode;
                    	            }
                    	        }
                    
                    	        if (lastCharIndex < unicode) {
                    	            lastCharIndex = unicode;
                    	        }
                    
                    	        var position = os2.getUnicodeRange(unicode);
                    	        if (position < 32) {
                    	            ulUnicodeRange1 |= 1 << position;
                    	        } else if (position < 64) {
                    	            ulUnicodeRange2 |= 1 << position - 32;
                    	        } else if (position < 96) {
                    	            ulUnicodeRange3 |= 1 << position - 64;
                    	        } else if (position < 123) {
                    	            ulUnicodeRange4 |= 1 << position - 96;
                    	        } else {
                    	            throw new Error('Unicode ranges bits > 123 are reserved for internal usage');
                    	        }
                    	        // Skip non-important characters.
                    	        if (glyph.name === '.notdef') { continue; }
                    	        var metrics = glyph.getMetrics();
                    	        xMins.push(metrics.xMin);
                    	        yMins.push(metrics.yMin);
                    	        xMaxs.push(metrics.xMax);
                    	        yMaxs.push(metrics.yMax);
                    	        leftSideBearings.push(metrics.leftSideBearing);
                    	        rightSideBearings.push(metrics.rightSideBearing);
                    	        advanceWidths.push(glyph.advanceWidth);
                    	    }
                    
                    	    var globals = {
                    	        xMin: Math.min.apply(null, xMins),
                    	        yMin: Math.min.apply(null, yMins),
                    	        xMax: Math.max.apply(null, xMaxs),
                    	        yMax: Math.max.apply(null, yMaxs),
                    	        advanceWidthMax: Math.max.apply(null, advanceWidths),
                    	        advanceWidthAvg: average(advanceWidths),
                    	        minLeftSideBearing: Math.min.apply(null, leftSideBearings),
                    	        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
                    	        minRightSideBearing: Math.min.apply(null, rightSideBearings)
                    	    };
                    	    globals.ascender = font.ascender;
                    	    globals.descender = font.descender;
                    
                    	    var headTable = head.make({
                    	        flags: 3, // 00000011 (baseline for font at y=0; left sidebearing point at x=0)
                    	        unitsPerEm: font.unitsPerEm,
                    	        xMin: globals.xMin,
                    	        yMin: globals.yMin,
                    	        xMax: globals.xMax,
                    	        yMax: globals.yMax,
                    	        lowestRecPPEM: 3,
                    	        createdTimestamp: font.createdTimestamp
                    	    });
                    
                    	    var hheaTable = hhea.make({
                    	        ascender: globals.ascender,
                    	        descender: globals.descender,
                    	        advanceWidthMax: globals.advanceWidthMax,
                    	        minLeftSideBearing: globals.minLeftSideBearing,
                    	        minRightSideBearing: globals.minRightSideBearing,
                    	        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
                    	        numberOfHMetrics: font.glyphs.length
                    	    });
                    
                    	    var maxpTable = maxp.make(font.glyphs.length);
                    
                    	    var os2Table = os2.make({
                    	        xAvgCharWidth: Math.round(globals.advanceWidthAvg),
                    	        usWeightClass: font.tables.os2.usWeightClass,
                    	        usWidthClass: font.tables.os2.usWidthClass,
                    	        usFirstCharIndex: firstCharIndex,
                    	        usLastCharIndex: lastCharIndex,
                    	        ulUnicodeRange1: ulUnicodeRange1,
                    	        ulUnicodeRange2: ulUnicodeRange2,
                    	        ulUnicodeRange3: ulUnicodeRange3,
                    	        ulUnicodeRange4: ulUnicodeRange4,
                    	        fsSelection: font.tables.os2.fsSelection, // REGULAR
                    	        // See http://typophile.com/node/13081 for more info on vertical metrics.
                    	        // We get metrics for typical characters (such as "x" for xHeight).
                    	        // We provide some fallback characters if characters are unavailable: their
                    	        // ordering was chosen experimentally.
                    	        sTypoAscender: globals.ascender,
                    	        sTypoDescender: globals.descender,
                    	        sTypoLineGap: 0,
                    	        usWinAscent: globals.yMax,
                    	        usWinDescent: Math.abs(globals.yMin),
                    	        ulCodePageRange1: 1, // FIXME: hard-code Latin 1 support for now
                    	        sxHeight: metricsForChar(font, 'xyvw', {yMax: Math.round(globals.ascender / 2)}).yMax,
                    	        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,
                    	        usDefaultChar: font.hasChar(' ') ? 32 : 0, // Use space as the default character, if available.
                    	        usBreakChar: font.hasChar(' ') ? 32 : 0 // Use space as the break character, if available.
                    	    });
                    
                    	    var hmtxTable = hmtx.make(font.glyphs);
                    	    var cmapTable = cmap.make(font.glyphs);
                    
                    	    var englishFamilyName = font.getEnglishName('fontFamily');
                    	    var englishStyleName = font.getEnglishName('fontSubfamily');
                    	    var englishFullName = englishFamilyName + ' ' + englishStyleName;
                    	    var postScriptName = font.getEnglishName('postScriptName');
                    	    if (!postScriptName) {
                    	        postScriptName = englishFamilyName.replace(/\s/g, '') + '-' + englishStyleName;
                    	    }
                    
                    	    var names = {};
                    	    for (var n in font.names) {
                    	        names[n] = font.names[n];
                    	    }
                    
                    	    if (!names.uniqueID) {
                    	        names.uniqueID = {en: font.getEnglishName('manufacturer') + ':' + englishFullName};
                    	    }
                    
                    	    if (!names.postScriptName) {
                    	        names.postScriptName = {en: postScriptName};
                    	    }
                    
                    	    if (!names.preferredFamily) {
                    	        names.preferredFamily = font.names.fontFamily;
                    	    }
                    
                    	    if (!names.preferredSubfamily) {
                    	        names.preferredSubfamily = font.names.fontSubfamily;
                    	    }
                    
                    	    var languageTags = [];
                    	    var nameTable = _name.make(names, languageTags);
                    	    var ltagTable = (languageTags.length > 0 ? ltag.make(languageTags) : undefined);
                    
                    	    var postTable = post.make();
                    	    var cffTable = cff.make(font.glyphs, {
                    	        version: font.getEnglishName('version'),
                    	        fullName: englishFullName,
                    	        familyName: englishFamilyName,
                    	        weightName: englishStyleName,
                    	        postScriptName: postScriptName,
                    	        unitsPerEm: font.unitsPerEm,
                    	        fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]
                    	    });
                    
                    	    var metaTable = (font.metas && Object.keys(font.metas).length > 0) ? meta.make(font.metas) : undefined;
                    
                    	    // The order does not matter because makeSfntTable() will sort them.
                    	    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];
                    	    if (ltagTable) {
                    	        tables.push(ltagTable);
                    	    }
                    	    // Optional tables
                    	    if (font.tables.gsub) {
                    	        tables.push(gsub.make(font.tables.gsub));
                    	    }
                    	    if (metaTable) {
                    	        tables.push(metaTable);
                    	    }
                    
                    	    var sfntTable = makeSfntTable(tables);
                    
                    	    // Compute the font's checkSum and store it in head.checkSumAdjustment.
                    	    var bytes = sfntTable.encode();
                    	    var checkSum = computeCheckSum(bytes);
                    	    var tableFields = sfntTable.fields;
                    	    var checkSumAdjusted = false;
                    	    for (var i$1 = 0; i$1 < tableFields.length; i$1 += 1) {
                    	        if (tableFields[i$1].name === 'head table') {
                    	            tableFields[i$1].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;
                    	            checkSumAdjusted = true;
                    	            break;
                    	        }
                    	    }
                    
                    	    if (!checkSumAdjusted) {
                    	        throw new Error('Could not find head table with checkSum to adjust.');
                    	    }
                    
                    	    return sfntTable;
                    	}
                    
                    	var sfnt = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum: computeCheckSum };
                    
                    	// The Layout object is the prototype of Substitution objects, and provides
                    
                    	function searchTag(arr, tag) {
                    	    /* jshint bitwise: false */
                    	    var imin = 0;
                    	    var imax = arr.length - 1;
                    	    while (imin <= imax) {
                    	        var imid = (imin + imax) >>> 1;
                    	        var val = arr[imid].tag;
                    	        if (val === tag) {
                    	            return imid;
                    	        } else if (val < tag) {
                    	            imin = imid + 1;
                    	        } else { imax = imid - 1; }
                    	    }
                    	    // Not found: return -1-insertion point
                    	    return -imin - 1;
                    	}
                    
                    	function binSearch(arr, value) {
                    	    /* jshint bitwise: false */
                    	    var imin = 0;
                    	    var imax = arr.length - 1;
                    	    while (imin <= imax) {
                    	        var imid = (imin + imax) >>> 1;
                    	        var val = arr[imid];
                    	        if (val === value) {
                    	            return imid;
                    	        } else if (val < value) {
                    	            imin = imid + 1;
                    	        } else { imax = imid - 1; }
                    	    }
                    	    // Not found: return -1-insertion point
                    	    return -imin - 1;
                    	}
                    
                    	// binary search in a list of ranges (coverage, class definition)
                    	function searchRange(ranges, value) {
                    	    // jshint bitwise: false
                    	    var range;
                    	    var imin = 0;
                    	    var imax = ranges.length - 1;
                    	    while (imin <= imax) {
                    	        var imid = (imin + imax) >>> 1;
                    	        range = ranges[imid];
                    	        var start = range.start;
                    	        if (start === value) {
                    	            return range;
                    	        } else if (start < value) {
                    	            imin = imid + 1;
                    	        } else { imax = imid - 1; }
                    	    }
                    	    if (imin > 0) {
                    	        range = ranges[imin - 1];
                    	        if (value > range.end) { return 0; }
                    	        return range;
                    	    }
                    	}
                    
                    	/**
                    	 * @exports opentype.Layout
                    	 * @class
                    	 */
                    	function Layout(font, tableName) {
                    	    this.font = font;
                    	    this.tableName = tableName;
                    	}
                    
                    	Layout.prototype = {
                    
                    	    /**
                    	     * Binary search an object by "tag" property
                    	     * @instance
                    	     * @function searchTag
                    	     * @memberof opentype.Layout
                    	     * @param  {Array} arr
                    	     * @param  {string} tag
                    	     * @return {number}
                    	     */
                    	    searchTag: searchTag,
                    
                    	    /**
                    	     * Binary search in a list of numbers
                    	     * @instance
                    	     * @function binSearch
                    	     * @memberof opentype.Layout
                    	     * @param  {Array} arr
                    	     * @param  {number} value
                    	     * @return {number}
                    	     */
                    	    binSearch: binSearch,
                    
                    	    /**
                    	     * Get or create the Layout table (GSUB, GPOS etc).
                    	     * @param  {boolean} create - Whether to create a new one.
                    	     * @return {Object} The GSUB or GPOS table.
                    	     */
                    	    getTable: function(create) {
                    	        var layout = this.font.tables[this.tableName];
                    	        if (!layout && create) {
                    	            layout = this.font.tables[this.tableName] = this.createDefaultTable();
                    	        }
                    	        return layout;
                    	    },
                    
                    	    /**
                    	     * Returns all scripts in the substitution table.
                    	     * @instance
                    	     * @return {Array}
                    	     */
                    	    getScriptNames: function() {
                    	        var layout = this.getTable();
                    	        if (!layout) { return []; }
                    	        return layout.scripts.map(function(script) {
                    	            return script.tag;
                    	        });
                    	    },
                    
                    	    /**
                    	     * Returns the best bet for a script name.
                    	     * Returns 'DFLT' if it exists.
                    	     * If not, returns 'latn' if it exists.
                    	     * If neither exist, returns undefined.
                    	     */
                    	    getDefaultScriptName: function() {
                    	        var layout = this.getTable();
                    	        if (!layout) { return; }
                    	        var hasLatn = false;
                    	        for (var i = 0; i < layout.scripts.length; i++) {
                    	            var name = layout.scripts[i].tag;
                    	            if (name === 'DFLT') { return name; }
                    	            if (name === 'latn') { hasLatn = true; }
                    	        }
                    	        if (hasLatn) { return 'latn'; }
                    	    },
                    
                    	    /**
                    	     * Returns all LangSysRecords in the given script.
                    	     * @instance
                    	     * @param {string} [script='DFLT']
                    	     * @param {boolean} create - forces the creation of this script table if it doesn't exist.
                    	     * @return {Object} An object with tag and script properties.
                    	     */
                    	    getScriptTable: function(script, create) {
                    	        var layout = this.getTable(create);
                    	        if (layout) {
                    	            script = script || 'DFLT';
                    	            var scripts = layout.scripts;
                    	            var pos = searchTag(layout.scripts, script);
                    	            if (pos >= 0) {
                    	                return scripts[pos].script;
                    	            } else if (create) {
                    	                var scr = {
                    	                    tag: script,
                    	                    script: {
                    	                        defaultLangSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []},
                    	                        langSysRecords: []
                    	                    }
                    	                };
                    	                scripts.splice(-1 - pos, 0, scr);
                    	                return scr.script;
                    	            }
                    	        }
                    	    },
                    
                    	    /**
                    	     * Returns a language system table
                    	     * @instance
                    	     * @param {string} [script='DFLT']
                    	     * @param {string} [language='dlft']
                    	     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.
                    	     * @return {Object}
                    	     */
                    	    getLangSysTable: function(script, language, create) {
                    	        var scriptTable = this.getScriptTable(script, create);
                    	        if (scriptTable) {
                    	            if (!language || language === 'dflt' || language === 'DFLT') {
                    	                return scriptTable.defaultLangSys;
                    	            }
                    	            var pos = searchTag(scriptTable.langSysRecords, language);
                    	            if (pos >= 0) {
                    	                return scriptTable.langSysRecords[pos].langSys;
                    	            } else if (create) {
                    	                var langSysRecord = {
                    	                    tag: language,
                    	                    langSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []}
                    	                };
                    	                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);
                    	                return langSysRecord.langSys;
                    	            }
                    	        }
                    	    },
                    
                    	    /**
                    	     * Get a specific feature table.
                    	     * @instance
                    	     * @param {string} [script='DFLT']
                    	     * @param {string} [language='dlft']
                    	     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm
                    	     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.
                    	     * @return {Object}
                    	     */
                    	    getFeatureTable: function(script, language, feature, create) {
                    	        var langSysTable = this.getLangSysTable(script, language, create);
                    	        if (langSysTable) {
                    	            var featureRecord;
                    	            var featIndexes = langSysTable.featureIndexes;
                    	            var allFeatures = this.font.tables[this.tableName].features;
                    	            // The FeatureIndex array of indices is in arbitrary order,
                    	            // even if allFeatures is sorted alphabetically by feature tag.
                    	            for (var i = 0; i < featIndexes.length; i++) {
                    	                featureRecord = allFeatures[featIndexes[i]];
                    	                if (featureRecord.tag === feature) {
                    	                    return featureRecord.feature;
                    	                }
                    	            }
                    	            if (create) {
                    	                var index = allFeatures.length;
                    	                // Automatic ordering of features would require to shift feature indexes in the script list.
                    	                check.assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');
                    	                featureRecord = {
                    	                    tag: feature,
                    	                    feature: { params: 0, lookupListIndexes: [] }
                    	                };
                    	                allFeatures.push(featureRecord);
                    	                featIndexes.push(index);
                    	                return featureRecord.feature;
                    	            }
                    	        }
                    	    },
                    
                    	    /**
                    	     * Get the lookup tables of a given type for a script/language/feature.
                    	     * @instance
                    	     * @param {string} [script='DFLT']
                    	     * @param {string} [language='dlft']
                    	     * @param {string} feature - 4-letter feature code
                    	     * @param {number} lookupType - 1 to 9
                    	     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.
                    	     * @return {Object[]}
                    	     */
                    	    getLookupTables: function(script, language, feature, lookupType, create) {
                    	        var featureTable = this.getFeatureTable(script, language, feature, create);
                    	        var tables = [];
                    	        if (featureTable) {
                    	            var lookupTable;
                    	            var lookupListIndexes = featureTable.lookupListIndexes;
                    	            var allLookups = this.font.tables[this.tableName].lookups;
                    	            // lookupListIndexes are in no particular order, so use naive search.
                    	            for (var i = 0; i < lookupListIndexes.length; i++) {
                    	                lookupTable = allLookups[lookupListIndexes[i]];
                    	                if (lookupTable.lookupType === lookupType) {
                    	                    tables.push(lookupTable);
                    	                }
                    	            }
                    	            if (tables.length === 0 && create) {
                    	                lookupTable = {
                    	                    lookupType: lookupType,
                    	                    lookupFlag: 0,
                    	                    subtables: [],
                    	                    markFilteringSet: undefined
                    	                };
                    	                var index = allLookups.length;
                    	                allLookups.push(lookupTable);
                    	                lookupListIndexes.push(index);
                    	                return [lookupTable];
                    	            }
                    	        }
                    	        return tables;
                    	    },
                    
                    	    /**
                    	     * Find a glyph in a class definition table
                    	     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table
                    	     * @param {object} classDefTable - an OpenType Layout class definition table
                    	     * @param {number} glyphIndex - the index of the glyph to find
                    	     * @returns {number} -1 if not found
                    	     */
                    	    getGlyphClass: function(classDefTable, glyphIndex) {
                    	        switch (classDefTable.format) {
                    	            case 1:
                    	                if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) {
                    	                    return classDefTable.classes[glyphIndex - classDefTable.startGlyph];
                    	                }
                    	                return 0;
                    	            case 2:
                    	                var range = searchRange(classDefTable.ranges, glyphIndex);
                    	                return range ? range.classId : 0;
                    	        }
                    	    },
                    
                    	    /**
                    	     * Find a glyph in a coverage table
                    	     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table
                    	     * @param {object} coverageTable - an OpenType Layout coverage table
                    	     * @param {number} glyphIndex - the index of the glyph to find
                    	     * @returns {number} -1 if not found
                    	     */
                    	    getCoverageIndex: function(coverageTable, glyphIndex) {
                    	        switch (coverageTable.format) {
                    	            case 1:
                    	                var index = binSearch(coverageTable.glyphs, glyphIndex);
                    	                return index >= 0 ? index : -1;
                    	            case 2:
                    	                var range = searchRange(coverageTable.ranges, glyphIndex);
                    	                return range ? range.index + glyphIndex - range.start : -1;
                    	        }
                    	    },
                    
                    	    /**
                    	     * Returns the list of glyph indexes of a coverage table.
                    	     * Format 1: the list is stored raw
                    	     * Format 2: compact list as range records.
                    	     * @instance
                    	     * @param  {Object} coverageTable
                    	     * @return {Array}
                    	     */
                    	    expandCoverage: function(coverageTable) {
                    	        if (coverageTable.format === 1) {
                    	            return coverageTable.glyphs;
                    	        } else {
                    	            var glyphs = [];
                    	            var ranges = coverageTable.ranges;
                    	            for (var i = 0; i < ranges.length; i++) {
                    	                var range = ranges[i];
                    	                var start = range.start;
                    	                var end = range.end;
                    	                for (var j = start; j <= end; j++) {
                    	                    glyphs.push(j);
                    	                }
                    	            }
                    	            return glyphs;
                    	        }
                    	    }
                    
                    	};
                    
                    	// The Position object provides utility methods to manipulate
                    
                    	/**
                    	 * @exports opentype.Position
                    	 * @class
                    	 * @extends opentype.Layout
                    	 * @param {opentype.Font}
                    	 * @constructor
                    	 */
                    	function Position(font) {
                    	    Layout.call(this, font, 'gpos');
                    	}
                    
                    	Position.prototype = Layout.prototype;
                    
                    	/**
                    	 * Init some data for faster and easier access later.
                    	 */
                    	Position.prototype.init = function() {
                    	    var script = this.getDefaultScriptName();
                    	    this.defaultKerningTables = this.getKerningTables(script);
                    	};
                    
                    	/**
                    	 * Find a glyph pair in a list of lookup tables of type 2 and retrieve the xAdvance kerning value.
                    	 *
                    	 * @param {integer} leftIndex - left glyph index
                    	 * @param {integer} rightIndex - right glyph index
                    	 * @returns {integer}
                    	 */
                    	Position.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {
                    	    var this$1 = this;
                    
                    	    for (var i = 0; i < kerningLookups.length; i++) {
                    	        var subtables = kerningLookups[i].subtables;
                    	        for (var j = 0; j < subtables.length; j++) {
                    	            var subtable = subtables[j];
                    	            var covIndex = this$1.getCoverageIndex(subtable.coverage, leftIndex);
                    	            if (covIndex < 0) { continue; }
                    	            switch (subtable.posFormat) {
                    	                case 1:
                    	                    // Search Pair Adjustment Positioning Format 1
                    	                    var pairSet = subtable.pairSets[covIndex];
                    	                    for (var k = 0; k < pairSet.length; k++) {
                    	                        var pair = pairSet[k];
                    	                        if (pair.secondGlyph === rightIndex) {
                    	                            return pair.value1 && pair.value1.xAdvance || 0;
                    	                        }
                    	                    }
                    	                    break;      // left glyph found, not right glyph - try next subtable
                    	                case 2:
                    	                    // Search Pair Adjustment Positioning Format 2
                    	                    var class1 = this$1.getGlyphClass(subtable.classDef1, leftIndex);
                    	                    var class2 = this$1.getGlyphClass(subtable.classDef2, rightIndex);
                    	                    var pair$1 = subtable.classRecords[class1][class2];
                    	                    return pair$1.value1 && pair$1.value1.xAdvance || 0;
                    	            }
                    	        }
                    	    }
                    	    return 0;
                    	};
                    
                    	/**
                    	 * List all kerning lookup tables.
                    	 *
                    	 * @param {string} [script='DFLT'] - use font.position.getDefaultScriptName() for a better default value
                    	 * @param {string} [language='dflt']
                    	 * @return {object[]} The list of kerning lookup tables (may be empty), or undefined if there is no GPOS table (and we should use the kern table)
                    	 */
                    	Position.prototype.getKerningTables = function(script, language) {
                    	    if (this.font.tables.gpos) {
                    	        return this.getLookupTables(script, language, 'kern', 2);
                    	    }
                    	};
                    
                    	// The Substitution object provides utility methods to manipulate
                    
                    	/**
                    	 * @exports opentype.Substitution
                    	 * @class
                    	 * @extends opentype.Layout
                    	 * @param {opentype.Font}
                    	 * @constructor
                    	 */
                    	function Substitution(font) {
                    	    Layout.call(this, font, 'gsub');
                    	}
                    
                    	// Check if 2 arrays of primitives are equal.
                    	function arraysEqual(ar1, ar2) {
                    	    var n = ar1.length;
                    	    if (n !== ar2.length) { return false; }
                    	    for (var i = 0; i < n; i++) {
                    	        if (ar1[i] !== ar2[i]) { return false; }
                    	    }
                    	    return true;
                    	}
                    
                    	// Find the first subtable of a lookup table in a particular format.
                    	function getSubstFormat(lookupTable, format, defaultSubtable) {
                    	    var subtables = lookupTable.subtables;
                    	    for (var i = 0; i < subtables.length; i++) {
                    	        var subtable = subtables[i];
                    	        if (subtable.substFormat === format) {
                    	            return subtable;
                    	        }
                    	    }
                    	    if (defaultSubtable) {
                    	        subtables.push(defaultSubtable);
                    	        return defaultSubtable;
                    	    }
                    	    return undefined;
                    	}
                    
                    	Substitution.prototype = Layout.prototype;
                    
                    	/**
                    	 * Create a default GSUB table.
                    	 * @return {Object} gsub - The GSUB table.
                    	 */
                    	Substitution.prototype.createDefaultTable = function() {
                    	    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.
                    	    return {
                    	        version: 1,
                    	        scripts: [{
                    	            tag: 'DFLT',
                    	            script: {
                    	                defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },
                    	                langSysRecords: []
                    	            }
                    	        }],
                    	        features: [],
                    	        lookups: []
                    	    };
                    	};
                    
                    	/**
                    	 * List all single substitutions (lookup type 1) for a given script, language, and feature.
                    	 * @param {string} [script='DFLT']
                    	 * @param {string} [language='dflt']
                    	 * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)
                    	 * @return {Array} substitutions - The list of substitutions.
                    	 */
                    	Substitution.prototype.getSingle = function(feature, script, language) {
                    	    var this$1 = this;
                    
                    	    var substitutions = [];
                    	    var lookupTables = this.getLookupTables(script, language, feature, 1);
                    	    for (var idx = 0; idx < lookupTables.length; idx++) {
                    	        var subtables = lookupTables[idx].subtables;
                    	        for (var i = 0; i < subtables.length; i++) {
                    	            var subtable = subtables[i];
                    	            var glyphs = this$1.expandCoverage(subtable.coverage);
                    	            var j = (void 0);
                    	            if (subtable.substFormat === 1) {
                    	                var delta = subtable.deltaGlyphId;
                    	                for (j = 0; j < glyphs.length; j++) {
                    	                    var glyph = glyphs[j];
                    	                    substitutions.push({ sub: glyph, by: glyph + delta });
                    	                }
                    	            } else {
                    	                var substitute = subtable.substitute;
                    	                for (j = 0; j < glyphs.length; j++) {
                    	                    substitutions.push({ sub: glyphs[j], by: substitute[j] });
                    	                }
                    	            }
                    	        }
                    	    }
                    	    return substitutions;
                    	};
                    
                    	/**
                    	 * List all alternates (lookup type 3) for a given script, language, and feature.
                    	 * @param {string} [script='DFLT']
                    	 * @param {string} [language='dflt']
                    	 * @param {string} feature - 4-character feature name ('aalt', 'salt'...)
                    	 * @return {Array} alternates - The list of alternates
                    	 */
                    	Substitution.prototype.getAlternates = function(feature, script, language) {
                    	    var this$1 = this;
                    
                    	    var alternates = [];
                    	    var lookupTables = this.getLookupTables(script, language, feature, 3);
                    	    for (var idx = 0; idx < lookupTables.length; idx++) {
                    	        var subtables = lookupTables[idx].subtables;
                    	        for (var i = 0; i < subtables.length; i++) {
                    	            var subtable = subtables[i];
                    	            var glyphs = this$1.expandCoverage(subtable.coverage);
                    	            var alternateSets = subtable.alternateSets;
                    	            for (var j = 0; j < glyphs.length; j++) {
                    	                alternates.push({ sub: glyphs[j], by: alternateSets[j] });
                    	            }
                    	        }
                    	    }
                    	    return alternates;
                    	};
                    
                    	/**
                    	 * List all ligatures (lookup type 4) for a given script, language, and feature.
                    	 * The result is an array of ligature objects like { sub: [ids], by: id }
                    	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
                    	 * @param {string} [script='DFLT']
                    	 * @param {string} [language='dflt']
                    	 * @return {Array} ligatures - The list of ligatures.
                    	 */
                    	Substitution.prototype.getLigatures = function(feature, script, language) {
                    	    var this$1 = this;
                    
                    	    var ligatures = [];
                    	    var lookupTables = this.getLookupTables(script, language, feature, 4);
                    	    for (var idx = 0; idx < lookupTables.length; idx++) {
                    	        var subtables = lookupTables[idx].subtables;
                    	        for (var i = 0; i < subtables.length; i++) {
                    	            var subtable = subtables[i];
                    	            var glyphs = this$1.expandCoverage(subtable.coverage);
                    	            var ligatureSets = subtable.ligatureSets;
                    	            for (var j = 0; j < glyphs.length; j++) {
                    	                var startGlyph = glyphs[j];
                    	                var ligSet = ligatureSets[j];
                    	                for (var k = 0; k < ligSet.length; k++) {
                    	                    var lig = ligSet[k];
                    	                    ligatures.push({
                    	                        sub: [startGlyph].concat(lig.components),
                    	                        by: lig.ligGlyph
                    	                    });
                    	                }
                    	            }
                    	        }
                    	    }
                    	    return ligatures;
                    	};
                    
                    	/**
                    	 * Add or modify a single substitution (lookup type 1)
                    	 * Format 2, more flexible, is always used.
                    	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
                    	 * @param {Object} substitution - { sub: id, delta: number } for format 1 or { sub: id, by: id } for format 2.
                    	 * @param {string} [script='DFLT']
                    	 * @param {string} [language='dflt']
                    	 */
                    	Substitution.prototype.addSingle = function(feature, substitution, script, language) {
                    	    var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];
                    	    var subtable = getSubstFormat(lookupTable, 2, {                // lookup type 1 subtable, format 2, coverage format 1
                    	        substFormat: 2,
                    	        coverage: {format: 1, glyphs: []},
                    	        substitute: []
                    	    });
                    	    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
                    	    var coverageGlyph = substitution.sub;
                    	    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
                    	    if (pos < 0) {
                    	        pos = -1 - pos;
                    	        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
                    	        subtable.substitute.splice(pos, 0, 0);
                    	    }
                    	    subtable.substitute[pos] = substitution.by;
                    	};
                    
                    	/**
                    	 * Add or modify an alternate substitution (lookup type 1)
                    	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
                    	 * @param {Object} substitution - { sub: id, by: [ids] }
                    	 * @param {string} [script='DFLT']
                    	 * @param {string} [language='dflt']
                    	 */
                    	Substitution.prototype.addAlternate = function(feature, substitution, script, language) {
                    	    var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];
                    	    var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 3 subtable, format 1, coverage format 1
                    	        substFormat: 1,
                    	        coverage: {format: 1, glyphs: []},
                    	        alternateSets: []
                    	    });
                    	    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
                    	    var coverageGlyph = substitution.sub;
                    	    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
                    	    if (pos < 0) {
                    	        pos = -1 - pos;
                    	        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
                    	        subtable.alternateSets.splice(pos, 0, 0);
                    	    }
                    	    subtable.alternateSets[pos] = substitution.by;
                    	};
                    
                    	/**
                    	 * Add a ligature (lookup type 4)
                    	 * Ligatures with more components must be stored ahead of those with fewer components in order to be found
                    	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
                    	 * @param {Object} ligature - { sub: [ids], by: id }
                    	 * @param {string} [script='DFLT']
                    	 * @param {string} [language='dflt']
                    	 */
                    	Substitution.prototype.addLigature = function(feature, ligature, script, language) {
                    	    var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];
                    	    var subtable = lookupTable.subtables[0];
                    	    if (!subtable) {
                    	        subtable = {                // lookup type 4 subtable, format 1, coverage format 1
                    	            substFormat: 1,
                    	            coverage: { format: 1, glyphs: [] },
                    	            ligatureSets: []
                    	        };
                    	        lookupTable.subtables[0] = subtable;
                    	    }
                    	    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
                    	    var coverageGlyph = ligature.sub[0];
                    	    var ligComponents = ligature.sub.slice(1);
                    	    var ligatureTable = {
                    	        ligGlyph: ligature.by,
                    	        components: ligComponents
                    	    };
                    	    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
                    	    if (pos >= 0) {
                    	        // ligatureSet already exists
                    	        var ligatureSet = subtable.ligatureSets[pos];
                    	        for (var i = 0; i < ligatureSet.length; i++) {
                    	            // If ligature already exists, return.
                    	            if (arraysEqual(ligatureSet[i].components, ligComponents)) {
                    	                return;
                    	            }
                    	        }
                    	        // ligature does not exist: add it.
                    	        ligatureSet.push(ligatureTable);
                    	    } else {
                    	        // Create a new ligatureSet and add coverage for the first glyph.
                    	        pos = -1 - pos;
                    	        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
                    	        subtable.ligatureSets.splice(pos, 0, [ligatureTable]);
                    	    }
                    	};
                    
                    	/**
                    	 * List all feature data for a given script and language.
                    	 * @param {string} feature - 4-letter feature name
                    	 * @param {string} [script='DFLT']
                    	 * @param {string} [language='dflt']
                    	 * @return {Array} substitutions - The list of substitutions.
                    	 */
                    	Substitution.prototype.getFeature = function(feature, script, language) {
                    	    if (/ss\d\d/.test(feature)) {
                    	        // ss01 - ss20
                    	        return this.getSingle(feature, script, language);
                    	    }
                    	    switch (feature) {
                    	        case 'aalt':
                    	        case 'salt':
                    	            return this.getSingle(feature, script, language)
                    	                    .concat(this.getAlternates(feature, script, language));
                    	        case 'dlig':
                    	        case 'liga':
                    	        case 'rlig': return this.getLigatures(feature, script, language);
                    	    }
                    	    return undefined;
                    	};
                    
                    	/**
                    	 * Add a substitution to a feature for a given script and language.
                    	 * @param {string} feature - 4-letter feature name
                    	 * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })
                    	 * @param {string} [script='DFLT']
                    	 * @param {string} [language='dflt']
                    	 */
                    	Substitution.prototype.add = function(feature, sub, script, language) {
                    	    if (/ss\d\d/.test(feature)) {
                    	        // ss01 - ss20
                    	        return this.addSingle(feature, sub, script, language);
                    	    }
                    	    switch (feature) {
                    	        case 'aalt':
                    	        case 'salt':
                    	            if (typeof sub.by === 'number') {
                    	                return this.addSingle(feature, sub, script, language);
                    	            }
                    	            return this.addAlternate(feature, sub, script, language);
                    	        case 'dlig':
                    	        case 'liga':
                    	        case 'rlig':
                    	            return this.addLigature(feature, sub, script, language);
                    	    }
                    	    return undefined;
                    	};
                    
                    	function isBrowser() {
                    	    return typeof window !== 'undefined';
                    	}
                    
                    	function nodeBufferToArrayBuffer(buffer) {
                    	    var ab = new ArrayBuffer(buffer.length);
                    	    var view = new Uint8Array(ab);
                    	    for (var i = 0; i < buffer.length; ++i) {
                    	        view[i] = buffer[i];
                    	    }
                    
                    	    return ab;
                    	}
                    
                    	function arrayBufferToNodeBuffer(ab) {
                    	    var buffer = new Buffer(ab.byteLength);
                    	    var view = new Uint8Array(ab);
                    	    for (var i = 0; i < buffer.length; ++i) {
                    	        buffer[i] = view[i];
                    	    }
                    
                    	    return buffer;
                    	}
                    
                    	function checkArgument(expression, message) {
                    	    if (!expression) {
                    	        throw message;
                    	    }
                    	}
                    
                    	// The `glyf` table describes the glyphs in TrueType outline format.
                    
                    	// Parse the coordinate data for a glyph.
                    	function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
                    	    var v;
                    	    if ((flag & shortVectorBitMask) > 0) {
                    	        // The coordinate is 1 byte long.
                    	        v = p.parseByte();
                    	        // The `same` bit is re-used for short values to signify the sign of the value.
                    	        if ((flag & sameBitMask) === 0) {
                    	            v = -v;
                    	        }
                    
                    	        v = previousValue + v;
                    	    } else {
                    	        //  The coordinate is 2 bytes long.
                    	        // If the `same` bit is set, the coordinate is the same as the previous coordinate.
                    	        if ((flag & sameBitMask) > 0) {
                    	            v = previousValue;
                    	        } else {
                    	            // Parse the coordinate as a signed 16-bit delta value.
                    	            v = previousValue + p.parseShort();
                    	        }
                    	    }
                    
                    	    return v;
                    	}
                    
                    	// Parse a TrueType glyph.
                    	function parseGlyph(glyph, data, start) {
                    	    var p = new parse.Parser(data, start);
                    	    glyph.numberOfContours = p.parseShort();
                    	    glyph._xMin = p.parseShort();
                    	    glyph._yMin = p.parseShort();
                    	    glyph._xMax = p.parseShort();
                    	    glyph._yMax = p.parseShort();
                    	    var flags;
                    	    var flag;
                    
                    	    if (glyph.numberOfContours > 0) {
                    	        // This glyph is not a composite.
                    	        var endPointIndices = glyph.endPointIndices = [];
                    	        for (var i = 0; i < glyph.numberOfContours; i += 1) {
                    	            endPointIndices.push(p.parseUShort());
                    	        }
                    
                    	        glyph.instructionLength = p.parseUShort();
                    	        glyph.instructions = [];
                    	        for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {
                    	            glyph.instructions.push(p.parseByte());
                    	        }
                    
                    	        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
                    	        flags = [];
                    	        for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {
                    	            flag = p.parseByte();
                    	            flags.push(flag);
                    	            // If bit 3 is set, we repeat this flag n times, where n is the next byte.
                    	            if ((flag & 8) > 0) {
                    	                var repeatCount = p.parseByte();
                    	                for (var j = 0; j < repeatCount; j += 1) {
                    	                    flags.push(flag);
                    	                    i$2 += 1;
                    	                }
                    	            }
                    	        }
                    
                    	        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');
                    
                    	        if (endPointIndices.length > 0) {
                    	            var points = [];
                    	            var point;
                    	            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.
                    	            if (numberOfCoordinates > 0) {
                    	                for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {
                    	                    flag = flags[i$3];
                    	                    point = {};
                    	                    point.onCurve = !!(flag & 1);
                    	                    point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;
                    	                    points.push(point);
                    	                }
                    
                    	                var px = 0;
                    	                for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {
                    	                    flag = flags[i$4];
                    	                    point = points[i$4];
                    	                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
                    	                    px = point.x;
                    	                }
                    
                    	                var py = 0;
                    	                for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {
                    	                    flag = flags[i$5];
                    	                    point = points[i$5];
                    	                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
                    	                    py = point.y;
                    	                }
                    	            }
                    
                    	            glyph.points = points;
                    	        } else {
                    	            glyph.points = [];
                    	        }
                    	    } else if (glyph.numberOfContours === 0) {
                    	        glyph.points = [];
                    	    } else {
                    	        glyph.isComposite = true;
                    	        glyph.points = [];
                    	        glyph.components = [];
                    	        var moreComponents = true;
                    	        while (moreComponents) {
                    	            flags = p.parseUShort();
                    	            var component = {
                    	                glyphIndex: p.parseUShort(),
                    	                xScale: 1,
                    	                scale01: 0,
                    	                scale10: 0,
                    	                yScale: 1,
                    	                dx: 0,
                    	                dy: 0
                    	            };
                    	            if ((flags & 1) > 0) {
                    	                // The arguments are words
                    	                if ((flags & 2) > 0) {
                    	                    // values are offset
                    	                    component.dx = p.parseShort();
                    	                    component.dy = p.parseShort();
                    	                } else {
                    	                    // values are matched points
                    	                    component.matchedPoints = [p.parseUShort(), p.parseUShort()];
                    	                }
                    
                    	            } else {
                    	                // The arguments are bytes
                    	                if ((flags & 2) > 0) {
                    	                    // values are offset
                    	                    component.dx = p.parseChar();
                    	                    component.dy = p.parseChar();
                    	                } else {
                    	                    // values are matched points
                    	                    component.matchedPoints = [p.parseByte(), p.parseByte()];
                    	                }
                    	            }
                    
                    	            if ((flags & 8) > 0) {
                    	                // We have a scale
                    	                component.xScale = component.yScale = p.parseF2Dot14();
                    	            } else if ((flags & 64) > 0) {
                    	                // We have an X / Y scale
                    	                component.xScale = p.parseF2Dot14();
                    	                component.yScale = p.parseF2Dot14();
                    	            } else if ((flags & 128) > 0) {
                    	                // We have a 2x2 transformation
                    	                component.xScale = p.parseF2Dot14();
                    	                component.scale01 = p.parseF2Dot14();
                    	                component.scale10 = p.parseF2Dot14();
                    	                component.yScale = p.parseF2Dot14();
                    	            }
                    
                    	            glyph.components.push(component);
                    	            moreComponents = !!(flags & 32);
                    	        }
                    	        if (flags & 0x100) {
                    	            // We have instructions
                    	            glyph.instructionLength = p.parseUShort();
                    	            glyph.instructions = [];
                    	            for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {
                    	                glyph.instructions.push(p.parseByte());
                    	            }
                    	        }
                    	    }
                    	}
                    
                    	// Transform an array of points and return a new array.
                    	function transformPoints(points, transform) {
                    	    var newPoints = [];
                    	    for (var i = 0; i < points.length; i += 1) {
                    	        var pt = points[i];
                    	        var newPt = {
                    	            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
                    	            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
                    	            onCurve: pt.onCurve,
                    	            lastPointOfContour: pt.lastPointOfContour
                    	        };
                    	        newPoints.push(newPt);
                    	    }
                    
                    	    return newPoints;
                    	}
                    
                    	function getContours(points) {
                    	    var contours = [];
                    	    var currentContour = [];
                    	    for (var i = 0; i < points.length; i += 1) {
                    	        var pt = points[i];
                    	        currentContour.push(pt);
                    	        if (pt.lastPointOfContour) {
                    	            contours.push(currentContour);
                    	            currentContour = [];
                    	        }
                    	    }
                    
                    	    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
                    	    return contours;
                    	}
                    
                    	// Convert the TrueType glyph outline to a Path.
                    	function getPath(points) {
                    	    var p = new Path();
                    	    if (!points) {
                    	        return p;
                    	    }
                    
                    	    var contours = getContours(points);
                    
                    	    for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {
                    	        var contour = contours[contourIndex];
                    
                    	        var prev = null;
                    	        var curr = contour[contour.length - 1];
                    	        var next = contour[0];
                    
                    	        if (curr.onCurve) {
                    	            p.moveTo(curr.x, curr.y);
                    	        } else {
                    	            if (next.onCurve) {
                    	                p.moveTo(next.x, next.y);
                    	            } else {
                    	                // If both first and last points are off-curve, start at their middle.
                    	                var start = {x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5};
                    	                p.moveTo(start.x, start.y);
                    	            }
                    	        }
                    
                    	        for (var i = 0; i < contour.length; ++i) {
                    	            prev = curr;
                    	            curr = next;
                    	            next = contour[(i + 1) % contour.length];
                    
                    	            if (curr.onCurve) {
                    	                // This is a straight line.
                    	                p.lineTo(curr.x, curr.y);
                    	            } else {
                    	                var prev2 = prev;
                    	                var next2 = next;
                    
                    	                if (!prev.onCurve) {
                    	                    prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };
                    	                }
                    
                    	                if (!next.onCurve) {
                    	                    next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
                    	                }
                    
                    	                p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);
                    	            }
                    	        }
                    
                    	        p.closePath();
                    	    }
                    	    return p;
                    	}
                    
                    	function buildPath(glyphs, glyph) {
                    	    if (glyph.isComposite) {
                    	        for (var j = 0; j < glyph.components.length; j += 1) {
                    	            var component = glyph.components[j];
                    	            var componentGlyph = glyphs.get(component.glyphIndex);
                    	            // Force the ttfGlyphLoader to parse the glyph.
                    	            componentGlyph.getPath();
                    	            if (componentGlyph.points) {
                    	                var transformedPoints = (void 0);
                    	                if (component.matchedPoints === undefined) {
                    	                    // component positioned by offset
                    	                    transformedPoints = transformPoints(componentGlyph.points, component);
                    	                } else {
                    	                    // component positioned by matched points
                    	                    if ((component.matchedPoints[0] > glyph.points.length - 1) ||
                    	                        (component.matchedPoints[1] > componentGlyph.points.length - 1)) {
                    	                        throw Error('Matched points out of range in ' + glyph.name);
                    	                    }
                    	                    var firstPt = glyph.points[component.matchedPoints[0]];
                    	                    var secondPt = componentGlyph.points[component.matchedPoints[1]];
                    	                    var transform = {
                    	                        xScale: component.xScale, scale01: component.scale01,
                    	                        scale10: component.scale10, yScale: component.yScale,
                    	                        dx: 0, dy: 0
                    	                    };
                    	                    secondPt = transformPoints([secondPt], transform)[0];
                    	                    transform.dx = firstPt.x - secondPt.x;
                    	                    transform.dy = firstPt.y - secondPt.y;
                    	                    transformedPoints = transformPoints(componentGlyph.points, transform);
                    	                }
                    	                glyph.points = glyph.points.concat(transformedPoints);
                    	            }
                    	        }
                    	    }
                    
                    	    return getPath(glyph.points);
                    	}
                    
                    	// Parse all the glyphs according to the offsets from the `loca` table.
                    	function parseGlyfTable(data, start, loca, font) {
                    	    var glyphs = new glyphset.GlyphSet(font);
                    
                    	    // The last element of the loca table is invalid.
                    	    for (var i = 0; i < loca.length - 1; i += 1) {
                    	        var offset = loca[i];
                    	        var nextOffset = loca[i + 1];
                    	        if (offset !== nextOffset) {
                    	            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));
                    	        } else {
                    	            glyphs.push(i, glyphset.glyphLoader(font, i));
                    	        }
                    	    }
                    
                    	    return glyphs;
                    	}
                    
                    	var glyf = { getPath: getPath, parse: parseGlyfTable };
                    
                    	/* A TrueType font hinting interpreter.
                    	*
                    	* (c) 2017 Axel Kittenberger
                    	*
                    	* This interpreter has been implemented according to this documentation:
                    	* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html
                    	*
                    	* According to the documentation F24DOT6 values are used for pixels.
                    	* That means calculation is 1/64 pixel accurate and uses integer operations.
                    	* However, Javascript has floating point operations by default and only
                    	* those are available. One could make a case to simulate the 1/64 accuracy
                    	* exactly by truncating after every division operation
                    	* (for example with << 0) to get pixel exactly results as other TrueType
                    	* implementations. It may make sense since some fonts are pixel optimized
                    	* by hand using DELTAP instructions. The current implementation doesn't
                    	* and rather uses full floating point precision.
                    	*
                    	* xScale, yScale and rotation is currently ignored.
                    	*
                    	* A few non-trivial instructions are missing as I didn't encounter yet
                    	* a font that used them to test a possible implementation.
                    	*
                    	* Some fonts seem to use undocumented features regarding the twilight zone.
                    	* Only some of them are implemented as they were encountered.
                    	*
                    	* The exports.DEBUG statements are removed on the minified distribution file.
                    	*/
                    
                    	var instructionTable;
                    	var exec;
                    	var execGlyph;
                    	var execComponent;
                    
                    	/*
                    	* Creates a hinting object.
                    	*
                    	* There ought to be exactly one
                    	* for each truetype font that is used for hinting.
                    	*/
                    	function Hinting(font) {
                    	    // the font this hinting object is for
                    	    this.font = font;
                    
                    	    this.getCommands = function (hPoints) {
                    	        return glyf.getPath(hPoints).commands;
                    	    };
                    
                    	    // cached states
                    	    this._fpgmState  =
                    	    this._prepState  =
                    	        undefined;
                    
                    	    // errorState
                    	    // 0 ... all okay
                    	    // 1 ... had an error in a glyf,
                    	    //       continue working but stop spamming
                    	    //       the console
                    	    // 2 ... error at prep, stop hinting at this ppem
                    	    // 3 ... error at fpeg, stop hinting for this font at all
                    	    this._errorState = 0;
                    	}
                    
                    	/*
                    	* Not rounding.
                    	*/
                    	function roundOff(v) {
                    	    return v;
                    	}
                    
                    	/*
                    	* Rounding to grid.
                    	*/
                    	function roundToGrid(v) {
                    	    //Rounding in TT is supposed to "symmetrical around zero"
                    	    return Math.sign(v) * Math.round(Math.abs(v));
                    	}
                    
                    	/*
                    	* Rounding to double grid.
                    	*/
                    	function roundToDoubleGrid(v) {
                    	    return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;
                    	}
                    
                    	/*
                    	* Rounding to half grid.
                    	*/
                    	function roundToHalfGrid(v) {
                    	    return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);
                    	}
                    
                    	/*
                    	* Rounding to up to grid.
                    	*/
                    	function roundUpToGrid(v) {
                    	    return Math.sign(v) * Math.ceil(Math.abs(v));
                    	}
                    
                    	/*
                    	* Rounding to down to grid.
                    	*/
                    	function roundDownToGrid(v) {
                    	    return Math.sign(v) * Math.floor(Math.abs(v));
                    	}
                    
                    	/*
                    	* Super rounding.
                    	*/
                    	var roundSuper = function (v) {
                    	    var period = this.srPeriod;
                    	    var phase = this.srPhase;
                    	    var threshold = this.srThreshold;
                    	    var sign = 1;
                    
                    	    if (v < 0) {
                    	        v = -v;
                    	        sign = -1;
                    	    }
                    
                    	    v += threshold - phase;
                    
                    	    v = Math.trunc(v / period) * period;
                    
                    	    v += phase;
                    
                    	    // according to http://xgridfit.sourceforge.net/round.html
                    	    if (v < 0) { return phase * sign; }
                    
                    	    return v * sign;
                    	};
                    
                    	/*
                    	* Unit vector of x-axis.
                    	*/
                    	var xUnitVector = {
                    	    x: 1,
                    
                    	    y: 0,
                    
                    	    axis: 'x',
                    
                    	    // Gets the projected distance between two points.
                    	    // o1/o2 ... if true, respective original position is used.
                    	    distance: function (p1, p2, o1, o2) {
                    	        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);
                    	    },
                    
                    	    // Moves point p so the moved position has the same relative
                    	    // position to the moved positions of rp1 and rp2 than the
                    	    // original positions had.
                    	    //
                    	    // See APPENDIX on INTERPOLATE at the bottom of this file.
                    	    interpolate: function (p, rp1, rp2, pv) {
                    	        var do1;
                    	        var do2;
                    	        var doa1;
                    	        var doa2;
                    	        var dm1;
                    	        var dm2;
                    	        var dt;
                    
                    	        if (!pv || pv === this) {
                    	            do1 = p.xo - rp1.xo;
                    	            do2 = p.xo - rp2.xo;
                    	            dm1 = rp1.x - rp1.xo;
                    	            dm2 = rp2.x - rp2.xo;
                    	            doa1 = Math.abs(do1);
                    	            doa2 = Math.abs(do2);
                    	            dt = doa1 + doa2;
                    
                    	            if (dt === 0) {
                    	                p.x = p.xo + (dm1 + dm2) / 2;
                    	                return;
                    	            }
                    
                    	            p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;
                    	            return;
                    	        }
                    
                    	        do1 = pv.distance(p, rp1, true, true);
                    	        do2 = pv.distance(p, rp2, true, true);
                    	        dm1 = pv.distance(rp1, rp1, false, true);
                    	        dm2 = pv.distance(rp2, rp2, false, true);
                    	        doa1 = Math.abs(do1);
                    	        doa2 = Math.abs(do2);
                    	        dt = doa1 + doa2;
                    
                    	        if (dt === 0) {
                    	            xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
                    	            return;
                    	        }
                    
                    	        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
                    	    },
                    
                    	    // Slope of line normal to this
                    	    normalSlope: Number.NEGATIVE_INFINITY,
                    
                    	    // Sets the point 'p' relative to point 'rp'
                    	    // by the distance 'd'.
                    	    //
                    	    // See APPENDIX on SETRELATIVE at the bottom of this file.
                    	    //
                    	    // p   ... point to set
                    	    // rp  ... reference point
                    	    // d   ... distance on projection vector
                    	    // pv  ... projection vector (undefined = this)
                    	    // org ... if true, uses the original position of rp as reference.
                    	    setRelative: function (p, rp, d, pv, org) {
                    	        if (!pv || pv === this) {
                    	            p.x = (org ? rp.xo : rp.x) + d;
                    	            return;
                    	        }
                    
                    	        var rpx = org ? rp.xo : rp.x;
                    	        var rpy = org ? rp.yo : rp.y;
                    	        var rpdx = rpx + d * pv.x;
                    	        var rpdy = rpy + d * pv.y;
                    
                    	        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;
                    	    },
                    
                    	    // Slope of vector line.
                    	    slope: 0,
                    
                    	    // Touches the point p.
                    	    touch: function (p) {
                    	        p.xTouched = true;
                    	    },
                    
                    	    // Tests if a point p is touched.
                    	    touched: function (p) {
                    	        return p.xTouched;
                    	    },
                    
                    	    // Untouches the point p.
                    	    untouch: function (p) {
                    	        p.xTouched = false;
                    	    }
                    	};
                    
                    	/*
                    	* Unit vector of y-axis.
                    	*/
                    	var yUnitVector = {
                    	    x: 0,
                    
                    	    y: 1,
                    
                    	    axis: 'y',
                    
                    	    // Gets the projected distance between two points.
                    	    // o1/o2 ... if true, respective original position is used.
                    	    distance: function (p1, p2, o1, o2) {
                    	        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);
                    	    },
                    
                    	    // Moves point p so the moved position has the same relative
                    	    // position to the moved positions of rp1 and rp2 than the
                    	    // original positions had.
                    	    //
                    	    // See APPENDIX on INTERPOLATE at the bottom of this file.
                    	    interpolate: function (p, rp1, rp2, pv) {
                    	        var do1;
                    	        var do2;
                    	        var doa1;
                    	        var doa2;
                    	        var dm1;
                    	        var dm2;
                    	        var dt;
                    
                    	        if (!pv || pv === this) {
                    	            do1 = p.yo - rp1.yo;
                    	            do2 = p.yo - rp2.yo;
                    	            dm1 = rp1.y - rp1.yo;
                    	            dm2 = rp2.y - rp2.yo;
                    	            doa1 = Math.abs(do1);
                    	            doa2 = Math.abs(do2);
                    	            dt = doa1 + doa2;
                    
                    	            if (dt === 0) {
                    	                p.y = p.yo + (dm1 + dm2) / 2;
                    	                return;
                    	            }
                    
                    	            p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;
                    	            return;
                    	        }
                    
                    	        do1 = pv.distance(p, rp1, true, true);
                    	        do2 = pv.distance(p, rp2, true, true);
                    	        dm1 = pv.distance(rp1, rp1, false, true);
                    	        dm2 = pv.distance(rp2, rp2, false, true);
                    	        doa1 = Math.abs(do1);
                    	        doa2 = Math.abs(do2);
                    	        dt = doa1 + doa2;
                    
                    	        if (dt === 0) {
                    	            yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
                    	            return;
                    	        }
                    
                    	        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
                    	    },
                    
                    	    // Slope of line normal to this.
                    	    normalSlope: 0,
                    
                    	    // Sets the point 'p' relative to point 'rp'
                    	    // by the distance 'd'
                    	    //
                    	    // See APPENDIX on SETRELATIVE at the bottom of this file.
                    	    //
                    	    // p   ... point to set
                    	    // rp  ... reference point
                    	    // d   ... distance on projection vector
                    	    // pv  ... projection vector (undefined = this)
                    	    // org ... if true, uses the original position of rp as reference.
                    	    setRelative: function (p, rp, d, pv, org) {
                    	        if (!pv || pv === this) {
                    	            p.y = (org ? rp.yo : rp.y) + d;
                    	            return;
                    	        }
                    
                    	        var rpx = org ? rp.xo : rp.x;
                    	        var rpy = org ? rp.yo : rp.y;
                    	        var rpdx = rpx + d * pv.x;
                    	        var rpdy = rpy + d * pv.y;
                    
                    	        p.y = rpdy + pv.normalSlope * (p.x - rpdx);
                    	    },
                    
                    	    // Slope of vector line.
                    	    slope: Number.POSITIVE_INFINITY,
                    
                    	    // Touches the point p.
                    	    touch: function (p) {
                    	        p.yTouched = true;
                    	    },
                    
                    	    // Tests if a point p is touched.
                    	    touched: function (p) {
                    	        return p.yTouched;
                    	    },
                    
                    	    // Untouches the point p.
                    	    untouch: function (p) {
                    	        p.yTouched = false;
                    	    }
                    	};
                    
                    	Object.freeze(xUnitVector);
                    	Object.freeze(yUnitVector);
                    
                    	/*
                    	* Creates a unit vector that is not x- or y-axis.
                    	*/
                    	function UnitVector(x, y) {
                    	    this.x = x;
                    	    this.y = y;
                    	    this.axis = undefined;
                    	    this.slope = y / x;
                    	    this.normalSlope = -x / y;
                    	    Object.freeze(this);
                    	}
                    
                    	/*
                    	* Gets the projected distance between two points.
                    	* o1/o2 ... if true, respective original position is used.
                    	*/
                    	UnitVector.prototype.distance = function(p1, p2, o1, o2) {
                    	    return (
                    	        this.x * xUnitVector.distance(p1, p2, o1, o2) +
                    	        this.y * yUnitVector.distance(p1, p2, o1, o2)
                    	    );
                    	};
                    
                    	/*
                    	* Moves point p so the moved position has the same relative
                    	* position to the moved positions of rp1 and rp2 than the
                    	* original positions had.
                    	*
                    	* See APPENDIX on INTERPOLATE at the bottom of this file.
                    	*/
                    	UnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {
                    	    var dm1;
                    	    var dm2;
                    	    var do1;
                    	    var do2;
                    	    var doa1;
                    	    var doa2;
                    	    var dt;
                    
                    	    do1 = pv.distance(p, rp1, true, true);
                    	    do2 = pv.distance(p, rp2, true, true);
                    	    dm1 = pv.distance(rp1, rp1, false, true);
                    	    dm2 = pv.distance(rp2, rp2, false, true);
                    	    doa1 = Math.abs(do1);
                    	    doa2 = Math.abs(do2);
                    	    dt = doa1 + doa2;
                    
                    	    if (dt === 0) {
                    	        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
                    	        return;
                    	    }
                    
                    	    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
                    	};
                    
                    	/*
                    	* Sets the point 'p' relative to point 'rp'
                    	* by the distance 'd'
                    	*
                    	* See APPENDIX on SETRELATIVE at the bottom of this file.
                    	*
                    	* p   ...  point to set
                    	* rp  ... reference point
                    	* d   ... distance on projection vector
                    	* pv  ... projection vector (undefined = this)
                    	* org ... if true, uses the original position of rp as reference.
                    	*/
                    	UnitVector.prototype.setRelative = function(p, rp, d, pv, org) {
                    	    pv = pv || this;
                    
                    	    var rpx = org ? rp.xo : rp.x;
                    	    var rpy = org ? rp.yo : rp.y;
                    	    var rpdx = rpx + d * pv.x;
                    	    var rpdy = rpy + d * pv.y;
                    
                    	    var pvns = pv.normalSlope;
                    	    var fvs = this.slope;
                    
                    	    var px = p.x;
                    	    var py = p.y;
                    
                    	    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);
                    	    p.y = fvs * (p.x - px) + py;
                    	};
                    
                    	/*
                    	* Touches the point p.
                    	*/
                    	UnitVector.prototype.touch = function(p) {
                    	    p.xTouched = true;
                    	    p.yTouched = true;
                    	};
                    
                    	/*
                    	* Returns a unit vector with x/y coordinates.
                    	*/
                    	function getUnitVector(x, y) {
                    	    var d = Math.sqrt(x * x + y * y);
                    
                    	    x /= d;
                    	    y /= d;
                    
                    	    if (x === 1 && y === 0) { return xUnitVector; }
                    	    else if (x === 0 && y === 1) { return yUnitVector; }
                    	    else { return new UnitVector(x, y); }
                    	}
                    
                    	/*
                    	* Creates a point in the hinting engine.
                    	*/
                    	function HPoint(
                    	    x,
                    	    y,
                    	    lastPointOfContour,
                    	    onCurve
                    	) {
                    	    this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value
                    	    this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value
                    
                    	    this.lastPointOfContour = lastPointOfContour;
                    	    this.onCurve = onCurve;
                    	    this.prevPointOnContour = undefined;
                    	    this.nextPointOnContour = undefined;
                    	    this.xTouched = false;
                    	    this.yTouched = false;
                    
                    	    Object.preventExtensions(this);
                    	}
                    
                    	/*
                    	* Returns the next touched point on the contour.
                    	*
                    	* v  ... unit vector to test touch axis.
                    	*/
                    	HPoint.prototype.nextTouched = function(v) {
                    	    var p = this.nextPointOnContour;
                    
                    	    while (!v.touched(p) && p !== this) { p = p.nextPointOnContour; }
                    
                    	    return p;
                    	};
                    
                    	/*
                    	* Returns the previous touched point on the contour
                    	*
                    	* v  ... unit vector to test touch axis.
                    	*/
                    	HPoint.prototype.prevTouched = function(v) {
                    	    var p = this.prevPointOnContour;
                    
                    	    while (!v.touched(p) && p !== this) { p = p.prevPointOnContour; }
                    
                    	    return p;
                    	};
                    
                    	/*
                    	* The zero point.
                    	*/
                    	var HPZero = Object.freeze(new HPoint(0, 0));
                    
                    	/*
                    	* The default state of the interpreter.
                    	*
                    	* Note: Freezing the defaultState and then deriving from it
                    	* makes the V8 Javascript engine going awkward,
                    	* so this is avoided, albeit the defaultState shouldn't
                    	* ever change.
                    	*/
                    	var defaultState = {
                    	    cvCutIn: 17 / 16,    // control value cut in
                    	    deltaBase: 9,
                    	    deltaShift: 0.125,
                    	    loop: 1,             // loops some instructions
                    	    minDis: 1,           // minimum distance
                    	    autoFlip: true
                    	};
                    
                    	/*
                    	* The current state of the interpreter.
                    	*
                    	* env  ... 'fpgm' or 'prep' or 'glyf'
                    	* prog ... the program
                    	*/
                    	function State(env, prog) {
                    	    this.env = env;
                    	    this.stack = [];
                    	    this.prog = prog;
                    
                    	    switch (env) {
                    	        case 'glyf' :
                    	            this.zp0 = this.zp1 = this.zp2 = 1;
                    	            this.rp0 = this.rp1 = this.rp2 = 0;
                    	            /* fall through */
                    	        case 'prep' :
                    	            this.fv = this.pv = this.dpv = xUnitVector;
                    	            this.round = roundToGrid;
                    	    }
                    	}
                    
                    	/*
                    	* Executes a glyph program.
                    	*
                    	* This does the hinting for each glyph.
                    	*
                    	* Returns an array of moved points.
                    	*
                    	* glyph: the glyph to hint
                    	* ppem: the size the glyph is rendered for
                    	*/
                    	Hinting.prototype.exec = function(glyph, ppem) {
                    	    if (typeof ppem !== 'number') {
                    	        throw new Error('Point size is not a number!');
                    	    }
                    
                    	    // Received a fatal error, don't do any hinting anymore.
                    	    if (this._errorState > 2) { return; }
                    
                    	    var font = this.font;
                    	    var prepState = this._prepState;
                    
                    	    if (!prepState || prepState.ppem !== ppem) {
                    	        var fpgmState = this._fpgmState;
                    
                    	        if (!fpgmState) {
                    	            // Executes the fpgm state.
                    	            // This is used by fonts to define functions.
                    	            State.prototype = defaultState;
                    
                    	            fpgmState =
                    	            this._fpgmState =
                    	                new State('fpgm', font.tables.fpgm);
                    
                    	            fpgmState.funcs = [ ];
                    	            fpgmState.font = font;
                    
                    	            if (exports.DEBUG) {
                    	                console.log('---EXEC FPGM---');
                    	                fpgmState.step = -1;
                    	            }
                    
                    	            try {
                    	                exec(fpgmState);
                    	            } catch (e) {
                    	                console.log('Hinting error in FPGM:' + e);
                    	                this._errorState = 3;
                    	                return;
                    	            }
                    	        }
                    
                    	        // Executes the prep program for this ppem setting.
                    	        // This is used by fonts to set cvt values
                    	        // depending on to be rendered font size.
                    
                    	        State.prototype = fpgmState;
                    	        prepState =
                    	        this._prepState =
                    	            new State('prep', font.tables.prep);
                    
                    	        prepState.ppem = ppem;
                    
                    	        // Creates a copy of the cvt table
                    	        // and scales it to the current ppem setting.
                    	        var oCvt = font.tables.cvt;
                    	        if (oCvt) {
                    	            var cvt = prepState.cvt = new Array(oCvt.length);
                    	            var scale = ppem / font.unitsPerEm;
                    	            for (var c = 0; c < oCvt.length; c++) {
                    	                cvt[c] = oCvt[c] * scale;
                    	            }
                    	        } else {
                    	            prepState.cvt = [];
                    	        }
                    
                    	        if (exports.DEBUG) {
                    	            console.log('---EXEC PREP---');
                    	            prepState.step = -1;
                    	        }
                    
                    	        try {
                    	            exec(prepState);
                    	        } catch (e) {
                    	            if (this._errorState < 2) {
                    	                console.log('Hinting error in PREP:' + e);
                    	            }
                    	            this._errorState = 2;
                    	        }
                    	    }
                    
                    	    if (this._errorState > 1) { return; }
                    
                    	    try {
                    	        return execGlyph(glyph, prepState);
                    	    } catch (e) {
                    	        if (this._errorState < 1) {
                    	            console.log('Hinting error:' + e);
                    	            console.log('Note: further hinting errors are silenced');
                    	        }
                    	        this._errorState = 1;
                    	        return undefined;
                    	    }
                    	};
                    
                    	/*
                    	* Executes the hinting program for a glyph.
                    	*/
                    	execGlyph = function(glyph, prepState) {
                    	    // original point positions
                    	    var xScale = prepState.ppem / prepState.font.unitsPerEm;
                    	    var yScale = xScale;
                    	    var components = glyph.components;
                    	    var contours;
                    	    var gZone;
                    	    var state;
                    
                    	    State.prototype = prepState;
                    	    if (!components) {
                    	        state = new State('glyf', glyph.instructions);
                    	        if (exports.DEBUG) {
                    	            console.log('---EXEC GLYPH---');
                    	            state.step = -1;
                    	        }
                    	        execComponent(glyph, state, xScale, yScale);
                    	        gZone = state.gZone;
                    	    } else {
                    	        var font = prepState.font;
                    	        gZone = [];
                    	        contours = [];
                    	        for (var i = 0; i < components.length; i++) {
                    	            var c = components[i];
                    	            var cg = font.glyphs.get(c.glyphIndex);
                    
                    	            state = new State('glyf', cg.instructions);
                    
                    	            if (exports.DEBUG) {
                    	                console.log('---EXEC COMP ' + i + '---');
                    	                state.step = -1;
                    	            }
                    
                    	            execComponent(cg, state, xScale, yScale);
                    	            // appends the computed points to the result array
                    	            // post processes the component points
                    	            var dx = Math.round(c.dx * xScale);
                    	            var dy = Math.round(c.dy * yScale);
                    	            var gz = state.gZone;
                    	            var cc = state.contours;
                    	            for (var pi = 0; pi < gz.length; pi++) {
                    	                var p = gz[pi];
                    	                p.xTouched = p.yTouched = false;
                    	                p.xo = p.x = p.x + dx;
                    	                p.yo = p.y = p.y + dy;
                    	            }
                    
                    	            var gLen = gZone.length;
                    	            gZone.push.apply(gZone, gz);
                    	            for (var j = 0; j < cc.length; j++) {
                    	                contours.push(cc[j] + gLen);
                    	            }
                    	        }
                    
                    	        if (glyph.instructions && !state.inhibitGridFit) {
                    	            // the composite has instructions on its own
                    	            state = new State('glyf', glyph.instructions);
                    
                    	            state.gZone = state.z0 = state.z1 = state.z2 = gZone;
                    
                    	            state.contours = contours;
                    
                    	            // note: HPZero cannot be used here, since
                    	            //       the point might be modified
                    	            gZone.push(
                    	                new HPoint(0, 0),
                    	                new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
                    	            );
                    
                    	            if (exports.DEBUG) {
                    	                console.log('---EXEC COMPOSITE---');
                    	                state.step = -1;
                    	            }
                    
                    	            exec(state);
                    
                    	            gZone.length -= 2;
                    	        }
                    	    }
                    
                    	    return gZone;
                    	};
                    
                    	/*
                    	* Executes the hinting program for a component of a multi-component glyph
                    	* or of the glyph itself for a non-component glyph.
                    	*/
                    	execComponent = function(glyph, state, xScale, yScale)
                    	{
                    	    var points = glyph.points || [];
                    	    var pLen = points.length;
                    	    var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];
                    	    var contours = state.contours = [];
                    
                    	    // Scales the original points and
                    	    // makes copies for the hinted points.
                    	    var cp; // current point
                    	    for (var i = 0; i < pLen; i++) {
                    	        cp = points[i];
                    
                    	        gZone[i] = new HPoint(
                    	            cp.x * xScale,
                    	            cp.y * yScale,
                    	            cp.lastPointOfContour,
                    	            cp.onCurve
                    	        );
                    	    }
                    
                    	    // Chain links the contours.
                    	    var sp; // start point
                    	    var np; // next point
                    
                    	    for (var i$1 = 0; i$1 < pLen; i$1++) {
                    	        cp = gZone[i$1];
                    
                    	        if (!sp) {
                    	            sp = cp;
                    	            contours.push(i$1);
                    	        }
                    
                    	        if (cp.lastPointOfContour) {
                    	            cp.nextPointOnContour = sp;
                    	            sp.prevPointOnContour = cp;
                    	            sp = undefined;
                    	        } else {
                    	            np = gZone[i$1 + 1];
                    	            cp.nextPointOnContour = np;
                    	            np.prevPointOnContour = cp;
                    	        }
                    	    }
                    
                    	    if (state.inhibitGridFit) { return; }
                    
                    	    if (exports.DEBUG) {
                    	        console.log('PROCESSING GLYPH', state.stack);
                    	        for (var i$2 = 0; i$2 < pLen; i$2++) {
                    	            console.log(i$2, gZone[i$2].x, gZone[i$2].y);
                    	        }
                    	    }
                    
                    	    gZone.push(
                    	        new HPoint(0, 0),
                    	        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
                    	    );
                    
                    	    exec(state);
                    
                    	    // Removes the extra points.
                    	    gZone.length -= 2;
                    
                    	    if (exports.DEBUG) {
                    	        console.log('FINISHED GLYPH', state.stack);
                    	        for (var i$3 = 0; i$3 < pLen; i$3++) {
                    	            console.log(i$3, gZone[i$3].x, gZone[i$3].y);
                    	        }
                    	    }
                    	};
                    
                    	/*
                    	* Executes the program loaded in state.
                    	*/
                    	exec = function(state) {
                    	    var prog = state.prog;
                    
                    	    if (!prog) { return; }
                    
                    	    var pLen = prog.length;
                    	    var ins;
                    
                    	    for (state.ip = 0; state.ip < pLen; state.ip++) {
                    	        if (exports.DEBUG) { state.step++; }
                    	        ins = instructionTable[prog[state.ip]];
                    
                    	        if (!ins) {
                    	            throw new Error(
                    	                'unknown instruction: 0x' +
                    	                Number(prog[state.ip]).toString(16)
                    	            );
                    	        }
                    
                    	        ins(state);
                    
                    	        // very extensive debugging for each step
                    	        /*
                    	        if (exports.DEBUG) {
                    	            var da;
                    	            if (state.gZone) {
                    	                da = [];
                    	                for (let i = 0; i < state.gZone.length; i++)
                    	                {
                    	                    da.push(i + ' ' +
                    	                        state.gZone[i].x * 64 + ' ' +
                    	                        state.gZone[i].y * 64 + ' ' +
                    	                        (state.gZone[i].xTouched ? 'x' : '') +
                    	                        (state.gZone[i].yTouched ? 'y' : '')
                    	                    );
                    	                }
                    	                console.log('GZ', da);
                    	            }
                    
                    	            if (state.tZone) {
                    	                da = [];
                    	                for (let i = 0; i < state.tZone.length; i++) {
                    	                    da.push(i + ' ' +
                    	                        state.tZone[i].x * 64 + ' ' +
                    	                        state.tZone[i].y * 64 + ' ' +
                    	                        (state.tZone[i].xTouched ? 'x' : '') +
                    	                        (state.tZone[i].yTouched ? 'y' : '')
                    	                    );
                    	                }
                    	                console.log('TZ', da);
                    	            }
                    
                    	            if (state.stack.length > 10) {
                    	                console.log(
                    	                    state.stack.length,
                    	                    '...', state.stack.slice(state.stack.length - 10)
                    	                );
                    	            } else {
                    	                console.log(state.stack.length, state.stack);
                    	            }
                    	        }
                    	        */
                    	    }
                    	};
                    
                    	/*
                    	* Initializes the twilight zone.
                    	*
                    	* This is only done if a SZPx instruction
                    	* refers to the twilight zone.
                    	*/
                    	function initTZone(state)
                    	{
                    	    var tZone = state.tZone = new Array(state.gZone.length);
                    
                    	    // no idea if this is actually correct...
                    	    for (var i = 0; i < tZone.length; i++)
                    	    {
                    	        tZone[i] = new HPoint(0, 0);
                    	    }
                    	}
                    
                    	/*
                    	* Skips the instruction pointer ahead over an IF/ELSE block.
                    	* handleElse .. if true breaks on matching ELSE
                    	*/
                    	function skip(state, handleElse)
                    	{
                    	    var prog = state.prog;
                    	    var ip = state.ip;
                    	    var nesting = 1;
                    	    var ins;
                    
                    	    do {
                    	        ins = prog[++ip];
                    	        if (ins === 0x58) // IF
                    	            { nesting++; }
                    	        else if (ins === 0x59) // EIF
                    	            { nesting--; }
                    	        else if (ins === 0x40) // NPUSHB
                    	            { ip += prog[ip + 1] + 1; }
                    	        else if (ins === 0x41) // NPUSHW
                    	            { ip += 2 * prog[ip + 1] + 1; }
                    	        else if (ins >= 0xB0 && ins <= 0xB7) // PUSHB
                    	            { ip += ins - 0xB0 + 1; }
                    	        else if (ins >= 0xB8 && ins <= 0xBF) // PUSHW
                    	            { ip += (ins - 0xB8 + 1) * 2; }
                    	        else if (handleElse && nesting === 1 && ins === 0x1B) // ELSE
                    	            { break; }
                    	    } while (nesting > 0);
                    
                    	    state.ip = ip;
                    	}
                    
                    	/*----------------------------------------------------------*
                    	*          And then a lot of instructions...                *
                    	*----------------------------------------------------------*/
                    
                    	// SVTCA[a] Set freedom and projection Vectors To Coordinate Axis
                    	// 0x00-0x01
                    	function SVTCA(v, state) {
                    	    if (exports.DEBUG) { console.log(state.step, 'SVTCA[' + v.axis + ']'); }
                    
                    	    state.fv = state.pv = state.dpv = v;
                    	}
                    
                    	// SPVTCA[a] Set Projection Vector to Coordinate Axis
                    	// 0x02-0x03
                    	function SPVTCA(v, state) {
                    	    if (exports.DEBUG) { console.log(state.step, 'SPVTCA[' + v.axis + ']'); }
                    
                    	    state.pv = state.dpv = v;
                    	}
                    
                    	// SFVTCA[a] Set Freedom Vector to Coordinate Axis
                    	// 0x04-0x05
                    	function SFVTCA(v, state) {
                    	    if (exports.DEBUG) { console.log(state.step, 'SFVTCA[' + v.axis + ']'); }
                    
                    	    state.fv = v;
                    	}
                    
                    	// SPVTL[a] Set Projection Vector To Line
                    	// 0x06-0x07
                    	function SPVTL(a, state) {
                    	    var stack = state.stack;
                    	    var p2i = stack.pop();
                    	    var p1i = stack.pop();
                    	    var p2 = state.z2[p2i];
                    	    var p1 = state.z1[p1i];
                    
                    	    if (exports.DEBUG) { console.log('SPVTL[' + a + ']', p2i, p1i); }
                    
                    	    var dx;
                    	    var dy;
                    
                    	    if (!a) {
                    	        dx = p1.x - p2.x;
                    	        dy = p1.y - p2.y;
                    	    } else {
                    	        dx = p2.y - p1.y;
                    	        dy = p1.x - p2.x;
                    	    }
                    
                    	    state.pv = state.dpv = getUnitVector(dx, dy);
                    	}
                    
                    	// SFVTL[a] Set Freedom Vector To Line
                    	// 0x08-0x09
                    	function SFVTL(a, state) {
                    	    var stack = state.stack;
                    	    var p2i = stack.pop();
                    	    var p1i = stack.pop();
                    	    var p2 = state.z2[p2i];
                    	    var p1 = state.z1[p1i];
                    
                    	    if (exports.DEBUG) { console.log('SFVTL[' + a + ']', p2i, p1i); }
                    
                    	    var dx;
                    	    var dy;
                    
                    	    if (!a) {
                    	        dx = p1.x - p2.x;
                    	        dy = p1.y - p2.y;
                    	    } else {
                    	        dx = p2.y - p1.y;
                    	        dy = p1.x - p2.x;
                    	    }
                    
                    	    state.fv = getUnitVector(dx, dy);
                    	}
                    
                    	// SPVFS[] Set Projection Vector From Stack
                    	// 0x0A
                    	function SPVFS(state) {
                    	    var stack = state.stack;
                    	    var y = stack.pop();
                    	    var x = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }
                    
                    	    state.pv = state.dpv = getUnitVector(x, y);
                    	}
                    
                    	// SFVFS[] Set Freedom Vector From Stack
                    	// 0x0B
                    	function SFVFS(state) {
                    	    var stack = state.stack;
                    	    var y = stack.pop();
                    	    var x = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }
                    
                    	    state.fv = getUnitVector(x, y);
                    	}
                    
                    	// GPV[] Get Projection Vector
                    	// 0x0C
                    	function GPV(state) {
                    	    var stack = state.stack;
                    	    var pv = state.pv;
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'GPV[]'); }
                    
                    	    stack.push(pv.x * 0x4000);
                    	    stack.push(pv.y * 0x4000);
                    	}
                    
                    	// GFV[] Get Freedom Vector
                    	// 0x0C
                    	function GFV(state) {
                    	    var stack = state.stack;
                    	    var fv = state.fv;
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'GFV[]'); }
                    
                    	    stack.push(fv.x * 0x4000);
                    	    stack.push(fv.y * 0x4000);
                    	}
                    
                    	// SFVTPV[] Set Freedom Vector To Projection Vector
                    	// 0x0E
                    	function SFVTPV(state) {
                    	    state.fv = state.pv;
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'SFVTPV[]'); }
                    	}
                    
                    	// ISECT[] moves point p to the InterSECTion of two lines
                    	// 0x0F
                    	function ISECT(state)
                    	{
                    	    var stack = state.stack;
                    	    var pa0i = stack.pop();
                    	    var pa1i = stack.pop();
                    	    var pb0i = stack.pop();
                    	    var pb1i = stack.pop();
                    	    var pi = stack.pop();
                    	    var z0 = state.z0;
                    	    var z1 = state.z1;
                    	    var pa0 = z0[pa0i];
                    	    var pa1 = z0[pa1i];
                    	    var pb0 = z1[pb0i];
                    	    var pb1 = z1[pb1i];
                    	    var p = state.z2[pi];
                    
                    	    if (exports.DEBUG) { console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi); }
                    
                    	    // math from
                    	    // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line
                    
                    	    var x1 = pa0.x;
                    	    var y1 = pa0.y;
                    	    var x2 = pa1.x;
                    	    var y2 = pa1.y;
                    	    var x3 = pb0.x;
                    	    var y3 = pb0.y;
                    	    var x4 = pb1.x;
                    	    var y4 = pb1.y;
                    
                    	    var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
                    	    var f1 = x1 * y2 - y1 * x2;
                    	    var f2 = x3 * y4 - y3 * x4;
                    
                    	    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;
                    	    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;
                    	}
                    
                    	// SRP0[] Set Reference Point 0
                    	// 0x10
                    	function SRP0(state) {
                    	    state.rp0 = state.stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'SRP0[]', state.rp0); }
                    	}
                    
                    	// SRP1[] Set Reference Point 1
                    	// 0x11
                    	function SRP1(state) {
                    	    state.rp1 = state.stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'SRP1[]', state.rp1); }
                    	}
                    
                    	// SRP1[] Set Reference Point 2
                    	// 0x12
                    	function SRP2(state) {
                    	    state.rp2 = state.stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'SRP2[]', state.rp2); }
                    	}
                    
                    	// SZP0[] Set Zone Pointer 0
                    	// 0x13
                    	function SZP0(state) {
                    	    var n = state.stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'SZP0[]', n); }
                    
                    	    state.zp0 = n;
                    
                    	    switch (n) {
                    	        case 0:
                    	            if (!state.tZone) { initTZone(state); }
                    	            state.z0 = state.tZone;
                    	            break;
                    	        case 1 :
                    	            state.z0 = state.gZone;
                    	            break;
                    	        default :
                    	            throw new Error('Invalid zone pointer');
                    	    }
                    	}
                    
                    	// SZP1[] Set Zone Pointer 1
                    	// 0x14
                    	function SZP1(state) {
                    	    var n = state.stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'SZP1[]', n); }
                    
                    	    state.zp1 = n;
                    
                    	    switch (n) {
                    	        case 0:
                    	            if (!state.tZone) { initTZone(state); }
                    	            state.z1 = state.tZone;
                    	            break;
                    	        case 1 :
                    	            state.z1 = state.gZone;
                    	            break;
                    	        default :
                    	            throw new Error('Invalid zone pointer');
                    	    }
                    	}
                    
                    	// SZP2[] Set Zone Pointer 2
                    	// 0x15
                    	function SZP2(state) {
                    	    var n = state.stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'SZP2[]', n); }
                    
                    	    state.zp2 = n;
                    
                    	    switch (n) {
                    	        case 0:
                    	            if (!state.tZone) { initTZone(state); }
                    	            state.z2 = state.tZone;
                    	            break;
                    	        case 1 :
                    	            state.z2 = state.gZone;
                    	            break;
                    	        default :
                    	            throw new Error('Invalid zone pointer');
                    	    }
                    	}
                    
                    	// SZPS[] Set Zone PointerS
                    	// 0x16
                    	function SZPS(state) {
                    	    var n = state.stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'SZPS[]', n); }
                    
                    	    state.zp0 = state.zp1 = state.zp2 = n;
                    
                    	    switch (n) {
                    	        case 0:
                    	            if (!state.tZone) { initTZone(state); }
                    	            state.z0 = state.z1 = state.z2 = state.tZone;
                    	            break;
                    	        case 1 :
                    	            state.z0 = state.z1 = state.z2 = state.gZone;
                    	            break;
                    	        default :
                    	            throw new Error('Invalid zone pointer');
                    	    }
                    	}
                    
                    	// SLOOP[] Set LOOP variable
                    	// 0x17
                    	function SLOOP(state) {
                    	    state.loop = state.stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'SLOOP[]', state.loop); }
                    	}
                    
                    	// RTG[] Round To Grid
                    	// 0x18
                    	function RTG(state) {
                    	    if (exports.DEBUG) { console.log(state.step, 'RTG[]'); }
                    
                    	    state.round = roundToGrid;
                    	}
                    
                    	// RTHG[] Round To Half Grid
                    	// 0x19
                    	function RTHG(state) {
                    	    if (exports.DEBUG) { console.log(state.step, 'RTHG[]'); }
                    
                    	    state.round = roundToHalfGrid;
                    	}
                    
                    	// SMD[] Set Minimum Distance
                    	// 0x1A
                    	function SMD(state) {
                    	    var d = state.stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'SMD[]', d); }
                    
                    	    state.minDis = d / 0x40;
                    	}
                    
                    	// ELSE[] ELSE clause
                    	// 0x1B
                    	function ELSE(state) {
                    	    // This instruction has been reached by executing a then branch
                    	    // so it just skips ahead until matching EIF.
                    	    //
                    	    // In case the IF was negative the IF[] instruction already
                    	    // skipped forward over the ELSE[]
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'ELSE[]'); }
                    
                    	    skip(state, false);
                    	}
                    
                    	// JMPR[] JuMP Relative
                    	// 0x1C
                    	function JMPR(state) {
                    	    var o = state.stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'JMPR[]', o); }
                    
                    	    // A jump by 1 would do nothing.
                    	    state.ip += o - 1;
                    	}
                    
                    	// SCVTCI[] Set Control Value Table Cut-In
                    	// 0x1D
                    	function SCVTCI(state) {
                    	    var n = state.stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'SCVTCI[]', n); }
                    
                    	    state.cvCutIn = n / 0x40;
                    	}
                    
                    	// DUP[] DUPlicate top stack element
                    	// 0x20
                    	function DUP(state) {
                    	    var stack = state.stack;
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'DUP[]'); }
                    
                    	    stack.push(stack[stack.length - 1]);
                    	}
                    
                    	// POP[] POP top stack element
                    	// 0x21
                    	function POP(state) {
                    	    if (exports.DEBUG) { console.log(state.step, 'POP[]'); }
                    
                    	    state.stack.pop();
                    	}
                    
                    	// CLEAR[] CLEAR the stack
                    	// 0x22
                    	function CLEAR(state) {
                    	    if (exports.DEBUG) { console.log(state.step, 'CLEAR[]'); }
                    
                    	    state.stack.length = 0;
                    	}
                    
                    	// SWAP[] SWAP the top two elements on the stack
                    	// 0x23
                    	function SWAP(state) {
                    	    var stack = state.stack;
                    
                    	    var a = stack.pop();
                    	    var b = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'SWAP[]'); }
                    
                    	    stack.push(a);
                    	    stack.push(b);
                    	}
                    
                    	// DEPTH[] DEPTH of the stack
                    	// 0x24
                    	function DEPTH(state) {
                    	    var stack = state.stack;
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'DEPTH[]'); }
                    
                    	    stack.push(stack.length);
                    	}
                    
                    	// LOOPCALL[] LOOPCALL function
                    	// 0x2A
                    	function LOOPCALL(state) {
                    	    var stack = state.stack;
                    	    var fn = stack.pop();
                    	    var c = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'LOOPCALL[]', fn, c); }
                    
                    	    // saves callers program
                    	    var cip = state.ip;
                    	    var cprog = state.prog;
                    
                    	    state.prog = state.funcs[fn];
                    
                    	    // executes the function
                    	    for (var i = 0; i < c; i++) {
                    	        exec(state);
                    
                    	        if (exports.DEBUG) { console.log(
                    	            ++state.step,
                    	            i + 1 < c ? 'next loopcall' : 'done loopcall',
                    	            i
                    	        ); }
                    	    }
                    
                    	    // restores the callers program
                    	    state.ip = cip;
                    	    state.prog = cprog;
                    	}
                    
                    	// CALL[] CALL function
                    	// 0x2B
                    	function CALL(state) {
                    	    var fn = state.stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'CALL[]', fn); }
                    
                    	    // saves callers program
                    	    var cip = state.ip;
                    	    var cprog = state.prog;
                    
                    	    state.prog = state.funcs[fn];
                    
                    	    // executes the function
                    	    exec(state);
                    
                    	    // restores the callers program
                    	    state.ip = cip;
                    	    state.prog = cprog;
                    
                    	    if (exports.DEBUG) { console.log(++state.step, 'returning from', fn); }
                    	}
                    
                    	// CINDEX[] Copy the INDEXed element to the top of the stack
                    	// 0x25
                    	function CINDEX(state) {
                    	    var stack = state.stack;
                    	    var k = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'CINDEX[]', k); }
                    
                    	    // In case of k == 1, it copies the last element after popping
                    	    // thus stack.length - k.
                    	    stack.push(stack[stack.length - k]);
                    	}
                    
                    	// MINDEX[] Move the INDEXed element to the top of the stack
                    	// 0x26
                    	function MINDEX(state) {
                    	    var stack = state.stack;
                    	    var k = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'MINDEX[]', k); }
                    
                    	    stack.push(stack.splice(stack.length - k, 1)[0]);
                    	}
                    
                    	// FDEF[] Function DEFinition
                    	// 0x2C
                    	function FDEF(state) {
                    	    if (state.env !== 'fpgm') { throw new Error('FDEF not allowed here'); }
                    	    var stack = state.stack;
                    	    var prog = state.prog;
                    	    var ip = state.ip;
                    
                    	    var fn = stack.pop();
                    	    var ipBegin = ip;
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'FDEF[]', fn); }
                    
                    	    while (prog[++ip] !== 0x2D){ }
                    
                    	    state.ip = ip;
                    	    state.funcs[fn] = prog.slice(ipBegin + 1, ip);
                    	}
                    
                    	// MDAP[a] Move Direct Absolute Point
                    	// 0x2E-0x2F
                    	function MDAP(round, state) {
                    	    var pi = state.stack.pop();
                    	    var p = state.z0[pi];
                    	    var fv = state.fv;
                    	    var pv = state.pv;
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'MDAP[' + round + ']', pi); }
                    
                    	    var d = pv.distance(p, HPZero);
                    
                    	    if (round) { d = state.round(d); }
                    
                    	    fv.setRelative(p, HPZero, d, pv);
                    	    fv.touch(p);
                    
                    	    state.rp0 = state.rp1 = pi;
                    	}
                    
                    	// IUP[a] Interpolate Untouched Points through the outline
                    	// 0x30
                    	function IUP(v, state) {
                    	    var z2 = state.z2;
                    	    var pLen = z2.length - 2;
                    	    var cp;
                    	    var pp;
                    	    var np;
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'IUP[' + v.axis + ']'); }
                    
                    	    for (var i = 0; i < pLen; i++) {
                    	        cp = z2[i]; // current point
                    
                    	        // if this point has been touched go on
                    	        if (v.touched(cp)) { continue; }
                    
                    	        pp = cp.prevTouched(v);
                    
                    	        // no point on the contour has been touched?
                    	        if (pp === cp) { continue; }
                    
                    	        np = cp.nextTouched(v);
                    
                    	        if (pp === np) {
                    	            // only one point on the contour has been touched
                    	            // so simply moves the point like that
                    
                    	            v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);
                    	        }
                    
                    	        v.interpolate(cp, pp, np, v);
                    	    }
                    	}
                    
                    	// SHP[] SHift Point using reference point
                    	// 0x32-0x33
                    	function SHP(a, state) {
                    	    var stack = state.stack;
                    	    var rpi = a ? state.rp1 : state.rp2;
                    	    var rp = (a ? state.z0 : state.z1)[rpi];
                    	    var fv = state.fv;
                    	    var pv = state.pv;
                    	    var loop = state.loop;
                    	    var z2 = state.z2;
                    
                    	    while (loop--)
                    	    {
                    	        var pi = stack.pop();
                    	        var p = z2[pi];
                    
                    	        var d = pv.distance(rp, rp, false, true);
                    	        fv.setRelative(p, p, d, pv);
                    	        fv.touch(p);
                    
                    	        if (exports.DEBUG) {
                    	            console.log(
                    	                state.step,
                    	                (state.loop > 1 ?
                    	                   'loop ' + (state.loop - loop) + ': ' :
                    	                   ''
                    	                ) +
                    	                'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi
                    	            );
                    	        }
                    	    }
                    
                    	    state.loop = 1;
                    	}
                    
                    	// SHC[] SHift Contour using reference point
                    	// 0x36-0x37
                    	function SHC(a, state) {
                    	    var stack = state.stack;
                    	    var rpi = a ? state.rp1 : state.rp2;
                    	    var rp = (a ? state.z0 : state.z1)[rpi];
                    	    var fv = state.fv;
                    	    var pv = state.pv;
                    	    var ci = stack.pop();
                    	    var sp = state.z2[state.contours[ci]];
                    	    var p = sp;
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'SHC[' + a + ']', ci); }
                    
                    	    var d = pv.distance(rp, rp, false, true);
                    
                    	    do {
                    	        if (p !== rp) { fv.setRelative(p, p, d, pv); }
                    	        p = p.nextPointOnContour;
                    	    } while (p !== sp);
                    	}
                    
                    	// SHZ[] SHift Zone using reference point
                    	// 0x36-0x37
                    	function SHZ(a, state) {
                    	    var stack = state.stack;
                    	    var rpi = a ? state.rp1 : state.rp2;
                    	    var rp = (a ? state.z0 : state.z1)[rpi];
                    	    var fv = state.fv;
                    	    var pv = state.pv;
                    
                    	    var e = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'SHZ[' + a + ']', e); }
                    
                    	    var z;
                    	    switch (e) {
                    	        case 0 : z = state.tZone; break;
                    	        case 1 : z = state.gZone; break;
                    	        default : throw new Error('Invalid zone');
                    	    }
                    
                    	    var p;
                    	    var d = pv.distance(rp, rp, false, true);
                    	    var pLen = z.length - 2;
                    	    for (var i = 0; i < pLen; i++)
                    	    {
                    	        p = z[i];
                    	        fv.setRelative(p, p, d, pv);
                    	        //if (p !== rp) fv.setRelative(p, p, d, pv);
                    	    }
                    	}
                    
                    	// SHPIX[] SHift point by a PIXel amount
                    	// 0x38
                    	function SHPIX(state) {
                    	    var stack = state.stack;
                    	    var loop = state.loop;
                    	    var fv = state.fv;
                    	    var d = stack.pop() / 0x40;
                    	    var z2 = state.z2;
                    
                    	    while (loop--) {
                    	        var pi = stack.pop();
                    	        var p = z2[pi];
                    
                    	        if (exports.DEBUG) {
                    	            console.log(
                    	                state.step,
                    	                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
                    	                'SHPIX[]', pi, d
                    	            );
                    	        }
                    
                    	        fv.setRelative(p, p, d);
                    	        fv.touch(p);
                    	    }
                    
                    	    state.loop = 1;
                    	}
                    
                    	// IP[] Interpolate Point
                    	// 0x39
                    	function IP(state) {
                    	    var stack = state.stack;
                    	    var rp1i = state.rp1;
                    	    var rp2i = state.rp2;
                    	    var loop = state.loop;
                    	    var rp1 = state.z0[rp1i];
                    	    var rp2 = state.z1[rp2i];
                    	    var fv = state.fv;
                    	    var pv = state.dpv;
                    	    var z2 = state.z2;
                    
                    	    while (loop--) {
                    	        var pi = stack.pop();
                    	        var p = z2[pi];
                    
                    	        if (exports.DEBUG) {
                    	            console.log(
                    	                state.step,
                    	                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
                    	                'IP[]', pi, rp1i, '<->', rp2i
                    	            );
                    	        }
                    
                    	        fv.interpolate(p, rp1, rp2, pv);
                    
                    	        fv.touch(p);
                    	    }
                    
                    	    state.loop = 1;
                    	}
                    
                    	// MSIRP[a] Move Stack Indirect Relative Point
                    	// 0x3A-0x3B
                    	function MSIRP(a, state) {
                    	    var stack = state.stack;
                    	    var d = stack.pop() / 64;
                    	    var pi = stack.pop();
                    	    var p = state.z1[pi];
                    	    var rp0 = state.z0[state.rp0];
                    	    var fv = state.fv;
                    	    var pv = state.pv;
                    
                    	    fv.setRelative(p, rp0, d, pv);
                    	    fv.touch(p);
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'MSIRP[' + a + ']', d, pi); }
                    
                    	    state.rp1 = state.rp0;
                    	    state.rp2 = pi;
                    	    if (a) { state.rp0 = pi; }
                    	}
                    
                    	// ALIGNRP[] Align to reference point.
                    	// 0x3C
                    	function ALIGNRP(state) {
                    	    var stack = state.stack;
                    	    var rp0i = state.rp0;
                    	    var rp0 = state.z0[rp0i];
                    	    var loop = state.loop;
                    	    var fv = state.fv;
                    	    var pv = state.pv;
                    	    var z1 = state.z1;
                    
                    	    while (loop--) {
                    	        var pi = stack.pop();
                    	        var p = z1[pi];
                    
                    	        if (exports.DEBUG) {
                    	            console.log(
                    	                state.step,
                    	                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
                    	                'ALIGNRP[]', pi
                    	            );
                    	        }
                    
                    	        fv.setRelative(p, rp0, 0, pv);
                    	        fv.touch(p);
                    	    }
                    
                    	    state.loop = 1;
                    	}
                    
                    	// RTG[] Round To Double Grid
                    	// 0x3D
                    	function RTDG(state) {
                    	    if (exports.DEBUG) { console.log(state.step, 'RTDG[]'); }
                    
                    	    state.round = roundToDoubleGrid;
                    	}
                    
                    	// MIAP[a] Move Indirect Absolute Point
                    	// 0x3E-0x3F
                    	function MIAP(round, state) {
                    	    var stack = state.stack;
                    	    var n = stack.pop();
                    	    var pi = stack.pop();
                    	    var p = state.z0[pi];
                    	    var fv = state.fv;
                    	    var pv = state.pv;
                    	    var cv = state.cvt[n];
                    
                    	    if (exports.DEBUG) {
                    	        console.log(
                    	            state.step,
                    	            'MIAP[' + round + ']',
                    	            n, '(', cv, ')', pi
                    	        );
                    	    }
                    
                    	    var d = pv.distance(p, HPZero);
                    
                    	    if (round) {
                    	        if (Math.abs(d - cv) < state.cvCutIn) { d = cv; }
                    
                    	        d = state.round(d);
                    	    }
                    
                    	    fv.setRelative(p, HPZero, d, pv);
                    
                    	    if (state.zp0 === 0) {
                    	        p.xo = p.x;
                    	        p.yo = p.y;
                    	    }
                    
                    	    fv.touch(p);
                    
                    	    state.rp0 = state.rp1 = pi;
                    	}
                    
                    	// NPUSB[] PUSH N Bytes
                    	// 0x40
                    	function NPUSHB(state) {
                    	    var prog = state.prog;
                    	    var ip = state.ip;
                    	    var stack = state.stack;
                    
                    	    var n = prog[++ip];
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'NPUSHB[]', n); }
                    
                    	    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }
                    
                    	    state.ip = ip;
                    	}
                    
                    	// NPUSHW[] PUSH N Words
                    	// 0x41
                    	function NPUSHW(state) {
                    	    var ip = state.ip;
                    	    var prog = state.prog;
                    	    var stack = state.stack;
                    	    var n = prog[++ip];
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'NPUSHW[]', n); }
                    
                    	    for (var i = 0; i < n; i++) {
                    	        var w = (prog[++ip] << 8) | prog[++ip];
                    	        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }
                    	        stack.push(w);
                    	    }
                    
                    	    state.ip = ip;
                    	}
                    
                    	// WS[] Write Store
                    	// 0x42
                    	function WS(state) {
                    	    var stack = state.stack;
                    	    var store = state.store;
                    
                    	    if (!store) { store = state.store = []; }
                    
                    	    var v = stack.pop();
                    	    var l = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'WS', v, l); }
                    
                    	    store[l] = v;
                    	}
                    
                    	// RS[] Read Store
                    	// 0x43
                    	function RS(state) {
                    	    var stack = state.stack;
                    	    var store = state.store;
                    
                    	    var l = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'RS', l); }
                    
                    	    var v = (store && store[l]) || 0;
                    
                    	    stack.push(v);
                    	}
                    
                    	// WCVTP[] Write Control Value Table in Pixel units
                    	// 0x44
                    	function WCVTP(state) {
                    	    var stack = state.stack;
                    
                    	    var v = stack.pop();
                    	    var l = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'WCVTP', v, l); }
                    
                    	    state.cvt[l] = v / 0x40;
                    	}
                    
                    	// RCVT[] Read Control Value Table entry
                    	// 0x45
                    	function RCVT(state) {
                    	    var stack = state.stack;
                    	    var cvte = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'RCVT', cvte); }
                    
                    	    stack.push(state.cvt[cvte] * 0x40);
                    	}
                    
                    	// GC[] Get Coordinate projected onto the projection vector
                    	// 0x46-0x47
                    	function GC(a, state) {
                    	    var stack = state.stack;
                    	    var pi = stack.pop();
                    	    var p = state.z2[pi];
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'GC[' + a + ']', pi); }
                    
                    	    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);
                    	}
                    
                    	// MD[a] Measure Distance
                    	// 0x49-0x4A
                    	function MD(a, state) {
                    	    var stack = state.stack;
                    	    var pi2 = stack.pop();
                    	    var pi1 = stack.pop();
                    	    var p2 = state.z1[pi2];
                    	    var p1 = state.z0[pi1];
                    	    var d = state.dpv.distance(p1, p2, a, a);
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d); }
                    
                    	    state.stack.push(Math.round(d * 64));
                    	}
                    
                    	// MPPEM[] Measure Pixels Per EM
                    	// 0x4B
                    	function MPPEM(state) {
                    	    if (exports.DEBUG) { console.log(state.step, 'MPPEM[]'); }
                    	    state.stack.push(state.ppem);
                    	}
                    
                    	// FLIPON[] set the auto FLIP Boolean to ON
                    	// 0x4D
                    	function FLIPON(state) {
                    	    if (exports.DEBUG) { console.log(state.step, 'FLIPON[]'); }
                    	    state.autoFlip = true;
                    	}
                    
                    	// LT[] Less Than
                    	// 0x50
                    	function LT(state) {
                    	    var stack = state.stack;
                    	    var e2 = stack.pop();
                    	    var e1 = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'LT[]', e2, e1); }
                    
                    	    stack.push(e1 < e2 ? 1 : 0);
                    	}
                    
                    	// LTEQ[] Less Than or EQual
                    	// 0x53
                    	function LTEQ(state) {
                    	    var stack = state.stack;
                    	    var e2 = stack.pop();
                    	    var e1 = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'LTEQ[]', e2, e1); }
                    
                    	    stack.push(e1 <= e2 ? 1 : 0);
                    	}
                    
                    	// GTEQ[] Greater Than
                    	// 0x52
                    	function GT(state) {
                    	    var stack = state.stack;
                    	    var e2 = stack.pop();
                    	    var e1 = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'GT[]', e2, e1); }
                    
                    	    stack.push(e1 > e2 ? 1 : 0);
                    	}
                    
                    	// GTEQ[] Greater Than or EQual
                    	// 0x53
                    	function GTEQ(state) {
                    	    var stack = state.stack;
                    	    var e2 = stack.pop();
                    	    var e1 = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'GTEQ[]', e2, e1); }
                    
                    	    stack.push(e1 >= e2 ? 1 : 0);
                    	}
                    
                    	// EQ[] EQual
                    	// 0x54
                    	function EQ(state) {
                    	    var stack = state.stack;
                    	    var e2 = stack.pop();
                    	    var e1 = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'EQ[]', e2, e1); }
                    
                    	    stack.push(e2 === e1 ? 1 : 0);
                    	}
                    
                    	// NEQ[] Not EQual
                    	// 0x55
                    	function NEQ(state) {
                    	    var stack = state.stack;
                    	    var e2 = stack.pop();
                    	    var e1 = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'NEQ[]', e2, e1); }
                    
                    	    stack.push(e2 !== e1 ? 1 : 0);
                    	}
                    
                    	// ODD[] ODD
                    	// 0x56
                    	function ODD(state) {
                    	    var stack = state.stack;
                    	    var n = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'ODD[]', n); }
                    
                    	    stack.push(Math.trunc(n) % 2 ? 1 : 0);
                    	}
                    
                    	// EVEN[] EVEN
                    	// 0x57
                    	function EVEN(state) {
                    	    var stack = state.stack;
                    	    var n = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'EVEN[]', n); }
                    
                    	    stack.push(Math.trunc(n) % 2 ? 0 : 1);
                    	}
                    
                    	// IF[] IF test
                    	// 0x58
                    	function IF(state) {
                    	    var test = state.stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'IF[]', test); }
                    
                    	    // if test is true it just continues
                    	    // if not the ip is skipped until matching ELSE or EIF
                    	    if (!test) {
                    	        skip(state, true);
                    
                    	        if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }
                    	    }
                    	}
                    
                    	// EIF[] End IF
                    	// 0x59
                    	function EIF(state) {
                    	    // this can be reached normally when
                    	    // executing an else branch.
                    	    // -> just ignore it
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }
                    	}
                    
                    	// AND[] logical AND
                    	// 0x5A
                    	function AND(state) {
                    	    var stack = state.stack;
                    	    var e2 = stack.pop();
                    	    var e1 = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'AND[]', e2, e1); }
                    
                    	    stack.push(e2 && e1 ? 1 : 0);
                    	}
                    
                    	// OR[] logical OR
                    	// 0x5B
                    	function OR(state) {
                    	    var stack = state.stack;
                    	    var e2 = stack.pop();
                    	    var e1 = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'OR[]', e2, e1); }
                    
                    	    stack.push(e2 || e1 ? 1 : 0);
                    	}
                    
                    	// NOT[] logical NOT
                    	// 0x5C
                    	function NOT(state) {
                    	    var stack = state.stack;
                    	    var e = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'NOT[]', e); }
                    
                    	    stack.push(e ? 0 : 1);
                    	}
                    
                    	// DELTAP1[] DELTA exception P1
                    	// DELTAP2[] DELTA exception P2
                    	// DELTAP3[] DELTA exception P3
                    	// 0x5D, 0x71, 0x72
                    	function DELTAP123(b, state) {
                    	    var stack = state.stack;
                    	    var n = stack.pop();
                    	    var fv = state.fv;
                    	    var pv = state.pv;
                    	    var ppem = state.ppem;
                    	    var base = state.deltaBase + (b - 1) * 16;
                    	    var ds = state.deltaShift;
                    	    var z0 = state.z0;
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'DELTAP[' + b + ']', n, stack); }
                    
                    	    for (var i = 0; i < n; i++) {
                    	        var pi = stack.pop();
                    	        var arg = stack.pop();
                    	        var appem = base + ((arg & 0xF0) >> 4);
                    	        if (appem !== ppem) { continue; }
                    
                    	        var mag = (arg & 0x0F) - 8;
                    	        if (mag >= 0) { mag++; }
                    	        if (exports.DEBUG) { console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds); }
                    
                    	        var p = z0[pi];
                    	        fv.setRelative(p, p, mag * ds, pv);
                    	    }
                    	}
                    
                    	// SDB[] Set Delta Base in the graphics state
                    	// 0x5E
                    	function SDB(state) {
                    	    var stack = state.stack;
                    	    var n = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'SDB[]', n); }
                    
                    	    state.deltaBase = n;
                    	}
                    
                    	// SDS[] Set Delta Shift in the graphics state
                    	// 0x5F
                    	function SDS(state) {
                    	    var stack = state.stack;
                    	    var n = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'SDS[]', n); }
                    
                    	    state.deltaShift = Math.pow(0.5, n);
                    	}
                    
                    	// ADD[] ADD
                    	// 0x60
                    	function ADD(state) {
                    	    var stack = state.stack;
                    	    var n2 = stack.pop();
                    	    var n1 = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'ADD[]', n2, n1); }
                    
                    	    stack.push(n1 + n2);
                    	}
                    
                    	// SUB[] SUB
                    	// 0x61
                    	function SUB(state) {
                    	    var stack = state.stack;
                    	    var n2 = stack.pop();
                    	    var n1 = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'SUB[]', n2, n1); }
                    
                    	    stack.push(n1 - n2);
                    	}
                    
                    	// DIV[] DIV
                    	// 0x62
                    	function DIV(state) {
                    	    var stack = state.stack;
                    	    var n2 = stack.pop();
                    	    var n1 = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'DIV[]', n2, n1); }
                    
                    	    stack.push(n1 * 64 / n2);
                    	}
                    
                    	// MUL[] MUL
                    	// 0x63
                    	function MUL(state) {
                    	    var stack = state.stack;
                    	    var n2 = stack.pop();
                    	    var n1 = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'MUL[]', n2, n1); }
                    
                    	    stack.push(n1 * n2 / 64);
                    	}
                    
                    	// ABS[] ABSolute value
                    	// 0x64
                    	function ABS(state) {
                    	    var stack = state.stack;
                    	    var n = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'ABS[]', n); }
                    
                    	    stack.push(Math.abs(n));
                    	}
                    
                    	// NEG[] NEGate
                    	// 0x65
                    	function NEG(state) {
                    	    var stack = state.stack;
                    	    var n = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'NEG[]', n); }
                    
                    	    stack.push(-n);
                    	}
                    
                    	// FLOOR[] FLOOR
                    	// 0x66
                    	function FLOOR(state) {
                    	    var stack = state.stack;
                    	    var n = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'FLOOR[]', n); }
                    
                    	    stack.push(Math.floor(n / 0x40) * 0x40);
                    	}
                    
                    	// CEILING[] CEILING
                    	// 0x67
                    	function CEILING(state) {
                    	    var stack = state.stack;
                    	    var n = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'CEILING[]', n); }
                    
                    	    stack.push(Math.ceil(n / 0x40) * 0x40);
                    	}
                    
                    	// ROUND[ab] ROUND value
                    	// 0x68-0x6B
                    	function ROUND(dt, state) {
                    	    var stack = state.stack;
                    	    var n = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'ROUND[]'); }
                    
                    	    stack.push(state.round(n / 0x40) * 0x40);
                    	}
                    
                    	// WCVTF[] Write Control Value Table in Funits
                    	// 0x70
                    	function WCVTF(state) {
                    	    var stack = state.stack;
                    	    var v = stack.pop();
                    	    var l = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'WCVTF[]', v, l); }
                    
                    	    state.cvt[l] = v * state.ppem / state.font.unitsPerEm;
                    	}
                    
                    	// DELTAC1[] DELTA exception C1
                    	// DELTAC2[] DELTA exception C2
                    	// DELTAC3[] DELTA exception C3
                    	// 0x73, 0x74, 0x75
                    	function DELTAC123(b, state) {
                    	    var stack = state.stack;
                    	    var n = stack.pop();
                    	    var ppem = state.ppem;
                    	    var base = state.deltaBase + (b - 1) * 16;
                    	    var ds = state.deltaShift;
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'DELTAC[' + b + ']', n, stack); }
                    
                    	    for (var i = 0; i < n; i++) {
                    	        var c = stack.pop();
                    	        var arg = stack.pop();
                    	        var appem = base + ((arg & 0xF0) >> 4);
                    	        if (appem !== ppem) { continue; }
                    
                    	        var mag = (arg & 0x0F) - 8;
                    	        if (mag >= 0) { mag++; }
                    
                    	        var delta = mag * ds;
                    
                    	        if (exports.DEBUG) { console.log(state.step, 'DELTACFIX', c, 'by', delta); }
                    
                    	        state.cvt[c] += delta;
                    	    }
                    	}
                    
                    	// SROUND[] Super ROUND
                    	// 0x76
                    	function SROUND(state) {
                    	    var n = state.stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'SROUND[]', n); }
                    
                    	    state.round = roundSuper;
                    
                    	    var period;
                    
                    	    switch (n & 0xC0) {
                    	        case 0x00:
                    	            period = 0.5;
                    	            break;
                    	        case 0x40:
                    	            period = 1;
                    	            break;
                    	        case 0x80:
                    	            period = 2;
                    	            break;
                    	        default:
                    	            throw new Error('invalid SROUND value');
                    	    }
                    
                    	    state.srPeriod = period;
                    
                    	    switch (n & 0x30) {
                    	        case 0x00:
                    	            state.srPhase = 0;
                    	            break;
                    	        case 0x10:
                    	            state.srPhase = 0.25 * period;
                    	            break;
                    	        case 0x20:
                    	            state.srPhase = 0.5  * period;
                    	            break;
                    	        case 0x30:
                    	            state.srPhase = 0.75 * period;
                    	            break;
                    	        default: throw new Error('invalid SROUND value');
                    	    }
                    
                    	    n &= 0x0F;
                    
                    	    if (n === 0) { state.srThreshold = 0; }
                    	    else { state.srThreshold = (n / 8 - 0.5) * period; }
                    	}
                    
                    	// S45ROUND[] Super ROUND 45 degrees
                    	// 0x77
                    	function S45ROUND(state) {
                    	    var n = state.stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'S45ROUND[]', n); }
                    
                    	    state.round = roundSuper;
                    
                    	    var period;
                    
                    	    switch (n & 0xC0) {
                    	        case 0x00:
                    	            period = Math.sqrt(2) / 2;
                    	            break;
                    	        case 0x40:
                    	            period = Math.sqrt(2);
                    	            break;
                    	        case 0x80:
                    	            period = 2 * Math.sqrt(2);
                    	            break;
                    	        default:
                    	            throw new Error('invalid S45ROUND value');
                    	    }
                    
                    	    state.srPeriod = period;
                    
                    	    switch (n & 0x30) {
                    	        case 0x00:
                    	            state.srPhase = 0;
                    	            break;
                    	        case 0x10:
                    	            state.srPhase = 0.25 * period;
                    	            break;
                    	        case 0x20:
                    	            state.srPhase = 0.5  * period;
                    	            break;
                    	        case 0x30:
                    	            state.srPhase = 0.75 * period;
                    	            break;
                    	        default:
                    	            throw new Error('invalid S45ROUND value');
                    	    }
                    
                    	    n &= 0x0F;
                    
                    	    if (n === 0) { state.srThreshold = 0; }
                    	    else { state.srThreshold = (n / 8 - 0.5) * period; }
                    	}
                    
                    	// ROFF[] Round Off
                    	// 0x7A
                    	function ROFF(state) {
                    	    if (exports.DEBUG) { console.log(state.step, 'ROFF[]'); }
                    
                    	    state.round = roundOff;
                    	}
                    
                    	// RUTG[] Round Up To Grid
                    	// 0x7C
                    	function RUTG(state) {
                    	    if (exports.DEBUG) { console.log(state.step, 'RUTG[]'); }
                    
                    	    state.round = roundUpToGrid;
                    	}
                    
                    	// RDTG[] Round Down To Grid
                    	// 0x7D
                    	function RDTG(state) {
                    	    if (exports.DEBUG) { console.log(state.step, 'RDTG[]'); }
                    
                    	    state.round = roundDownToGrid;
                    	}
                    
                    	// SCANCTRL[] SCAN conversion ConTRoL
                    	// 0x85
                    	function SCANCTRL(state) {
                    	    var n = state.stack.pop();
                    
                    	    // ignored by opentype.js
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'SCANCTRL[]', n); }
                    	}
                    
                    	// SDPVTL[a] Set Dual Projection Vector To Line
                    	// 0x86-0x87
                    	function SDPVTL(a, state) {
                    	    var stack = state.stack;
                    	    var p2i = stack.pop();
                    	    var p1i = stack.pop();
                    	    var p2 = state.z2[p2i];
                    	    var p1 = state.z1[p1i];
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'SDPVTL[' + a + ']', p2i, p1i); }
                    
                    	    var dx;
                    	    var dy;
                    
                    	    if (!a) {
                    	        dx = p1.x - p2.x;
                    	        dy = p1.y - p2.y;
                    	    } else {
                    	        dx = p2.y - p1.y;
                    	        dy = p1.x - p2.x;
                    	    }
                    
                    	    state.dpv = getUnitVector(dx, dy);
                    	}
                    
                    	// GETINFO[] GET INFOrmation
                    	// 0x88
                    	function GETINFO(state) {
                    	    var stack = state.stack;
                    	    var sel = stack.pop();
                    	    var r = 0;
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'GETINFO[]', sel); }
                    
                    	    // v35 as in no subpixel hinting
                    	    if (sel & 0x01) { r = 35; }
                    
                    	    // TODO rotation and stretch currently not supported
                    	    // and thus those GETINFO are always 0.
                    
                    	    // opentype.js is always gray scaling
                    	    if (sel & 0x20) { r |= 0x1000; }
                    
                    	    stack.push(r);
                    	}
                    
                    	// ROLL[] ROLL the top three stack elements
                    	// 0x8A
                    	function ROLL(state) {
                    	    var stack = state.stack;
                    	    var a = stack.pop();
                    	    var b = stack.pop();
                    	    var c = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'ROLL[]'); }
                    
                    	    stack.push(b);
                    	    stack.push(a);
                    	    stack.push(c);
                    	}
                    
                    	// MAX[] MAXimum of top two stack elements
                    	// 0x8B
                    	function MAX(state) {
                    	    var stack = state.stack;
                    	    var e2 = stack.pop();
                    	    var e1 = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'MAX[]', e2, e1); }
                    
                    	    stack.push(Math.max(e1, e2));
                    	}
                    
                    	// MIN[] MINimum of top two stack elements
                    	// 0x8C
                    	function MIN(state) {
                    	    var stack = state.stack;
                    	    var e2 = stack.pop();
                    	    var e1 = stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'MIN[]', e2, e1); }
                    
                    	    stack.push(Math.min(e1, e2));
                    	}
                    
                    	// SCANTYPE[] SCANTYPE
                    	// 0x8D
                    	function SCANTYPE(state) {
                    	    var n = state.stack.pop();
                    	    // ignored by opentype.js
                    	    if (exports.DEBUG) { console.log(state.step, 'SCANTYPE[]', n); }
                    	}
                    
                    	// INSTCTRL[] INSTCTRL
                    	// 0x8D
                    	function INSTCTRL(state) {
                    	    var s = state.stack.pop();
                    	    var v = state.stack.pop();
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'INSTCTRL[]', s, v); }
                    
                    	    switch (s) {
                    	        case 1 : state.inhibitGridFit = !!v; return;
                    	        case 2 : state.ignoreCvt = !!v; return;
                    	        default: throw new Error('invalid INSTCTRL[] selector');
                    	    }
                    	}
                    
                    	// PUSHB[abc] PUSH Bytes
                    	// 0xB0-0xB7
                    	function PUSHB(n, state) {
                    	    var stack = state.stack;
                    	    var prog = state.prog;
                    	    var ip = state.ip;
                    
                    	    if (exports.DEBUG) { console.log(state.step, 'PUSHB[' + n + ']'); }
                    
                    	    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }
                    
                    	    state.ip = ip;
                    	}
                    
                    	// PUSHW[abc] PUSH Words
                    	// 0xB8-0xBF
                    	function PUSHW(n, state) {
                    	    var ip = state.ip;
                    	    var prog = state.prog;
                    	    var stack = state.stack;
                    
                    	    if (exports.DEBUG) { console.log(state.ip, 'PUSHW[' + n + ']'); }
                    
                    	    for (var i = 0; i < n; i++) {
                    	        var w = (prog[++ip] << 8) | prog[++ip];
                    	        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }
                    	        stack.push(w);
                    	    }
                    
                    	    state.ip = ip;
                    	}
                    
                    	// MDRP[abcde] Move Direct Relative Point
                    	// 0xD0-0xEF
                    	// (if indirect is 0)
                    	//
                    	// and
                    	//
                    	// MIRP[abcde] Move Indirect Relative Point
                    	// 0xE0-0xFF
                    	// (if indirect is 1)
                    
                    	function MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {
                    	    var stack = state.stack;
                    	    var cvte = indirect && stack.pop();
                    	    var pi = stack.pop();
                    	    var rp0i = state.rp0;
                    	    var rp = state.z0[rp0i];
                    	    var p = state.z1[pi];
                    
                    	    var md = state.minDis;
                    	    var fv = state.fv;
                    	    var pv = state.dpv;
                    	    var od; // original distance
                    	    var d; // moving distance
                    	    var sign; // sign of distance
                    	    var cv;
                    
                    	    d = od = pv.distance(p, rp, true, true);
                    	    sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0
                    
                    	    // TODO consider autoFlip
                    	    d = Math.abs(d);
                    
                    	    if (indirect) {
                    	        cv = state.cvt[cvte];
                    
                    	        if (ro && Math.abs(d - cv) < state.cvCutIn) { d = cv; }
                    	    }
                    
                    	    if (keepD && d < md) { d = md; }
                    
                    	    if (ro) { d = state.round(d); }
                    
                    	    fv.setRelative(p, rp, sign * d, pv);
                    	    fv.touch(p);
                    
                    	    if (exports.DEBUG) {
                    	        console.log(
                    	            state.step,
                    	            (indirect ? 'MIRP[' : 'MDRP[') +
                    	            (setRp0 ? 'M' : 'm') +
                    	            (keepD ? '>' : '_') +
                    	            (ro ? 'R' : '_') +
                    	            (dt === 0 ? 'Gr' : (dt === 1 ? 'Bl' : (dt === 2 ? 'Wh' : ''))) +
                    	            ']',
                    	            indirect ?
                    	                cvte + '(' + state.cvt[cvte] + ',' +  cv + ')' :
                    	                '',
                    	            pi,
                    	            '(d =', od, '->', sign * d, ')'
                    	        );
                    	    }
                    
                    	    state.rp1 = state.rp0;
                    	    state.rp2 = pi;
                    	    if (setRp0) { state.rp0 = pi; }
                    	}
                    
                    	/*
                    	* The instruction table.
                    	*/
                    	instructionTable = [
                    	    /* 0x00 */ SVTCA.bind(undefined, yUnitVector),
                    	    /* 0x01 */ SVTCA.bind(undefined, xUnitVector),
                    	    /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),
                    	    /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),
                    	    /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),
                    	    /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),
                    	    /* 0x06 */ SPVTL.bind(undefined, 0),
                    	    /* 0x07 */ SPVTL.bind(undefined, 1),
                    	    /* 0x08 */ SFVTL.bind(undefined, 0),
                    	    /* 0x09 */ SFVTL.bind(undefined, 1),
                    	    /* 0x0A */ SPVFS,
                    	    /* 0x0B */ SFVFS,
                    	    /* 0x0C */ GPV,
                    	    /* 0x0D */ GFV,
                    	    /* 0x0E */ SFVTPV,
                    	    /* 0x0F */ ISECT,
                    	    /* 0x10 */ SRP0,
                    	    /* 0x11 */ SRP1,
                    	    /* 0x12 */ SRP2,
                    	    /* 0x13 */ SZP0,
                    	    /* 0x14 */ SZP1,
                    	    /* 0x15 */ SZP2,
                    	    /* 0x16 */ SZPS,
                    	    /* 0x17 */ SLOOP,
                    	    /* 0x18 */ RTG,
                    	    /* 0x19 */ RTHG,
                    	    /* 0x1A */ SMD,
                    	    /* 0x1B */ ELSE,
                    	    /* 0x1C */ JMPR,
                    	    /* 0x1D */ SCVTCI,
                    	    /* 0x1E */ undefined,   // TODO SSWCI
                    	    /* 0x1F */ undefined,   // TODO SSW
                    	    /* 0x20 */ DUP,
                    	    /* 0x21 */ POP,
                    	    /* 0x22 */ CLEAR,
                    	    /* 0x23 */ SWAP,
                    	    /* 0x24 */ DEPTH,
                    	    /* 0x25 */ CINDEX,
                    	    /* 0x26 */ MINDEX,
                    	    /* 0x27 */ undefined,   // TODO ALIGNPTS
                    	    /* 0x28 */ undefined,
                    	    /* 0x29 */ undefined,   // TODO UTP
                    	    /* 0x2A */ LOOPCALL,
                    	    /* 0x2B */ CALL,
                    	    /* 0x2C */ FDEF,
                    	    /* 0x2D */ undefined,   // ENDF (eaten by FDEF)
                    	    /* 0x2E */ MDAP.bind(undefined, 0),
                    	    /* 0x2F */ MDAP.bind(undefined, 1),
                    	    /* 0x30 */ IUP.bind(undefined, yUnitVector),
                    	    /* 0x31 */ IUP.bind(undefined, xUnitVector),
                    	    /* 0x32 */ SHP.bind(undefined, 0),
                    	    /* 0x33 */ SHP.bind(undefined, 1),
                    	    /* 0x34 */ SHC.bind(undefined, 0),
                    	    /* 0x35 */ SHC.bind(undefined, 1),
                    	    /* 0x36 */ SHZ.bind(undefined, 0),
                    	    /* 0x37 */ SHZ.bind(undefined, 1),
                    	    /* 0x38 */ SHPIX,
                    	    /* 0x39 */ IP,
                    	    /* 0x3A */ MSIRP.bind(undefined, 0),
                    	    /* 0x3B */ MSIRP.bind(undefined, 1),
                    	    /* 0x3C */ ALIGNRP,
                    	    /* 0x3D */ RTDG,
                    	    /* 0x3E */ MIAP.bind(undefined, 0),
                    	    /* 0x3F */ MIAP.bind(undefined, 1),
                    	    /* 0x40 */ NPUSHB,
                    	    /* 0x41 */ NPUSHW,
                    	    /* 0x42 */ WS,
                    	    /* 0x43 */ RS,
                    	    /* 0x44 */ WCVTP,
                    	    /* 0x45 */ RCVT,
                    	    /* 0x46 */ GC.bind(undefined, 0),
                    	    /* 0x47 */ GC.bind(undefined, 1),
                    	    /* 0x48 */ undefined,   // TODO SCFS
                    	    /* 0x49 */ MD.bind(undefined, 0),
                    	    /* 0x4A */ MD.bind(undefined, 1),
                    	    /* 0x4B */ MPPEM,
                    	    /* 0x4C */ undefined,   // TODO MPS
                    	    /* 0x4D */ FLIPON,
                    	    /* 0x4E */ undefined,   // TODO FLIPOFF
                    	    /* 0x4F */ undefined,   // TODO DEBUG
                    	    /* 0x50 */ LT,
                    	    /* 0x51 */ LTEQ,
                    	    /* 0x52 */ GT,
                    	    /* 0x53 */ GTEQ,
                    	    /* 0x54 */ EQ,
                    	    /* 0x55 */ NEQ,
                    	    /* 0x56 */ ODD,
                    	    /* 0x57 */ EVEN,
                    	    /* 0x58 */ IF,
                    	    /* 0x59 */ EIF,
                    	    /* 0x5A */ AND,
                    	    /* 0x5B */ OR,
                    	    /* 0x5C */ NOT,
                    	    /* 0x5D */ DELTAP123.bind(undefined, 1),
                    	    /* 0x5E */ SDB,
                    	    /* 0x5F */ SDS,
                    	    /* 0x60 */ ADD,
                    	    /* 0x61 */ SUB,
                    	    /* 0x62 */ DIV,
                    	    /* 0x63 */ MUL,
                    	    /* 0x64 */ ABS,
                    	    /* 0x65 */ NEG,
                    	    /* 0x66 */ FLOOR,
                    	    /* 0x67 */ CEILING,
                    	    /* 0x68 */ ROUND.bind(undefined, 0),
                    	    /* 0x69 */ ROUND.bind(undefined, 1),
                    	    /* 0x6A */ ROUND.bind(undefined, 2),
                    	    /* 0x6B */ ROUND.bind(undefined, 3),
                    	    /* 0x6C */ undefined,   // TODO NROUND[ab]
                    	    /* 0x6D */ undefined,   // TODO NROUND[ab]
                    	    /* 0x6E */ undefined,   // TODO NROUND[ab]
                    	    /* 0x6F */ undefined,   // TODO NROUND[ab]
                    	    /* 0x70 */ WCVTF,
                    	    /* 0x71 */ DELTAP123.bind(undefined, 2),
                    	    /* 0x72 */ DELTAP123.bind(undefined, 3),
                    	    /* 0x73 */ DELTAC123.bind(undefined, 1),
                    	    /* 0x74 */ DELTAC123.bind(undefined, 2),
                    	    /* 0x75 */ DELTAC123.bind(undefined, 3),
                    	    /* 0x76 */ SROUND,
                    	    /* 0x77 */ S45ROUND,
                    	    /* 0x78 */ undefined,   // TODO JROT[]
                    	    /* 0x79 */ undefined,   // TODO JROF[]
                    	    /* 0x7A */ ROFF,
                    	    /* 0x7B */ undefined,
                    	    /* 0x7C */ RUTG,
                    	    /* 0x7D */ RDTG,
                    	    /* 0x7E */ POP, // actually SANGW, supposed to do only a pop though
                    	    /* 0x7F */ POP, // actually AA, supposed to do only a pop though
                    	    /* 0x80 */ undefined,   // TODO FLIPPT
                    	    /* 0x81 */ undefined,   // TODO FLIPRGON
                    	    /* 0x82 */ undefined,   // TODO FLIPRGOFF
                    	    /* 0x83 */ undefined,
                    	    /* 0x84 */ undefined,
                    	    /* 0x85 */ SCANCTRL,
                    	    /* 0x86 */ SDPVTL.bind(undefined, 0),
                    	    /* 0x87 */ SDPVTL.bind(undefined, 1),
                    	    /* 0x88 */ GETINFO,
                    	    /* 0x89 */ undefined,   // TODO IDEF
                    	    /* 0x8A */ ROLL,
                    	    /* 0x8B */ MAX,
                    	    /* 0x8C */ MIN,
                    	    /* 0x8D */ SCANTYPE,
                    	    /* 0x8E */ INSTCTRL,
                    	    /* 0x8F */ undefined,
                    	    /* 0x90 */ undefined,
                    	    /* 0x91 */ undefined,
                    	    /* 0x92 */ undefined,
                    	    /* 0x93 */ undefined,
                    	    /* 0x94 */ undefined,
                    	    /* 0x95 */ undefined,
                    	    /* 0x96 */ undefined,
                    	    /* 0x97 */ undefined,
                    	    /* 0x98 */ undefined,
                    	    /* 0x99 */ undefined,
                    	    /* 0x9A */ undefined,
                    	    /* 0x9B */ undefined,
                    	    /* 0x9C */ undefined,
                    	    /* 0x9D */ undefined,
                    	    /* 0x9E */ undefined,
                    	    /* 0x9F */ undefined,
                    	    /* 0xA0 */ undefined,
                    	    /* 0xA1 */ undefined,
                    	    /* 0xA2 */ undefined,
                    	    /* 0xA3 */ undefined,
                    	    /* 0xA4 */ undefined,
                    	    /* 0xA5 */ undefined,
                    	    /* 0xA6 */ undefined,
                    	    /* 0xA7 */ undefined,
                    	    /* 0xA8 */ undefined,
                    	    /* 0xA9 */ undefined,
                    	    /* 0xAA */ undefined,
                    	    /* 0xAB */ undefined,
                    	    /* 0xAC */ undefined,
                    	    /* 0xAD */ undefined,
                    	    /* 0xAE */ undefined,
                    	    /* 0xAF */ undefined,
                    	    /* 0xB0 */ PUSHB.bind(undefined, 1),
                    	    /* 0xB1 */ PUSHB.bind(undefined, 2),
                    	    /* 0xB2 */ PUSHB.bind(undefined, 3),
                    	    /* 0xB3 */ PUSHB.bind(undefined, 4),
                    	    /* 0xB4 */ PUSHB.bind(undefined, 5),
                    	    /* 0xB5 */ PUSHB.bind(undefined, 6),
                    	    /* 0xB6 */ PUSHB.bind(undefined, 7),
                    	    /* 0xB7 */ PUSHB.bind(undefined, 8),
                    	    /* 0xB8 */ PUSHW.bind(undefined, 1),
                    	    /* 0xB9 */ PUSHW.bind(undefined, 2),
                    	    /* 0xBA */ PUSHW.bind(undefined, 3),
                    	    /* 0xBB */ PUSHW.bind(undefined, 4),
                    	    /* 0xBC */ PUSHW.bind(undefined, 5),
                    	    /* 0xBD */ PUSHW.bind(undefined, 6),
                    	    /* 0xBE */ PUSHW.bind(undefined, 7),
                    	    /* 0xBF */ PUSHW.bind(undefined, 8),
                    	    /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),
                    	    /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),
                    	    /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),
                    	    /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),
                    	    /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),
                    	    /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),
                    	    /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),
                    	    /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),
                    	    /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),
                    	    /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),
                    	    /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),
                    	    /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),
                    	    /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),
                    	    /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),
                    	    /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),
                    	    /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),
                    	    /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),
                    	    /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),
                    	    /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),
                    	    /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),
                    	    /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),
                    	    /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),
                    	    /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),
                    	    /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),
                    	    /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),
                    	    /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),
                    	    /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),
                    	    /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),
                    	    /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),
                    	    /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),
                    	    /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),
                    	    /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),
                    	    /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),
                    	    /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),
                    	    /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),
                    	    /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),
                    	    /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),
                    	    /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),
                    	    /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),
                    	    /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),
                    	    /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),
                    	    /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),
                    	    /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),
                    	    /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),
                    	    /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),
                    	    /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),
                    	    /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),
                    	    /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),
                    	    /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),
                    	    /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),
                    	    /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),
                    	    /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),
                    	    /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),
                    	    /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),
                    	    /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),
                    	    /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),
                    	    /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),
                    	    /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),
                    	    /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),
                    	    /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),
                    	    /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),
                    	    /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),
                    	    /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),
                    	    /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)
                    	];
                    
                    	/*****************************
                    	  Mathematical Considerations
                    	******************************
                    
                    	fv ... refers to freedom vector
                    	pv ... refers to projection vector
                    	rp ... refers to reference point
                    	p  ... refers to to point being operated on
                    	d  ... refers to distance
                    
                    	SETRELATIVE:
                    	============
                    
                    	case freedom vector == x-axis:
                    	------------------------------
                    
                    	                        (pv)
                    	                     .-'
                    	              rpd .-'
                    	               .-*
                    	          d .-'90°'
                    	         .-'       '
                    	      .-'           '
                    	   *-'               ' b
                    	  rp                  '
                    	                       '
                    	                        '
                    	            p *----------*-------------- (fv)
                    	                          pm
                    
                    	  rpdx = rpx + d * pv.x
                    	  rpdy = rpy + d * pv.y
                    
                    	  equation of line b
                    
                    	   y - rpdy = pvns * (x- rpdx)
                    
                    	   y = p.y
                    
                    	   x = rpdx + ( p.y - rpdy ) / pvns
                    
                    
                    	case freedom vector == y-axis:
                    	------------------------------
                    
                    	    * pm
                    	    |\
                    	    | \
                    	    |  \
                    	    |   \
                    	    |    \
                    	    |     \
                    	    |      \
                    	    |       \
                    	    |        \
                    	    |         \ b
                    	    |          \
                    	    |           \
                    	    |            \    .-' (pv)
                    	    |         90° \.-'
                    	    |           .-'* rpd
                    	    |        .-'
                    	    *     *-'  d
                    	    p     rp
                    
                    	  rpdx = rpx + d * pv.x
                    	  rpdy = rpy + d * pv.y
                    
                    	  equation of line b:
                    	           pvns ... normal slope to pv
                    
                    	   y - rpdy = pvns * (x - rpdx)
                    
                    	   x = p.x
                    
                    	   y = rpdy +  pvns * (p.x - rpdx)
                    
                    
                    
                    	generic case:
                    	-------------
                    
                    
                    	                              .'(fv)
                    	                            .'
                    	                          .* pm
                    	                        .' !
                    	                      .'    .
                    	                    .'      !
                    	                  .'         . b
                    	                .'           !
                    	               *              .
                    	              p               !
                    	                         90°   .    ... (pv)
                    	                           ...-*-'''
                    	                  ...---'''    rpd
                    	         ...---'''   d
                    	   *--'''
                    	  rp
                    
                    	    rpdx = rpx + d * pv.x
                    	    rpdy = rpy + d * pv.y
                    
                    	 equation of line b:
                    	    pvns... normal slope to pv
                    
                    	    y - rpdy = pvns * (x - rpdx)
                    
                    	 equation of freedom vector line:
                    	    fvs ... slope of freedom vector (=fy/fx)
                    
                    	    y - py = fvs * (x - px)
                    
                    
                    	  on pm both equations are true for same x/y
                    
                    	    y - rpdy = pvns * (x - rpdx)
                    
                    	    y - py = fvs * (x - px)
                    
                    	  form to y and set equal:
                    
                    	    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py
                    
                    	  expand:
                    
                    	    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py
                    
                    	  switch:
                    
                    	    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy
                    
                    	  solve for x:
                    
                    	    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy
                    
                    
                    
                    	          fvs * px - pvns * rpdx + rpdy - py
                    	    x =  -----------------------------------
                    	                 fvs - pvns
                    
                    	  and:
                    
                    	    y = fvs * (x - px) + py
                    
                    
                    
                    	INTERPOLATE:
                    	============
                    
                    	Examples of point interpolation.
                    
                    	The weight of the movement of the reference point gets bigger
                    	the further the other reference point is away, thus the safest
                    	option (that is avoiding 0/0 divisions) is to weight the
                    	original distance of the other point by the sum of both distances.
                    
                    	If the sum of both distances is 0, then move the point by the
                    	arithmetic average of the movement of both reference points.
                    
                    
                    
                    
                    	           (+6)
                    	    rp1o *---->*rp1
                    	         .     .                          (+12)
                    	         .     .                  rp2o *---------->* rp2
                    	         .     .                       .           .
                    	         .     .                       .           .
                    	         .    10          20           .           .
                    	         |.........|...................|           .
                    	               .   .                               .
                    	               .   . (+8)                          .
                    	                po *------>*p                      .
                    	               .           .                       .
                    	               .    12     .          24           .
                    	               |...........|.......................|
                    	                                  36
                    
                    
                    	-------
                    
                    
                    
                    	           (+10)
                    	    rp1o *-------->*rp1
                    	         .         .                      (-10)
                    	         .         .              rp2 *<---------* rpo2
                    	         .         .                   .         .
                    	         .         .                   .         .
                    	         .    10   .          30       .         .
                    	         |.........|.............................|
                    	                   .                   .
                    	                   . (+5)              .
                    	                po *--->* p            .
                    	                   .    .              .
                    	                   .    .   20         .
                    	                   |....|..............|
                    	                     5        15
                    
                    
                    	-------
                    
                    
                    	           (+10)
                    	    rp1o *-------->*rp1
                    	         .         .
                    	         .         .
                    	    rp2o *-------->*rp2
                    
                    
                    	                               (+10)
                    	                          po *-------->* p
                    
                    	-------
                    
                    
                    	           (+10)
                    	    rp1o *-------->*rp1
                    	         .         .
                    	         .         .(+30)
                    	    rp2o *---------------------------->*rp2
                    
                    
                    	                                        (+25)
                    	                          po *----------------------->* p
                    
                    
                    
                    	vim: set ts=4 sw=4 expandtab:
                    	*****/
                    
                    	/**
                    	 * Converts a string into a list of tokens.
                    	 */
                    
                    	/**
                    	 * Create a new token
                    	 * @param {string} char a single char
                    	 */
                    	function Token(char) {
                    	    this.char = char;
                    	    this.state = {};
                    	    this.activeState = null;
                    	}
                    
                    	/**
                    	 * Create a new context range
                    	 * @param {number} startIndex range start index
                    	 * @param {number} endOffset range end index offset
                    	 * @param {string} contextName owner context name
                    	 */
                    	function ContextRange(startIndex, endOffset, contextName) {
                    	    this.contextName = contextName;
                    	    this.startIndex = startIndex;
                    	    this.endOffset = endOffset;
                    	}
                    
                    	/**
                    	 * Check context start and end
                    	 * @param {string} contextName a unique context name
                    	 * @param {function} checkStart a predicate function the indicates a context's start
                    	 * @param {function} checkEnd a predicate function the indicates a context's end
                    	 */
                    	function ContextChecker(contextName, checkStart, checkEnd) {
                    	    this.contextName = contextName;
                    	    this.openRange = null;
                    	    this.ranges = [];
                    	    this.checkStart = checkStart;
                    	    this.checkEnd = checkEnd;
                    	}
                    
                    	/**
                    	 * Create a context params
                    	 * @param {array} context a list of items
                    	 * @param {number} currentIndex current item index
                    	 */
                    	function ContextParams(context, currentIndex) {
                    	    this.context = context;
                    	    this.index = currentIndex;
                    	    this.length = context.length;
                    	    this.current = context[currentIndex];
                    	    this.backtrack = context.slice(0, currentIndex);
                    	    this.lookahead = context.slice(currentIndex + 1);
                    	}
                    
                    	/**
                    	 * Create an event instance
                    	 * @param {string} eventId event unique id
                    	 */
                    	function Event(eventId) {
                    	    this.eventId = eventId;
                    	    this.subscribers = [];
                    	}
                    
                    	/**
                    	 * Initialize a core events and auto subscribe required event handlers
                    	 * @param {any} events an object that enlists core events handlers
                    	 */
                    	function initializeCoreEvents(events) {
                    	    var this$1 = this;
                    
                    	    var coreEvents = [
                    	        'start', 'end', 'next', 'newToken', 'contextStart',
                    	        'contextEnd', 'insertToken', 'removeToken', 'removeRange',
                    	        'replaceToken', 'replaceRange', 'composeRUD', 'updateContextsRanges'
                    	    ];
                    
                    	    coreEvents.forEach(function (eventId) {
                    	        Object.defineProperty(this$1.events, eventId, {
                    	            value: new Event(eventId)
                    	        });
                    	    });
                    
                    	    if (!!events) {
                    	        coreEvents.forEach(function (eventId) {
                    	            var event = events[eventId];
                    	            if (typeof event === 'function') {
                    	                this$1.events[eventId].subscribe(event);
                    	            }
                    	        });
                    	    }
                    	    var requiresContextUpdate = [
                    	        'insertToken', 'removeToken', 'removeRange',
                    	        'replaceToken', 'replaceRange', 'composeRUD'
                    	    ];
                    	    requiresContextUpdate.forEach(function (eventId) {
                    	        this$1.events[eventId].subscribe(
                    	            this$1.updateContextsRanges
                    	        );
                    	    });
                    	}
                    
                    	/**
                    	 * Converts a string into a list of tokens
                    	 * @param {any} events tokenizer core events
                    	 */
                    	function Tokenizer(events) {
                    	    this.tokens = [];
                    	    this.registeredContexts = {};
                    	    this.contextCheckers = [];
                    	    this.events = {};
                    	    this.registeredModifiers = [];
                    
                    	    initializeCoreEvents.call(this, events);
                    	}
                    
                    	/**
                    	 * Sets the state of a token, usually called by a state modifier.
                    	 * @param {string} key state item key
                    	 * @param {any} value state item value
                    	 */
                    	Token.prototype.setState = function(key, value) {
                    	    this.state[key] = value;
                    	    this.activeState = { key: key, value: this.state[key] };
                    	    return this.activeState;
                    	};
                    
                    	Token.prototype.getState = function (stateId) {
                    	    return this.state[stateId] || null;
                    	};
                    
                    	/**
                    	 * Checks if an index exists in the tokens list.
                    	 * @param {number} index token index
                    	 */
                    	Tokenizer.prototype.inboundIndex = function(index) {
                    	    return index >= 0 && index < this.tokens.length;
                    	};
                    
                    	/**
                    	 * Compose and apply a list of operations (replace, update, delete)
                    	 * @param {array} RUDs replace, update and delete operations
                    	 * TODO: Perf. Optimization (lengthBefore === lengthAfter ? dispatch once)
                    	 */
                    	Tokenizer.prototype.composeRUD = function (RUDs) {
                    	    var this$1 = this;
                    
                    	    var silent = true;
                    	    var state = RUDs.map(function (RUD) { return (
                    	        this$1[RUD[0]].apply(this$1, RUD.slice(1).concat(silent))
                    	    ); });
                    	    var hasFAILObject = function (obj) { return (
                    	        typeof obj === 'object' &&
                    	        obj.hasOwnProperty('FAIL')
                    	    ); };
                    	    if (state.every(hasFAILObject)) {
                    	        return {
                    	            FAIL: "composeRUD: one or more operations hasn't completed successfully",
                    	            report: state.filter(hasFAILObject)
                    	        };
                    	    }
                    	    this.dispatch('composeRUD', [state.filter(function (op) { return !hasFAILObject(op); })]);
                    	};
                    
                    	/**
                    	 * Replace a range of tokens with a list of tokens
                    	 * @param {number} startIndex range start index
                    	 * @param {number} offset range offset
                    	 * @param {token} tokens a list of tokens to replace
                    	 * @param {boolean} silent dispatch events and update context ranges
                    	 */
                    	Tokenizer.prototype.replaceRange = function (startIndex, offset, tokens, silent) {
                    	    offset = offset !== null ? offset : this.tokens.length;
                    	    var isTokenType = tokens.every(function (token) { return token instanceof Token; });
                    	    if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {
                    	        var replaced = this.tokens.splice.apply(
                    	            this.tokens, [startIndex, offset].concat(tokens)
                    	        );
                    	        if (!silent) { this.dispatch('replaceToken', [startIndex, offset, tokens]); }
                    	        return [replaced, tokens];
                    	    } else {
                    	        return { FAIL: 'replaceRange: invalid tokens or startIndex.' };
                    	    }
                    	};
                    
                    	/**
                    	 * Replace a token with another token
                    	 * @param {number} index token index
                    	 * @param {token} token a token to replace
                    	 * @param {boolean} silent dispatch events and update context ranges
                    	 */
                    	Tokenizer.prototype.replaceToken = function (index, token, silent) {
                    	    if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {
                    	        var replaced = this.tokens.splice(index, 1, token);
                    	        if (!silent) { this.dispatch('replaceToken', [index, token]); }
                    	        return [replaced[0], token];
                    	    } else {
                    	        return { FAIL: 'replaceToken: invalid token or index.' };
                    	    }
                    	};
                    
                    	/**
                    	 * Removes a range of tokens
                    	 * @param {number} startIndex range start index
                    	 * @param {number} offset range offset
                    	 * @param {boolean} silent dispatch events and update context ranges
                    	 */
                    	Tokenizer.prototype.removeRange = function(startIndex, offset, silent) {
                    	    offset = !isNaN(offset) ? offset : this.tokens.length;
                    	    var tokens = this.tokens.splice(startIndex, offset);
                    	    if (!silent) { this.dispatch('removeRange', [tokens, startIndex, offset]); }
                    	    return tokens;
                    	};
                    
                    	/**
                    	 * Remove a token at a certain index
                    	 * @param {number} index token index
                    	 * @param {boolean} silent dispatch events and update context ranges
                    	 */
                    	Tokenizer.prototype.removeToken = function(index, silent) {
                    	    if (!isNaN(index) && this.inboundIndex(index)) {
                    	        var token = this.tokens.splice(index, 1);
                    	        if (!silent) { this.dispatch('removeToken', [token, index]); }
                    	        return token;
                    	    } else {
                    	        return { FAIL: 'removeToken: invalid token index.' };
                    	    }
                    	};
                    
                    	/**
                    	 * Insert a list of tokens at a certain index
                    	 * @param {array} tokens a list of tokens to insert
                    	 * @param {number} index insert the list of tokens at index
                    	 * @param {boolean} silent dispatch events and update context ranges
                    	 */
                    	Tokenizer.prototype.insertToken = function (tokens, index, silent) {
                    	    var tokenType = tokens.every(
                    	        function (token) { return token instanceof Token; }
                    	    );
                    	    if (tokenType) {
                    	        this.tokens.splice.apply(
                    	            this.tokens, [index, 0].concat(tokens)
                    	        );
                    	        if (!silent) { this.dispatch('insertToken', [tokens, index]); }
                    	        return tokens;
                    	    } else {
                    	        return { FAIL: 'insertToken: invalid token(s).' };
                    	    }
                    	};
                    
                    	/**
                    	 * A state modifier that is called on 'newToken' event
                    	 * @param {string} modifierId state modifier id
                    	 * @param {function} condition a predicate function that returns true or false
                    	 * @param {function} modifier a function to update token state
                    	 */
                    	Tokenizer.prototype.registerModifier = function(modifierId, condition, modifier) {
                    	    this.events.newToken.subscribe(function(token, contextParams) {
                    	        var conditionParams = [token, contextParams];
                    	        var canApplyModifier = (
                    	            condition === null ||
                    	            condition.apply(this, conditionParams) === true
                    	        );
                    	        var modifierParams = [token, contextParams];
                    	        if (canApplyModifier) {
                    	            var newStateValue = modifier.apply(this, modifierParams);
                    	            token.setState(modifierId, newStateValue);
                    	        }
                    	    });
                    	    this.registeredModifiers.push(modifierId);
                    	};
                    
                    	/**
                    	 * Subscribe a handler to an event
                    	 * @param {function} eventHandler an event handler function
                    	 */
                    	Event.prototype.subscribe = function (eventHandler) {
                    	    if (typeof eventHandler === 'function') {
                    	        return ((this.subscribers.push(eventHandler)) - 1);
                    	    } else {
                    	        return { FAIL: ("invalid '" + (this.eventId) + "' event handler")};
                    	    }
                    	};
                    
                    	/**
                    	 * Unsubscribe an event handler
                    	 * @param {string} subsId subscription id
                    	 */
                    	Event.prototype.unsubscribe = function (subsId) {
                    	    this.subscribers.splice(subsId, 1);
                    	};
                    
                    	/**
                    	 * Sets context params current value index
                    	 * @param {number} index context params current value index
                    	 */
                    	ContextParams.prototype.setCurrentIndex = function(index) {
                    	    this.index = index;
                    	    this.current = this.context[index];
                    	    this.backtrack = this.context.slice(0, index);
                    	    this.lookahead = this.context.slice(index + 1);
                    	};
                    
                    	/**
                    	 * Get an item at an offset from the current value
                    	 * example (current value is 3):
                    	 *  1    2   [3]   4    5   |   items values
                    	 * -2   -1    0    1    2   |   offset values
                    	 * @param {number} offset an offset from current value index
                    	 */
                    	ContextParams.prototype.get = function (offset) {
                    	    switch (true) {
                    	        case (offset === 0):
                    	            return this.current;
                    	        case (offset < 0 && Math.abs(offset) <= this.backtrack.length):
                    	            return this.backtrack.slice(offset)[0];
                    	        case (offset > 0 && offset <= this.lookahead.length):
                    	            return this.lookahead[offset - 1];
                    	        default:
                    	            return null;
                    	    }
                    	};
                    
                    	/**
                    	 * Converts a context range into a string value
                    	 * @param {contextRange} range a context range
                    	 */
                    	Tokenizer.prototype.rangeToText = function (range) {
                    	    if (range instanceof ContextRange) {
                    	        return (
                    	            this.getRangeTokens(range)
                    	                .map(function (token) { return token.char; }).join('')
                    	        );
                    	    }
                    	};
                    
                    	/**
                    	 * Converts all tokens into a string
                    	 */
                    	Tokenizer.prototype.getText = function () {
                    	    return this.tokens.map(function (token) { return token.char; }).join('');
                    	};
                    
                    	/**
                    	 * Get a context by name
                    	 * @param {string} contextName context name to get
                    	 */
                    	Tokenizer.prototype.getContext = function (contextName) {
                    	    var context = this.registeredContexts[contextName];
                    	    return !!context ? context : null;
                    	};
                    
                    	/**
                    	 * Subscribes a new event handler to an event
                    	 * @param {string} eventName event name to subscribe to
                    	 * @param {function} eventHandler a function to be invoked on event
                    	 */
                    	Tokenizer.prototype.on = function(eventName, eventHandler) {
                    	    var event = this.events[eventName];
                    	    if (!!event) {
                    	        return event.subscribe(eventHandler);
                    	    } else {
                    	        return null;
                    	    }
                    	};
                    
                    	/**
                    	 * Dispatches an event
                    	 * @param {string} eventName event name
                    	 * @param {any} args event handler arguments
                    	 */
                    	Tokenizer.prototype.dispatch = function(eventName, args) {
                    	    var this$1 = this;
                    
                    	    var event = this.events[eventName];
                    	    if (event instanceof Event) {
                    	        event.subscribers.forEach(function (subscriber) {
                    	            subscriber.apply(this$1, args || []);
                    	        });
                    	    }
                    	};
                    
                    	/**
                    	 * Register a new context checker
                    	 * @param {string} contextName a unique context name
                    	 * @param {function} contextStartCheck a predicate function that returns true on context start
                    	 * @param {function} contextEndCheck  a predicate function that returns true on context end
                    	 * TODO: call tokenize on registration to update context ranges with the new context.
                    	 */
                    	Tokenizer.prototype.registerContextChecker = function(contextName, contextStartCheck, contextEndCheck) {
                    	    if (!!this.getContext(contextName)) { return {
                    	        FAIL:
                    	        ("context name '" + contextName + "' is already registered.")
                    	    }; }
                    	    if (typeof contextStartCheck !== 'function') { return {
                    	        FAIL:
                    	        "missing context start check."
                    	    }; }
                    	    if (typeof contextEndCheck !== 'function') { return {
                    	        FAIL:
                    	        "missing context end check."
                    	    }; }
                    	    var contextCheckers = new ContextChecker(
                    	        contextName, contextStartCheck, contextEndCheck
                    	    );
                    	    this.registeredContexts[contextName] = contextCheckers;
                    	    this.contextCheckers.push(contextCheckers);
                    	    return contextCheckers;
                    	};
                    
                    	/**
                    	 * Gets a context range tokens
                    	 * @param {contextRange} range a context range
                    	 */
                    	Tokenizer.prototype.getRangeTokens = function(range) {
                    	    var endIndex = range.startIndex + range.endOffset;
                    	    return [].concat(
                    	        this.tokens
                    	            .slice(range.startIndex, endIndex)
                    	    );
                    	};
                    
                    	/**
                    	 * Gets the ranges of a context
                    	 * @param {string} contextName context name
                    	 */
                    	Tokenizer.prototype.getContextRanges = function(contextName) {
                    	    var context = this.getContext(contextName);
                    	    if (!!context) {
                    	        return context.ranges;
                    	    } else {
                    	        return { FAIL: ("context checker '" + contextName + "' is not registered.") };
                    	    }
                    	};
                    
                    	/**
                    	 * Resets context ranges to run context update
                    	 */
                    	Tokenizer.prototype.resetContextsRanges = function () {
                    	    var registeredContexts = this.registeredContexts;
                    	    for (var contextName in registeredContexts) {
                    	        if (registeredContexts.hasOwnProperty(contextName)) {
                    	            var context = registeredContexts[contextName];
                    	            context.ranges = [];
                    	        }
                    	    }
                    	};
                    
                    	/**
                    	 * Updates context ranges
                    	 */
                    	Tokenizer.prototype.updateContextsRanges = function () {
                    	    var this$1 = this;
                    
                    	    this.resetContextsRanges();
                    	    var chars = this.tokens.map(function (token) { return token.char; });
                    	    for (var i = 0; i < chars.length; i++) {
                    	        var contextParams = new ContextParams(chars, i);
                    	        this$1.runContextCheck(contextParams);
                    	    }
                    	    this.dispatch('updateContextsRanges', [this.registeredContexts]);
                    	};
                    
                    	/**
                    	 * Sets the end offset of an open range
                    	 * @param {number} offset range end offset
                    	 * @param {string} contextName context name
                    	 */
                    	Tokenizer.prototype.setEndOffset = function (offset, contextName) {
                    	    var startIndex = this.getContext(contextName).openRange.startIndex;
                    	    var range = new ContextRange(startIndex, offset, contextName);
                    	    var ranges = this.getContext(contextName).ranges;
                    	    range.rangeId = contextName + "." + (ranges.length);
                    	    ranges.push(range);
                    	    this.getContext(contextName).openRange = null;
                    	    return range;
                    	};
                    
                    	/**
                    	 * Runs a context check on the current context
                    	 * @param {contextParams} contextParams current context params
                    	 */
                    	Tokenizer.prototype.runContextCheck = function(contextParams) {
                    	    var this$1 = this;
                    
                    	    var index = contextParams.index;
                    	    this.contextCheckers.forEach(function (contextChecker) {
                    	        var contextName = contextChecker.contextName;
                    	        var openRange = this$1.getContext(contextName).openRange;
                    	        if (!openRange && contextChecker.checkStart(contextParams)) {
                    	            openRange = new ContextRange(index, null, contextName);
                    	            this$1.getContext(contextName).openRange = openRange;
                    	            this$1.dispatch('contextStart', [contextName, index]);
                    	        }
                    	        if (!!openRange && contextChecker.checkEnd(contextParams)) {
                    	            var offset = (index - openRange.startIndex) + 1;
                    	            var range = this$1.setEndOffset(offset, contextName);
                    	            this$1.dispatch('contextEnd', [contextName, range]);
                    	        }
                    	    });
                    	};
                    
                    	/**
                    	 * Converts a text into a list of tokens
                    	 * @param {string} text a text to tokenize
                    	 */
                    	Tokenizer.prototype.tokenize = function (text) {
                    	    var this$1 = this;
                    
                    	    this.tokens = [];
                    	    this.resetContextsRanges();
                    	    var chars = Array.from(text);
                    	    this.dispatch('start');
                    	    for (var i = 0; i < chars.length; i++) {
                    	        var char = chars[i];
                    	        var contextParams = new ContextParams(chars, i);
                    	        this$1.dispatch('next', [contextParams]);
                    	        this$1.runContextCheck(contextParams);
                    	        var token = new Token(char);
                    	        this$1.tokens.push(token);
                    	        this$1.dispatch('newToken', [token, contextParams]);
                    	    }
                    	    this.dispatch('end', [this.tokens]);
                    	    return this.tokens;
                    	};
                    
                    	// ╭─┄┄┄────────────────────────┄─────────────────────────────────────────────╮
                    	// ┊ Character Class Assertions ┊ Checks if a char belongs to a certain class ┊
                    	// ╰─╾──────────────────────────┄─────────────────────────────────────────────╯
                    	// jscs:disable maximumLineLength
                    	/**
                    	 * Check if a char is Arabic
                    	 * @param {string} c a single char
                    	 */
                    	function isArabicChar(c) {
                    	    return /[\u0600-\u065F\u066A-\u06D2\u06FA-\u06FF]/.test(c);
                    	}
                    
                    	/**
                    	 * Check if a char is an isolated arabic char
                    	 * @param {string} c a single char
                    	 */
                    	function isIsolatedArabicChar(char) {
                    	    return /[\u0630\u0690\u0621\u0631\u0661\u0671\u0622\u0632\u0672\u0692\u06C2\u0623\u0673\u0693\u06C3\u0624\u0694\u06C4\u0625\u0675\u0695\u06C5\u06E5\u0676\u0696\u06C6\u0627\u0677\u0697\u06C7\u0648\u0688\u0698\u06C8\u0689\u0699\u06C9\u068A\u06CA\u066B\u068B\u06CB\u068C\u068D\u06CD\u06FD\u068E\u06EE\u06FE\u062F\u068F\u06CF\u06EF]/.test(char);
                    	}
                    
                    	/**
                    	 * Check if a char is an Arabic Tashkeel char
                    	 * @param {string} c a single char
                    	 */
                    	function isTashkeelArabicChar(char) {
                    	    return /[\u0600-\u0605\u060C-\u060E\u0610-\u061B\u061E\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED]/.test(char);
                    	}
                    
                    	/**
                    	 * Check if a char is whitespace char
                    	 * @param {string} c a single char
                    	 */
                    	function isWhiteSpace(c) {
                    	    return /\s/.test(c);
                    	}
                    
                    	/**
                    	 * Arabic word context checkers
                    	 */
                    
                    	function arabicWordStartCheck(contextParams) {
                    	    var char = contextParams.current;
                    	    var prevChar = contextParams.get(-1);
                    	    return (
                    	        // ? arabic first char
                    	        (prevChar === null && isArabicChar(char)) ||
                    	        // ? arabic char preceded with a non arabic char
                    	        (!isArabicChar(prevChar) && isArabicChar(char))
                    	    );
                    	}
                    
                    	function arabicWordEndCheck(contextParams) {
                    	    var nextChar = contextParams.get(1);
                    	    return (
                    	        // ? last arabic char
                    	        (nextChar === null) ||
                    	        // ? next char is not arabic
                    	        (!isArabicChar(nextChar))
                    	    );
                    	}
                    	var arabicWordCheck = { arabicWordStartCheck: arabicWordStartCheck, arabicWordEndCheck: arabicWordEndCheck };
                    
                    	/**
                    	 * Arabic sentence context checkers
                    	 */
                    
                    	function arabicSentenceStartCheck(contextParams) {
                    	    var char = contextParams.current;
                    	    var prevChar = contextParams.get(-1);
                    	    return (
                    	        // ? an arabic char preceded with a non arabic char
                    	        (isArabicChar(char) || isTashkeelArabicChar(char)) &&
                    	        !isArabicChar(prevChar)
                    	    );
                    	}
                    
                    	function arabicSentenceEndCheck(contextParams) {
                    	    var nextChar = contextParams.get(1);
                    	    switch (true) {
                    	        case nextChar === null:
                    	            return true;
                    	        case (!isArabicChar(nextChar) && !isTashkeelArabicChar(nextChar)):
                    	            var nextIsWhitespace = isWhiteSpace(nextChar);
                    	            if (!nextIsWhitespace) { return true; }
                    	            if (nextIsWhitespace) {
                    	                var arabicCharAhead = false;
                    	                arabicCharAhead = (
                    	                    contextParams.lookahead.some(
                    	                        function (c) { return isArabicChar(c) || isTashkeelArabicChar(c); }
                    	                    )
                    	                );
                    	                if (!arabicCharAhead) { return true; }
                    	            }
                    	            break;
                    	        default:
                    	            return false;
                    	    }
                    	}
                    	var arabicSentenceCheck = { arabicSentenceStartCheck: arabicSentenceStartCheck, arabicSentenceEndCheck: arabicSentenceEndCheck };
                    
                    	/**
                    	 * Apply Arabic presentation forms to a range of tokens
                    	 */
                    	/**
                    	 * Check if a char can be connected to it's preceding char
                    	 * @param {ContextParams} charContextParams context params of a char
                    	 */
                    	function willConnectPrev(charContextParams) {
                    	    var backtrack = [].concat(charContextParams.backtrack);
                    	    for (var i = backtrack.length - 1; i >= 0; i--) {
                    	        var prevChar = backtrack[i];
                    	        var isolated = isIsolatedArabicChar(prevChar);
                    	        var tashkeel = isTashkeelArabicChar(prevChar);
                    	        if (!isolated && !tashkeel) { return true; }
                    	        if (isolated) { return false; }
                    	    }
                    	    return false;
                    	}
                    
                    	/**
                    	 * Check if a char can be connected to it's proceeding char
                    	 * @param {ContextParams} charContextParams context params of a char
                    	 */
                    	function willConnectNext(charContextParams) {
                    	    if (isIsolatedArabicChar(charContextParams.current)) { return false; }
                    	    for (var i = 0; i < charContextParams.lookahead.length; i++) {
                    	        var nextChar = charContextParams.lookahead[i];
                    	        var tashkeel = isTashkeelArabicChar(nextChar);
                    	        if (!tashkeel) { return true; }
                    	    }
                    	    return false;
                    	}
                    
                    	/**
                    	 * Apply arabic presentation forms to a list of tokens
                    	 * @param {ContextRange} range a range of tokens
                    	 */
                    	function arabicPresentationForms(range) {
                    	    var features = this.features.arab;
                    	    var rangeTokens = this.tokenizer.getRangeTokens(range);
                    	    if (rangeTokens.length === 1) { return; }
                    	    var getSubstitutionIndex = function (substitution) { return (
                    	        substitution.length === 1 &&
                    	        substitution[0].id === 12 &&
                    	        substitution[0].substitution
                    	    ); };
                    	    var applyForm = function (tag, token, params) {
                    	        if (!features.hasOwnProperty(tag)) { return; }
                    	        var substitution = features[tag].lookup(params) || null;
                    	        var substIndex = getSubstitutionIndex(substitution)[0];
                    	        if (substIndex >= 0) {
                    	            return token.setState(tag, substIndex);
                    	        }
                    	    };
                    	    var tokensParams = new ContextParams(rangeTokens, 0);
                    	    var charContextParams = new ContextParams(rangeTokens.map(function (t){ return t.char; }), 0);
                    	    rangeTokens.forEach(function (token, i) {
                    	        if (isTashkeelArabicChar(token.char)) { return; }
                    	        tokensParams.setCurrentIndex(i);
                    	        charContextParams.setCurrentIndex(i);
                    	        var CONNECT = 0; // 2 bits 00 (10: can connect next) (01: can connect prev)
                    	        if (willConnectPrev(charContextParams)) { CONNECT |= 1; }
                    	        if (willConnectNext(charContextParams)) { CONNECT |= 2; }
                    	        switch (CONNECT) {
                    	            case 0: // isolated * original form
                    	                return;
                    	            case 1: // fina
                    	                applyForm('fina', token, tokensParams);
                    	                break;
                    	            case 2: // init
                    	                applyForm('init', token, tokensParams);
                    	                break;
                    	            case 3: // medi
                    	                applyForm('medi', token, tokensParams);
                    	                break;
                    	        }
                    	    });
                    	}
                    
                    	/**
                    	 * Apply Arabic required ligatures feature to a range of tokens
                    	 */
                    
                    	/**
                    	 * Apply Arabic required ligatures to a context range
                    	 * @param {ContextRange} range a range of tokens
                    	 */
                    	function arabicRequiredLigatures(range) {
                    	    var features = this.features.arab;
                    	    if (!features.hasOwnProperty('rlig')) { return; }
                    	    var tokens = this.tokenizer.getRangeTokens(range);
                    	    for (var i = 0; i < tokens.length; i++) {
                    	        var lookupParams = new ContextParams(tokens, i);
                    	        var substitution = features.rlig.lookup(lookupParams) || null;
                    	        var chainingContext = (
                    	            substitution.length === 1 &&
                    	            substitution[0].id === 63 &&
                    	            substitution[0].substitution
                    	        );
                    	        var ligature = (
                    	            substitution.length === 1 &&
                    	            substitution[0].id === 41 &&
                    	            substitution[0].substitution[0]
                    	        );
                    	        var token = tokens[i];
                    	        if (!!ligature) {
                    	            token.setState('rlig', [ligature.ligGlyph]);
                    	            for (var c = 0; c < ligature.components.length; c++) {
                    	                var component = ligature.components[c];
                    	                var lookaheadToken = lookupParams.get(c + 1);
                    	                if (lookaheadToken.activeState.value === component) {
                    	                    lookaheadToken.state.deleted = true;
                    	                }
                    	            }
                    	        } else if (chainingContext) {
                    	            var substIndex = (
                    	                chainingContext &&
                    	                chainingContext.length === 1 &&
                    	                chainingContext[0].id === 12 &&
                    	                chainingContext[0].substitution
                    	            );
                    	            if (!!substIndex && substIndex >= 0) { token.setState('rlig', substIndex); }
                    	        }
                    	    }
                    	}
                    
                    	/**
                    	 * Infer bidirectional properties for a given text and apply
                    	 * the corresponding layout rules.
                    	 */
                    
                    	/**
                    	 * Create Bidi. features
                    	 * @param {string} baseDir text base direction. value either 'ltr' or 'rtl'
                    	 */
                    	function Bidi(baseDir) {
                    	    this.baseDir = baseDir || 'ltr';
                    	    this.tokenizer = new Tokenizer();
                    	    this.features = [];
                    	}
                    
                    	/**
                    	 * Sets Bidi text
                    	 * @param {string} text a text input
                    	 */
                    	Bidi.prototype.setText = function (text) {
                    	    this.text = text;
                    	};
                    
                    	/**
                    	 * Store essential context checks:
                    	 * arabic word check for applying gsub features
                    	 * arabic sentence check for adjusting arabic layout
                    	 */
                    	Bidi.prototype.contextChecks = ({
                    	    arabicWordCheck: arabicWordCheck,
                    	    arabicSentenceCheck: arabicSentenceCheck
                    	});
                    
                    	/**
                    	 * Register arabic word check
                    	 */
                    	function registerArabicWordCheck() {
                    	    var checks = this.contextChecks.arabicWordCheck;
                    	    return this.tokenizer.registerContextChecker(
                    	        'arabicWord',
                    	        checks.arabicWordStartCheck,
                    	        checks.arabicWordEndCheck
                    	    );
                    	}
                    
                    	/**
                    	 * Register arabic sentence check
                    	 */
                    	function registerArabicSentenceCheck() {
                    	    var checks = this.contextChecks.arabicSentenceCheck;
                    	    return this.tokenizer.registerContextChecker(
                    	        'arabicSentence',
                    	        checks.arabicSentenceStartCheck,
                    	        checks.arabicSentenceEndCheck
                    	    );
                    	}
                    
                    	/**
                    	 * Perform pre tokenization procedure then
                    	 * tokenize text input
                    	 */
                    	function tokenizeText() {
                    	    registerArabicWordCheck.call(this);
                    	    registerArabicSentenceCheck.call(this);
                    	    return this.tokenizer.tokenize(this.text);
                    	}
                    
                    	/**
                    	 * Reverse arabic sentence layout
                    	 * TODO: check base dir before applying adjustments - priority low
                    	 */
                    	function reverseArabicSentences() {
                    	    var this$1 = this;
                    
                    	    var ranges = this.tokenizer.getContextRanges('arabicSentence');
                    	    ranges.forEach(function (range) {
                    	        var rangeTokens = this$1.tokenizer.getRangeTokens(range);
                    	        this$1.tokenizer.replaceRange(
                    	            range.startIndex,
                    	            range.endOffset,
                    	            rangeTokens.reverse()
                    	        );
                    	    });
                    	}
                    
                    	/**
                    	 * Subscribe arabic presentation form features
                    	 * @param {feature} feature a feature to apply
                    	 */
                    	Bidi.prototype.subscribeArabicForms = function(feature) {
                    	    var this$1 = this;
                    
                    	    this.tokenizer.events.contextEnd.subscribe(
                    	        function (contextName, range) {
                    	            if (contextName === 'arabicWord') {
                    	                return arabicPresentationForms.call(
                    	                    this$1.tokenizer, range, feature
                    	                );
                    	            }
                    	        }
                    	    );
                    	};
                    
                    	/**
                    	 * Apply Gsub features
                    	 * @param {feature} features a list of features
                    	 */
                    	Bidi.prototype.applyFeatures = function (features) {
                    	    var this$1 = this;
                    
                    	    for (var i = 0; i < features.length; i++) {
                    	        var feature = features[i];
                    	        if (feature) {
                    	            var script = feature.script;
                    	            if (!this$1.features[script]) {
                    	                this$1.features[script] = {};
                    	            }
                    	            this$1.features[script][feature.tag] = feature;
                    	        }
                    	    }
                    	};
                    
                    	/**
                    	 * Register a state modifier
                    	 * @param {string} modifierId state modifier id
                    	 * @param {function} condition a predicate function that returns true or false
                    	 * @param {function} modifier a modifier function to set token state
                    	 */
                    	Bidi.prototype.registerModifier = function (modifierId, condition, modifier) {
                    	    this.tokenizer.registerModifier(modifierId, condition, modifier);
                    	};
                    
                    	/**
                    	 * Check if 'glyphIndex' is registered
                    	 */
                    	function checkGlyphIndexStatus() {
                    	    if (this.tokenizer.registeredModifiers.indexOf('glyphIndex') === -1) {
                    	        throw new Error(
                    	            'glyphIndex modifier is required to apply ' +
                    	            'arabic presentation features.'
                    	        );
                    	    }
                    	}
                    
                    	/**
                    	 * Apply arabic presentation forms features
                    	 */
                    	function applyArabicPresentationForms() {
                    	    var this$1 = this;
                    
                    	    if (!this.features.hasOwnProperty('arab')) { return; }
                    	    checkGlyphIndexStatus.call(this);
                    	    var ranges = this.tokenizer.getContextRanges('arabicWord');
                    	    ranges.forEach(function (range) {
                    	        arabicPresentationForms.call(this$1, range);
                    	    });
                    	}
                    
                    	/**
                    	 * Apply required arabic ligatures
                    	 */
                    	function applyArabicRequireLigatures() {
                    	    var this$1 = this;
                    
                    	    if (!this.features.hasOwnProperty('arab')) { return; }
                    	    if (!this.features.arab.hasOwnProperty('rlig')) { return; }
                    	    checkGlyphIndexStatus.call(this);
                    	    var ranges = this.tokenizer.getContextRanges('arabicWord');
                    	    ranges.forEach(function (range) {
                    	        arabicRequiredLigatures.call(this$1, range);
                    	    });
                    	}
                    
                    	/**
                    	 * process text input
                    	 * @param {string} text an input text
                    	 */
                    	Bidi.prototype.processText = function(text) {
                    	    if (!this.text || this.text !== text) {
                    	        this.setText(text);
                    	        tokenizeText.call(this);
                    	        applyArabicPresentationForms.call(this);
                    	        applyArabicRequireLigatures.call(this);
                    	        reverseArabicSentences.call(this);
                    	    }
                    	};
                    
                    	/**
                    	 * Process a string of text to identify and adjust
                    	 * bidirectional text entities.
                    	 * @param {string} text input text
                    	 */
                    	Bidi.prototype.getBidiText = function (text) {
                    	    this.processText(text);
                    	    return this.tokenizer.getText();
                    	};
                    
                    	/**
                    	 * Get the current state index of each token
                    	 * @param {text} text an input text
                    	 */
                    	Bidi.prototype.getTextGlyphs = function (text) {
                    	    var this$1 = this;
                    
                    	    this.processText(text);
                    	    var indexes = [];
                    	    for (var i = 0; i < this.tokenizer.tokens.length; i++) {
                    	        var token = this$1.tokenizer.tokens[i];
                    	        if (token.state.deleted) { continue; }
                    	        var index = token.activeState.value;
                    	        indexes.push(Array.isArray(index) ? index[0] : index);
                    	    }
                    	    return indexes;
                    	};
                    
                    	/**
                    	 * Query a feature by some of it's properties to lookup a glyph substitution.
                    	 */
                    
                    	// DEFAULT TEXT BASE DIRECTION
                    	var BASE_DIR = 'ltr';
                    
                    	/**
                    	 * Create feature query instance
                    	 * @param {Font} font opentype font instance
                    	 * @param {string} baseDir text base direction
                    	 */
                    	function FeatureQuery(font, baseDir) {
                    	    this.font = font;
                    	    this.features = {};
                    	    BASE_DIR = !!baseDir ? baseDir : BASE_DIR;
                    	}
                    
                    	/**
                    	 * Create a new feature lookup
                    	 * @param {string} tag feature tag
                    	 * @param {feature} feature reference to feature at gsub table
                    	 * @param {FeatureLookups} feature lookups associated with this feature
                    	 * @param {string} script gsub script tag
                    	 */
                    	function Feature(tag, feature, featureLookups, script) {
                    	    this.tag = tag;
                    	    this.featureRef = feature;
                    	    this.lookups = featureLookups.lookups;
                    	    this.script = script;
                    	}
                    
                    	/**
                    	 * Create a coverage table lookup
                    	 * @param {any} coverageTable gsub coverage table
                    	 */
                    	function Coverage$1(coverageTable) {
                    	    this.table = coverageTable;
                    	}
                    
                    	/**
                    	 * Create a ligature set lookup
                    	 * @param {any} ligatureSets gsub ligature set
                    	 */
                    	function LigatureSets(ligatureSets) {
                    	    this.ligatureSets = ligatureSets;
                    	}
                    
                    	/**
                    	 * Lookup a glyph ligature
                    	 * @param {ContextParams} contextParams context params to lookup
                    	 * @param {number} ligSetIndex ligature set index at ligature sets
                    	 */
                    	LigatureSets.prototype.lookup = function (contextParams, ligSetIndex) {
                    	    var ligatureSet = this.ligatureSets[ligSetIndex];
                    	    var matchComponents = function (components, indexes) {
                    	        if (components.length > indexes.length) { return null; }
                    	        for (var c = 0; c < components.length; c++) {
                    	            var component = components[c];
                    	            var index = indexes[c];
                    	            if (component !== index) { return false; }
                    	        }
                    	        return true;
                    	    };
                    	    for (var s = 0; s < ligatureSet.length; s++) {
                    	        var ligSetItem = ligatureSet[s];
                    	        var lookaheadIndexes = contextParams.lookahead.map(
                    	            function (token) { return token.activeState.value; }
                    	        );
                    	        if (BASE_DIR === 'rtl') { lookaheadIndexes.reverse(); }
                    	        var componentsMatch = matchComponents(
                    	            ligSetItem.components, lookaheadIndexes
                    	        );
                    	        if (componentsMatch) { return ligSetItem; }
                    	    }
                    	    return null;
                    	};
                    
                    	/**
                    	 * Create a feature substitution
                    	 * @param {any} lookups a reference to gsub lookups
                    	 * @param {Lookuptable} lookupTable a feature lookup table
                    	 * @param {any} subtable substitution table
                    	 */
                    	function Substitution$1(lookups, lookupTable, subtable) {
                    	    this.lookups = lookups;
                    	    this.subtable = subtable;
                    	    this.lookupTable = lookupTable;
                    	    if (subtable.hasOwnProperty('coverage')) {
                    	        this.coverage = new Coverage$1(
                    	            subtable.coverage
                    	        );
                    	    }
                    	    if (subtable.hasOwnProperty('inputCoverage')) {
                    	        this.inputCoverage = subtable.inputCoverage.map(
                    	            function (table) { return new Coverage$1(table); }
                    	        );
                    	    }
                    	    if (subtable.hasOwnProperty('backtrackCoverage')) {
                    	        this.backtrackCoverage = subtable.backtrackCoverage.map(
                    	            function (table) { return new Coverage$1(table); }
                    	        );
                    	    }
                    	    if (subtable.hasOwnProperty('lookaheadCoverage')) {
                    	        this.lookaheadCoverage = subtable.lookaheadCoverage.map(
                    	            function (table) { return new Coverage$1(table); }
                    	        );
                    	    }
                    	    if (subtable.hasOwnProperty('ligatureSets')) {
                    	        this.ligatureSets = new LigatureSets(subtable.ligatureSets);
                    	    }
                    	}
                    
                    	/**
                    	 * Create a lookup table lookup
                    	 * @param {number} index table index at gsub lookups
                    	 * @param {any} lookups a reference to gsub lookups
                    	 */
                    	function LookupTable(index, lookups) {
                    	    this.index = index;
                    	    this.subtables = lookups[index].subtables.map(
                    	        function (subtable) { return new Substitution$1(
                    	            lookups, lookups[index], subtable
                    	        ); }
                    	    );
                    	}
                    
                    	function FeatureLookups(lookups, lookupListIndexes) {
                    	    this.lookups = lookupListIndexes.map(
                    	        function (index) { return new LookupTable(index, lookups); }
                    	    );
                    	}
                    
                    	/**
                    	 * Lookup a lookup table subtables
                    	 * @param {ContextParams} contextParams context params to lookup
                    	 */
                    	LookupTable.prototype.lookup = function (contextParams) {
                    	    var this$1 = this;
                    
                    	    var substitutions = [];
                    	    for (var i = 0; i < this.subtables.length; i++) {
                    	        var subsTable = this$1.subtables[i];
                    	        var substitution = subsTable.lookup(contextParams);
                    	        if (substitution !== null || substitution.length) {
                    	            substitutions = substitutions.concat(substitution);
                    	        }
                    	    }
                    	    return substitutions;
                    	};
                    
                    	/**
                    	 * Handle a single substitution - format 2
                    	 * @param {ContextParams} contextParams context params to lookup
                    	 */
                    	function singleSubstitutionFormat2(contextParams) {
                    	    var glyphIndex = contextParams.current.activeState.value;
                    	    glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;
                    	    var substituteIndex = this.coverage.lookup(glyphIndex);
                    	    if (substituteIndex === -1) { return []; }
                    	    return [this.subtable.substitute[substituteIndex]];
                    	}
                    
                    	/**
                    	 * Lookup a list of coverage tables
                    	 * @param {any} coverageList a list of coverage tables
                    	 * @param {any} contextParams context params to lookup
                    	 */
                    	function lookupCoverageList(coverageList, contextParams) {
                    	    var lookupList = [];
                    	    for (var i = 0; i < coverageList.length; i++) {
                    	        var coverage = coverageList[i];
                    	        var glyphIndex = contextParams.current.activeState.value;
                    	        glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;
                    	        var lookupIndex = coverage.lookup(glyphIndex);
                    	        if (lookupIndex !== -1) {
                    	            lookupList.push(lookupIndex);
                    	        }
                    	    }
                    	    if (lookupList.length !== coverageList.length) { return -1; }
                    	    return lookupList;
                    	}
                    
                    	/**
                    	 * Handle chaining context substitution - format 3
                    	 * @param {any} contextParams context params to lookup
                    	 */
                    	function chainingSubstitutionFormat3(contextParams) {
                    	    var this$1 = this;
                    
                    	    var lookupsCount = (
                    	        this.inputCoverage.length +
                    	        this.lookaheadCoverage.length +
                    	        this.backtrackCoverage.length
                    	    );
                    	    if (contextParams.context.length < lookupsCount) { return []; }
                    	    // INPUT LOOKUP //
                    	    var inputLookups = lookupCoverageList(
                    	        this.inputCoverage, contextParams
                    	    );
                    	    if (inputLookups === -1) { return []; }
                    	    // LOOKAHEAD LOOKUP //
                    	    var lookaheadOffset = this.inputCoverage.length - 1;
                    	    if (contextParams.lookahead.length < this.lookaheadCoverage.length) { return []; }
                    	    var lookaheadContext = contextParams.lookahead.slice(lookaheadOffset);
                    	    while (lookaheadContext.length && isTashkeelArabicChar(lookaheadContext[0].char)) {
                    	        lookaheadContext.shift();
                    	    }
                    	    var lookaheadParams = new ContextParams(lookaheadContext, 0);
                    	    var lookaheadLookups = lookupCoverageList(
                    	        this.lookaheadCoverage, lookaheadParams
                    	    );
                    	    // BACKTRACK LOOKUP //
                    	    var backtrackContext = [].concat(contextParams.backtrack);
                    	    backtrackContext.reverse();
                    	    while (backtrackContext.length && isTashkeelArabicChar(backtrackContext[0].char)) {
                    	        backtrackContext.shift();
                    	    }
                    	    if (backtrackContext.length < this.backtrackCoverage.length) { return []; }
                    	    var backtrackParams = new ContextParams(backtrackContext, 0);
                    	    var backtrackLookups = lookupCoverageList(
                    	        this.backtrackCoverage, backtrackParams
                    	    );
                    	    var contextRulesMatch = (
                    	        inputLookups.length === this.inputCoverage.length &&
                    	        lookaheadLookups.length === this.lookaheadCoverage.length &&
                    	        backtrackLookups.length === this.backtrackCoverage.length
                    	    );
                    	    var substitutions = [];
                    	    if (contextRulesMatch) {
                    	        var lookupRecords = this.subtable.lookupRecords;
                    	        for (var i = 0; i < lookupRecords.length; i++) {
                    	            var lookupRecord = lookupRecords[i];
                    	            for (var j = 0; j < inputLookups.length; j++) {
                    	                var inputContext = new ContextParams([contextParams.get(j)], 0);
                    	                var lookupIndex = lookupRecord.lookupListIndex;
                    	                var lookupTable = new LookupTable(lookupIndex, this$1.lookups);
                    	                var lookup = lookupTable.lookup(inputContext);
                    	                substitutions = substitutions.concat(lookup);
                    	            }
                    	        }
                    	    }
                    	    return substitutions;
                    	}
                    
                    	/**
                    	 * Handle ligature substitution - format 1
                    	 * @param {any} contextParams context params to lookup
                    	 */
                    	function ligatureSubstitutionFormat1(contextParams) {
                    	    // COVERAGE LOOKUP //
                    	    var glyphIndex = contextParams.current.activeState.value;
                    	    var ligSetIndex = this.coverage.lookup(glyphIndex);
                    	    if (ligSetIndex === -1) { return []; }
                    	    // COMPONENTS LOOKUP * note that components is logically ordered
                    	    var ligGlyphs = this.ligatureSets.lookup(contextParams, ligSetIndex);
                    	    return ligGlyphs ? [ligGlyphs] : [];
                    	}
                    
                    	/**
                    	 * [ LOOKUP TYPES ]
                    	 * -------------------------------
                    	 * Single                        1;
                    	 * Multiple                      2;
                    	 * Alternate                     3;
                    	 * Ligature                      4;
                    	 * Context                       5;
                    	 * ChainingContext               6;
                    	 * ExtensionSubstitution         7;
                    	 * ReverseChainingContext        8;
                    	 * -------------------------------
                    	 * @param {any} contextParams context params to lookup
                    	 */
                    	Substitution$1.prototype.lookup = function (contextParams) {
                    	    var substitutions = [];
                    	    var lookupType = this.lookupTable.lookupType;
                    	    var substFormat = this.subtable.substFormat;
                    	    if (lookupType === 1 && substFormat === 2) {
                    	        var substitution = singleSubstitutionFormat2.call(this, contextParams);
                    	        if (substitution.length > 0) {
                    	            substitutions.push({ id: 12, substitution: substitution });
                    	        }
                    	    }
                    	    if (lookupType === 6 && substFormat === 3) {
                    	        var substitution$1 = chainingSubstitutionFormat3.call(this, contextParams);
                    	        if (substitution$1.length > 0) {
                    	            substitutions.push({ id: 63, substitution: substitution$1 });
                    	        }
                    	    }
                    	    if (lookupType === 4 && substFormat === 1) {
                    	        var substitution$2 = ligatureSubstitutionFormat1.call(this, contextParams);
                    	        if (substitution$2.length > 0) {
                    	            substitutions.push({ id: 41, substitution: substitution$2 });
                    	        }
                    	    }
                    	    return substitutions;
                    	};
                    
                    	/**
                    	 * Lookup a coverage table
                    	 * @param {number} glyphIndex to lookup
                    	 */
                    	Coverage$1.prototype.lookup = function (glyphIndex) {
                    	    if (!glyphIndex) { return -1; }
                    	    switch (this.table.format) {
                    	        case 1:
                    	            return this.table.glyphs.indexOf(glyphIndex);
                    
                    	        case 2:
                    	            var ranges = this.table.ranges;
                    	            for (var i = 0; i < ranges.length; i++) {
                    	                var range = ranges[i];
                    	                if (glyphIndex >= range.start && glyphIndex <= range.end) {
                    	                    var offset = glyphIndex - range.start;
                    	                    return range.index + offset;
                    	                }
                    	            }
                    	            break;
                    	        default:
                    	            return -1; // not found
                    	    }
                    	    return -1;
                    	};
                    
                    	/**
                    	 * Lookup a feature for a substitution or more
                    	 * @param {any} contextParams context params to lookup
                    	 */
                    	Feature.prototype.lookup = function(contextParams) {
                    	    var this$1 = this;
                    
                    	    var lookups = [];
                    	    for (var i = 0; i < this.lookups.length; i++) {
                    	        var lookupTable = this$1.lookups[i];
                    	        var lookup = lookupTable.lookup(contextParams);
                    	        if (lookup !== null || lookup.length) {
                    	            lookups = lookups.concat(lookup);
                    	        }
                    	    }
                    	    return lookups;
                    	};
                    
                    	/**
                    	 * Get feature indexes of a specific script
                    	 * @param {string} scriptTag script tag
                    	 */
                    	FeatureQuery.prototype.getScriptFeaturesIndexes = function(scriptTag) {
                    	    if (!scriptTag) { return []; }
                    	    var tables = this.font.tables;
                    	    if (!tables.gsub) { return []; }
                    	    var scripts = this.font.tables.gsub.scripts;
                    	    for (var i = 0; i < scripts.length; i++) {
                    	        var script = scripts[i];
                    	        if (script.tag === scriptTag) {
                    	            var defaultLangSys = script.script.defaultLangSys;
                    	            return defaultLangSys.featureIndexes;
                    	        } else {
                    	            var langSysRecords = script.langSysRecords;
                    	            if (!!langSysRecords) {
                    	                for (var j = 0; j < langSysRecords.length; j++) {
                    	                    var langSysRecord = langSysRecords[j];
                    	                    if (langSysRecord.tag === scriptTag) {
                    	                        var langSys = langSysRecord.langSys;
                    	                        return langSys.featureIndexes;
                    	                    }
                    	                }
                    	            }
                    	        }
                    	    }
                    	    return [];
                    	};
                    
                    	/**
                    	 * Map a feature tag to a gsub feature
                    	 * @param {any} features gsub features
                    	 * @param {*} scriptTag script tag
                    	 */
                    	FeatureQuery.prototype.mapTagsToFeatures = function (features, scriptTag) {
                    	    var this$1 = this;
                    
                    	    var tags = {};
                    	    for (var i = 0; i < features.length; i++) {
                    	        var feature = features[i].feature;
                    	        var tag = features[i].tag;
                    	        var lookups = this$1.font.tables.gsub.lookups;
                    	        var featureLookups = new FeatureLookups(lookups, feature.lookupListIndexes);
                    	        tags[tag] = new Feature(tag, feature, featureLookups, scriptTag);
                    	    }
                    	    this.features[scriptTag].tags = tags;
                    	};
                    
                    	/**
                    	 * Get features of a specific script
                    	 * @param {string} scriptTag script tag
                    	 */
                    	FeatureQuery.prototype.getScriptFeatures = function (scriptTag) {
                    	    var features = this.features[scriptTag];
                    	    if (this.features.hasOwnProperty(scriptTag)) { return features; }
                    	    var featuresIndexes = this.getScriptFeaturesIndexes(scriptTag);
                    	    if (!featuresIndexes) { return null; }
                    	    var gsub = this.font.tables.gsub;
                    	    features = featuresIndexes.map(function (index) { return gsub.features[index]; });
                    	    this.features[scriptTag] = features;
                    	    this.mapTagsToFeatures(features, scriptTag);
                    	    return features;
                    	};
                    
                    	/**
                    	 * Query a feature by it's properties
                    	 * @param {any} query an object that describes the properties of a query
                    	 */
                    	FeatureQuery.prototype.getFeature = function (query) {
                    	    if (!this.font) { return { FAIL: "No font was found"}; }
                    	    if (!this.features.hasOwnProperty(query.script)) {
                    	        this.getScriptFeatures(query.script);
                    	    }
                    	    return this.features[query.script].tags[query.tag] || null;
                    	};
                    
                    	// The Font object
                    
                    	/**
                    	 * @typedef FontOptions
                    	 * @type Object
                    	 * @property {Boolean} empty - whether to create a new empty font
                    	 * @property {string} familyName
                    	 * @property {string} styleName
                    	 * @property {string=} fullName
                    	 * @property {string=} postScriptName
                    	 * @property {string=} designer
                    	 * @property {string=} designerURL
                    	 * @property {string=} manufacturer
                    	 * @property {string=} manufacturerURL
                    	 * @property {string=} license
                    	 * @property {string=} licenseURL
                    	 * @property {string=} version
                    	 * @property {string=} description
                    	 * @property {string=} copyright
                    	 * @property {string=} trademark
                    	 * @property {Number} unitsPerEm
                    	 * @property {Number} ascender
                    	 * @property {Number} descender
                    	 * @property {Number} createdTimestamp
                    	 * @property {string=} weightClass
                    	 * @property {string=} widthClass
                    	 * @property {string=} fsSelection
                    	 */
                    
                    	/**
                    	 * A Font represents a loaded OpenType font file.
                    	 * It contains a set of glyphs and methods to draw text on a drawing context,
                    	 * or to get a path representing the text.
                    	 * @exports opentype.Font
                    	 * @class
                    	 * @param {FontOptions}
                    	 * @constructor
                    	 */
                    	function Font(options) {
                    	    options = options || {};
                    
                    	    if (!options.empty) {
                    	        // Check that we've provided the minimum set of names.
                    	        checkArgument(options.familyName, 'When creating a new Font object, familyName is required.');
                    	        checkArgument(options.styleName, 'When creating a new Font object, styleName is required.');
                    	        checkArgument(options.unitsPerEm, 'When creating a new Font object, unitsPerEm is required.');
                    	        checkArgument(options.ascender, 'When creating a new Font object, ascender is required.');
                    	        checkArgument(options.descender, 'When creating a new Font object, descender is required.');
                    	        checkArgument(options.descender < 0, 'Descender should be negative (e.g. -512).');
                    
                    	        // OS X will complain if the names are empty, so we put a single space everywhere by default.
                    	        this.names = {
                    	            fontFamily: {en: options.familyName || ' '},
                    	            fontSubfamily: {en: options.styleName || ' '},
                    	            fullName: {en: options.fullName || options.familyName + ' ' + options.styleName},
                    	            // postScriptName may not contain any whitespace
                    	            postScriptName: {en: options.postScriptName || (options.familyName + options.styleName).replace(/\s/g, '')},
                    	            designer: {en: options.designer || ' '},
                    	            designerURL: {en: options.designerURL || ' '},
                    	            manufacturer: {en: options.manufacturer || ' '},
                    	            manufacturerURL: {en: options.manufacturerURL || ' '},
                    	            license: {en: options.license || ' '},
                    	            licenseURL: {en: options.licenseURL || ' '},
                    	            version: {en: options.version || 'Version 0.1'},
                    	            description: {en: options.description || ' '},
                    	            copyright: {en: options.copyright || ' '},
                    	            trademark: {en: options.trademark || ' '}
                    	        };
                    	        this.unitsPerEm = options.unitsPerEm || 1000;
                    	        this.ascender = options.ascender;
                    	        this.descender = options.descender;
                    	        this.createdTimestamp = options.createdTimestamp;
                    	        this.tables = { os2: {
                    	            usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,
                    	            usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,
                    	            fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR
                    	        } };
                    	    }
                    
                    	    this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.
                    	    this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);
                    	    this.encoding = new DefaultEncoding(this);
                    	    this.position = new Position(this);
                    	    this.substitution = new Substitution(this);
                    	    this.tables = this.tables || {};
                    
                    	    Object.defineProperty(this, 'hinting', {
                    	        get: function() {
                    	            if (this._hinting) { return this._hinting; }
                    	            if (this.outlinesFormat === 'truetype') {
                    	                return (this._hinting = new Hinting(this));
                    	            }
                    	        }
                    	    });
                    	}
                    
                    	/**
                    	 * Check if the font has a glyph for the given character.
                    	 * @param  {string}
                    	 * @return {Boolean}
                    	 */
                    	Font.prototype.hasChar = function(c) {
                    	    return this.encoding.charToGlyphIndex(c) !== null;
                    	};
                    
                    	/**
                    	 * Convert the given character to a single glyph index.
                    	 * Note that this function assumes that there is a one-to-one mapping between
                    	 * the given character and a glyph; for complex scripts this might not be the case.
                    	 * @param  {string}
                    	 * @return {Number}
                    	 */
                    	Font.prototype.charToGlyphIndex = function(s) {
                    	    return this.encoding.charToGlyphIndex(s);
                    	};
                    
                    	/**
                    	 * Convert the given character to a single Glyph object.
                    	 * Note that this function assumes that there is a one-to-one mapping between
                    	 * the given character and a glyph; for complex scripts this might not be the case.
                    	 * @param  {string}
                    	 * @return {opentype.Glyph}
                    	 */
                    	Font.prototype.charToGlyph = function(c) {
                    	    var glyphIndex = this.charToGlyphIndex(c);
                    	    var glyph = this.glyphs.get(glyphIndex);
                    	    if (!glyph) {
                    	        // .notdef
                    	        glyph = this.glyphs.get(0);
                    	    }
                    
                    	    return glyph;
                    	};
                    
                    	/**
                    	 * Convert the given text to a list of Glyph objects.
                    	 * Note that there is no strict one-to-one mapping between characters and
                    	 * glyphs, so the list of returned glyphs can be larger or smaller than the
                    	 * length of the given string.
                    	 * @param  {string}
                    	 * @param  {GlyphRenderOptions} [options]
                    	 * @return {opentype.Glyph[]}
                    	 */
                    	Font.prototype.stringToGlyphs = function(s, options) {
                    	    var this$1 = this;
                    
                    	    options = options || this.defaultRenderOptions;
                    
                    	    var bidi = new Bidi();
                    
                    	    // Create and register 'glyphIndex' state modifier
                    	    var charToGlyphIndexMod = function (token) { return this$1.charToGlyphIndex(token.char); };
                    	    bidi.registerModifier('glyphIndex', null, charToGlyphIndexMod);
                    
                    	    var arabFeatureQuery = new FeatureQuery(this);
                    	    var arabFeatures = ['init', 'medi', 'fina', 'rlig'];
                    	    bidi.applyFeatures(
                    	        arabFeatures.map(function (tag) {
                    	            var query = { tag: tag, script: 'arab' };
                    	            var feature = arabFeatureQuery.getFeature(query);
                    	            if (!!feature) { return feature; }
                    	        })
                    	    );
                    	    var indexes = bidi.getTextGlyphs(s);
                    
                    	    var length = indexes.length;
                    
                    	    // Apply substitutions on glyph indexes
                    	    if (options.features) {
                    	        var script = options.script || this.substitution.getDefaultScriptName();
                    	        var manyToOne = [];
                    	        if (options.features.liga) { manyToOne = manyToOne.concat(this.substitution.getFeature('liga', script, options.language)); }
                    	        if (options.features.rlig) { manyToOne = manyToOne.concat(this.substitution.getFeature('rlig', script, options.language)); }
                    	        for (var i = 0; i < length; i += 1) {
                    	            for (var j = 0; j < manyToOne.length; j++) {
                    	                var ligature = manyToOne[j];
                    	                var components = ligature.sub;
                    	                var compCount = components.length;
                    	                var k = 0;
                    	                while (k < compCount && components[k] === indexes[i + k]) { k++; }
                    	                if (k === compCount) {
                    	                    indexes.splice(i, compCount, ligature.by);
                    	                    length = length - compCount + 1;
                    	                }
                    	            }
                    	        }
                    	    }
                    
                    	    // convert glyph indexes to glyph objects
                    	    var glyphs = new Array(length);
                    	    var notdef = this.glyphs.get(0);
                    	    for (var i$1 = 0; i$1 < length; i$1 += 1) {
                    	        glyphs[i$1] = this$1.glyphs.get(indexes[i$1]) || notdef;
                    	    }
                    	    return glyphs;
                    	};
                    
                    	/**
                    	 * @param  {string}
                    	 * @return {Number}
                    	 */
                    	Font.prototype.nameToGlyphIndex = function(name) {
                    	    return this.glyphNames.nameToGlyphIndex(name);
                    	};
                    
                    	/**
                    	 * @param  {string}
                    	 * @return {opentype.Glyph}
                    	 */
                    	Font.prototype.nameToGlyph = function(name) {
                    	    var glyphIndex = this.nameToGlyphIndex(name);
                    	    var glyph = this.glyphs.get(glyphIndex);
                    	    if (!glyph) {
                    	        // .notdef
                    	        glyph = this.glyphs.get(0);
                    	    }
                    
                    	    return glyph;
                    	};
                    
                    	/**
                    	 * @param  {Number}
                    	 * @return {String}
                    	 */
                    	Font.prototype.glyphIndexToName = function(gid) {
                    	    if (!this.glyphNames.glyphIndexToName) {
                    	        return '';
                    	    }
                    
                    	    return this.glyphNames.glyphIndexToName(gid);
                    	};
                    
                    	/**
                    	 * Retrieve the value of the kerning pair between the left glyph (or its index)
                    	 * and the right glyph (or its index). If no kerning pair is found, return 0.
                    	 * The kerning value gets added to the advance width when calculating the spacing
                    	 * between glyphs.
                    	 * For GPOS kerning, this method uses the default script and language, which covers
                    	 * most use cases. To have greater control, use font.position.getKerningValue .
                    	 * @param  {opentype.Glyph} leftGlyph
                    	 * @param  {opentype.Glyph} rightGlyph
                    	 * @return {Number}
                    	 */
                    	Font.prototype.getKerningValue = function(leftGlyph, rightGlyph) {
                    	    leftGlyph = leftGlyph.index || leftGlyph;
                    	    rightGlyph = rightGlyph.index || rightGlyph;
                    	    var gposKerning = this.position.defaultKerningTables;
                    	    if (gposKerning) { 
                    	        return this.position.getKerningValue(gposKerning, leftGlyph, rightGlyph);
                    	    }
                    	    // "kern" table
                    	    return this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0;
                    	};
                    
                    	/**
                    	 * @typedef GlyphRenderOptions
                    	 * @type Object
                    	 * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.
                    	 *                               See https://www.microsoft.com/typography/otspec/scripttags.htm
                    	 * @property {string} [language='dflt'] - language system used to determine which features to apply.
                    	 *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx
                    	 * @property {boolean} [kerning=true] - whether to include kerning values
                    	 * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.
                    	 *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm
                    	 */
                    	Font.prototype.defaultRenderOptions = {
                    	    kerning: true,
                    	    features: {
                    	        liga: true,
                    	        rlig: true
                    	    }
                    	};
                    
                    	/**
                    	 * Helper function that invokes the given callback for each glyph in the given text.
                    	 * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text
                    	 * @param {string} text - The text to apply.
                    	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
                    	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
                    	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
                    	 * @param  {GlyphRenderOptions=} options
                    	 * @param  {Function} callback
                    	 */
                    	Font.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {
                    	    var this$1 = this;
                    
                    	    x = x !== undefined ? x : 0;
                    	    y = y !== undefined ? y : 0;
                    	    fontSize = fontSize !== undefined ? fontSize : 72;
                    	    options = options || this.defaultRenderOptions;
                    	    var fontScale = 1 / this.unitsPerEm * fontSize;
                    	    var glyphs = this.stringToGlyphs(text, options);
                    	    var kerningLookups;
                    	    if (options.kerning) {
                    	        var script = options.script || this.position.getDefaultScriptName();
                    	        kerningLookups = this.position.getKerningTables(script, options.language);
                    	    }
                    	    for (var i = 0; i < glyphs.length; i += 1) {
                    	        var glyph = glyphs[i];
                    	        callback.call(this$1, glyph, x, y, fontSize, options);
                    	        if (glyph.advanceWidth) {
                    	            x += glyph.advanceWidth * fontScale;
                    	        }
                    
                    	        if (options.kerning && i < glyphs.length - 1) {
                    	            // We should apply position adjustment lookups in a more generic way.
                    	            // Here we only use the xAdvance value.
                    	            var kerningValue = kerningLookups ?
                    	                  this$1.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index) :
                    	                  this$1.getKerningValue(glyph, glyphs[i + 1]);
                    	            x += kerningValue * fontScale;
                    	        }
                    
                    	        if (options.letterSpacing) {
                    	            x += options.letterSpacing * fontSize;
                    	        } else if (options.tracking) {
                    	            x += (options.tracking / 1000) * fontSize;
                    	        }
                    	    }
                    	    return x;
                    	};
                    
                    	/**
                    	 * Create a Path object that represents the given text.
                    	 * @param  {string} text - The text to create.
                    	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
                    	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
                    	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
                    	 * @param  {GlyphRenderOptions=} options
                    	 * @return {opentype.Path}
                    	 */
                    	Font.prototype.getPath = function(text, x, y, fontSize, options) {
                    	    var fullPath = new Path();
                    	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
                    	        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
                    	        fullPath.extend(glyphPath);
                    	    });
                    	    return fullPath;
                    	};
                    
                    	/**
                    	 * Create an array of Path objects that represent the glyphs of a given text.
                    	 * @param  {string} text - The text to create.
                    	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
                    	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
                    	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
                    	 * @param  {GlyphRenderOptions=} options
                    	 * @return {opentype.Path[]}
                    	 */
                    	Font.prototype.getPaths = function(text, x, y, fontSize, options) {
                    	    var glyphPaths = [];
                    	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
                    	        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
                    	        glyphPaths.push(glyphPath);
                    	    });
                    
                    	    return glyphPaths;
                    	};
                    
                    	/**
                    	 * Returns the advance width of a text.
                    	 *
                    	 * This is something different than Path.getBoundingBox() as for example a
                    	 * suffixed whitespace increases the advanceWidth but not the bounding box
                    	 * or an overhanging letter like a calligraphic 'f' might have a quite larger
                    	 * bounding box than its advance width.
                    	 *
                    	 * This corresponds to canvas2dContext.measureText(text).width
                    	 *
                    	 * @param  {string} text - The text to create.
                    	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
                    	 * @param  {GlyphRenderOptions=} options
                    	 * @return advance width
                    	 */
                    	Font.prototype.getAdvanceWidth = function(text, fontSize, options) {
                    	    return this.forEachGlyph(text, 0, 0, fontSize, options, function() {});
                    	};
                    
                    	/**
                    	 * Draw the text on the given drawing context.
                    	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
                    	 * @param  {string} text - The text to create.
                    	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
                    	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
                    	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
                    	 * @param  {GlyphRenderOptions=} options
                    	 */
                    	Font.prototype.draw = function(ctx, text, x, y, fontSize, options) {
                    	    this.getPath(text, x, y, fontSize, options).draw(ctx);
                    	};
                    
                    	/**
                    	 * Draw the points of all glyphs in the text.
                    	 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
                    	 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
                    	 * @param {string} text - The text to create.
                    	 * @param {number} [x=0] - Horizontal position of the beginning of the text.
                    	 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
                    	 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
                    	 * @param {GlyphRenderOptions=} options
                    	 */
                    	Font.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {
                    	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
                    	        glyph.drawPoints(ctx, gX, gY, gFontSize);
                    	    });
                    	};
                    
                    	/**
                    	 * Draw lines indicating important font measurements for all glyphs in the text.
                    	 * Black lines indicate the origin of the coordinate system (point 0,0).
                    	 * Blue lines indicate the glyph bounding box.
                    	 * Green line indicates the advance width of the glyph.
                    	 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
                    	 * @param {string} text - The text to create.
                    	 * @param {number} [x=0] - Horizontal position of the beginning of the text.
                    	 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
                    	 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
                    	 * @param {GlyphRenderOptions=} options
                    	 */
                    	Font.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {
                    	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
                    	        glyph.drawMetrics(ctx, gX, gY, gFontSize);
                    	    });
                    	};
                    
                    	/**
                    	 * @param  {string}
                    	 * @return {string}
                    	 */
                    	Font.prototype.getEnglishName = function(name) {
                    	    var translations = this.names[name];
                    	    if (translations) {
                    	        return translations.en;
                    	    }
                    	};
                    
                    	/**
                    	 * Validate
                    	 */
                    	Font.prototype.validate = function() {
                    	    var _this = this;
                    
                    	    function assert(predicate, message) {
                    	    }
                    
                    	    function assertNamePresent(name) {
                    	        var englishName = _this.getEnglishName(name);
                    	        assert(englishName && englishName.trim().length > 0,
                    	               'No English ' + name + ' specified.');
                    	    }
                    
                    	    // Identification information
                    	    assertNamePresent('fontFamily');
                    	    assertNamePresent('weightName');
                    	    assertNamePresent('manufacturer');
                    	    assertNamePresent('copyright');
                    	    assertNamePresent('version');
                    
                    	    // Dimension information
                    	    assert(this.unitsPerEm > 0, 'No unitsPerEm specified.');
                    	};
                    
                    	/**
                    	 * Convert the font object to a SFNT data structure.
                    	 * This structure contains all the necessary tables and metadata to create a binary OTF file.
                    	 * @return {opentype.Table}
                    	 */
                    	Font.prototype.toTables = function() {
                    	    return sfnt.fontToTable(this);
                    	};
                    	/**
                    	 * @deprecated Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.
                    	 */
                    	Font.prototype.toBuffer = function() {
                    	    console.warn('Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.');
                    	    return this.toArrayBuffer();
                    	};
                    	/**
                    	 * Converts a `opentype.Font` into an `ArrayBuffer`
                    	 * @return {ArrayBuffer}
                    	 */
                    	Font.prototype.toArrayBuffer = function() {
                    	    var sfntTable = this.toTables();
                    	    var bytes = sfntTable.encode();
                    	    var buffer = new ArrayBuffer(bytes.length);
                    	    var intArray = new Uint8Array(buffer);
                    	    for (var i = 0; i < bytes.length; i++) {
                    	        intArray[i] = bytes[i];
                    	    }
                    
                    	    return buffer;
                    	};
                    
                    	/**
                    	 * Initiate a download of the OpenType font.
                    	 */
                    	Font.prototype.download = function(fileName) {
                    	    var familyName = this.getEnglishName('fontFamily');
                    	    var styleName = this.getEnglishName('fontSubfamily');
                    	    fileName = fileName || familyName.replace(/\s/g, '') + '-' + styleName + '.otf';
                    	    var arrayBuffer = this.toArrayBuffer();
                    
                    	    if (isBrowser()) {
                    	        window.URL = window.URL || window.webkitURL;
                    
                    	        if (window.URL) {
                    	            var dataView = new DataView(arrayBuffer);
                    	            var blob = new Blob([dataView], {type: 'font/opentype'});
                    
                    	            var link = document.createElement('a');
                    	            link.href = window.URL.createObjectURL(blob);
                    	            link.download = fileName;
                    
                    	            var event = document.createEvent('MouseEvents');
                    	            event.initEvent('click', true, false);
                    	            link.dispatchEvent(event);
                    	        } else {
                    	            console.warn('Font file could not be downloaded. Try using a different browser.');
                    	        }
                    	    } else {
                    	        var fs = require('fs');
                    	        var buffer = arrayBufferToNodeBuffer(arrayBuffer);
                    	        fs.writeFileSync(fileName, buffer);
                    	    }
                    	};
                    	/**
                    	 * @private
                    	 */
                    	Font.prototype.fsSelectionValues = {
                    	    ITALIC:              0x001, //1
                    	    UNDERSCORE:          0x002, //2
                    	    NEGATIVE:            0x004, //4
                    	    OUTLINED:            0x008, //8
                    	    STRIKEOUT:           0x010, //16
                    	    BOLD:                0x020, //32
                    	    REGULAR:             0x040, //64
                    	    USER_TYPO_METRICS:   0x080, //128
                    	    WWS:                 0x100, //256
                    	    OBLIQUE:             0x200  //512
                    	};
                    
                    	/**
                    	 * @private
                    	 */
                    	Font.prototype.usWidthClasses = {
                    	    ULTRA_CONDENSED: 1,
                    	    EXTRA_CONDENSED: 2,
                    	    CONDENSED: 3,
                    	    SEMI_CONDENSED: 4,
                    	    MEDIUM: 5,
                    	    SEMI_EXPANDED: 6,
                    	    EXPANDED: 7,
                    	    EXTRA_EXPANDED: 8,
                    	    ULTRA_EXPANDED: 9
                    	};
                    
                    	/**
                    	 * @private
                    	 */
                    	Font.prototype.usWeightClasses = {
                    	    THIN: 100,
                    	    EXTRA_LIGHT: 200,
                    	    LIGHT: 300,
                    	    NORMAL: 400,
                    	    MEDIUM: 500,
                    	    SEMI_BOLD: 600,
                    	    BOLD: 700,
                    	    EXTRA_BOLD: 800,
                    	    BLACK:    900
                    	};
                    
                    	// The `fvar` table stores font variation axes and instances.
                    
                    	function addName(name, names) {
                    	    var nameString = JSON.stringify(name);
                    	    var nameID = 256;
                    	    for (var nameKey in names) {
                    	        var n = parseInt(nameKey);
                    	        if (!n || n < 256) {
                    	            continue;
                    	        }
                    
                    	        if (JSON.stringify(names[nameKey]) === nameString) {
                    	            return n;
                    	        }
                    
                    	        if (nameID <= n) {
                    	            nameID = n + 1;
                    	        }
                    	    }
                    
                    	    names[nameID] = name;
                    	    return nameID;
                    	}
                    
                    	function makeFvarAxis(n, axis, names) {
                    	    var nameID = addName(axis.name, names);
                    	    return [
                    	        {name: 'tag_' + n, type: 'TAG', value: axis.tag},
                    	        {name: 'minValue_' + n, type: 'FIXED', value: axis.minValue << 16},
                    	        {name: 'defaultValue_' + n, type: 'FIXED', value: axis.defaultValue << 16},
                    	        {name: 'maxValue_' + n, type: 'FIXED', value: axis.maxValue << 16},
                    	        {name: 'flags_' + n, type: 'USHORT', value: 0},
                    	        {name: 'nameID_' + n, type: 'USHORT', value: nameID}
                    	    ];
                    	}
                    
                    	function parseFvarAxis(data, start, names) {
                    	    var axis = {};
                    	    var p = new parse.Parser(data, start);
                    	    axis.tag = p.parseTag();
                    	    axis.minValue = p.parseFixed();
                    	    axis.defaultValue = p.parseFixed();
                    	    axis.maxValue = p.parseFixed();
                    	    p.skip('uShort', 1);  // reserved for flags; no values defined
                    	    axis.name = names[p.parseUShort()] || {};
                    	    return axis;
                    	}
                    
                    	function makeFvarInstance(n, inst, axes, names) {
                    	    var nameID = addName(inst.name, names);
                    	    var fields = [
                    	        {name: 'nameID_' + n, type: 'USHORT', value: nameID},
                    	        {name: 'flags_' + n, type: 'USHORT', value: 0}
                    	    ];
                    
                    	    for (var i = 0; i < axes.length; ++i) {
                    	        var axisTag = axes[i].tag;
                    	        fields.push({
                    	            name: 'axis_' + n + ' ' + axisTag,
                    	            type: 'FIXED',
                    	            value: inst.coordinates[axisTag] << 16
                    	        });
                    	    }
                    
                    	    return fields;
                    	}
                    
                    	function parseFvarInstance(data, start, axes, names) {
                    	    var inst = {};
                    	    var p = new parse.Parser(data, start);
                    	    inst.name = names[p.parseUShort()] || {};
                    	    p.skip('uShort', 1);  // reserved for flags; no values defined
                    
                    	    inst.coordinates = {};
                    	    for (var i = 0; i < axes.length; ++i) {
                    	        inst.coordinates[axes[i].tag] = p.parseFixed();
                    	    }
                    
                    	    return inst;
                    	}
                    
                    	function makeFvarTable(fvar, names) {
                    	    var result = new table.Table('fvar', [
                    	        {name: 'version', type: 'ULONG', value: 0x10000},
                    	        {name: 'offsetToData', type: 'USHORT', value: 0},
                    	        {name: 'countSizePairs', type: 'USHORT', value: 2},
                    	        {name: 'axisCount', type: 'USHORT', value: fvar.axes.length},
                    	        {name: 'axisSize', type: 'USHORT', value: 20},
                    	        {name: 'instanceCount', type: 'USHORT', value: fvar.instances.length},
                    	        {name: 'instanceSize', type: 'USHORT', value: 4 + fvar.axes.length * 4}
                    	    ]);
                    	    result.offsetToData = result.sizeOf();
                    
                    	    for (var i = 0; i < fvar.axes.length; i++) {
                    	        result.fields = result.fields.concat(makeFvarAxis(i, fvar.axes[i], names));
                    	    }
                    
                    	    for (var j = 0; j < fvar.instances.length; j++) {
                    	        result.fields = result.fields.concat(makeFvarInstance(j, fvar.instances[j], fvar.axes, names));
                    	    }
                    
                    	    return result;
                    	}
                    
                    	function parseFvarTable(data, start, names) {
                    	    var p = new parse.Parser(data, start);
                    	    var tableVersion = p.parseULong();
                    	    check.argument(tableVersion === 0x00010000, 'Unsupported fvar table version.');
                    	    var offsetToData = p.parseOffset16();
                    	    // Skip countSizePairs.
                    	    p.skip('uShort', 1);
                    	    var axisCount = p.parseUShort();
                    	    var axisSize = p.parseUShort();
                    	    var instanceCount = p.parseUShort();
                    	    var instanceSize = p.parseUShort();
                    
                    	    var axes = [];
                    	    for (var i = 0; i < axisCount; i++) {
                    	        axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));
                    	    }
                    
                    	    var instances = [];
                    	    var instanceStart = start + offsetToData + axisCount * axisSize;
                    	    for (var j = 0; j < instanceCount; j++) {
                    	        instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));
                    	    }
                    
                    	    return {axes: axes, instances: instances};
                    	}
                    
                    	var fvar = { make: makeFvarTable, parse: parseFvarTable };
                    
                    	// The `GPOS` table contains kerning pairs, among other things.
                    
                    	var subtableParsers$1 = new Array(10);         // subtableParsers[0] is unused
                    
                    	// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable
                    	// this = Parser instance
                    	subtableParsers$1[1] = function parseLookup1() {
                    	    var start = this.offset + this.relativeOffset;
                    	    var posformat = this.parseUShort();
                    	    if (posformat === 1) {
                    	        return {
                    	            posFormat: 1,
                    	            coverage: this.parsePointer(Parser.coverage),
                    	            value: this.parseValueRecord()
                    	        };
                    	    } else if (posformat === 2) {
                    	        return {
                    	            posFormat: 2,
                    	            coverage: this.parsePointer(Parser.coverage),
                    	            values: this.parseValueRecordList()
                    	        };
                    	    }
                    	    check.assert(false, '0x' + start.toString(16) + ': GPOS lookup type 1 format must be 1 or 2.');
                    	};
                    
                    	// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-2-pair-adjustment-positioning-subtable
                    	subtableParsers$1[2] = function parseLookup2() {
                    	    var start = this.offset + this.relativeOffset;
                    	    var posFormat = this.parseUShort();
                    	    check.assert(posFormat === 1 || posFormat === 2, '0x' + start.toString(16) + ': GPOS lookup type 2 format must be 1 or 2.');
                    	    var coverage = this.parsePointer(Parser.coverage);
                    	    var valueFormat1 = this.parseUShort();
                    	    var valueFormat2 = this.parseUShort();
                    	    if (posFormat === 1) {
                    	        // Adjustments for Glyph Pairs
                    	        return {
                    	            posFormat: posFormat,
                    	            coverage: coverage,
                    	            valueFormat1: valueFormat1,
                    	            valueFormat2: valueFormat2,
                    	            pairSets: this.parseList(Parser.pointer(Parser.list(function() {
                    	                return {        // pairValueRecord
                    	                    secondGlyph: this.parseUShort(),
                    	                    value1: this.parseValueRecord(valueFormat1),
                    	                    value2: this.parseValueRecord(valueFormat2)
                    	                };
                    	            })))
                    	        };
                    	    } else if (posFormat === 2) {
                    	        var classDef1 = this.parsePointer(Parser.classDef);
                    	        var classDef2 = this.parsePointer(Parser.classDef);
                    	        var class1Count = this.parseUShort();
                    	        var class2Count = this.parseUShort();
                    	        return {
                    	            // Class Pair Adjustment
                    	            posFormat: posFormat,
                    	            coverage: coverage,
                    	            valueFormat1: valueFormat1,
                    	            valueFormat2: valueFormat2,
                    	            classDef1: classDef1,
                    	            classDef2: classDef2,
                    	            class1Count: class1Count,
                    	            class2Count: class2Count,
                    	            classRecords: this.parseList(class1Count, Parser.list(class2Count, function() {
                    	                return {
                    	                    value1: this.parseValueRecord(valueFormat1),
                    	                    value2: this.parseValueRecord(valueFormat2)
                    	                };
                    	            }))
                    	        };
                    	    }
                    	};
                    
                    	subtableParsers$1[3] = function parseLookup3() { return { error: 'GPOS Lookup 3 not supported' }; };
                    	subtableParsers$1[4] = function parseLookup4() { return { error: 'GPOS Lookup 4 not supported' }; };
                    	subtableParsers$1[5] = function parseLookup5() { return { error: 'GPOS Lookup 5 not supported' }; };
                    	subtableParsers$1[6] = function parseLookup6() { return { error: 'GPOS Lookup 6 not supported' }; };
                    	subtableParsers$1[7] = function parseLookup7() { return { error: 'GPOS Lookup 7 not supported' }; };
                    	subtableParsers$1[8] = function parseLookup8() { return { error: 'GPOS Lookup 8 not supported' }; };
                    	subtableParsers$1[9] = function parseLookup9() { return { error: 'GPOS Lookup 9 not supported' }; };
                    
                    	// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos
                    	function parseGposTable(data, start) {
                    	    start = start || 0;
                    	    var p = new Parser(data, start);
                    	    var tableVersion = p.parseVersion(1);
                    	    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GPOS table version ' + tableVersion);
                    
                    	    if (tableVersion === 1) {
                    	        return {
                    	            version: tableVersion,
                    	            scripts: p.parseScriptList(),
                    	            features: p.parseFeatureList(),
                    	            lookups: p.parseLookupList(subtableParsers$1)
                    	        };
                    	    } else {
                    	        return {
                    	            version: tableVersion,
                    	            scripts: p.parseScriptList(),
                    	            features: p.parseFeatureList(),
                    	            lookups: p.parseLookupList(subtableParsers$1),
                    	            variations: p.parseFeatureVariationsList()
                    	        };
                    	    }
                    
                    	}
                    
                    	// GPOS Writing //////////////////////////////////////////////
                    	// NOT SUPPORTED
                    	var subtableMakers$1 = new Array(10);
                    
                    	function makeGposTable(gpos) {
                    	    return new table.Table('GPOS', [
                    	        {name: 'version', type: 'ULONG', value: 0x10000},
                    	        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gpos.scripts)},
                    	        {name: 'features', type: 'TABLE', value: new table.FeatureList(gpos.features)},
                    	        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gpos.lookups, subtableMakers$1)}
                    	    ]);
                    	}
                    
                    	var gpos = { parse: parseGposTable, make: makeGposTable };
                    
                    	// The `kern` table contains kerning pairs.
                    
                    	function parseWindowsKernTable(p) {
                    	    var pairs = {};
                    	    // Skip nTables.
                    	    p.skip('uShort');
                    	    var subtableVersion = p.parseUShort();
                    	    check.argument(subtableVersion === 0, 'Unsupported kern sub-table version.');
                    	    // Skip subtableLength, subtableCoverage
                    	    p.skip('uShort', 2);
                    	    var nPairs = p.parseUShort();
                    	    // Skip searchRange, entrySelector, rangeShift.
                    	    p.skip('uShort', 3);
                    	    for (var i = 0; i < nPairs; i += 1) {
                    	        var leftIndex = p.parseUShort();
                    	        var rightIndex = p.parseUShort();
                    	        var value = p.parseShort();
                    	        pairs[leftIndex + ',' + rightIndex] = value;
                    	    }
                    	    return pairs;
                    	}
                    
                    	function parseMacKernTable(p) {
                    	    var pairs = {};
                    	    // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.
                    	    // Skip the rest.
                    	    p.skip('uShort');
                    	    var nTables = p.parseULong();
                    	    //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');
                    	    if (nTables > 1) {
                    	        console.warn('Only the first kern subtable is supported.');
                    	    }
                    	    p.skip('uLong');
                    	    var coverage = p.parseUShort();
                    	    var subtableVersion = coverage & 0xFF;
                    	    p.skip('uShort');
                    	    if (subtableVersion === 0) {
                    	        var nPairs = p.parseUShort();
                    	        // Skip searchRange, entrySelector, rangeShift.
                    	        p.skip('uShort', 3);
                    	        for (var i = 0; i < nPairs; i += 1) {
                    	            var leftIndex = p.parseUShort();
                    	            var rightIndex = p.parseUShort();
                    	            var value = p.parseShort();
                    	            pairs[leftIndex + ',' + rightIndex] = value;
                    	        }
                    	    }
                    	    return pairs;
                    	}
                    
                    	// Parse the `kern` table which contains kerning pairs.
                    	function parseKernTable(data, start) {
                    	    var p = new parse.Parser(data, start);
                    	    var tableVersion = p.parseUShort();
                    	    if (tableVersion === 0) {
                    	        return parseWindowsKernTable(p);
                    	    } else if (tableVersion === 1) {
                    	        return parseMacKernTable(p);
                    	    } else {
                    	        throw new Error('Unsupported kern table version (' + tableVersion + ').');
                    	    }
                    	}
                    
                    	var kern = { parse: parseKernTable };
                    
                    	// The `loca` table stores the offsets to the locations of the glyphs in the font.
                    
                    	// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,
                    	// relative to the beginning of the glyphData table.
                    	// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)
                    	// The loca table has two versions: a short version where offsets are stored as uShorts, and a long
                    	// version where offsets are stored as uLongs. The `head` table specifies which version to use
                    	// (under indexToLocFormat).
                    	function parseLocaTable(data, start, numGlyphs, shortVersion) {
                    	    var p = new parse.Parser(data, start);
                    	    var parseFn = shortVersion ? p.parseUShort : p.parseULong;
                    	    // There is an extra entry after the last index element to compute the length of the last glyph.
                    	    // That's why we use numGlyphs + 1.
                    	    var glyphOffsets = [];
                    	    for (var i = 0; i < numGlyphs + 1; i += 1) {
                    	        var glyphOffset = parseFn.call(p);
                    	        if (shortVersion) {
                    	            // The short table version stores the actual offset divided by 2.
                    	            glyphOffset *= 2;
                    	        }
                    
                    	        glyphOffsets.push(glyphOffset);
                    	    }
                    
                    	    return glyphOffsets;
                    	}
                    
                    	var loca = { parse: parseLocaTable };
                    
                    	// opentype.js
                    
                    	/**
                    	 * The opentype library.
                    	 * @namespace opentype
                    	 */
                    
                    	// File loaders /////////////////////////////////////////////////////////
                    	/**
                    	 * Loads a font from a file. The callback throws an error message as the first parameter if it fails
                    	 * and the font as an ArrayBuffer in the second parameter if it succeeds.
                    	 * @param  {string} path - The path of the file
                    	 * @param  {Function} callback - The function to call when the font load completes
                    	 */
                    	function loadFromFile(path, callback) {
                    	    var fs = require('fs');
                    	    fs.readFile(path, function(err, buffer) {
                    	        if (err) {
                    	            return callback(err.message);
                    	        }
                    
                    	        callback(null, nodeBufferToArrayBuffer(buffer));
                    	    });
                    	}
                    	/**
                    	 * Loads a font from a URL. The callback throws an error message as the first parameter if it fails
                    	 * and the font as an ArrayBuffer in the second parameter if it succeeds.
                    	 * @param  {string} url - The URL of the font file.
                    	 * @param  {Function} callback - The function to call when the font load completes
                    	 */
                    	function loadFromUrl(url, callback) {
                    	    var request = new XMLHttpRequest();
                    	    request.open('get', url, true);
                    	    request.responseType = 'arraybuffer';
                    	    request.onload = function() {
                    	        if (request.response) {
                    	            return callback(null, request.response);
                    	        } else {
                    	            return callback('Font could not be loaded: ' + request.statusText);
                    	        }
                    	    };
                    
                    	    request.onerror = function () {
                    	        callback('Font could not be loaded');
                    	    };
                    
                    	    request.send();
                    	}
                    
                    	// Table Directory Entries //////////////////////////////////////////////
                    	/**
                    	 * Parses OpenType table entries.
                    	 * @param  {DataView}
                    	 * @param  {Number}
                    	 * @return {Object[]}
                    	 */
                    	function parseOpenTypeTableEntries(data, numTables) {
                    	    var tableEntries = [];
                    	    var p = 12;
                    	    for (var i = 0; i < numTables; i += 1) {
                    	        var tag = parse.getTag(data, p);
                    	        var checksum = parse.getULong(data, p + 4);
                    	        var offset = parse.getULong(data, p + 8);
                    	        var length = parse.getULong(data, p + 12);
                    	        tableEntries.push({tag: tag, checksum: checksum, offset: offset, length: length, compression: false});
                    	        p += 16;
                    	    }
                    
                    	    return tableEntries;
                    	}
                    
                    	/**
                    	 * Parses WOFF table entries.
                    	 * @param  {DataView}
                    	 * @param  {Number}
                    	 * @return {Object[]}
                    	 */
                    	function parseWOFFTableEntries(data, numTables) {
                    	    var tableEntries = [];
                    	    var p = 44; // offset to the first table directory entry.
                    	    for (var i = 0; i < numTables; i += 1) {
                    	        var tag = parse.getTag(data, p);
                    	        var offset = parse.getULong(data, p + 4);
                    	        var compLength = parse.getULong(data, p + 8);
                    	        var origLength = parse.getULong(data, p + 12);
                    	        var compression = (void 0);
                    	        if (compLength < origLength) {
                    	            compression = 'WOFF';
                    	        } else {
                    	            compression = false;
                    	        }
                    
                    	        tableEntries.push({tag: tag, offset: offset, compression: compression,
                    	            compressedLength: compLength, length: origLength});
                    	        p += 20;
                    	    }
                    
                    	    return tableEntries;
                    	}
                    
                    	/**
                    	 * @typedef TableData
                    	 * @type Object
                    	 * @property {DataView} data - The DataView
                    	 * @property {number} offset - The data offset.
                    	 */
                    
                    	/**
                    	 * @param  {DataView}
                    	 * @param  {Object}
                    	 * @return {TableData}
                    	 */
                    	function uncompressTable(data, tableEntry) {
                    	    if (tableEntry.compression === 'WOFF') {
                    	        var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);
                    	        var outBuffer = new Uint8Array(tableEntry.length);
                    	        tinyInflate(inBuffer, outBuffer);
                    	        if (outBuffer.byteLength !== tableEntry.length) {
                    	            throw new Error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\'t match recorded length');
                    	        }
                    
                    	        var view = new DataView(outBuffer.buffer, 0);
                    	        return {data: view, offset: 0};
                    	    } else {
                    	        return {data: data, offset: tableEntry.offset};
                    	    }
                    	}
                    
                    	// Public API ///////////////////////////////////////////////////////////
                    
                    	/**
                    	 * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.
                    	 * Throws an error if the font could not be parsed.
                    	 * @param  {ArrayBuffer}
                    	 * @return {opentype.Font}
                    	 */
                    	function parseBuffer(buffer) {
                    	    var indexToLocFormat;
                    	    var ltagTable;
                    
                    	    // Since the constructor can also be called to create new fonts from scratch, we indicate this
                    	    // should be an empty font that we'll fill with our own data.
                    	    var font = new Font({empty: true});
                    
                    	    // OpenType fonts use big endian byte ordering.
                    	    // We can't rely on typed array view types, because they operate with the endianness of the host computer.
                    	    // Instead we use DataViews where we can specify endianness.
                    	    var data = new DataView(buffer, 0);
                    	    var numTables;
                    	    var tableEntries = [];
                    	    var signature = parse.getTag(data, 0);
                    	    if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {
                    	        font.outlinesFormat = 'truetype';
                    	        numTables = parse.getUShort(data, 4);
                    	        tableEntries = parseOpenTypeTableEntries(data, numTables);
                    	    } else if (signature === 'OTTO') {
                    	        font.outlinesFormat = 'cff';
                    	        numTables = parse.getUShort(data, 4);
                    	        tableEntries = parseOpenTypeTableEntries(data, numTables);
                    	    } else if (signature === 'wOFF') {
                    	        var flavor = parse.getTag(data, 4);
                    	        if (flavor === String.fromCharCode(0, 1, 0, 0)) {
                    	            font.outlinesFormat = 'truetype';
                    	        } else if (flavor === 'OTTO') {
                    	            font.outlinesFormat = 'cff';
                    	        } else {
                    	            throw new Error('Unsupported OpenType flavor ' + signature);
                    	        }
                    
                    	        numTables = parse.getUShort(data, 12);
                    	        tableEntries = parseWOFFTableEntries(data, numTables);
                    	    } else {
                    	        throw new Error('Unsupported OpenType signature ' + signature);
                    	    }
                    
                    	    var cffTableEntry;
                    	    var fvarTableEntry;
                    	    var glyfTableEntry;
                    	    var gposTableEntry;
                    	    var gsubTableEntry;
                    	    var hmtxTableEntry;
                    	    var kernTableEntry;
                    	    var locaTableEntry;
                    	    var nameTableEntry;
                    	    var metaTableEntry;
                    	    var p;
                    
                    	    for (var i = 0; i < numTables; i += 1) {
                    	        var tableEntry = tableEntries[i];
                    	        var table = (void 0);
                    	        switch (tableEntry.tag) {
                    	            case 'cmap':
                    	                table = uncompressTable(data, tableEntry);
                    	                font.tables.cmap = cmap.parse(table.data, table.offset);
                    	                font.encoding = new CmapEncoding(font.tables.cmap);
                    	                break;
                    	            case 'cvt ' :
                    	                table = uncompressTable(data, tableEntry);
                    	                p = new parse.Parser(table.data, table.offset);
                    	                font.tables.cvt = p.parseShortList(tableEntry.length / 2);
                    	                break;
                    	            case 'fvar':
                    	                fvarTableEntry = tableEntry;
                    	                break;
                    	            case 'fpgm' :
                    	                table = uncompressTable(data, tableEntry);
                    	                p = new parse.Parser(table.data, table.offset);
                    	                font.tables.fpgm = p.parseByteList(tableEntry.length);
                    	                break;
                    	            case 'head':
                    	                table = uncompressTable(data, tableEntry);
                    	                font.tables.head = head.parse(table.data, table.offset);
                    	                font.unitsPerEm = font.tables.head.unitsPerEm;
                    	                indexToLocFormat = font.tables.head.indexToLocFormat;
                    	                break;
                    	            case 'hhea':
                    	                table = uncompressTable(data, tableEntry);
                    	                font.tables.hhea = hhea.parse(table.data, table.offset);
                    	                font.ascender = font.tables.hhea.ascender;
                    	                font.descender = font.tables.hhea.descender;
                    	                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
                    	                break;
                    	            case 'hmtx':
                    	                hmtxTableEntry = tableEntry;
                    	                break;
                    	            case 'ltag':
                    	                table = uncompressTable(data, tableEntry);
                    	                ltagTable = ltag.parse(table.data, table.offset);
                    	                break;
                    	            case 'maxp':
                    	                table = uncompressTable(data, tableEntry);
                    	                font.tables.maxp = maxp.parse(table.data, table.offset);
                    	                font.numGlyphs = font.tables.maxp.numGlyphs;
                    	                break;
                    	            case 'name':
                    	                nameTableEntry = tableEntry;
                    	                break;
                    	            case 'OS/2':
                    	                table = uncompressTable(data, tableEntry);
                    	                font.tables.os2 = os2.parse(table.data, table.offset);
                    	                break;
                    	            case 'post':
                    	                table = uncompressTable(data, tableEntry);
                    	                font.tables.post = post.parse(table.data, table.offset);
                    	                font.glyphNames = new GlyphNames(font.tables.post);
                    	                break;
                    	            case 'prep' :
                    	                table = uncompressTable(data, tableEntry);
                    	                p = new parse.Parser(table.data, table.offset);
                    	                font.tables.prep = p.parseByteList(tableEntry.length);
                    	                break;
                    	            case 'glyf':
                    	                glyfTableEntry = tableEntry;
                    	                break;
                    	            case 'loca':
                    	                locaTableEntry = tableEntry;
                    	                break;
                    	            case 'CFF ':
                    	                cffTableEntry = tableEntry;
                    	                break;
                    	            case 'kern':
                    	                kernTableEntry = tableEntry;
                    	                break;
                    	            case 'GPOS':
                    	                gposTableEntry = tableEntry;
                    	                break;
                    	            case 'GSUB':
                    	                gsubTableEntry = tableEntry;
                    	                break;
                    	            case 'meta':
                    	                metaTableEntry = tableEntry;
                    	                break;
                    	        }
                    	    }
                    
                    	    var nameTable = uncompressTable(data, nameTableEntry);
                    	    font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);
                    	    font.names = font.tables.name;
                    
                    	    if (glyfTableEntry && locaTableEntry) {
                    	        var shortVersion = indexToLocFormat === 0;
                    	        var locaTable = uncompressTable(data, locaTableEntry);
                    	        var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);
                    	        var glyfTable = uncompressTable(data, glyfTableEntry);
                    	        font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font);
                    	    } else if (cffTableEntry) {
                    	        var cffTable = uncompressTable(data, cffTableEntry);
                    	        cff.parse(cffTable.data, cffTable.offset, font);
                    	    } else {
                    	        throw new Error('Font doesn\'t contain TrueType or CFF outlines.');
                    	    }
                    
                    	    var hmtxTable = uncompressTable(data, hmtxTableEntry);
                    	    hmtx.parse(hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs);
                    	    addGlyphNames(font);
                    
                    	    if (kernTableEntry) {
                    	        var kernTable = uncompressTable(data, kernTableEntry);
                    	        font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);
                    	    } else {
                    	        font.kerningPairs = {};
                    	    }
                    
                    	    if (gposTableEntry) {
                    	        var gposTable = uncompressTable(data, gposTableEntry);
                    	        font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);
                    	        font.position.init();
                    	    }
                    
                    	    if (gsubTableEntry) {
                    	        var gsubTable = uncompressTable(data, gsubTableEntry);
                    	        font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);
                    	    }
                    
                    	    if (fvarTableEntry) {
                    	        var fvarTable = uncompressTable(data, fvarTableEntry);
                    	        font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);
                    	    }
                    
                    	    if (metaTableEntry) {
                    	        var metaTable = uncompressTable(data, metaTableEntry);
                    	        font.tables.meta = meta.parse(metaTable.data, metaTable.offset);
                    	        font.metas = font.tables.meta;
                    	    }
                    
                    	    return font;
                    	}
                    
                    	/**
                    	 * Asynchronously load the font from a URL or a filesystem. When done, call the callback
                    	 * with two arguments `(err, font)`. The `err` will be null on success,
                    	 * the `font` is a Font object.
                    	 * We use the node.js callback convention so that
                    	 * opentype.js can integrate with frameworks like async.js.
                    	 * @alias opentype.load
                    	 * @param  {string} url - The URL of the font to load.
                    	 * @param  {Function} callback - The callback.
                    	 */
                    	function load(url, callback) {
                    	    var isNode$$1 = typeof window === 'undefined';
                    	    var loadFn = isNode$$1 ? loadFromFile : loadFromUrl;
                    	    loadFn(url, function(err, arrayBuffer) {
                    	        if (err) {
                    	            return callback(err);
                    	        }
                    	        var font;
                    	        try {
                    	            font = parseBuffer(arrayBuffer);
                    	        } catch (e) {
                    	            return callback(e, null);
                    	        }
                    	        return callback(null, font);
                    	    });
                    	}
                    
                    	/**
                    	 * Synchronously load the font from a URL or file.
                    	 * When done, returns the font object or throws an error.
                    	 * @alias opentype.loadSync
                    	 * @param  {string} url - The URL of the font to load.
                    	 * @return {opentype.Font}
                    	 */
                    	function loadSync(url) {
                    	    var fs = require('fs');
                    	    var buffer = fs.readFileSync(url);
                    	    return parseBuffer(nodeBufferToArrayBuffer(buffer));
                    	}
                    
                    	exports.Font = Font;
                    	exports.Glyph = Glyph;
                    	exports.Path = Path;
                    	exports.BoundingBox = BoundingBox;
                    	exports._parse = parse;
                    	exports.parse = parseBuffer;
                    	exports.load = load;
                    	exports.loadSync = loadSync;
                    
                    	Object.defineProperty(exports, '__esModule', { value: true });
                    
                    })));
                    this.earcut = function(points,holeIndices){
                    	//https://github.com/mapbox/earcut
                    	
                        var outputPoints = [];
                        earcut(points,holeIndices).forEach(function(a){ outputPoints = outputPoints.concat([ points[(a*2)],points[(a*2)+1] ]); });
                        return outputPoints;
                    
                        function earcut(data, holeIndices, dim) {
                    
                            dim = dim || 2;
                    
                            var hasHoles = holeIndices && holeIndices.length,
                                outerLen = hasHoles ? holeIndices[0] * dim : data.length,
                                outerNode = linkedList(data, 0, outerLen, dim, true),
                                triangles = [];
                    
                            if (!outerNode || outerNode.next === outerNode.prev) return triangles;
                    
                            var minX, minY, maxX, maxY, x, y, invSize;
                    
                            if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
                    
                            // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
                            if (data.length > 80 * dim) {
                                minX = maxX = data[0];
                                minY = maxY = data[1];
                    
                                for (var i = dim; i < outerLen; i += dim) {
                                    x = data[i];
                                    y = data[i + 1];
                                    if (x < minX) minX = x;
                                    if (y < minY) minY = y;
                                    if (x > maxX) maxX = x;
                                    if (y > maxY) maxY = y;
                                }
                    
                                // minX, minY and invSize are later used to transform coords into integers for z-order calculation
                                invSize = Math.max(maxX - minX, maxY - minY);
                                invSize = invSize !== 0 ? 1 / invSize : 0;
                            }
                    
                            earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
                    
                            return triangles;
                        }
                    
                        // create a circular doubly linked list from polygon points in the specified winding order
                        function linkedList(data, start, end, dim, clockwise) {
                            var i, last;
                    
                            if (clockwise === (signedArea(data, start, end, dim) > 0)) {
                                for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
                            } else {
                                for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
                            }
                    
                            if (last && equals(last, last.next)) {
                                removeNode(last);
                                last = last.next;
                            }
                    
                            return last;
                        }
                    
                        // eliminate colinear or duplicate points
                        function filterPoints(start, end) {
                            if (!start) return start;
                            if (!end) end = start;
                    
                            var p = start,
                                again;
                            do {
                                again = false;
                    
                                if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
                                    removeNode(p);
                                    p = end = p.prev;
                                    if (p === p.next) break;
                                    again = true;
                    
                                } else {
                                    p = p.next;
                                }
                            } while (again || p !== end);
                    
                            return end;
                        }
                    
                        // main ear slicing loop which triangulates a polygon (given as a linked list)
                        function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
                            if (!ear) return;
                    
                            // interlink polygon nodes in z-order
                            if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
                    
                            var stop = ear,
                                prev, next;
                    
                            // iterate through ears, slicing them one by one
                            while (ear.prev !== ear.next) {
                                prev = ear.prev;
                                next = ear.next;
                    
                                if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
                                    // cut off the triangle
                                    triangles.push(prev.i / dim);
                                    triangles.push(ear.i / dim);
                                    triangles.push(next.i / dim);
                    
                                    removeNode(ear);
                    
                                    // skipping the next vertex leads to less sliver triangles
                                    ear = next.next;
                                    stop = next.next;
                    
                                    continue;
                                }
                    
                                ear = next;
                    
                                // if we looped through the whole remaining polygon and can't find any more ears
                                if (ear === stop) {
                                    // try filtering points and slicing again
                                    if (!pass) {
                                        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
                    
                                    // if this didn't work, try curing all small self-intersections locally
                                    } else if (pass === 1) {
                                        ear = cureLocalIntersections(ear, triangles, dim);
                                        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                    
                                    // as a last resort, try splitting the remaining polygon into two
                                    } else if (pass === 2) {
                                        splitEarcut(ear, triangles, dim, minX, minY, invSize);
                                    }
                    
                                    break;
                                }
                            }
                        }
                    
                        // check whether a polygon node forms a valid ear with adjacent nodes
                        function isEar(ear) {
                            var a = ear.prev,
                                b = ear,
                                c = ear.next;
                    
                            if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
                    
                            // now make sure we don't have other points inside the potential ear
                            var p = ear.next.next;
                    
                            while (p !== ear.prev) {
                                if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                                    area(p.prev, p, p.next) >= 0) return false;
                                p = p.next;
                            }
                    
                            return true;
                        }
                    
                        function isEarHashed(ear, minX, minY, invSize) {
                            var a = ear.prev,
                                b = ear,
                                c = ear.next;
                    
                            if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
                    
                            // triangle bbox; min & max are calculated like this for speed
                            var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
                                minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
                                maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
                                maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
                    
                            // z-order range for the current triangle bbox;
                            var minZ = zOrder(minTX, minTY, minX, minY, invSize),
                                maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
                    
                            var p = ear.prevZ,
                                n = ear.nextZ;
                    
                            // look for points inside the triangle in both directions
                            while (p && p.z >= minZ && n && n.z <= maxZ) {
                                if (p !== ear.prev && p !== ear.next &&
                                    pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                                    area(p.prev, p, p.next) >= 0) return false;
                                p = p.prevZ;
                    
                                if (n !== ear.prev && n !== ear.next &&
                                    pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                                    area(n.prev, n, n.next) >= 0) return false;
                                n = n.nextZ;
                            }
                    
                            // look for remaining points in decreasing z-order
                            while (p && p.z >= minZ) {
                                if (p !== ear.prev && p !== ear.next &&
                                    pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                                    area(p.prev, p, p.next) >= 0) return false;
                                p = p.prevZ;
                            }
                    
                            // look for remaining points in increasing z-order
                            while (n && n.z <= maxZ) {
                                if (n !== ear.prev && n !== ear.next &&
                                    pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                                    area(n.prev, n, n.next) >= 0) return false;
                                n = n.nextZ;
                            }
                    
                            return true;
                        }
                    
                        // go through all polygon nodes and cure small local self-intersections
                        function cureLocalIntersections(start, triangles, dim) {
                            var p = start;
                            do {
                                var a = p.prev,
                                    b = p.next.next;
                    
                                if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
                    
                                    triangles.push(a.i / dim);
                                    triangles.push(p.i / dim);
                                    triangles.push(b.i / dim);
                    
                                    // remove two nodes involved
                                    removeNode(p);
                                    removeNode(p.next);
                    
                                    p = start = b;
                                }
                                p = p.next;
                            } while (p !== start);
                    
                            return p;
                        }
                    
                        // try splitting polygon into two and triangulate them independently
                        function splitEarcut(start, triangles, dim, minX, minY, invSize) {
                            // look for a valid diagonal that divides the polygon into two
                            var a = start;
                            do {
                                var b = a.next.next;
                                while (b !== a.prev) {
                                    if (a.i !== b.i && isValidDiagonal(a, b)) {
                                        // split the polygon in two by the diagonal
                                        var c = splitPolygon(a, b);
                    
                                        // filter colinear points around the cuts
                                        a = filterPoints(a, a.next);
                                        c = filterPoints(c, c.next);
                    
                                        // run earcut on each half
                                        earcutLinked(a, triangles, dim, minX, minY, invSize);
                                        earcutLinked(c, triangles, dim, minX, minY, invSize);
                                        return;
                                    }
                                    b = b.next;
                                }
                                a = a.next;
                            } while (a !== start);
                        }
                    
                        // link every hole into the outer loop, producing a single-ring polygon without holes
                        function eliminateHoles(data, holeIndices, outerNode, dim) {
                            var queue = [],
                                i, len, start, end, list;
                    
                            for (i = 0, len = holeIndices.length; i < len; i++) {
                                start = holeIndices[i] * dim;
                                end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                                list = linkedList(data, start, end, dim, false);
                                if (list === list.next) list.steiner = true;
                                queue.push(getLeftmost(list));
                            }
                    
                            queue.sort(compareX);
                    
                            // process holes from left to right
                            for (i = 0; i < queue.length; i++) {
                                eliminateHole(queue[i], outerNode);
                                outerNode = filterPoints(outerNode, outerNode.next);
                            }
                    
                            return outerNode;
                        }
                    
                        function compareX(a, b) {
                            return a.x - b.x;
                        }
                    
                        // find a bridge between vertices that connects hole with an outer ring and and link it
                        function eliminateHole(hole, outerNode) {
                            outerNode = findHoleBridge(hole, outerNode);
                            if (outerNode) {
                                var b = splitPolygon(outerNode, hole);
                                filterPoints(b, b.next);
                            }
                        }
                    
                        // David Eberly's algorithm for finding a bridge between hole and outer polygon
                        function findHoleBridge(hole, outerNode) {
                            var p = outerNode,
                                hx = hole.x,
                                hy = hole.y,
                                qx = -Infinity,
                                m;
                    
                            // find a segment intersected by a ray from the hole's leftmost point to the left;
                            // segment's endpoint with lesser x will be potential connection point
                            do {
                                if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                                    var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                                    if (x <= hx && x > qx) {
                                        qx = x;
                                        if (x === hx) {
                                            if (hy === p.y) return p;
                                            if (hy === p.next.y) return p.next;
                                        }
                                        m = p.x < p.next.x ? p : p.next;
                                    }
                                }
                                p = p.next;
                            } while (p !== outerNode);
                    
                            if (!m) return null;
                    
                            if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint
                    
                            // look for points inside the triangle of hole point, segment intersection and endpoint;
                            // if there are no points found, we have a valid connection;
                            // otherwise choose the point of the minimum angle with the ray as connection point
                    
                            var stop = m,
                                mx = m.x,
                                my = m.y,
                                tanMin = Infinity,
                                tan;
                    
                            p = m.next;
                    
                            while (p !== stop) {
                                if (hx >= p.x && p.x >= mx && hx !== p.x &&
                                        pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                    
                                    tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
                    
                                    if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                                        m = p;
                                        tanMin = tan;
                                    }
                                }
                    
                                p = p.next;
                            }
                    
                            return m;
                        }
                    
                        // interlink polygon nodes in z-order
                        function indexCurve(start, minX, minY, invSize) {
                            var p = start;
                            do {
                                if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
                                p.prevZ = p.prev;
                                p.nextZ = p.next;
                                p = p.next;
                            } while (p !== start);
                    
                            p.prevZ.nextZ = null;
                            p.prevZ = null;
                    
                            sortLinked(p);
                        }
                    
                        // Simon Tatham's linked list merge sort algorithm
                        // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
                        function sortLinked(list) {
                            var i, p, q, e, tail, numMerges, pSize, qSize,
                                inSize = 1;
                    
                            do {
                                p = list;
                                list = null;
                                tail = null;
                                numMerges = 0;
                    
                                while (p) {
                                    numMerges++;
                                    q = p;
                                    pSize = 0;
                                    for (i = 0; i < inSize; i++) {
                                        pSize++;
                                        q = q.nextZ;
                                        if (!q) break;
                                    }
                                    qSize = inSize;
                    
                                    while (pSize > 0 || (qSize > 0 && q)) {
                    
                                        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                                            e = p;
                                            p = p.nextZ;
                                            pSize--;
                                        } else {
                                            e = q;
                                            q = q.nextZ;
                                            qSize--;
                                        }
                    
                                        if (tail) tail.nextZ = e;
                                        else list = e;
                    
                                        e.prevZ = tail;
                                        tail = e;
                                    }
                    
                                    p = q;
                                }
                    
                                tail.nextZ = null;
                                inSize *= 2;
                    
                            } while (numMerges > 1);
                    
                            return list;
                        }
                    
                        // z-order of a point given coords and inverse of the longer side of data bbox
                        function zOrder(x, y, minX, minY, invSize) {
                            // coords are transformed into non-negative 15-bit integer range
                            x = 32767 * (x - minX) * invSize;
                            y = 32767 * (y - minY) * invSize;
                    
                            x = (x | (x << 8)) & 0x00FF00FF;
                            x = (x | (x << 4)) & 0x0F0F0F0F;
                            x = (x | (x << 2)) & 0x33333333;
                            x = (x | (x << 1)) & 0x55555555;
                    
                            y = (y | (y << 8)) & 0x00FF00FF;
                            y = (y | (y << 4)) & 0x0F0F0F0F;
                            y = (y | (y << 2)) & 0x33333333;
                            y = (y | (y << 1)) & 0x55555555;
                    
                            return x | (y << 1);
                        }
                    
                        // find the leftmost node of a polygon ring
                        function getLeftmost(start) {
                            var p = start,
                                leftmost = start;
                            do {
                                if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
                                p = p.next;
                            } while (p !== start);
                    
                            return leftmost;
                        }
                    
                        // check if a point lies within a convex triangle
                        function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
                            return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
                                (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
                                (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
                        }
                    
                        // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
                        function isValidDiagonal(a, b) {
                            return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
                                locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
                        }
                    
                        // signed area of a triangle
                        function area(p, q, r) {
                            return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
                        }
                    
                        // check if two points are equal
                        function equals(p1, p2) {
                            return p1.x === p2.x && p1.y === p2.y;
                        }
                    
                        // check if two segments intersect
                        function intersects(p1, q1, p2, q2) {
                            if ((equals(p1, p2) && equals(q1, q2)) ||
                                (equals(p1, q2) && equals(p2, q1))) return true;
                            return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
                                area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
                        }
                    
                        // check if a polygon diagonal intersects any polygon segments
                        function intersectsPolygon(a, b) {
                            var p = a;
                            do {
                                if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                                        intersects(p, p.next, a, b)) return true;
                                p = p.next;
                            } while (p !== a);
                    
                            return false;
                        }
                    
                        // check if a polygon diagonal is locally inside the polygon
                        function locallyInside(a, b) {
                            return area(a.prev, a, a.next) < 0 ?
                                area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
                                area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
                        }
                    
                        // check if the middle point of a polygon diagonal is inside the polygon
                        function middleInside(a, b) {
                            var p = a,
                                inside = false,
                                px = (a.x + b.x) / 2,
                                py = (a.y + b.y) / 2;
                            do {
                                if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                                        (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
                                    inside = !inside;
                                p = p.next;
                            } while (p !== a);
                    
                            return inside;
                        }
                    
                        // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
                        // if one belongs to the outer ring and another to a hole, it merges it into a single ring
                        function splitPolygon(a, b) {
                            var a2 = new Node(a.i, a.x, a.y),
                                b2 = new Node(b.i, b.x, b.y),
                                an = a.next,
                                bp = b.prev;
                    
                            a.next = b;
                            b.prev = a;
                    
                            a2.next = an;
                            an.prev = a2;
                    
                            b2.next = a2;
                            a2.prev = b2;
                    
                            bp.next = b2;
                            b2.prev = bp;
                    
                            return b2;
                        }
                    
                        // create a node and optionally link it with previous one (in a circular doubly linked list)
                        function insertNode(i, x, y, last) {
                            var p = new Node(i, x, y);
                    
                            if (!last) {
                                p.prev = p;
                                p.next = p;
                    
                            } else {
                                p.next = last.next;
                                p.prev = last;
                                last.next.prev = p;
                                last.next = p;
                            }
                            return p;
                        }
                    
                        function removeNode(p) {
                            p.next.prev = p.prev;
                            p.prev.next = p.next;
                    
                            if (p.prevZ) p.prevZ.nextZ = p.nextZ;
                            if (p.nextZ) p.nextZ.prevZ = p.prevZ;
                        }
                    
                        function Node(i, x, y) {
                            // vertex index in coordinates array
                            this.i = i;
                    
                            // vertex coordinates
                            this.x = x;
                            this.y = y;
                    
                            // previous and next vertex nodes in a polygon ring
                            this.prev = null;
                            this.next = null;
                    
                            // z-order curve value
                            this.z = null;
                    
                            // previous and next nodes in z-order
                            this.prevZ = null;
                            this.nextZ = null;
                    
                            // indicates whether this is a steiner point
                            this.steiner = false;
                        }
                    
                        // // return a percentage difference between the polygon area and its triangulation area;
                        // // used to verify correctness of triangulation
                        // earcut.deviation = function (data, holeIndices, dim, triangles) {
                        //     var hasHoles = holeIndices && holeIndices.length;
                        //     var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
                    
                        //     var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
                        //     if (hasHoles) {
                        //         for (var i = 0, len = holeIndices.length; i < len; i++) {
                        //             var start = holeIndices[i] * dim;
                        //             var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                        //             polygonArea -= Math.abs(signedArea(data, start, end, dim));
                        //         }
                        //     }
                    
                        //     var trianglesArea = 0;
                        //     for (i = 0; i < triangles.length; i += 3) {
                        //         var a = triangles[i] * dim;
                        //         var b = triangles[i + 1] * dim;
                        //         var c = triangles[i + 2] * dim;
                        //         trianglesArea += Math.abs(
                        //             (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
                        //             (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
                        //     }
                    
                        //     return polygonArea === 0 && trianglesArea === 0 ? 0 :
                        //         Math.abs((trianglesArea - polygonArea) / polygonArea);
                        // };
                    
                        function signedArea(data, start, end, dim) {
                            var sum = 0;
                            for (var i = start, j = end - dim; i < end; i += dim) {
                                sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
                                j = i;
                            }
                            return sum;
                        }
                    
                        // // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
                        // earcut.flatten = function (data) {
                        //     var dim = data[0][0].length,
                        //         result = {vertices: [], holes: [], dimensions: dim},
                        //         holeIndex = 0;
                    
                        //     for (var i = 0; i < data.length; i++) {
                        //         for (var j = 0; j < data[i].length; j++) {
                        //             for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
                        //         }
                        //         if (i > 0) {
                        //             holeIndex += data[i - 1].length;
                        //             result.holes.push(holeIndex);
                        //         }
                        //     }
                        //     return result;
                        // };
                    };
                    (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
                    	/*
                    	 * @copyright 2016 Sean Connelly (@voidqk), http://syntheti.cc
                    	 * @license MIT
                    	 * @preserve Project Home: https://github.com/voidqk/polybooljs
                    	 */
                    	
                        // Modified by Metasophiea <metasophiea@gmail.com>
                    
                    
                    	var BuildLog = require('./lib/build-log');
                    	var Epsilon = require('./lib/epsilon');
                    	var Intersecter = require('./lib/intersecter');
                    	var SegmentChainer = require('./lib/segment-chainer');
                    	var SegmentSelector = require('./lib/segment-selector');
                    	var GeoJSON = require('./lib/geojson');
                    	
                    	var buildLog = false;
                    	var epsilon = Epsilon();
                    	
                    	var PolyBool;
                    	PolyBool = {
                    		// getter/setter for buildLog
                    		buildLog: function(bl){
                    			if (bl === true)
                    				buildLog = BuildLog();
                    			else if (bl === false)
                    				buildLog = false;
                    			return buildLog === false ? false : buildLog.list;
                    		},
                    		// getter/setter for epsilon
                    		epsilon: function(v){
                    			return epsilon.epsilon(v);
                    		},
                    	
                    		// core API
                    		segments: function(poly){
                    			var i = Intersecter(true, epsilon, buildLog);
                    			poly.regions.forEach(i.addRegion);
                    			return {
                    				segments: i.calculate(poly.inverted),
                    				inverted: poly.inverted
                    			};
                    		},
                    		combine: function(segments1, segments2){
                    			var i3 = Intersecter(false, epsilon, buildLog);
                    			return {
                    				combined: i3.calculate(
                    					segments1.segments, segments1.inverted,
                    					segments2.segments, segments2.inverted
                    				),
                    				inverted1: segments1.inverted,
                    				inverted2: segments2.inverted
                    			};
                    		},
                    		selectUnion: function(combined){
                    			return {
                    				segments: SegmentSelector.union(combined.combined, buildLog),
                    				inverted: combined.inverted1 || combined.inverted2
                    			}
                    		},
                    		selectIntersect: function(combined){
                    			return {
                    				segments: SegmentSelector.intersect(combined.combined, buildLog),
                    				inverted: combined.inverted1 && combined.inverted2
                    			}
                    		},
                    		selectDifference: function(combined){
                    			return {
                    				segments: SegmentSelector.difference(combined.combined, buildLog),
                    				inverted: combined.inverted1 && !combined.inverted2
                    			}
                    		},
                    		selectDifferenceRev: function(combined){
                    			return {
                    				segments: SegmentSelector.differenceRev(combined.combined, buildLog),
                    				inverted: !combined.inverted1 && combined.inverted2
                    			}
                    		},
                    		selectXor: function(combined){
                    			return {
                    				segments: SegmentSelector.xor(combined.combined, buildLog),
                    				inverted: combined.inverted1 !== combined.inverted2
                    			}
                    		},
                    		polygon: function(segments){
                    			return {
                    				regions: SegmentChainer(segments.segments, epsilon, buildLog),
                    				inverted: segments.inverted
                    			};
                    		},
                    	
                    		// GeoJSON converters
                    		polygonFromGeoJSON: function(geojson){
                    			return GeoJSON.toPolygon(PolyBool, geojson);
                    		},
                    		polygonToGeoJSON: function(poly){
                    			return GeoJSON.fromPolygon(PolyBool, epsilon, poly);
                    		},
                    	
                    		// helper functions for common operations
                    		union: function(poly1, poly2){
                    			return operate(poly1, poly2, PolyBool.selectUnion);
                    		},
                    		intersect: function(poly1, poly2){
                    			return operate(poly1, poly2, PolyBool.selectIntersect);
                    		},
                    		difference: function(poly1, poly2){
                    			return operate(poly1, poly2, PolyBool.selectDifference);
                    		},
                    		differenceRev: function(poly1, poly2){
                    			return operate(poly1, poly2, PolyBool.selectDifferenceRev);
                    		},
                    		xor: function(poly1, poly2){
                    			return operate(poly1, poly2, PolyBool.selectXor);
                    		}
                    	};
                    
                    	thirdparty.PolyBool = PolyBool;
                    	
                    	function operate(poly1, poly2, selector){
                    		var seg1 = PolyBool.segments(poly1);
                    		var seg2 = PolyBool.segments(poly2);
                    		var comb = PolyBool.combine(seg1, seg2);
                    		var seg3 = selector(comb);
                    		return PolyBool.polygon(seg3);
                    	}
                    		
                    	},{"./lib/build-log":2,"./lib/epsilon":3,"./lib/geojson":4,"./lib/intersecter":5,"./lib/segment-chainer":7,"./lib/segment-selector":8}],2:[function(require,module,exports){
                    	// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc
                    	// MIT License
                    	// Project Home: https://github.com/voidqk/polybooljs
                    	
                    	//
                    	// used strictly for logging the processing of the algorithm... only useful if you intend on
                    	// looking under the covers (for pretty UI's or debugging)
                    	//
                    	
                    	function BuildLog(){
                    		var my;
                    		var nextSegmentId = 0;
                    		var curVert = false;
                    	
                    		function push(type, data){
                    			my.list.push({
                    				type: type,
                    				data: data ? JSON.parse(JSON.stringify(data)) : void 0
                    			});
                    			return my;
                    		}
                    	
                    		my = {
                    			list: [],
                    			segmentId: function(){
                    				return nextSegmentId++;
                    			},
                    			checkIntersection: function(seg1, seg2){
                    				return push('check', { seg1: seg1, seg2: seg2 });
                    			},
                    			segmentChop: function(seg, end){
                    				push('div_seg', { seg: seg, pt: end });
                    				return push('chop', { seg: seg, pt: end });
                    			},
                    			statusRemove: function(seg){
                    				return push('pop_seg', { seg: seg });
                    			},
                    			segmentUpdate: function(seg){
                    				return push('seg_update', { seg: seg });
                    			},
                    			segmentNew: function(seg, primary){
                    				return push('new_seg', { seg: seg, primary: primary });
                    			},
                    			segmentRemove: function(seg){
                    				return push('rem_seg', { seg: seg });
                    			},
                    			tempStatus: function(seg, above, below){
                    				return push('temp_status', { seg: seg, above: above, below: below });
                    			},
                    			rewind: function(seg){
                    				return push('rewind', { seg: seg });
                    			},
                    			status: function(seg, above, below){
                    				return push('status', { seg: seg, above: above, below: below });
                    			},
                    			vert: function(x){
                    				if (x === curVert)
                    					return my;
                    				curVert = x;
                    				return push('vert', { x: x });
                    			},
                    			log: function(data){
                    				if (typeof data !== 'string')
                    					data = JSON.stringify(data, false, '  ');
                    				return push('log', { txt: data });
                    			},
                    			reset: function(){
                    				return push('reset');
                    			},
                    			selected: function(segs){
                    				return push('selected', { segs: segs });
                    			},
                    			chainStart: function(seg){
                    				return push('chain_start', { seg: seg });
                    			},
                    			chainRemoveHead: function(index, pt){
                    				return push('chain_rem_head', { index: index, pt: pt });
                    			},
                    			chainRemoveTail: function(index, pt){
                    				return push('chain_rem_tail', { index: index, pt: pt });
                    			},
                    			chainNew: function(pt1, pt2){
                    				return push('chain_new', { pt1: pt1, pt2: pt2 });
                    			},
                    			chainMatch: function(index){
                    				return push('chain_match', { index: index });
                    			},
                    			chainClose: function(index){
                    				return push('chain_close', { index: index });
                    			},
                    			chainAddHead: function(index, pt){
                    				return push('chain_add_head', { index: index, pt: pt });
                    			},
                    			chainAddTail: function(index, pt){
                    				return push('chain_add_tail', { index: index, pt: pt, });
                    			},
                    			chainConnect: function(index1, index2){
                    				return push('chain_con', { index1: index1, index2: index2 });
                    			},
                    			chainReverse: function(index){
                    				return push('chain_rev', { index: index });
                    			},
                    			chainJoin: function(index1, index2){
                    				return push('chain_join', { index1: index1, index2: index2 });
                    			},
                    			done: function(){
                    				return push('done');
                    			}
                    		};
                    		return my;
                    	}
                    	
                    	module.exports = BuildLog;
                    	
                    	},{}],3:[function(require,module,exports){
                    	// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc
                    	// MIT License
                    	// Project Home: https://github.com/voidqk/polybooljs
                    	
                    	//
                    	// provides the raw computation functions that takes epsilon into account
                    	//
                    	// zero is defined to be between (-epsilon, epsilon) exclusive
                    	//
                    	
                    	function Epsilon(eps){
                    		if (typeof eps !== 'number')
                    			eps = 0.0000000001; // sane default? sure why not
                    		var my = {
                    			epsilon: function(v){
                    				if (typeof v === 'number')
                    					eps = v;
                    				return eps;
                    			},
                    			pointAboveOrOnLine: function(pt, left, right){
                    				var Ax = left[0];
                    				var Ay = left[1];
                    				var Bx = right[0];
                    				var By = right[1];
                    				var Cx = pt[0];
                    				var Cy = pt[1];
                    				return (Bx - Ax) * (Cy - Ay) - (By - Ay) * (Cx - Ax) >= -eps;
                    			},
                    			pointBetween: function(p, left, right){
                    				// p must be collinear with left->right
                    				// returns false if p == left, p == right, or left == right
                    				var d_py_ly = p[1] - left[1];
                    				var d_rx_lx = right[0] - left[0];
                    				var d_px_lx = p[0] - left[0];
                    				var d_ry_ly = right[1] - left[1];
                    	
                    				var dot = d_px_lx * d_rx_lx + d_py_ly * d_ry_ly;
                    				// if `dot` is 0, then `p` == `left` or `left` == `right` (reject)
                    				// if `dot` is less than 0, then `p` is to the left of `left` (reject)
                    				if (dot < eps)
                    					return false;
                    	
                    				var sqlen = d_rx_lx * d_rx_lx + d_ry_ly * d_ry_ly;
                    				// if `dot` > `sqlen`, then `p` is to the right of `right` (reject)
                    				// therefore, if `dot - sqlen` is greater than 0, then `p` is to the right of `right` (reject)
                    				if (dot - sqlen > -eps)
                    					return false;
                    	
                    				return true;
                    			},
                    			pointsSameX: function(p1, p2){
                    				return Math.abs(p1[0] - p2[0]) < eps;
                    			},
                    			pointsSameY: function(p1, p2){
                    				return Math.abs(p1[1] - p2[1]) < eps;
                    			},
                    			pointsSame: function(p1, p2){
                    				return my.pointsSameX(p1, p2) && my.pointsSameY(p1, p2);
                    			},
                    			pointsCompare: function(p1, p2){
                    				// returns -1 if p1 is smaller, 1 if p2 is smaller, 0 if equal
                    				if (my.pointsSameX(p1, p2))
                    					return my.pointsSameY(p1, p2) ? 0 : (p1[1] < p2[1] ? -1 : 1);
                    				return p1[0] < p2[0] ? -1 : 1;
                    			},
                    			pointsCollinear: function(pt1, pt2, pt3){
                    				// does pt1->pt2->pt3 make a straight line?
                    				// essentially this is just checking to see if the slope(pt1->pt2) === slope(pt2->pt3)
                    				// if slopes are equal, then they must be collinear, because they share pt2
                    				var dx1 = pt1[0] - pt2[0];
                    				var dy1 = pt1[1] - pt2[1];
                    				var dx2 = pt2[0] - pt3[0];
                    				var dy2 = pt2[1] - pt3[1];
                    				return Math.abs(dx1 * dy2 - dx2 * dy1) < eps;
                    			},
                    			linesIntersect: function(a0, a1, b0, b1){
                    				// returns false if the lines are coincident (e.g., parallel or on top of each other)
                    				//
                    				// returns an object if the lines intersect:
                    				//   {
                    				//     pt: [x, y],    where the intersection point is at
                    				//     alongA: where intersection point is along A,
                    				//     alongB: where intersection point is along B
                    				//   }
                    				//
                    				//  alongA and alongB will each be one of: -2, -1, 0, 1, 2
                    				//
                    				//  with the following meaning:
                    				//
                    				//    -2   intersection point is before segment's first point
                    				//    -1   intersection point is directly on segment's first point
                    				//     0   intersection point is between segment's first and second points (exclusive)
                    				//     1   intersection point is directly on segment's second point
                    				//     2   intersection point is after segment's second point
                    				var adx = a1[0] - a0[0];
                    				var ady = a1[1] - a0[1];
                    				var bdx = b1[0] - b0[0];
                    				var bdy = b1[1] - b0[1];
                    	
                    				var axb = adx * bdy - ady * bdx;
                    				if (Math.abs(axb) < eps)
                    					return false; // lines are coincident
                    	
                    				var dx = a0[0] - b0[0];
                    				var dy = a0[1] - b0[1];
                    	
                    				var A = (bdx * dy - bdy * dx) / axb;
                    				var B = (adx * dy - ady * dx) / axb;
                    	
                    				var ret = {
                    					alongA: 0,
                    					alongB: 0,
                    					pt: [
                    						a0[0] + A * adx,
                    						a0[1] + A * ady
                    					]
                    				};
                    	
                    				// categorize where intersection point is along A and B
                    	
                    				if (A <= -eps)
                    					ret.alongA = -2;
                    				else if (A < eps)
                    					ret.alongA = -1;
                    				else if (A - 1 <= -eps)
                    					ret.alongA = 0;
                    				else if (A - 1 < eps)
                    					ret.alongA = 1;
                    				else
                    					ret.alongA = 2;
                    	
                    				if (B <= -eps)
                    					ret.alongB = -2;
                    				else if (B < eps)
                    					ret.alongB = -1;
                    				else if (B - 1 <= -eps)
                    					ret.alongB = 0;
                    				else if (B - 1 < eps)
                    					ret.alongB = 1;
                    				else
                    					ret.alongB = 2;
                    	
                    				return ret;
                    			},
                    			pointInsideRegion: function(pt, region){
                    				var x = pt[0];
                    				var y = pt[1];
                    				var last_x = region[region.length - 1][0];
                    				var last_y = region[region.length - 1][1];
                    				var inside = false;
                    				for (var i = 0; i < region.length; i++){
                    					var curr_x = region[i][0];
                    					var curr_y = region[i][1];
                    	
                    					// if y is between curr_y and last_y, and
                    					// x is to the right of the boundary created by the line
                    					if ((curr_y - y > eps) != (last_y - y > eps) &&
                    						(last_x - curr_x) * (y - curr_y) / (last_y - curr_y) + curr_x - x > eps)
                    						inside = !inside
                    	
                    					last_x = curr_x;
                    					last_y = curr_y;
                    				}
                    				return inside;
                    			}
                    		};
                    		return my;
                    	}
                    	
                    	module.exports = Epsilon;
                    	
                    	},{}],4:[function(require,module,exports){
                    	// (c) Copyright 2017, Sean Connelly (@voidqk), http://syntheti.cc
                    	// MIT License
                    	// Project Home: https://github.com/voidqk/polybooljs
                    	
                    	//
                    	// convert between PolyBool polygon format and GeoJSON formats (Polygon and MultiPolygon)
                    	//
                    	
                    	var GeoJSON = {
                    		// convert a GeoJSON object to a PolyBool polygon
                    		toPolygon: function(PolyBool, geojson){
                    	
                    			// converts list of LineString's to segments
                    			function GeoPoly(coords){
                    				// check for empty coords
                    				if (coords.length <= 0)
                    					return PolyBool.segments({ inverted: false, regions: [] });
                    	
                    				// convert LineString to segments
                    				function LineString(ls){
                    					// remove tail which should be the same as head
                    					var reg = ls.slice(0, ls.length - 1);
                    					return PolyBool.segments({ inverted: false, regions: [reg] });
                    				}
                    	
                    				// the first LineString is considered the outside
                    				var out = LineString(coords[0]);
                    	
                    				// the rest of the LineStrings are considered interior holes, so subtract them from the
                    				// current result
                    				for (var i = 1; i < coords.length; i++)
                    					out = PolyBool.selectDifference(PolyBool.combine(out, LineString(coords[i])));
                    	
                    				return out;
                    			}
                    	
                    			if (geojson.type === 'Polygon'){
                    				// single polygon, so just convert it and we're done
                    				return PolyBool.polygon(GeoPoly(geojson.coordinates));
                    			}
                    			else if (geojson.type === 'MultiPolygon'){
                    				// multiple polygons, so union all the polygons together
                    				var out = PolyBool.segments({ inverted: false, regions: [] });
                    				for (var i = 0; i < geojson.coordinates.length; i++)
                    					out = PolyBool.selectUnion(PolyBool.combine(out, GeoPoly(geojson.coordinates[i])));
                    				return PolyBool.polygon(out);
                    			}
                    			throw new Error('PolyBool: Cannot convert GeoJSON object to PolyBool polygon');
                    		},
                    	
                    		// convert a PolyBool polygon to a GeoJSON object
                    		fromPolygon: function(PolyBool, eps, poly){
                    			// make sure out polygon is clean
                    			poly = PolyBool.polygon(PolyBool.segments(poly));
                    	
                    			// test if r1 is inside r2
                    			function regionInsideRegion(r1, r2){
                    				// we're guaranteed no lines intersect (because the polygon is clean), but a vertex
                    				// could be on the edge -- so we just average pt[0] and pt[1] to produce a point on the
                    				// edge of the first line, which cannot be on an edge
                    				return eps.pointInsideRegion([
                    					(r1[0][0] + r1[1][0]) * 0.5,
                    					(r1[0][1] + r1[1][1]) * 0.5
                    				], r2);
                    			}
                    	
                    			// calculate inside heirarchy
                    			//
                    			//  _____________________   _______    roots -> A       -> F
                    			// |          A          | |   F   |            |          |
                    			// |  _______   _______  | |  ___  |            +-- B      +-- G
                    			// | |   B   | |   C   | | | |   | |            |   |
                    			// | |  ___  | |  ___  | | | |   | |            |   +-- D
                    			// | | | D | | | | E | | | | | G | |            |
                    			// | | |___| | | |___| | | | |   | |            +-- C
                    			// | |_______| |_______| | | |___| |                |
                    			// |_____________________| |_______|                +-- E
                    	
                    			function newNode(region){
                    				return {
                    					region: region,
                    					children: []
                    				};
                    			}
                    	
                    			var roots = newNode(null);
                    	
                    			function addChild(root, region){
                    				// first check if we're inside any children
                    				for (var i = 0; i < root.children.length; i++){
                    					var child = root.children[i];
                    					if (regionInsideRegion(region, child.region)){
                    						// we are, so insert inside them instead
                    						addChild(child, region);
                    						return;
                    					}
                    				}
                    	
                    				// not inside any children, so check to see if any children are inside us
                    				var node = newNode(region);
                    				for (var i = 0; i < root.children.length; i++){
                    					var child = root.children[i];
                    					if (regionInsideRegion(child.region, region)){
                    						// oops... move the child beneath us, and remove them from root
                    						node.children.push(child);
                    						root.children.splice(i, 1);
                    						i--;
                    					}
                    				}
                    	
                    				// now we can add ourselves
                    				root.children.push(node);
                    			}
                    	
                    			// add all regions to the root
                    			for (var i = 0; i < poly.regions.length; i++){
                    				var region = poly.regions[i];
                    				if (region.length < 3) // regions must have at least 3 points (sanity check)
                    					continue;
                    				addChild(roots, region);
                    			}
                    	
                    			// with our heirarchy, we can distinguish between exterior borders, and interior holes
                    			// the root nodes are exterior, children are interior, children's children are exterior,
                    			// children's children's children are interior, etc
                    	
                    			// while we're at it, exteriors are counter-clockwise, and interiors are clockwise
                    	
                    			function forceWinding(region, clockwise){
                    				// first, see if we're clockwise or counter-clockwise
                    				// https://en.wikipedia.org/wiki/Shoelace_formula
                    				var winding = 0;
                    				var last_x = region[region.length - 1][0];
                    				var last_y = region[region.length - 1][1];
                    				var copy = [];
                    				for (var i = 0; i < region.length; i++){
                    					var curr_x = region[i][0];
                    					var curr_y = region[i][1];
                    					copy.push([curr_x, curr_y]); // create a copy while we're at it
                    					winding += curr_y * last_x - curr_x * last_y;
                    					last_x = curr_x;
                    					last_y = curr_y;
                    				}
                    				// this assumes Cartesian coordinates (Y is positive going up)
                    				var isclockwise = winding < 0;
                    				if (isclockwise !== clockwise)
                    					copy.reverse();
                    				// while we're here, the last point must be the first point...
                    				copy.push([copy[0][0], copy[0][1]]);
                    				return copy;
                    			}
                    	
                    			var geopolys = [];
                    	
                    			function addExterior(node){
                    				var poly = [forceWinding(node.region, false)];
                    				geopolys.push(poly);
                    				// children of exteriors are interior
                    				for (var i = 0; i < node.children.length; i++)
                    					poly.push(getInterior(node.children[i]));
                    			}
                    	
                    			function getInterior(node){
                    				// children of interiors are exterior
                    				for (var i = 0; i < node.children.length; i++)
                    					addExterior(node.children[i]);
                    				// return the clockwise interior
                    				return forceWinding(node.region, true);
                    			}
                    	
                    			// root nodes are exterior
                    			for (var i = 0; i < roots.children.length; i++)
                    				addExterior(roots.children[i]);
                    	
                    			// lastly, construct the approrpriate GeoJSON object
                    	
                    			if (geopolys.length <= 0) // empty GeoJSON Polygon
                    				return { type: 'Polygon', coordinates: [] };
                    			if (geopolys.length == 1) // use a GeoJSON Polygon
                    				return { type: 'Polygon', coordinates: geopolys[0] };
                    			return { // otherwise, use a GeoJSON MultiPolygon
                    				type: 'MultiPolygon',
                    				coordinates: geopolys
                    			};
                    		}
                    	};
                    	
                    	module.exports = GeoJSON;
                    	
                    	},{}],5:[function(require,module,exports){
                    	// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc
                    	// MIT License
                    	// Project Home: https://github.com/voidqk/polybooljs
                    	
                    	//
                    	// this is the core work-horse
                    	//
                    	
                    	var LinkedList = require('./linked-list');
                    	
                    	function Intersecter(selfIntersection, eps, buildLog){
                    		// selfIntersection is true/false depending on the phase of the overall algorithm
                    	
                    		//
                    		// segment creation
                    		//
                    	
                    		function segmentNew(start, end){
                    			return {
                    				id: buildLog ? buildLog.segmentId() : -1,
                    				start: start,
                    				end: end,
                    				myFill: {
                    					above: null, // is there fill above us?
                    					below: null  // is there fill below us?
                    				},
                    				otherFill: null
                    			};
                    		}
                    	
                    		function segmentCopy(start, end, seg){
                    			return {
                    				id: buildLog ? buildLog.segmentId() : -1,
                    				start: start,
                    				end: end,
                    				myFill: {
                    					above: seg.myFill.above,
                    					below: seg.myFill.below
                    				},
                    				otherFill: null
                    			};
                    		}
                    	
                    		//
                    		// event logic
                    		//
                    	
                    		var event_root = LinkedList.create();
                    	
                    		function eventCompare(p1_isStart, p1_1, p1_2, p2_isStart, p2_1, p2_2){
                    			// compare the selected points first
                    			var comp = eps.pointsCompare(p1_1, p2_1);
                    			if (comp !== 0)
                    				return comp;
                    			// the selected points are the same
                    	
                    			if (eps.pointsSame(p1_2, p2_2)) // if the non-selected points are the same too...
                    				return 0; // then the segments are equal
                    	
                    			if (p1_isStart !== p2_isStart) // if one is a start and the other isn't...
                    				return p1_isStart ? 1 : -1; // favor the one that isn't the start
                    	
                    			// otherwise, we'll have to calculate which one is below the other manually
                    			return eps.pointAboveOrOnLine(p1_2,
                    				p2_isStart ? p2_1 : p2_2, // order matters
                    				p2_isStart ? p2_2 : p2_1
                    			) ? 1 : -1;
                    		}
                    	
                    		function eventAdd(ev, other_pt){
                    			event_root.insertBefore(ev, function(here){
                    				// should ev be inserted before here?
                    				var comp = eventCompare(
                    					ev  .isStart, ev  .pt,      other_pt,
                    					here.isStart, here.pt, here.other.pt
                    				);
                    				return comp < 0;
                    			});
                    		}
                    	
                    		function eventAddSegmentStart(seg, primary){
                    			var ev_start = LinkedList.node({
                    				isStart: true,
                    				pt: seg.start,
                    				seg: seg,
                    				primary: primary,
                    				other: null,
                    				status: null
                    			});
                    			eventAdd(ev_start, seg.end);
                    			return ev_start;
                    		}
                    	
                    		function eventAddSegmentEnd(ev_start, seg, primary){
                    			var ev_end = LinkedList.node({
                    				isStart: false,
                    				pt: seg.end,
                    				seg: seg,
                    				primary: primary,
                    				other: ev_start,
                    				status: null
                    			});
                    			ev_start.other = ev_end;
                    			eventAdd(ev_end, ev_start.pt);
                    		}
                    	
                    		function eventAddSegment(seg, primary){
                    			var ev_start = eventAddSegmentStart(seg, primary);
                    			eventAddSegmentEnd(ev_start, seg, primary);
                    			return ev_start;
                    		}
                    	
                    		function eventUpdateEnd(ev, end){
                    			// slides an end backwards
                    			//   (start)------------(end)    to:
                    			//   (start)---(end)
                    	
                    			if (buildLog)
                    				buildLog.segmentChop(ev.seg, end);
                    	
                    			ev.other.remove();
                    			ev.seg.end = end;
                    			ev.other.pt = end;
                    			eventAdd(ev.other, ev.pt);
                    		}
                    	
                    		function eventDivide(ev, pt){
                    			var ns = segmentCopy(pt, ev.seg.end, ev.seg);
                    			eventUpdateEnd(ev, pt);
                    			return eventAddSegment(ns, ev.primary);
                    		}
                    	
                    		function calculate(primaryPolyInverted, secondaryPolyInverted){
                    			// if selfIntersection is true then there is no secondary polygon, so that isn't used
                    	
                    			//
                    			// status logic
                    			//
                    	
                    			var status_root = LinkedList.create();
                    	
                    			function statusCompare(ev1, ev2){
                    				var a1 = ev1.seg.start;
                    				var a2 = ev1.seg.end;
                    				var b1 = ev2.seg.start;
                    				var b2 = ev2.seg.end;
                    	
                    				if (eps.pointsCollinear(a1, b1, b2)){
                    					if (eps.pointsCollinear(a2, b1, b2))
                    						return 1;//eventCompare(true, a1, a2, true, b1, b2);
                    					return eps.pointAboveOrOnLine(a2, b1, b2) ? 1 : -1;
                    				}
                    				return eps.pointAboveOrOnLine(a1, b1, b2) ? 1 : -1;
                    			}
                    	
                    			function statusFindSurrounding(ev){
                    				return status_root.findTransition(function(here){
                    					var comp = statusCompare(ev, here.ev);
                    					return comp > 0;
                    				});
                    			}
                    	
                    			function checkIntersection(ev1, ev2){
                    				// returns the segment equal to ev1, or false if nothing equal
                    	
                    				var seg1 = ev1.seg;
                    				var seg2 = ev2.seg;
                    				var a1 = seg1.start;
                    				var a2 = seg1.end;
                    				var b1 = seg2.start;
                    				var b2 = seg2.end;
                    	
                    				if (buildLog)
                    					buildLog.checkIntersection(seg1, seg2);
                    	
                    				var i = eps.linesIntersect(a1, a2, b1, b2);
                    	
                    				if (i === false){
                    					// segments are parallel or coincident
                    	
                    					// if points aren't collinear, then the segments are parallel, so no intersections
                    					if (!eps.pointsCollinear(a1, a2, b1))
                    						return false;
                    					// otherwise, segments are on top of each other somehow (aka coincident)
                    	
                    					if (eps.pointsSame(a1, b2) || eps.pointsSame(a2, b1))
                    						return false; // segments touch at endpoints... no intersection
                    	
                    					var a1_equ_b1 = eps.pointsSame(a1, b1);
                    					var a2_equ_b2 = eps.pointsSame(a2, b2);
                    	
                    					if (a1_equ_b1 && a2_equ_b2)
                    						return ev2; // segments are exactly equal
                    	
                    					var a1_between = !a1_equ_b1 && eps.pointBetween(a1, b1, b2);
                    					var a2_between = !a2_equ_b2 && eps.pointBetween(a2, b1, b2);
                    	
                    					// handy for debugging:
                    					// buildLog.log({
                    					//	a1_equ_b1: a1_equ_b1,
                    					//	a2_equ_b2: a2_equ_b2,
                    					//	a1_between: a1_between,
                    					//	a2_between: a2_between
                    					// });
                    	
                    					if (a1_equ_b1){
                    						if (a2_between){
                    							//  (a1)---(a2)
                    							//  (b1)----------(b2)
                    							eventDivide(ev2, a2);
                    						}
                    						else{
                    							//  (a1)----------(a2)
                    							//  (b1)---(b2)
                    							eventDivide(ev1, b2);
                    						}
                    						return ev2;
                    					}
                    					else if (a1_between){
                    						if (!a2_equ_b2){
                    							// make a2 equal to b2
                    							if (a2_between){
                    								//         (a1)---(a2)
                    								//  (b1)-----------------(b2)
                    								eventDivide(ev2, a2);
                    							}
                    							else{
                    								//         (a1)----------(a2)
                    								//  (b1)----------(b2)
                    								eventDivide(ev1, b2);
                    							}
                    						}
                    	
                    						//         (a1)---(a2)
                    						//  (b1)----------(b2)
                    						eventDivide(ev2, a1);
                    					}
                    				}
                    				else{
                    					// otherwise, lines intersect at i.pt, which may or may not be between the endpoints
                    	
                    					// is A divided between its endpoints? (exclusive)
                    					if (i.alongA === 0){
                    						if (i.alongB === -1) // yes, at exactly b1
                    							eventDivide(ev1, b1);
                    						else if (i.alongB === 0) // yes, somewhere between B's endpoints
                    							eventDivide(ev1, i.pt);
                    						else if (i.alongB === 1) // yes, at exactly b2
                    							eventDivide(ev1, b2);
                    					}
                    	
                    					// is B divided between its endpoints? (exclusive)
                    					if (i.alongB === 0){
                    						if (i.alongA === -1) // yes, at exactly a1
                    							eventDivide(ev2, a1);
                    						else if (i.alongA === 0) // yes, somewhere between A's endpoints (exclusive)
                    							eventDivide(ev2, i.pt);
                    						else if (i.alongA === 1) // yes, at exactly a2
                    							eventDivide(ev2, a2);
                    					}
                    				}
                    				return false;
                    			}
                    	
                    			//
                    			// main event loop
                    			//
                    			var segments = [];
                    			while (!event_root.isEmpty()){
                    				var ev = event_root.getHead();
                    	
                    				if (buildLog)
                    					buildLog.vert(ev.pt[0]);
                    	
                    				if (ev.isStart){
                    	
                    					if (buildLog)
                    						buildLog.segmentNew(ev.seg, ev.primary);
                    	
                    					var surrounding = statusFindSurrounding(ev);
                    					var above = surrounding.before ? surrounding.before.ev : null;
                    					var below = surrounding.after ? surrounding.after.ev : null;
                    	
                    					if (buildLog){
                    						buildLog.tempStatus(
                    							ev.seg,
                    							above ? above.seg : false,
                    							below ? below.seg : false
                    						);
                    					}
                    	
                    					function checkBothIntersections(){
                    						if (above){
                    							var eve = checkIntersection(ev, above);
                    							if (eve)
                    								return eve;
                    						}
                    						if (below)
                    							return checkIntersection(ev, below);
                    						return false;
                    					}
                    	
                    					var eve = checkBothIntersections();
                    					if (eve){
                    						// ev and eve are equal
                    						// we'll keep eve and throw away ev
                    	
                    						// merge ev.seg's fill information into eve.seg
                    	
                    						if (selfIntersection){
                    							var toggle; // are we a toggling edge?
                    							if (ev.seg.myFill.below === null)
                    								toggle = true;
                    							else
                    								toggle = ev.seg.myFill.above !== ev.seg.myFill.below;
                    	
                    							// merge two segments that belong to the same polygon
                    							// think of this as sandwiching two segments together, where `eve.seg` is
                    							// the bottom -- this will cause the above fill flag to toggle
                    							if (toggle)
                    								eve.seg.myFill.above = !eve.seg.myFill.above;
                    						}
                    						else{
                    							// merge two segments that belong to different polygons
                    							// each segment has distinct knowledge, so no special logic is needed
                    							// note that this can only happen once per segment in this phase, because we
                    							// are guaranteed that all self-intersections are gone
                    							eve.seg.otherFill = ev.seg.myFill;
                    						}
                    	
                    						if (buildLog)
                    							buildLog.segmentUpdate(eve.seg);
                    	
                    						ev.other.remove();
                    						ev.remove();
                    					}
                    	
                    					if (event_root.getHead() !== ev){
                    						// something was inserted before us in the event queue, so loop back around and
                    						// process it before continuing
                    						if (buildLog)
                    							buildLog.rewind(ev.seg);
                    						continue;
                    					}
                    	
                    					//
                    					// calculate fill flags
                    					//
                    					if (selfIntersection){
                    						var toggle; // are we a toggling edge?
                    						if (ev.seg.myFill.below === null) // if we are a new segment...
                    							toggle = true; // then we toggle
                    						else // we are a segment that has previous knowledge from a division
                    							toggle = ev.seg.myFill.above !== ev.seg.myFill.below; // calculate toggle
                    	
                    						// next, calculate whether we are filled below us
                    						if (!below){ // if nothing is below us...
                    							// we are filled below us if the polygon is inverted
                    							ev.seg.myFill.below = primaryPolyInverted;
                    						}
                    						else{
                    							// otherwise, we know the answer -- it's the same if whatever is below
                    							// us is filled above it
                    							ev.seg.myFill.below = below.seg.myFill.above;
                    						}
                    	
                    						// since now we know if we're filled below us, we can calculate whether
                    						// we're filled above us by applying toggle to whatever is below us
                    						if (toggle)
                    							ev.seg.myFill.above = !ev.seg.myFill.below;
                    						else
                    							ev.seg.myFill.above = ev.seg.myFill.below;
                    					}
                    					else{
                    						// now we fill in any missing transition information, since we are all-knowing
                    						// at this point
                    	
                    						if (ev.seg.otherFill === null){
                    							// if we don't have other information, then we need to figure out if we're
                    							// inside the other polygon
                    							var inside;
                    							if (!below){
                    								// if nothing is below us, then we're inside if the other polygon is
                    								// inverted
                    								inside =
                    									ev.primary ? secondaryPolyInverted : primaryPolyInverted;
                    							}
                    							else{ // otherwise, something is below us
                    								// so copy the below segment's other polygon's above
                    								if (ev.primary === below.primary)
                    									inside = below.seg.otherFill.above;
                    								else
                    									inside = below.seg.myFill.above;
                    							}
                    							ev.seg.otherFill = {
                    								above: inside,
                    								below: inside
                    							};
                    						}
                    					}
                    	
                    					if (buildLog){
                    						buildLog.status(
                    							ev.seg,
                    							above ? above.seg : false,
                    							below ? below.seg : false
                    						);
                    					}
                    	
                    					// insert the status and remember it for later removal
                    					ev.other.status = surrounding.insert(LinkedList.node({ ev: ev }));
                    				}
                    				else{
                    					var st = ev.status;
                    	
                    					if (st === null){
                    						throw new Error('PolyBool: Zero-length segment detected; your epsilon is ' +
                    							'probably too small or too large');
                    					}
                    	
                    					// removing the status will create two new adjacent edges, so we'll need to check
                    					// for those
                    					if (status_root.exists(st.prev) && status_root.exists(st.next))
                    						checkIntersection(st.prev.ev, st.next.ev);
                    	
                    					if (buildLog)
                    						buildLog.statusRemove(st.ev.seg);
                    	
                    					// remove the status
                    					st.remove();
                    	
                    					// if we've reached this point, we've calculated everything there is to know, so
                    					// save the segment for reporting
                    					if (!ev.primary){
                    						// make sure `seg.myFill` actually points to the primary polygon though
                    						var s = ev.seg.myFill;
                    						ev.seg.myFill = ev.seg.otherFill;
                    						ev.seg.otherFill = s;
                    					}
                    					segments.push(ev.seg);
                    				}
                    	
                    				// remove the event and continue
                    				event_root.getHead().remove();
                    			}
                    	
                    			if (buildLog)
                    				buildLog.done();
                    	
                    			return segments;
                    		}
                    	
                    		// return the appropriate API depending on what we're doing
                    		if (!selfIntersection){
                    			// performing combination of polygons, so only deal with already-processed segments
                    			return {
                    				calculate: function(segments1, inverted1, segments2, inverted2){
                    					// segmentsX come from the self-intersection API, or this API
                    					// invertedX is whether we treat that list of segments as an inverted polygon or not
                    					// returns segments that can be used for further operations
                    					segments1.forEach(function(seg){
                    						eventAddSegment(segmentCopy(seg.start, seg.end, seg), true);
                    					});
                    					segments2.forEach(function(seg){
                    						eventAddSegment(segmentCopy(seg.start, seg.end, seg), false);
                    					});
                    					return calculate(inverted1, inverted2);
                    				}
                    			};
                    		}
                    	
                    		// otherwise, performing self-intersection, so deal with regions
                    		return {
                    			addRegion: function(region){
                    				// regions are a list of points:
                    				//  [ [0, 0], [100, 0], [50, 100] ]
                    				// you can add multiple regions before running calculate
                    				var pt1;
                    				var pt2 = region[region.length - 1];
                    				for (var i = 0; i < region.length; i++){
                    					pt1 = pt2;
                    					pt2 = region[i];
                    	
                    					var forward = eps.pointsCompare(pt1, pt2);
                    					if (forward === 0) // points are equal, so we have a zero-length segment
                    						continue; // just skip it
                    	
                    					eventAddSegment(
                    						segmentNew(
                    							forward < 0 ? pt1 : pt2,
                    							forward < 0 ? pt2 : pt1
                    						),
                    						true
                    					);
                    				}
                    			},
                    			calculate: function(inverted){
                    				// is the polygon inverted?
                    				// returns segments
                    				return calculate(inverted, false);
                    			}
                    		};
                    	}
                    	
                    	module.exports = Intersecter;
                    	
                    	},{"./linked-list":6}],6:[function(require,module,exports){
                    	// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc
                    	// MIT License
                    	// Project Home: https://github.com/voidqk/polybooljs
                    	
                    	//
                    	// simple linked list implementation that allows you to traverse down nodes and save positions
                    	//
                    	
                    	var LinkedList = {
                    		create: function(){
                    			var my = {
                    				root: { root: true, next: null },
                    				exists: function(node){
                    					if (node === null || node === my.root)
                    						return false;
                    					return true;
                    				},
                    				isEmpty: function(){
                    					return my.root.next === null;
                    				},
                    				getHead: function(){
                    					return my.root.next;
                    				},
                    				insertBefore: function(node, check){
                    					var last = my.root;
                    					var here = my.root.next;
                    					while (here !== null){
                    						if (check(here)){
                    							node.prev = here.prev;
                    							node.next = here;
                    							here.prev.next = node;
                    							here.prev = node;
                    							return;
                    						}
                    						last = here;
                    						here = here.next;
                    					}
                    					last.next = node;
                    					node.prev = last;
                    					node.next = null;
                    				},
                    				findTransition: function(check){
                    					var prev = my.root;
                    					var here = my.root.next;
                    					while (here !== null){
                    						if (check(here))
                    							break;
                    						prev = here;
                    						here = here.next;
                    					}
                    					return {
                    						before: prev === my.root ? null : prev,
                    						after: here,
                    						insert: function(node){
                    							node.prev = prev;
                    							node.next = here;
                    							prev.next = node;
                    							if (here !== null)
                    								here.prev = node;
                    							return node;
                    						}
                    					};
                    				}
                    			};
                    			return my;
                    		},
                    		node: function(data){
                    			data.prev = null;
                    			data.next = null;
                    			data.remove = function(){
                    				data.prev.next = data.next;
                    				if (data.next)
                    					data.next.prev = data.prev;
                    				data.prev = null;
                    				data.next = null;
                    			};
                    			return data;
                    		}
                    	};
                    	
                    	module.exports = LinkedList;
                    	
                    	},{}],7:[function(require,module,exports){
                    	// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc
                    	// MIT License
                    	// Project Home: https://github.com/voidqk/polybooljs
                    	
                    	//
                    	// converts a list of segments into a list of regions, while also removing unnecessary verticies
                    	//
                    	
                    	function SegmentChainer(segments, eps, buildLog){
                    		var chains = [];
                    		var regions = [];
                    	
                    		segments.forEach(function(seg){
                    			var pt1 = seg.start;
                    			var pt2 = seg.end;
                    			if (eps.pointsSame(pt1, pt2)){
                    				console.warn('PolyBool: Warning: Zero-length segment detected; your epsilon is ' +
                    					'probably too small or too large');
                    				return;
                    			}
                    	
                    			if (buildLog)
                    				buildLog.chainStart(seg);
                    	
                    			// search for two chains that this segment matches
                    			var first_match = {
                    				index: 0,
                    				matches_head: false,
                    				matches_pt1: false
                    			};
                    			var second_match = {
                    				index: 0,
                    				matches_head: false,
                    				matches_pt1: false
                    			};
                    			var next_match = first_match;
                    			function setMatch(index, matches_head, matches_pt1){
                    				// return true if we've matched twice
                    				next_match.index = index;
                    				next_match.matches_head = matches_head;
                    				next_match.matches_pt1 = matches_pt1;
                    				if (next_match === first_match){
                    					next_match = second_match;
                    					return false;
                    				}
                    				next_match = null;
                    				return true; // we've matched twice, we're done here
                    			}
                    			for (var i = 0; i < chains.length; i++){
                    				var chain = chains[i];
                    				var head  = chain[0];
                    				var head2 = chain[1];
                    				var tail  = chain[chain.length - 1];
                    				var tail2 = chain[chain.length - 2];
                    				if (eps.pointsSame(head, pt1)){
                    					if (setMatch(i, true, true))
                    						break;
                    				}
                    				else if (eps.pointsSame(head, pt2)){
                    					if (setMatch(i, true, false))
                    						break;
                    				}
                    				else if (eps.pointsSame(tail, pt1)){
                    					if (setMatch(i, false, true))
                    						break;
                    				}
                    				else if (eps.pointsSame(tail, pt2)){
                    					if (setMatch(i, false, false))
                    						break;
                    				}
                    			}
                    	
                    			if (next_match === first_match){
                    				// we didn't match anything, so create a new chain
                    				chains.push([ pt1, pt2 ]);
                    				if (buildLog)
                    					buildLog.chainNew(pt1, pt2);
                    				return;
                    			}
                    	
                    			if (next_match === second_match){
                    				// we matched a single chain
                    	
                    				if (buildLog)
                    					buildLog.chainMatch(first_match.index);
                    	
                    				// add the other point to the apporpriate end, and check to see if we've closed the
                    				// chain into a loop
                    	
                    				var index = first_match.index;
                    				var pt = first_match.matches_pt1 ? pt2 : pt1; // if we matched pt1, then we add pt2, etc
                    				var addToHead = first_match.matches_head; // if we matched at head, then add to the head
                    	
                    				var chain = chains[index];
                    				var grow  = addToHead ? chain[0] : chain[chain.length - 1];
                    				var grow2 = addToHead ? chain[1] : chain[chain.length - 2];
                    				var oppo  = addToHead ? chain[chain.length - 1] : chain[0];
                    				var oppo2 = addToHead ? chain[chain.length - 2] : chain[1];
                    	
                    				if (eps.pointsCollinear(grow2, grow, pt)){
                    					// grow isn't needed because it's directly between grow2 and pt:
                    					// grow2 ---grow---> pt
                    					if (addToHead){
                    						if (buildLog)
                    							buildLog.chainRemoveHead(first_match.index, pt);
                    						chain.shift();
                    					}
                    					else{
                    						if (buildLog)
                    							buildLog.chainRemoveTail(first_match.index, pt);
                    						chain.pop();
                    					}
                    					grow = grow2; // old grow is gone... new grow is what grow2 was
                    				}
                    	
                    				if (eps.pointsSame(oppo, pt)){
                    					// we're closing the loop, so remove chain from chains
                    					chains.splice(index, 1);
                    	
                    					if (eps.pointsCollinear(oppo2, oppo, grow)){
                    						// oppo isn't needed because it's directly between oppo2 and grow:
                    						// oppo2 ---oppo--->grow
                    						if (addToHead){
                    							if (buildLog)
                    								buildLog.chainRemoveTail(first_match.index, grow);
                    							chain.pop();
                    						}
                    						else{
                    							if (buildLog)
                    								buildLog.chainRemoveHead(first_match.index, grow);
                    							chain.shift();
                    						}
                    					}
                    	
                    					if (buildLog)
                    						buildLog.chainClose(first_match.index);
                    	
                    					// we have a closed chain!
                    					regions.push(chain);
                    					return;
                    				}
                    	
                    				// not closing a loop, so just add it to the apporpriate side
                    				if (addToHead){
                    					if (buildLog)
                    						buildLog.chainAddHead(first_match.index, pt);
                    					chain.unshift(pt);
                    				}
                    				else{
                    					if (buildLog)
                    						buildLog.chainAddTail(first_match.index, pt);
                    					chain.push(pt);
                    				}
                    				return;
                    			}
                    	
                    			// otherwise, we matched two chains, so we need to combine those chains together
                    	
                    			function reverseChain(index){
                    				if (buildLog)
                    					buildLog.chainReverse(index);
                    				chains[index].reverse(); // gee, that's easy
                    			}
                    	
                    			function appendChain(index1, index2){
                    				// index1 gets index2 appended to it, and index2 is removed
                    				var chain1 = chains[index1];
                    				var chain2 = chains[index2];
                    				var tail  = chain1[chain1.length - 1];
                    				var tail2 = chain1[chain1.length - 2];
                    				var head  = chain2[0];
                    				var head2 = chain2[1];
                    	
                    				if (eps.pointsCollinear(tail2, tail, head)){
                    					// tail isn't needed because it's directly between tail2 and head
                    					// tail2 ---tail---> head
                    					if (buildLog)
                    						buildLog.chainRemoveTail(index1, tail);
                    					chain1.pop();
                    					tail = tail2; // old tail is gone... new tail is what tail2 was
                    				}
                    	
                    				if (eps.pointsCollinear(tail, head, head2)){
                    					// head isn't needed because it's directly between tail and head2
                    					// tail ---head---> head2
                    					if (buildLog)
                    						buildLog.chainRemoveHead(index2, head);
                    					chain2.shift();
                    				}
                    	
                    				if (buildLog)
                    					buildLog.chainJoin(index1, index2);
                    				chains[index1] = chain1.concat(chain2);
                    				chains.splice(index2, 1);
                    			}
                    	
                    			var F = first_match.index;
                    			var S = second_match.index;
                    	
                    			if (buildLog)
                    				buildLog.chainConnect(F, S);
                    	
                    			var reverseF = chains[F].length < chains[S].length; // reverse the shorter chain, if needed
                    			if (first_match.matches_head){
                    				if (second_match.matches_head){
                    					if (reverseF){
                    						// <<<< F <<<< --- >>>> S >>>>
                    						reverseChain(F);
                    						// >>>> F >>>> --- >>>> S >>>>
                    						appendChain(F, S);
                    					}
                    					else{
                    						// <<<< F <<<< --- >>>> S >>>>
                    						reverseChain(S);
                    						// <<<< F <<<< --- <<<< S <<<<   logically same as:
                    						// >>>> S >>>> --- >>>> F >>>>
                    						appendChain(S, F);
                    					}
                    				}
                    				else{
                    					// <<<< F <<<< --- <<<< S <<<<   logically same as:
                    					// >>>> S >>>> --- >>>> F >>>>
                    					appendChain(S, F);
                    				}
                    			}
                    			else{
                    				if (second_match.matches_head){
                    					// >>>> F >>>> --- >>>> S >>>>
                    					appendChain(F, S);
                    				}
                    				else{
                    					if (reverseF){
                    						// >>>> F >>>> --- <<<< S <<<<
                    						reverseChain(F);
                    						// <<<< F <<<< --- <<<< S <<<<   logically same as:
                    						// >>>> S >>>> --- >>>> F >>>>
                    						appendChain(S, F);
                    					}
                    					else{
                    						// >>>> F >>>> --- <<<< S <<<<
                    						reverseChain(S);
                    						// >>>> F >>>> --- >>>> S >>>>
                    						appendChain(F, S);
                    					}
                    				}
                    			}
                    		});
                    	
                    		return regions;
                    	}
                    	
                    	module.exports = SegmentChainer;
                    	
                    	},{}],8:[function(require,module,exports){
                    	// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc
                    	// MIT License
                    	// Project Home: https://github.com/voidqk/polybooljs
                    	
                    	//
                    	// filter a list of segments based on boolean operations
                    	//
                    	
                    	function select(segments, selection, buildLog){
                    		var result = [];
                    		segments.forEach(function(seg){
                    			var index =
                    				(seg.myFill.above ? 8 : 0) +
                    				(seg.myFill.below ? 4 : 0) +
                    				((seg.otherFill && seg.otherFill.above) ? 2 : 0) +
                    				((seg.otherFill && seg.otherFill.below) ? 1 : 0);
                    			if (selection[index] !== 0){
                    				// copy the segment to the results, while also calculating the fill status
                    				result.push({
                    					id: buildLog ? buildLog.segmentId() : -1,
                    					start: seg.start,
                    					end: seg.end,
                    					myFill: {
                    						above: selection[index] === 1, // 1 if filled above
                    						below: selection[index] === 2  // 2 if filled below
                    					},
                    					otherFill: null
                    				});
                    			}
                    		});
                    	
                    		if (buildLog)
                    			buildLog.selected(result);
                    	
                    		return result;
                    	}
                    	
                    	var SegmentSelector = {
                    		union: function(segments, buildLog){ // primary | secondary
                    			// above1 below1 above2 below2    Keep?               Value
                    			//    0      0      0      0   =>   no                  0
                    			//    0      0      0      1   =>   yes filled below    2
                    			//    0      0      1      0   =>   yes filled above    1
                    			//    0      0      1      1   =>   no                  0
                    			//    0      1      0      0   =>   yes filled below    2
                    			//    0      1      0      1   =>   yes filled below    2
                    			//    0      1      1      0   =>   no                  0
                    			//    0      1      1      1   =>   no                  0
                    			//    1      0      0      0   =>   yes filled above    1
                    			//    1      0      0      1   =>   no                  0
                    			//    1      0      1      0   =>   yes filled above    1
                    			//    1      0      1      1   =>   no                  0
                    			//    1      1      0      0   =>   no                  0
                    			//    1      1      0      1   =>   no                  0
                    			//    1      1      1      0   =>   no                  0
                    			//    1      1      1      1   =>   no                  0
                    			return select(segments, [
                    				0, 2, 1, 0,
                    				2, 2, 0, 0,
                    				1, 0, 1, 0,
                    				0, 0, 0, 0
                    			], buildLog);
                    		},
                    		intersect: function(segments, buildLog){ // primary & secondary
                    			// above1 below1 above2 below2    Keep?               Value
                    			//    0      0      0      0   =>   no                  0
                    			//    0      0      0      1   =>   no                  0
                    			//    0      0      1      0   =>   no                  0
                    			//    0      0      1      1   =>   no                  0
                    			//    0      1      0      0   =>   no                  0
                    			//    0      1      0      1   =>   yes filled below    2
                    			//    0      1      1      0   =>   no                  0
                    			//    0      1      1      1   =>   yes filled below    2
                    			//    1      0      0      0   =>   no                  0
                    			//    1      0      0      1   =>   no                  0
                    			//    1      0      1      0   =>   yes filled above    1
                    			//    1      0      1      1   =>   yes filled above    1
                    			//    1      1      0      0   =>   no                  0
                    			//    1      1      0      1   =>   yes filled below    2
                    			//    1      1      1      0   =>   yes filled above    1
                    			//    1      1      1      1   =>   no                  0
                    			return select(segments, [
                    				0, 0, 0, 0,
                    				0, 2, 0, 2,
                    				0, 0, 1, 1,
                    				0, 2, 1, 0
                    			], buildLog);
                    		},
                    		difference: function(segments, buildLog){ // primary - secondary
                    			// above1 below1 above2 below2    Keep?               Value
                    			//    0      0      0      0   =>   no                  0
                    			//    0      0      0      1   =>   no                  0
                    			//    0      0      1      0   =>   no                  0
                    			//    0      0      1      1   =>   no                  0
                    			//    0      1      0      0   =>   yes filled below    2
                    			//    0      1      0      1   =>   no                  0
                    			//    0      1      1      0   =>   yes filled below    2
                    			//    0      1      1      1   =>   no                  0
                    			//    1      0      0      0   =>   yes filled above    1
                    			//    1      0      0      1   =>   yes filled above    1
                    			//    1      0      1      0   =>   no                  0
                    			//    1      0      1      1   =>   no                  0
                    			//    1      1      0      0   =>   no                  0
                    			//    1      1      0      1   =>   yes filled above    1
                    			//    1      1      1      0   =>   yes filled below    2
                    			//    1      1      1      1   =>   no                  0
                    			return select(segments, [
                    				0, 0, 0, 0,
                    				2, 0, 2, 0,
                    				1, 1, 0, 0,
                    				0, 1, 2, 0
                    			], buildLog);
                    		},
                    		differenceRev: function(segments, buildLog){ // secondary - primary
                    			// above1 below1 above2 below2    Keep?               Value
                    			//    0      0      0      0   =>   no                  0
                    			//    0      0      0      1   =>   yes filled below    2
                    			//    0      0      1      0   =>   yes filled above    1
                    			//    0      0      1      1   =>   no                  0
                    			//    0      1      0      0   =>   no                  0
                    			//    0      1      0      1   =>   no                  0
                    			//    0      1      1      0   =>   yes filled above    1
                    			//    0      1      1      1   =>   yes filled above    1
                    			//    1      0      0      0   =>   no                  0
                    			//    1      0      0      1   =>   yes filled below    2
                    			//    1      0      1      0   =>   no                  0
                    			//    1      0      1      1   =>   yes filled below    2
                    			//    1      1      0      0   =>   no                  0
                    			//    1      1      0      1   =>   no                  0
                    			//    1      1      1      0   =>   no                  0
                    			//    1      1      1      1   =>   no                  0
                    			return select(segments, [
                    				0, 2, 1, 0,
                    				0, 0, 1, 1,
                    				0, 2, 0, 2,
                    				0, 0, 0, 0
                    			], buildLog);
                    		},
                    		xor: function(segments, buildLog){ // primary ^ secondary
                    			// above1 below1 above2 below2    Keep?               Value
                    			//    0      0      0      0   =>   no                  0
                    			//    0      0      0      1   =>   yes filled below    2
                    			//    0      0      1      0   =>   yes filled above    1
                    			//    0      0      1      1   =>   no                  0
                    			//    0      1      0      0   =>   yes filled below    2
                    			//    0      1      0      1   =>   no                  0
                    			//    0      1      1      0   =>   no                  0
                    			//    0      1      1      1   =>   yes filled above    1
                    			//    1      0      0      0   =>   yes filled above    1
                    			//    1      0      0      1   =>   no                  0
                    			//    1      0      1      0   =>   no                  0
                    			//    1      0      1      1   =>   yes filled below    2
                    			//    1      1      0      0   =>   no                  0
                    			//    1      1      0      1   =>   yes filled above    1
                    			//    1      1      1      0   =>   yes filled below    2
                    			//    1      1      1      1   =>   no                  0
                    			return select(segments, [
                    				0, 2, 1, 0,
                    				2, 0, 0, 1,
                    				1, 0, 0, 2,
                    				0, 1, 2, 0
                    			], buildLog);
                    		}
                    	};
                    	
                    	module.exports = SegmentSelector;
                    	
                    },{}]},{},[1]);
                };
            };
            
            _canvas_.library.audio.nowReady = function(){
                _canvas_.layers.registerLayerLoaded('library',_canvas_.library);
                _canvas_.library.go.__activate();
            };

            _canvas_.core = new function(){
                this.versionInformation = { tick:0, lastDateModified:{y:2020,m:2,d:8} };
                const core_engine = new Worker("/js/core_engine.js");
                const self = this;
                
                const communicationModuleMaker = function(communicationObject,callerName){
                    const self = this;
                    const devMode = false;
                    this.log = function(){
                        if(!devMode){return;}
                        let prefix = 'communicationModule['+callerName+']';
                        console.log('%c'+prefix+(new Array(...arguments).join(' ')),'color:rgb(235, 52, 131); font-style:italic;' );
                    };
                    this.function = {};
                    this.delayedFunction = {};
                
                    let messageId = 0;
                    const messagingCallbacks = {};
                
                    function generateMessageID(){
                        return messageId++;
                    }
                
                    communicationObject.onmessage = function(encodedPacket){
                        let message = encodedPacket.data;
                
                        if(message.outgoing){
                            if(message.cargo.function in self.function){
                                if(message.cargo.arguments == undefined){message.cargo.arguments = [];}
                                if(message.id == null){
                                    self.function[message.cargo.function](...message.cargo.arguments);
                                }else{
                                    communicationObject.postMessage({
                                        id:message.id,
                                        outgoing:false,
                                        cargo:self.function[message.cargo.function](...message.cargo.arguments),
                                    });
                                }
                            }else if(message.cargo.function in self.delayedFunction){
                                if(message.cargo.arguments == undefined){message.cargo.arguments = [];}
                                if(message.id == null){
                                    self.delayedFunction[message.cargo.function](...message.cargo.arguments);
                                }else{
                                    cargo:self.delayedFunction[message.cargo.function](...[function(returnedData){
                                        communicationObject.postMessage({ id:message.id, outgoing:false, cargo:returnedData });
                                    }].concat(message.cargo.arguments));
                                }
                            }else{
                            }
                        }else{
                            messagingCallbacks[message.id](message.cargo);
                            delete messagingCallbacks[message.id];
                        }
                    };
                    this.run = function(functionName,argumentList=[],callback,transferables){
                        let id = null;
                        if(callback != undefined){
                            id = generateMessageID();
                            messagingCallbacks[id] = callback;
                        }
                        communicationObject.postMessage({ id:id, outgoing:true, cargo:{function:functionName,arguments:argumentList} },transferables);
                    };
                };
                const communicationModule = new communicationModuleMaker(core_engine,'core_console');
                this.__com = communicationModule;
                
                _canvas_.setAttribute('tabIndex',1);
                
                const dev = new function(){
                    const prefix = 'core_console';
                    const active = {
                        elementLibrary:{
                            genericElementProxyTemplate:false,
                            rectangle:false,
                            rectangleWithOutline:false,
                
                            group:false,
                            circle:false,
                            circleWithOutline:false,
                            polygon:false,
                            polygonWithOutline:false,
                            path:false,
                            image:false,
                            canvas:false,
                            character:false,
                            characterString:false,
                        },
                        service:false,
                        interface:false,
                    };
                
                    this.log = {};
                    Object.entries(active).forEach(entry => {
                        if(typeof entry[1] == 'object'){
                            this.log[entry[0]] = {};
                            Object.keys(active[entry[0]]).forEach(key => {
                                this.log[entry[0]][key] = function(){
                                    if(active[entry[0]][key]){ 
                                        console.log( prefix+'.'+entry[0]+'.'+key+arguments[0], ...(new Array(...arguments).slice(1)) );
                                    }
                                };
                            });
                        }else{
                            this.log[entry[0]] = function(){
                                if(active[entry[0]]){ 
                                    console.log( prefix+'.'+entry[0]+arguments[0], ...(new Array(...arguments).slice(1)) );
                                }
                            };
                        }
                    });
                
                    const countActive = !false;
                    const countMemory = {};
                    this.count = function(commandTag){
                        if(!countActive){return;}
                        if(commandTag in countMemory){ countMemory[commandTag]++; }
                        else{ countMemory[commandTag] = 1; }
                    };
                    this.countResults = function(){return countMemory;};
                };

                let elementRegistry = [];
                const elementLibrary = new function(){
                    const genericElementProxy = function(_type, _name){
                        const self = this;
                    
                        //type
                            const type = _type;
                            this.getType = function(){return type;};
                    
                        //id
                            let id = -1;
                            this.getId = function(){return id;};
                            this.__idReceived = function(){};
                            this.__id = function(a,updateIdOnly=false){
                                id = a;
                                if(updateIdOnly){return;}
                    
                                //repush
                                    _canvas_.core.element.__executeMethod(id,'unifiedAttribute',[cashedAttributes]);
                                    Object.entries(cashedCallbacks).forEach(entry => { _canvas_.core.callback.attachCallback(this,entry[0],entry[1]); });
                                    if(this.__repush != undefined){this.__repush();}
                    
                                if(this.__idReceived){this.__idReceived();}
                            };
                    
                        //name
                            let name = _name;
                            this.getName = function(){return name;};
                            // this.setName = function(a){
                            //     name = a;
                            // };
                    
                        //hierarchy
                            this.parent = undefined;
                            this.getAddress = function(){
                                return (this.parent != undefined && this.parent.getId() != 0 ? this.parent.getAddress() : '') + '/' + name;
                            };
                            this.getOffset = function(){
                    
                                let output = {x:0,y:0,scale:1,angle:0};
                    
                                if(this.parent){
                                    const offset = this.parent.getOffset();
                                    const point = _canvas_.library.math.cartesianAngleAdjust(cashedAttributes.x,cashedAttributes.y,offset.angle);
                                    output = { 
                                        x: point.x*offset.scale + offset.x,
                                        y: point.y*offset.scale + offset.y,
                                        scale: offset.scale * cashedAttributes.scale,
                                        angle: offset.angle + cashedAttributes.angle,
                                    };
                                }else{
                                    output = {x:cashedAttributes.x ,y:cashedAttributes.y ,scale:cashedAttributes.scale ,angle:cashedAttributes.angle};
                                }
                    
                                return output;
                            };
                    
                        //attributes
                            const cashedAttributes = {};
                            this.setupSimpleAttribute = function(name,defaultValue){
                                cashedAttributes[name] = defaultValue;
                                this[name] = function(a){
                                    if(a == undefined){ return cashedAttributes[name]; }
                                    if(a == cashedAttributes[name]){ return; } //no need to set things to what they already are
                                    cashedAttributes[name] = a;
                                    if(this.getId() != -1){ _canvas_.core.element.__executeMethod(this.getId(),name,[...arguments]); }
                                };
                            }
                            Object.entries({
                                ignored: false,
                                scale: 1,
                            }).forEach(([name,defaultValue]) => this.setupSimpleAttribute(name,defaultValue) );
                            this.unifiedAttribute = function(attributes){
                                if(attributes == undefined){ return cashedAttributes; }
                                Object.keys(attributes).forEach(key => { cashedAttributes[key] = attributes[key]; });
                                if(id != -1){ _canvas_.core.element.__executeMethod(id,'unifiedAttribute',[attributes]); }
                            };
                    
                        //callbacks
                            const cashedCallbacks = {};
                            this.getCallback = function(callbackType){
                                return cashedCallbacks[callbackType];
                            };
                            this.attachCallback = function(callbackType, callback){
                                cashedCallbacks[callbackType] = callback;
                                if(id != -1){ _canvas_.core.callback.attachCallback(this,callbackType,callback); }
                            }
                            this.removeCallback = function(callbackType){
                                delete cashedCallbacks[callbackType];
                                if(id != -1){ _canvas_.core.callback.removeCallback(this,callbackType); }
                            }
                    
                        //info dump
                            this._dump = function(){
                                _canvas_.core.element.__executeMethod(id,'_dump',[]);
                            };
                    };
                    
                    // this.getType
                    // this.getId
                    // this.__idReceived
                    // this.__id
                    // this.__repush
                    // this.getName
                    // this.setName
                    // this.parent
                    // this.getAddress
                    // this.getOffset
                    // this.setupSimpleAttribute
                    // this.unifiedAttribute
                    // this.getCallback
                    // this.attachCallback
                    // this.removeCallback
                    // this._dump
                    
                    this.group = function(_name){
                        genericElementProxy.call(this,'group',_name);
                    
                        Object.entries({
                            heedCamera: false,
                            x: 0,
                            y: 0,
                            angle: 0,
                            clipActive: false,
                        }).forEach(([name,defaultValue]) => this.setupSimpleAttribute(name,defaultValue) );
                    
                    
                        const self = this;
                    
                        let children = [];
                        let childRegistry = {};
                        let stencilElement = undefined;
                    
                        let clearingLock = false;
                        function lockClearingLock(){
                            clearingLock = true;
                        }
                        function unlockClearingLock(){
                            self.__repush();
                            clearingLock = false;
                        }
                    
                        function checkForName(name){ return childRegistry[name] != undefined; }
                        function isValidElement(elementToCheck){
                            if( elementToCheck == undefined ){ return false; }
                            if( elementToCheck.getName() == undefined || elementToCheck.getName().length == 0 ){
                                console.warn('group error: element with no name being inserted into group "'+self.getAddress()+'", therefore; the element will not be added');
                                return false;
                            }
                            if( checkForName(elementToCheck.getName()) ){
                                console.warn('group error: element with name "'+elementToCheck.getName()+'" already exists in group "'+self.getAddress()+'", therefore; the element will not be added');
                                return false;
                            }
                    
                            return true;
                        }
                    
                        this.__repush = function(){
                            if(stencilElement != undefined){
                                function readdStencil(){
                                    if( stencilElement.getId() == -1 ){ setTimeout(readdStencil,1); }
                                    else{ _canvas_.core.element.__executeMethod(self.getId(),'stencil',[stencilElement.getId()]); }
                                }
                                readdStencil();
                            }
                    
                            communicationModule.run('element.executeMethod',[self.getId(),'clear'],() => {
                                function readdChildren(){
                                    const childIds = children.map(child => child.getId());
                                    if( childIds.indexOf(-1) != -1 ){ setTimeout(readdChildren,1); }
                                    else{ _canvas_.core.element.__executeMethod(self.getId(),'syncChildren',[childIds]); }
                                }
                                readdChildren();
                            });
                        };
                        
                        this.getChildren = function(){ 
                            return children;
                        };
                        this.getChildByName = function(name){
                            return childRegistry[name];
                        };
                        this.getChildIndexByName = function(name){
                            return children.indexOf(childRegistry[name]);
                        };
                        this.contains = function(elementToCheck){
                            return children.indexOf(elementToCheck) != -1;
                        };
                        this.append = function(newElement){
                    
                            if( !isValidElement(newElement) ){ return false; }
                            newElement.parent = this;
                            children.push(newElement);
                            childRegistry[newElement.getName()] = newElement;
                            if(newElement.getCallback('onadd')){newElement.getCallback('onadd')();}
                    
                            if(clearingLock){ return; }
                    
                            if(newElement.getId() == -1){
                                newElement.__calledBy = this.getAddress();
                                newElement.__idReceived = function(){
                                    if(self.getId() != -1){ 
                                        if(children.indexOf(newElement) != -1){
                                            _canvas_.core.element.__executeMethod(self.getId(),'append', [newElement.getId()]);
                                        }else{
                                        }
                                    }else{
                                    }
                                };
                            }else{
                                if(self.getId() != -1){
                                    _canvas_.core.element.__executeMethod(self.getId(),'append', [newElement.getId()]);
                                }else{
                                }
                            }
                        };
                        this.prepend = function(newElement){
                    
                            if( !isValidElement(newElement) ){ return false; }
                            newElement.parent = this;
                            children.unshift(newElement);
                            childRegistry[newElement.getName()] = newElement;
                            if(newElement.getCallback('onadd')){newElement.getCallback('onadd')();}
                    
                            if(clearingLock){ return; }
                    
                            if(newElement.getId() == -1){
                                newElement.__idReceived = function(){
                                    if(children.indexOf(newElement) != -1 && self.getId() != -1){ 
                                        _canvas_.core.element.__executeMethod(self.getId(),'prepend', [newElement.getId()]);
                                    }else{
                                    }
                                };
                            }else{
                                if(self.getId() != -1){
                                    _canvas_.core.element.__executeMethod(self.getId(),'prepend', [newElement.getId()]);
                                }else{
                                }
                            }
                        };
                        this.remove = function(elementToRemove){
                            children.splice(children.indexOf(elementToRemove), 1);
                            delete childRegistry[elementToRemove.getName()];
                            elementToRemove.parent = undefined;
                            if(elementToRemove.getCallback('onremove')){elementToRemove.getCallback('onremove')();}
                    
                            if(clearingLock){ return; }
                    
                            if(elementToRemove.getId() == -1){
                                elementToRemove.__idReceived = function(){
                                    if(children.indexOf(elementToRemove) == -1 && self.getId() != -1){ 
                                        _canvas_.core.element.__executeMethod(self.getId(),'remove', [elementToRemove.getId()]);
                                    }else{
                                    }
                                };
                            }else{
                                if(self.getId() != -1){
                                    _canvas_.core.element.__executeMethod(self.getId(),'remove', [elementToRemove.getId()]);
                                }else{
                                }
                            }
                        };
                        this.clear = function(){
                            children = [];
                            childRegistry = {};
                            if(self.getId() != -1){ 
                                lockClearingLock();
                                communicationModule.run('element.executeMethod',[self.getId(),'clear',[]],unlockClearingLock);
                            }else{
                            }
                        };
                        this.getElementsUnderPoint = function(x,y){
                            if(self.getId() != -1){
                                return new Promise((resolve, reject) => {
                                    _canvas_.core.element.__executeMethod(self.getId(),'getElementsUnderPoint',[x,y],result => resolve(result.map(elementId => elementRegistry[elementId])) );
                                });
                            }
                        };
                        this.getTree = function(){
                    
                            const result = {name:this.getName(), type:this.getType(), id:this.getId(), children:[]};
                            children.forEach(function(a){
                                if(a.getType() == 'group'){ result.children.push( a.getTree() ); }
                                else{ result.children.push({ type:a.getType(), name:a.getName(), id:a.getId() }); }
                            });
                            return result;
                        };
                        this.stencil = function(newStencilElement){
                            if(newStencilElement == undefined){ return stencilElement; }
                            stencilElement = newStencilElement;
                    
                            if(newStencilElement.getId() == -1){
                                newStencilElement.__idReceived = function(){
                                    if(self.getId() != -1){ _canvas_.core.element.__executeMethod(self.getId(),'stencil', [newStencilElement.getId()]); }
                                };
                            }else{
                                if(self.getId() != -1){ _canvas_.core.element.__executeMethod(self.getId(),'stencil', [newStencilElement.getId()]); }
                            }
                        };
                    };
                    
                    this.rectangle = function(_name){
                        genericElementProxy.call(this,'rectangle',_name);
                    
                        Object.entries({
                            x: 0,
                            y: 0,
                            angle: 0,
                            colour: {r:1,g:0,b:0,a:1},
                            anchor: {x:0,y:0},
                            width: 10,
                            height: 10,
                        }).forEach(([name,defaultValue]) => this.setupSimpleAttribute(name,defaultValue) );
                    };
                    this.rectangleWithOutline = function(_name){
                        genericElementProxy.call(this,'rectangleWithOutline',_name);
                    
                        Object.entries({
                            x: 0,
                            y: 0,
                            angle: 0,
                            colour: {r:1,g:0,b:0,a:1},
                            lineColour: {r:1,g:0,b:0,a:1},
                            anchor: {x:0,y:0},
                            width: 10,
                            height: 10,
                            thickness: 0,
                        }).forEach(([name,defaultValue]) => this.setupSimpleAttribute(name,defaultValue) );
                    };
                    this.circle = function(_name){
                        genericElementProxy.call(this,'circle',_name);
                    
                        Object.entries({
                            x: 0,
                            y: 0,
                            colour: {r:1,g:0,b:0,a:1},
                            radius: 10,
                        }).forEach(([name,defaultValue]) => this.setupSimpleAttribute(name,defaultValue) );
                    };
                    this.circleWithOutline = function(_name){
                        genericElementProxy.call(this,'circleWithOutline',_name);
                    
                        Object.entries({
                            x: 0,
                            y: 0,
                            colour: {r:1,g:0,b:0,a:1},
                            lineColour: {r:1,g:0,b:0,a:1},
                            radius: 10,
                            thickness: 0,
                        }).forEach(([name,defaultValue]) => this.setupSimpleAttribute(name,defaultValue) );
                    };
                    this.polygon = function(_name){
                        genericElementProxy.call(this,'polygon',_name);
                    
                        Object.entries({
                            colour: {r:1,g:0,b:0,a:1},
                            points: [], 
                        }).forEach(([name,defaultValue]) => this.setupSimpleAttribute(name,defaultValue) );
                    
                        function XYArrayToPoints(XYArrray){
                            return XYArrray.flatMap(i => [i.x,i.y]);
                        }
                        function pointsToXYArray(points){ 
                            const output = [];
                            for(let a = 0; a < points.length; a+=2){ output.push({x:points[a], y:points[a+1]}); }
                            return output;
                        }
                    
                        this.pointsAsXYArray = function(XYArrray){
                            if(XYArrray == undefined){ return pointsToXYArray(this.points()); }
                            this.points(XYArrayToPoints(XYArrray));
                        };
                    
                        const __unifiedAttribute = this.unifiedAttribute;
                        this.unifiedAttribute = function(attributes){
                            __unifiedAttribute(attributes);
                            if(attributes.points != undefined){
                                attributes.pointsAsXYArray = pointsToXYArray(attributes.points);
                                return attributes;
                            }
                            if(attributes.pointsAsXYArray != undefined){
                                attributes.points = XYArrayToPoints(attributes.pointsAsXYArray);
                                return attributes;
                            }
                        };
                    };
                    this.polygonWithOutline = function(_name){
                        genericElementProxy.call(this,'polygonWithOutline',_name);
                    
                        Object.entries({
                            colour: {r:1,g:0,b:0,a:1},
                            lineColour: {r:1,g:0,b:0,a:1},
                            points: [],
                            thickness: 0,
                            jointDetail: 25,
                            jointType: 'sharp',
                            sharpLimit: 4,
                        }).forEach(([name,defaultValue]) => this.setupSimpleAttribute(name,defaultValue) );
                    
                        function XYArrayToPoints(XYArrray){
                            return XYArrray.flatMap(i => [i.x,i.y]);
                        }
                        function pointsToXYArray(points){ 
                            const output = [];
                            for(let a = 0; a < points.length; a+=2){ output.push({x:points[a], y:points[a+1]}); }
                            return output;
                        }
                    
                        this.pointsAsXYArray = function(XYArrray){
                            if(XYArrray == undefined){ return pointsToXYArray(this.points()); }
                            this.points(XYArrayToPoints(XYArrray));
                        };
                    
                        const __unifiedAttribute = this.unifiedAttribute;
                        this.unifiedAttribute = function(attributes){
                            __unifiedAttribute(attributes);
                            if(attributes.points != undefined){
                                attributes.pointsAsXYArray = pointsToXYArray(attributes.points);
                                return attributes;
                            }
                            if(attributes.pointsAsXYArray != undefined){
                                attributes.points = XYArrayToPoints(attributes.pointsAsXYArray);
                                return attributes;
                            }
                        };
                    };
                    
                    this.path = function(_name){
                        genericElementProxy.call(this,'path',_name);
                    
                        Object.entries({
                            colour: {r:1,g:0,b:0,a:1},
                            points: [], 
                            thickness: 0,
                            capType: 'none',
                            jointDetail: 25,
                            jointType: 'sharp',
                            sharpLimit: 4,
                        }).forEach(([name,defaultValue]) => this.setupSimpleAttribute(name,defaultValue) );
                    
                        function XYArrayToPoints(XYArrray){
                            return XYArrray.flatMap(i => [i.x,i.y]);
                        }
                        function pointsToXYArray(points){ 
                            const output = [];
                            for(let a = 0; a < points.length; a+=2){ output.push({x:points[a], y:points[a+1]}); }
                            return output;
                        }
                    
                        this.pointsAsXYArray = function(XYArrray){
                            if(XYArrray == undefined){ return pointsToXYArray(this.points()); }
                            this.points(XYArrayToPoints(XYArrray));
                        };
                    
                        const __unifiedAttribute = this.unifiedAttribute;
                        this.unifiedAttribute = function(attributes){
                            __unifiedAttribute(attributes);
                            if(attributes.points != undefined){
                                attributes.pointsAsXYArray = pointsToXYArray(attributes.points);
                                return attributes;
                            }
                            if(attributes.pointsAsXYArray != undefined){
                                attributes.points = XYArrayToPoints(attributes.pointsAsXYArray);
                                return attributes;
                            }
                        };
                    };
                    
                    this.image = function(_name){
                        genericElementProxy.call(this,'image',_name);
                    
                        Object.entries({
                            x: 0,
                            y: 0,
                            angle: 0,
                            anchor: {x:0,y:0},
                            width: 10,
                            height: 10,
                            url:'',
                            bitmap: undefined,
                        }).forEach(([name,defaultValue]) => this.setupSimpleAttribute(name,defaultValue) );
                    };
                    this.canvas = function(_name){
                        genericElementProxy.call(this,'canvas',_name);
                    
                        Object.entries({
                            x: 0,
                            y: 0,
                            angle: 0,
                            anchor: {x:0,y:0},
                            width: 10,
                            height: 10,
                        }).forEach(([name,defaultValue]) => this.setupSimpleAttribute(name,defaultValue) );
                    
                        //subCanvas
                            const subCanvas = { object:document.createElement('canvas'), context:undefined, resolution:1 };
                            subCanvas.context = subCanvas.object.getContext('2d');
                    
                            function updateDimentions(self){
                                subCanvas.object.setAttribute('width',self.width()*subCanvas.resolution);
                                subCanvas.object.setAttribute('height',self.height()*subCanvas.resolution);
                            }
                            updateDimentions(this);
                    
                            this._ = subCanvas.context;
                            this.$ = function(a){return a*subCanvas.resolution;};
                            this.resolution = function(a){
                                if(a == undefined){return subCanvas.resolution;}
                                subCanvas.resolution = a;
                                updateDimentions(this);
                            };
                            this.requestUpdate = function(){
                                createImageBitmap(subCanvas.object).then(bitmap => {
                                    if(this.getId() != -1){ _canvas_.core.element.__executeMethod(this.getId(),'imageBitmap',[bitmap],undefined,[bitmap]); }
                                });
                            };
                            this.requestUpdate();
                            this.__repush = function(){ this.requestUpdate(); };
                    
                    
                        const __unifiedAttribute = this.unifiedAttribute;
                        this.unifiedAttribute = function(attributes){
                            if(attributes.resolution != undefined){
                                this.resolution(attributes.resolution);
                                delete attributes.resolution;
                            }
                            __unifiedAttribute(attributes);
                            updateDimentions(this);
                        };
                    };
                    
                    this.character = function(_name){
                        genericElementProxy.call(this,'character',_name);
                    
                        Object.entries({
                            colour: {r:1,g:0,b:0,a:1},
                            x: 0,
                            y: 0,
                            angle: 0,
                            anchor: {x:0,y:0},
                            width: 10,
                            height: 10,
                            font: 'defaultThin',
                            character: '',
                            printingMode: { horizontal:'left', vertical:'bottom' },
                        }).forEach(([name,defaultValue]) => this.setupSimpleAttribute(name,defaultValue) );
                    };
                    this.characterString = function(_name){
                        genericElementProxy.call(this,'characterString',_name);
                    
                        Object.entries({
                            colour: {r:1,g:0,b:0,a:1},
                            x: 0,
                            y: 0,
                            angle: 0,
                            width: 10,
                            height: 10,
                            font: 'defaultThin',
                            string: '',
                            spacing: 0.5,
                            interCharacterSpacing: 0,
                            printingMode: { widthCalculation:'absolute', horizontal:'left', vertical:'bottom' },
                        }).forEach(([name,defaultValue]) => this.setupSimpleAttribute(name,defaultValue) );
                    
                        const cashedAttributes_presentationOnly = {
                            resultingWidth: 0, 
                        };
                        const cashedCallbacks_elementSpecific = {
                            onFontUpdateCallback:function(){},
                        };
                        this.__updateValues = function(data){
                            Object.keys(data).forEach(key => { cashedAttributes_presentationOnly[key] = data[key]; });
                        };
                        this.__runCallback = function(data){
                            Object.entries(data).forEach(([name,values]) => {
                                if(name in cashedCallbacks_elementSpecific){ cashedCallbacks_elementSpecific[name](values); }
                            });
                        };
                        this.resultingWidth = function(){
                            return cashedAttributes_presentationOnly.resultingWidth;
                        };
                    
                        const __getCallback = this.getCallback;
                        this.getCallback = function(callbackType){
                            if(callbackType in cashedCallbacks_elementSpecific){
                                return cashedCallbacks_elementSpecific[callbackType];
                            }
                            __getCallback(callbackType);
                        };
                        const __attachCallback = this.attachCallback;
                        this.attachCallback = function(callbackType, callback){
                            if(callbackType in cashedCallbacks_elementSpecific){
                                cashedCallbacks_elementSpecific[callbackType] = callback;
                                return;
                            }
                            __attachCallback(callbackType);
                        }
                        const __removeCallback = this.removeCallback;
                        this.removeCallback = function(callbackType){
                            if(callbackType in cashedCallbacks_elementSpecific){
                                delete cashedCallbacks_elementSpecific[callbackType];
                                return;
                            }
                            __removeCallback(callbackType);
                        }
                    };

                };
                
                this.go = new function(){
                    const functionList = [];
                
                    this.add = function(newFunction){ functionList.push(newFunction); };
                    this.__activate = function(){ functionList.forEach(f => f()); };
                };
                
                this.meta = new function(){
                    this.areYouReady = function(){
                        return new Promise((resolve, reject) => {
                            communicationModule.run('areYouReady',[],resolve);
                        });
                    };
                    this.refresh = function(){
                        return new Promise((resolve, reject) => {
                            communicationModule.run('refresh',[],resolve);
                        });
                    };
                    this.getElementFromId = function(id){
                        return elementRegistry[id];
                    };
                };
                
                this._dump = new function(){
                    this.elememt = function(){
                        return new Promise((resolve, reject) => {
                            communicationModule.run('_dump.element',[],resolve);
                        });
                    };
                    this.arrangement = function(){
                        return new Promise((resolve, reject) => {
                            communicationModule.run('_dump.arrangement',[],resolve);
                        });
                    };
                    this.render = function(){
                        return new Promise((resolve, reject) => {
                            communicationModule.run('_dump.render',[],resolve);
                        });
                    };
                    this.viewport = function(){
                        return new Promise((resolve, reject) => {
                            communicationModule.run('_dump.viewport',[],resolve);
                        });
                    };
                    this.callback = function(){
                        return new Promise((resolve, reject) => {
                            communicationModule.run('_dump.callback',[],resolve);
                        });
                    };
                };
                
                this.element = new function(){
                    this.getAvailableElements = function(){
                        return Object.keys(elementLibrary);
                    };
                
                    this.create = function(type,name,forceId,updateIdOnly){
                
                        if(elementLibrary[type] == undefined){
                            console.warn('interface.element.create - unknown element type "'+type+'"');
                            return;
                        }
                
                        const newElementProxy = new elementLibrary[type](name);
                        if(forceId == undefined){
                            communicationModule.run('element.create', [type,name], id => {
                                newElementProxy.__id(id);
                                elementRegistry[id] = newElementProxy;
                            });
                        }else{
                            newElementProxy.__id(forceId,updateIdOnly);
                            elementRegistry[forceId] = newElementProxy;
                        }
                        return newElementProxy;
                    };
                    this.delete = function(ele){
                        communicationModule.run('element.delete',[ele.getId()]);
                        elementRegistry[element.getId()] = undefined;
                    };
                    this.deleteAllCreated = function(){
                        communicationModule.run('element.deleteAllCreated',[]);
                        elementRegistry = [];
                    };
                
                    this.__executeMethod = function(id,attribute,argumentList,callback,transferables){
                        communicationModule.run('element.executeMethod',[id,attribute,argumentList],callback,transferables);
                    };
                };
                this.arrangement = new function(){
                    const design = self.element.create('group','root',0,true)
                
                    this.new = function(){
                        communicationModule.run('arrangement.new');
                        design.clear();
                        design.unifiedAttribute({
                            x: 0,
                            y: 0,
                            angle: 0,
                            scale: 1,
                            heedCamera: false,
                            // static: false,
                        });
                    };
                    this.get = function(){
                        return design;
                    };
                    this.prepend = function(element){
                        return design.prepend(element);
                    };
                    this.append = function(element){
                        return design.append(element);
                    };
                    this.remove = function(element){
                        return design.remove(element);
                    };
                    this.clear = function(){
                        return design.clear();
                    };
                    this.getElementByAddress = function(address){
                        
                        const route = address.split('/');
                        route.shift();
                
                        let currentObject = design;
                        route.forEach((a) => {
                            currentObject = currentObject.getChildByName(a);
                        });
                
                        return currentObject;
                    };
                    this.getElementsUnderPoint = function(x,y){
                        return new Promise((resolve, reject) => {
                            communicationModule.run('arrangement.getElementsUnderPoint',[x,y],results => {
                                resolve(results.map(result => elementRegistry[result]));
                            });
                        });
                    };
                    this.getElementsUnderArea = function(points){
                        return new Promise((resolve, reject) => {
                            communicationModule.run('arrangement.getElementsUnderArea',[points],results => {
                                resolve(results.map(result => elementRegistry[result]));
                            });
                        });
                    };
                    this.printTree = function(mode='spaced',local=false,includeTypes=false){
                
                        if(local){
                            function recursivePrint(grouping,prefix=''){
                                grouping.children.forEach(function(a){
                                    const data = '('+a.id + (includeTypes ? ' : '+a.type : '') +')';
                
                                    if(mode == 'spaced'){
                                        console.log(prefix+' -  '+a.name+' '+data);
                                        if(a.type == 'group'){ recursivePrint(a, prefix+' - ') }
                                    }else if(mode == 'tabular'){
                                        console.log(prefix+'\t-\t\t'+a.name+' '+data);
                                        if(a.type == 'group'){ recursivePrint(a, prefix+'\t-\t') }
                                    }else if(mode == 'address'){
                                        console.log(prefix+'/'+a.name+' '+data);
                                        if(a.type == 'group'){ recursivePrint(a, prefix+'/'+a.name) }
                                    }
                                });
                            }
                    
                            if(design.getChildren().length == 0){console.log('-empty-');}
                            console.log(design.getName()+' ('+design.getId()+')');
                            recursivePrint(design.getTree(), '');
                        }else{
                            communicationModule.run('arrangement.printTree',[mode,includeTypes]);
                        }
                    };
                    this.printSurvey = function(local=true){
                        if(local){
                            const results = {};
                
                            function recursiveSearch(grouping){
                                grouping.children.forEach(child => {
                                    results[child.type] = results[child.type] == undefined ? 1 : results[child.type]+1;
                                    if(child.type == 'group'){
                                        recursiveSearch(child)
                                    }
                                });
                            }
                
                            recursiveSearch(design.getTree());
                            return results;
                        }else{
                            return new Promise((resolve, reject) => {
                                communicationModule.run('arrangement.printSurvey',[],results => {
                                    resolve(results);
                                });
                            });
                        }
                    };
                    this.areParents = function(element,potentialParents=[]){
                        return new Promise((resolve, reject) => {
                            communicationModule.run('arrangement.areParents',[element.getId(),potentialParents.map(parent => parent.getId())],resolve);
                        });
                    };
                    this._dump = function(local=true,engine=true){
                
                        if(local){
                            console.log(design.getAddress(),'._dump()');
                            console.log(design.getAddress(),'._dump -> id: '+design.getId());
                            console.log(design.getAddress(),'._dump -> type: '+design.getType());
                            console.log(design.getAddress(),'._dump -> name: '+design.getName());
                            console.log(design.getAddress(),'._dump -> address: '+design.getAddress());
                            console.log(design.getAddress(),'._dump -> parent: ',design.parent);
                            console.log(design.getAddress(),'._dump -> ignored: '+design.ignored());
                            console.log(design.getAddress(),'._dump -> x: '+design.x());
                            console.log(design.getAddress(),'._dump -> y: '+design.y());
                            console.log(design.getAddress(),'._dump -> angle: '+design.angle());
                            console.log(design.getAddress(),'._dump -> scale: '+design.scale());
                            console.log(design.getAddress(),'._dump -> heedCamera: '+design.heedCamera());
                            // console.log(design.getAddress(),'._dump -> static: '+design.static());
                            console.log(design.getAddress(),'._dump -> children.length: '+design.getChildren().length);
                            console.log(design.getAddress(),'._dump -> children: ',design.getChildren());
                            console.log(design.getAddress(),'._dump -> clipActive: '+design.clipActive());
                        }
                        if(engine){
                            _canvas_.core.element.__executeMethod(design.getId(),'_dump',[]);
                        }
                    };
                };
                this.render = new function(){
                    const cachedValues = {
                        clearColour:{r:1,g:1,b:1,a:1},
                        frameRateLimit:30,
                        allowFrameSkipping:true,
                        active:false,
                        activeLimitToFrameRate:false,
                    };
                
                    this.refresh = function(){
                        return new Promise((resolve, reject) => {
                            communicationModule.run('render.refresh',[],resolve);
                        });
                    };
                    this.clearColour = function(colour){
                        if(colour == undefined){return cachedValues.clearColour;}
                        cachedValues.clearColour = colour;
                        return new Promise((resolve, reject) => {
                            communicationModule.run('render.clearColour',[colour],resolve);
                        });
                    };
                    this.adjustCanvasSize = function(newWidth, newHeight){
                        communicationModule.run('render.adjustCanvasSize',[newWidth, newHeight]);
                    };
                    this.getCanvasSize = function(){
                        return new Promise((resolve, reject) => {
                            communicationModule.run('render.getCanvasSize',[],resolve);
                        });
                    };
                    this.activeLimitToFrameRate = function(active){
                        if(active == undefined){return cachedValues.activeLimitToFrameRate;}
                        cachedValues.activeLimitToFrameRate = active;
                        return new Promise((resolve, reject) => {
                            communicationModule.run('render.activeLimitToFrameRate',[active],resolve);
                        });
                    };
                    this.frameRateLimit = function(rate){
                        if(rate == undefined){return cachedValues.frameRateLimit;}
                        cachedValues.frameRateLimit = rate;
                        return new Promise((resolve, reject) => {
                            communicationModule.run('render.frameRateLimit',[rate],resolve);
                        });
                    };
                    this.allowFrameSkipping = function(active){
                        if(active == undefined){return cachedValues.allowFrameSkipping;}
                        cachedValues.allowFrameSkipping = active;
                        return new Promise((resolve, reject) => {
                            communicationModule.run('render.allowFrameSkipping',[active],resolve);
                        });
                    };
                    this.fra
                    this.frame = function(){
                        communicationModule.run('render.frame',[]);
                    };
                    this.active = function(active){
                        if(active == undefined){return cachedValues.active;}
                        cachedValues.active = active;
                        return new Promise((resolve, reject) => {
                            communicationModule.run('render.active',[active],resolve);
                        });
                    };
                };

                this.viewport = new function(){
                    const cachedValues = {
                        position:{x:0,y:0},
                        scale:1,
                        angle:0,
                        stopMouseScroll:false,
                    };
                    const mouseData = { 
                        x:undefined, 
                        y:undefined, 
                    };
                
                    //adapter
                        this.adapter = new function(){
                            this.windowPoint2workspacePoint = function(x,y){
                                const position = cachedValues.position;
                                const scale = cachedValues.scale;
                                const angle = cachedValues.angle;
                
                                let tmp = {x:x, y:y};
                                tmp.x = (tmp.x - position.x)/scale;
                                tmp.y = (tmp.y - position.y)/scale;
                                tmp = _canvas_.library.math.cartesianAngleAdjust(tmp.x,tmp.y,-angle);
                
                                return tmp;
                            };
                            // this.workspacePoint2windowPoint = function(x,y){
                                // const position = cachedValues.position;
                                // const scale = cachedValues.scale;
                                // const angle = cachedValues.angle;
                
                            //     let point = _canvas_.library.math.cartesianAngleAdjust(x,y,angle);
                
                            //     return {
                            //         x: (point.x+position.x) * scale,
                            //         y: (point.y+position.y) * scale
                            //     };
                            // };
                        };
                
                    this.refresh = function(){
                        communicationModule.run('viewport.refresh',[]);
                    };
                    this.position = function(x,y){
                        if(x==undefined || y==undefined){ return cachedValues.position; }
                        cachedValues.position = {x:x,y:y};
                        return new Promise((resolve, reject) => {
                            communicationModule.run('viewport.position',[x,y],resolve);
                        });
                    };
                    this.scale = function(s){
                        if(s==undefined){ return cachedValues.scale; }
                        if(s == 0){console.error('cannot set scale to zero');}
                        cachedValues.scale = s;
                        return new Promise((resolve, reject) => {
                            communicationModule.run('viewport.scale',[s],resolve);
                        });
                    };
                    this.angle = function(a){
                        if(a==undefined){ return cachedValues.angle; }
                        cachedValues.angle = a;
                        return new Promise((resolve, reject) => {
                            communicationModule.run('viewport.angle',[a],resolve);
                        });
                    };
                    this.getElementsUnderPoint = function(x,y){
                        return new Promise((resolve, reject) => {
                            communicationModule.run('viewport.getElementsUnderPoint',[x,y],resolve);
                        });
                    };
                    this.getElementsUnderArea = function(points){
                        return new Promise((resolve, reject) => {
                            communicationModule.run('viewport.getElementsUnderArea',[points],resolve);
                        });
                    };
                    this.getMousePosition = function(x,y){
                        if(x == undefined || y == undefined){ return mouseData; }
                        mouseData.x = x;
                        mouseData.y = y;
                        communicationModule.run('viewport.getMousePosition',[x,y]);
                    };
                    this.getBoundingBox = function(){
                        return new Promise((resolve, reject) => {
                            communicationModule.run('viewport.getBoundingBox',[],resolve);
                        });
                    };
                    this.stopMouseScroll = function(bool){
                        if(bool==undefined){ return cachedValues.stopMouseScroll; }
                        cachedValues.stopMouseScroll = bool;
                        communicationModule.run('viewport.stopMouseScroll',[bool]);
                    };
                
                    this.cursor = function(type){
                        //cursor types: https://www.w3schools.com/csSref/tryit.asp?filename=trycss_cursor
                        if(type == undefined){return document.body.style.cursor;}
                        document.body.style.cursor = type;
                    };
                };
                this.stats = new function(){
                    this.active = function(active){
                        return new Promise((resolve, reject) => {
                            communicationModule.run('stats.active',[active],resolve);
                        });
                    };
                    this.getReport = function(){
                        return new Promise((resolve, reject) => {
                            communicationModule.run('stats.getReport',[],resolve);
                        });
                    };
                
                    let autoPrintActive = false;
                    let autoPrintIntervalId = undefined;
                    this.autoPrint = function(bool){
                        if(bool == undefined){ return autoPrintActive; }
                        autoPrintActive = bool;
                
                        if(autoPrintActive){
                            autoPrintIntervalId = setInterval(() => {
                                _canvas_.core.stats.getReport().then(console.log)
                            }, 500);
                        }else{
                            clearInterval(autoPrintIntervalId);
                        }
                    };
                
                    let onScreenAutoPrint_active = false;
                    let onScreenAutoPrint_intervalId = false;
                    let onScreenAutoPrint_section = undefined;
                    this.onScreenAutoPrint = function(bool){
                        if(bool == undefined){ return onScreenAutoPrint_active; }
                        onScreenAutoPrint_active = bool;
                
                        _canvas_.core.stats.active(bool);
                
                        if(onScreenAutoPrint_active){
                            onScreenAutoPrint_section = document.createElement('section');
                                onScreenAutoPrint_section.style = 'position:fixed; z-index:1; margin:0; font-family:Helvetica;';
                                document.body.prepend(onScreenAutoPrint_section);
                                
                            onScreenAutoPrint_intervalId = setInterval(() => {
                                onScreenAutoPrint_section.style.top = (window.innerHeight-onScreenAutoPrint_section.offsetHeight)+'px';
                                _canvas_.core.stats.getReport().then(data => {
                                    const position = _canvas_.core.viewport.position();
                
                                    const potentialFPS = data.secondsPerFrameOverTheLastThirtyFrames != 0 ? (1/data.secondsPerFrameOverTheLastThirtyFrames).toFixed(2) : 'infinite ';
                        
                                    onScreenAutoPrint_section.innerHTML = ''+
                                        '<p style="margin:1px"> position: x:'+ position.x + ' y:' + position.y +'</p>' +
                                        '<p style="margin:1px"> scale:'+ _canvas_.core.viewport.scale() +'</p>' +
                                        '<p style="margin:1px"> angle:'+ _canvas_.core.viewport.angle()+'</p>' +
                                        '<p style="margin:1px"> framesPerSecond: '+ data.framesPerSecond.toFixed(2) +'</p>' +
                                        '<p style="margin:1px"> secondsPerFrameOverTheLastThirtyFrames: '+ data.secondsPerFrameOverTheLastThirtyFrames.toFixed(5) +' (potentially '+ potentialFPS +'fps)</p>' +
                                        '<p style="margin:1px"> renderNonRenderSplitOverTheLastThirtyFrames: '+ data.renderNonRenderSplitOverTheLastThirtyFrames.toFixed(2) +'</p>' +
                                    '';
                                });
                            }, 100);
                        }else{
                            clearInterval(onScreenAutoPrint_intervalId);
                            if(onScreenAutoPrint_section != undefined){ onScreenAutoPrint_section.remove(); }
                            onScreenAutoPrint_section = undefined;
                        }
                    };
                };
                this.callback = new function(){
                    this.listCallbackTypes = function(){
                        return new Promise((resolve, reject) => {
                            communicationModule.run('callback.listCallbackTypes',[],resolve);
                        });
                    };
                
                    const callbackRegistry = new function(){
                        const registeredShapes = {};
                
                        this.getCallback = function(id,callbackType){
                            if(id == undefined || registeredShapes[id] == undefined || registeredShapes[id][callbackType] == undefined){return;}
                            return registeredShapes[id][callbackType];
                        };
                        this.register = function(id,callbackType,callback){
                            if(!(id in registeredShapes)){ registeredShapes[id] = {}; }
                            registeredShapes[id][callbackType] = callback;
                        };
                        this.remove = function(id,callbackType){
                            registeredShapes[id][callbackType] = undefined;
                            delete registeredShapes[id][callbackType];
                        };
                        this.call = function(id,callbackType,x,y,event){
                            if(id == undefined || registeredShapes[id] == undefined || registeredShapes[id][callbackType] == undefined){return false;}
                            registeredShapes[id][callbackType](x,y,event);
                            return true;
                        };
                    };
                    this.getCallback = function(element, callbackType){
                        callbackRegistry.getCallback(element.getId(), callbackType);
                    };
                    this.attachCallback = function(element, callbackType, callback){
                        callbackRegistry.register(element.getId(), callbackType, callback);
                        communicationModule.run('callback.attachCallback',[element.getId(),callbackType]);
                    };
                    this.removeCallback = function(element, callbackType){
                        callbackRegistry.remove(element.getId(), callbackType);
                        communicationModule.run('callback.removeCallback',[element.getId(),callbackType]);
                    };
                
                    let callbackActivationMode = 'firstMatch'; //topMostOnly / firstMatch / allMatches
                    this.callbackActivationMode = function(mode){
                        if(mode==undefined){return callbackActivationMode;}
                        callbackActivationMode = mode;
                    };
                
                    this.functions = {};
                    this.listCallbackTypes().then(callbackNames => {
                        callbackNames.forEach(callbackName => {
                            _canvas_[callbackName] = function(event){
                                let sudoEvent = {};
                                if(event instanceof KeyboardEvent){
                                    sudoEvent = {
                                        key: event.key,
                                        code: event.code,
                                        keyCode: event.keyCode,
                                        altKey: event.altKey,
                                        ctrlKey: event.ctrlKey,
                                        metaKey: event.metaKey,
                                        shiftKey: event.shiftKey,
                                    };
                                }else if(event instanceof WheelEvent){
                                    sudoEvent = { 
                                        X: event.offsetX,
                                        Y: event.offsetY,
                                        wheelDelta: event.wheelDelta,
                                        wheelDeltaX: event.wheelDeltaX,
                                        wheelDeltaY: event.wheelDeltaY,
                                        altKey: event.altKey,
                                        ctrlKey: event.ctrlKey,
                                        metaKey: event.metaKey,
                                        shiftKey: event.shiftKey,
                                    };
                                }else if(event instanceof MouseEvent){
                                    sudoEvent = { 
                                        X: event.offsetX, 
                                        Y: event.offsetY,
                                        altKey: event.altKey,
                                        ctrlKey: event.ctrlKey,
                                        metaKey: event.metaKey,
                                        shiftKey: event.shiftKey,
                                        buttons: event.buttons,
                                    };
                                    if(callbackName == 'onmousemove'){
                                        _canvas_.core.viewport.getMousePosition(sudoEvent.X,sudoEvent.Y);
                                    }
                                }else{
                                    console.warn('unknown event type: ',event);
                                }
                                
                                communicationModule.run('callback.coupling_in.'+callbackName,[sudoEvent]);
                            };
                
                            //service
                                communicationModule.function['callback.'+callbackName] = function(x,y,event,elements){
                                    if(self.callback.functions[callbackName]){
                                        self.callback.functions[callbackName](x,y,event,{
                                            all: elements.all.map(id => elementRegistry[id]),
                                            relevant: elements.relevant ? elements.relevant.map(id => elementRegistry[id]) : undefined,
                                        });
                                    }
                
                                    elements.relevant.forEach(id => callbackRegistry.call(id,callbackName,x,y,event) );
                                };
                
                        });
                    });
                };

                communicationModule.function.go = function(){
                    _canvas_.layers.registerLayerLoaded('core',_canvas_.core);
                    self.go.__activate();
                };
                communicationModule.function.printToScreen = function(imageData){
                    _canvas_.getContext("bitmaprenderer").transferFromImageBitmap(imageData);
                };
                // communicationModule.function.onViewportAdjust = function(state){
                //     console.log('onViewportAdjust -> ',state); /* callback */
                // };
                
                communicationModule.function.updateElement = function(elem, data={}){
                    const proxyElement = _canvas_.core.meta.getElementFromId(elem);
                    if(proxyElement.__updateValues != undefined){ proxyElement.__updateValues(data); }
                };
                communicationModule.function.runElementCallback = function(elem, data={}){
                    const proxyElement = _canvas_.core.meta.getElementFromId(elem);
                    if(proxyElement.__runCallback != undefined){ proxyElement.__runCallback(data); }
                };
                
                communicationModule.function.getCanvasAttributes = function(attributeNames=[],prefixActiveArray=[]){
                    return attributeNames.map((name,index) => {
                        return _canvas_.getAttribute((prefixActiveArray[index]?__canvasPrefix:'')+name);
                    });    
                };
                communicationModule.function.setCanvasAttributes = function(attributes=[],prefixActiveArray=[]){
                    attributes.map((attribute,index) => {
                        _canvas_.setAttribute((prefixActiveArray[index]?__canvasPrefix:'')+attribute.name,attribute.value);
                    });
                };
                communicationModule.function.getCanvasParentAttributes = function(attributeNames=[],prefixActiveArray=[]){
                    return attributeNames.map((name,index) => {
                        return _canvas_.parentElement[(prefixActiveArray[index]?__canvasPrefix:'')+name];
                    });
                };
                
                communicationModule.function.getDocumentAttributes = function(attributeNames=[]){
                    return attributeNames.map(attribute => {
                        return eval('document.'+attribute);
                    });
                };
                communicationModule.function.setDocumentAttributes = function(attributeNames=[],values=[]){
                    return attributeNames.map((attribute,index) => {
                        eval('document.'+attribute+' = "'+values[index]+'"');
                    });
                };
                communicationModule.function.getWindowAttributes = function(attributeNames=[]){
                    return attributeNames.map(attribute => {
                        return eval('window.'+attribute);
                    });
                };
                communicationModule.function.setWindowAttributes = function(attributes=[]){
                    attributes.map((attribute,index) => {
                        eval('window.'+attribute.name+' = "'+attribute.value+'"');
                    });
                };

            };
            _canvas_.system = new function(){
                this.versionInformation = { tick:0, lastDateModified:{y:2019,m:12,d:28} };
                this.mouseReady = false;
            
                this.go = new function(){
                    const functionList = [];
            
                    this.add = function(newFunction){ functionList.push(newFunction); };
                    this.__activate = function(){ functionList.forEach(f => f()); };
                };
            };
            _canvas_.system.mouse = new function(){
                //setup
                    const mouse = this;
                
                    this.tmp = {};
                    this.functionList = {};
                    this.functionList.onmousedown = [];
                    this.functionList.onmousemove = [];
                    this.functionList.onmouseup = [];
                    this.functionList.onmouseleave = [];
                    this.functionList.onmouseenter = [];
                    this.functionList.onwheel = [];
                    this.functionList.onclick = [];
                    this.functionList.ondblclick = [];
                
                //save the listener functions of the canvas
                    _canvas_.core.go.add( function(){
                        _canvas_.system.mouse.original = {
                            onmousemove: _canvas_.onmousemove,
                            onmouseleave: _canvas_.onmouseleave,
                            onmouseup: _canvas_.onmouseup,
                        };
                        _canvas_.system.mouseReady = true;
                    } );
                
                //utility functions
                    this.mouseInteractionHandler = function(moveCode, stopCode){
                        //replace listener code
                            //movement code
                                _canvas_.onmousemove = function(event){ 
                                    if(moveCode!=undefined){
                                        event.X = event.offsetX; event.Y = event.offsetY;
                                        const XY = _canvas_.core.viewport.adapter.windowPoint2workspacePoint(event.X,event.Y);
                                        moveCode(XY.x,XY.y,event);
                                    }
                                };
                            //stopping code
                                _canvas_.onmouseup = function(event){
                                    if(stopCode != undefined){ 
                                        event.X = event.offsetX; event.Y = event.offsetY;
                                        const XY = _canvas_.core.viewport.adapter.windowPoint2workspacePoint(event.X,event.Y);
                                        stopCode(XY.x,XY.y,event);
                                    }
                
                                    _canvas_.onmousemove = mouse.original.onmousemove;
                                    _canvas_.onmouseleave = mouse.original.onmouseleave;
                                    _canvas_.onmouseup = mouse.original.onmouseup;
                                    _canvas_.onmouseup(event);
                                };
                                _canvas_.onmouseleave = _canvas_.onmouseup;
                    };
                
                    this.forceMouseUp = function(){ _canvas_.onmouseup(); };
                
                //connect callbacks to mouse function lists
                    this.setUpCallbacks = function(){
                        [ 'onmousedown', 'onmouseup', 'onmousemove', 'onmouseenter', 'onmouseleave', 'onwheel', 'onclick', 'ondblclick', 'onmouseenterelement', 'onmouseleaveelement' ].forEach(callback => {
                            _canvas_.core.callback.functions[callback] = function(x,y,event,elementIds){
                                if(elementIds.relevant.length == 0){
                                    _canvas_.library.structure.functionListRunner( mouse.functionList[callback], _canvas_.system.keyboard.pressedKeys )({x:event.X,y:event.Y,event:event}); 
                                }
                            }
                        });
                    }
                    this.setUpCallbacks();
            };
            _canvas_.system.keyboard = new function(){
                //setup
                    const keyboard = this;
                    this.pressedKeys = {
                        control:false,
                        alt:false,
                        meta:false,
                    };
                    this.functionList = {};
                    this.functionList.onkeydown = [];
                    this.functionList.onkeyup = [];
                
                //utility functions
                    function customKeyInterpreter(event,press){
                        const pressedKeys = keyboard.pressedKeys;
                        if(event.code == 'ControlLeft' || event.code == 'ControlRight'){  pressedKeys.control = press; }
                        else if(event.code == 'AltLeft' || event.code == 'AltRight'){     pressedKeys.alt = press;     }
                        else if(event.code == 'MetaLeft' || event.code == 'MetaRight'){   pressedKeys.meta = press;    }
                        else if(event.code == 'ShiftLeft' || event.code == 'ShiftRight'){ pressedKeys.shift = press;   }
                
                        //adjustment for mac keyboards
                            if( window.navigator.platform.indexOf('Mac') != -1 ){
                                pressedKeys.option = pressedKeys.alt;
                                pressedKeys.command = pressedKeys.meta;
                            }
                    }
                    this.releaseAll = function(){
                        Object.keys(this.pressedKeys).forEach(a => keyboard.releaseKey(a))
                    };
                    this.releaseKey = function(code){
                        _canvas_.onkeyup( new KeyboardEvent('keyup',{code:code}) );
                    }
                
                //connect callbacks to keyboard function lists
                    _canvas_.core.callback.functions.onkeydown = function(x,y,event,shapes){
                        //if key is already pressed, don't press it again
                            if(keyboard.pressedKeys[event.code]){ return; }
                            keyboard.pressedKeys[event.code] = true;
                            customKeyInterpreter(event,true);
                
                        // //ESCAPE operation code
                        //     if(event.key == 'Escape'){ 
                        //         console.log('%cEscape key pressed', 'color:White; background-color: Black;'); 
                        //         keyboard.releaseAll();
                        //         _canvas_.onmouseup({offsetX:0,offsetY:0});
                        //         _canvas_.system.mouse.setUpCallbacks();
                        //     }
                        
                        //perform action
                            _canvas_.library.structure.functionListRunner( keyboard.functionList.onkeydown, keyboard.pressedKeys )({x:event.X,y:event.Y,event:event});
                    };
                
                    _canvas_.core.callback.functions.onkeyup = function(x,y,event,shapes){
                        //if key isn't pressed, don't release it
                            if(!keyboard.pressedKeys[event.code]){return;}
                            delete keyboard.pressedKeys[event.code];
                            customKeyInterpreter(event,false);
                        
                        //perform action
                            _canvas_.library.structure.functionListRunner( keyboard.functionList.onkeyup, keyboard.pressedKeys )({x:event.X,y:event.Y,event:event});
                    };
            };
            
            //add main panes to arrangement
            _canvas_.system.pane = {};
            
            _canvas_.core.go.add( function(){
                //background
                    _canvas_.system.pane.background = _canvas_.core.element.create('group','background');
                    _canvas_.system.pane.background.ignored(true);
                    _canvas_.core.arrangement.append( _canvas_.system.pane.background );
            
                //middleground
                    _canvas_.system.pane.middleground = _canvas_.core.element.create('group','middleground');
                    _canvas_.system.pane.middleground.heedCamera(true);
                    _canvas_.core.arrangement.append( _canvas_.system.pane.middleground );
                    //back
                        _canvas_.system.pane.middleground_back = _canvas_.core.element.create('group','back');
                        _canvas_.system.pane.middleground.append( _canvas_.system.pane.middleground_back );
                    //middle
                        _canvas_.system.pane.middleground_middle = _canvas_.core.element.create('group','middle');
                        _canvas_.system.pane.middleground.append( _canvas_.system.pane.middleground_middle );
                    //front
                        _canvas_.system.pane.middleground_front = _canvas_.core.element.create('group','front');
                        _canvas_.system.pane.middleground.append( _canvas_.system.pane.middleground_front );
            
                //foreground
                    _canvas_.system.pane.foreground = _canvas_.core.element.create('group','foreground');
                    _canvas_.core.arrangement.append( _canvas_.system.pane.foreground );
            
                //shortcuts
                    _canvas_.system.pane.b = _canvas_.system.pane.background;
                    _canvas_.system.pane.mb = _canvas_.system.pane.middleground_back;
                    _canvas_.system.pane.mm = _canvas_.system.pane.middleground_middle;
                    _canvas_.system.pane.mf = _canvas_.system.pane.middleground_front;
                    _canvas_.system.pane.f = _canvas_.system.pane.foreground;
            } );
            
            //utility
                _canvas_.system.pane.getMiddlegroundPane = function(element){
                    let tempElement = element;
                    while(tempElement != undefined){
                        if(tempElement == _canvas_.system.pane.mb){ return _canvas_.system.pane.mb; }
                        if(tempElement == _canvas_.system.pane.mm){ return _canvas_.system.pane.mm; }
                        if(tempElement == _canvas_.system.pane.mf){ return _canvas_.system.pane.mf; }
                        tempElement = tempElement.parent;
                    }
                };
            
            const checkingInterval = setInterval(() => {
                if(
                    _canvas_.system.pane != undefined &&
                    _canvas_.system.pane.b != undefined &&
                    _canvas_.system.pane.b.getId() != -1 &&
                    _canvas_.system.pane.mb.getId() != -1 &&
                    _canvas_.system.pane.mm.getId() != -1 &&
                    _canvas_.system.pane.mf.getId() != -1 &&
                    _canvas_.system.pane.f.getId() != -1 &&
                    _canvas_.system.mouse.original != undefined
                ){
                    clearInterval(checkingInterval);
                    _canvas_.layers.registerLayerLoaded('system',_canvas_.system);
                    _canvas_.system.go.__activate();
                }
            }, 100);
            _canvas_.interface = new function(){
                this.versionInformation = { tick:0, lastDateModified:{y:2020,m:3,d:8} };
                const interface = this;
            
                const dev = {
                    prefix:'interface',
                    channels:{
                        circuit:{       prefix:'circuit',                   active:false,   fontStyle:'color:rgb(195, 81, 172); font-style:italic;' },
                        part:{          prefix:'part',                      active:false,   fontStyle:'color:rgb(81, 178, 223); font-style:italic;' },
                        partBasic:{     prefix:'part.collection.basic',     active:false,   fontStyle:'color:rgb(229, 96, 83);  font-style:italic;' },
                        partDisplay:{   prefix:'part.collection.display',   active:false,   fontStyle:'color:rgb(99, 196, 129); font-style:italic;' },
                        partControl:{   prefix:'part.collection.control',   active:false,   fontStyle:'color:rgb(243, 194, 95); font-style:italic;' },
                        partDynamic:{   prefix:'part.collection.dynamic',   active:false,   fontStyle:'color:rgb(24, 53, 157);  font-style:italic;' },
                        unit:{          prefix:'unit',                      active:false,   fontStyle:'color:rgb(66, 145, 115); font-style:italic;' },
                    },
                    log:{},
                };
                Object.keys(dev.channels).forEach(channel => {
                    dev.log[channel]  = function(data){
                        if(!dev.channels[channel].active){return;}
                        console.log('%c'+dev.prefix+'.'+dev.channels[channel].prefix+(new Array(...arguments).join(' ')), dev.channels[channel].fontStyle );
                    }
                });
            
                this.go = new function(){
                    const functionList = [];
            
                    this.add = function(newFunction){ functionList.push(newFunction); };
                    this.__activate = function(){ functionList.forEach(f => f()); };
                };
            
                this.circuit = new function(){
                    this.rapidAmplitudeModulator = function(
                        context
                    ){
                        //flow
                            let inputOption = 'internalOscillator';
                            //flow chain
                                const flow = {
                                    signalToModulate:{},
                    
                                    modulatingSignal:{},
                                    internalOscillator:{},
                                    amplitudeControlledModulator:{},
                    
                                    out:{},
                                };
                    
                            //signalToModulate
                                flow.signalToModulate.gain = 1;
                                flow.signalToModulate.node = context.createGain();
                                _canvas_.library.audio.changeAudioParam(context,flow.signalToModulate.node.gain, flow.signalToModulate.gain, 0.01, 'instant', true);
                            //modulatingSignal
                                flow.modulatingSignal.gain = 1;
                                flow.modulatingSignal.node = context.createGain();
                                _canvas_.library.audio.changeAudioParam(context,flow.modulatingSignal.node.gain, flow.modulatingSignal.gain, 0.01, 'instant', true);
                            //internalOscillator
                                flow.internalOscillator.frequency = 1;
                                flow.internalOscillator.type = 'sine'; 
                                flow.internalOscillator.node = context.createOscillator();
                                flow.internalOscillator.node.frequency.setTargetAtTime(flow.internalOscillator.frequency, _canvas_.library.audio.context.currentTime, 0);
                                flow.internalOscillator.node.type = flow.internalOscillator.type; 
                                flow.internalOscillator.node.start();
                            //amplitudeControlledModulator
                                flow.amplitudeControlledModulator.node = context.createAmplitudeControlledModulator();
                            //out
                                flow.out.gain = 1;
                                flow.out.node = context.createGain();
                                _canvas_.library.audio.changeAudioParam(context,flow.out.node.gain, flow.out.gain, 0.01, 'instant', true);
                    
                            //do connections
                                flow.signalToModulate.node.connect(flow.amplitudeControlledModulator.node, undefined, 0);
                                flow.internalOscillator.node.connect(flow.amplitudeControlledModulator.node, undefined, 1);
                                flow.amplitudeControlledModulator.node.connect(flow.out.node);
                    
                        //input/output node
                            this.signalToModulate = function(){
                                return flow.signalToModulate.node;
                            };
                            this.modulatingSignal = function(){
                                return flow.modulatingSignal.node;
                            };
                            this.out = function(){
                                return flow.out.node;
                            };
                    
                        //controls
                            this.frequency = function(a,transitionTime=0){
                                if(a == undefined){ return flow.internalOscillator.frequency; }
                                flow.internalOscillator.frequency = a;
                                flow.internalOscillator.node.frequency.linearRampToValueAtTime(flow.internalOscillator.frequency, _canvas_.library.audio.context.currentTime+transitionTime);
                            };
                            this.waveType = function(a){
                                if(a == undefined){ return flow.internalOscillator.type; }
                                if(a == 'custom'){
                                    if(inputOption == 'internalOscillator'){
                                        flow.internalOscillator.node.disconnect(flow.amplitudeControlledModulator.node, undefined, 1);
                                        flow.modulatingSignal.node.connect(flow.amplitudeControlledModulator.node, undefined, 1);
                                        inputOption = 'internalOscillator';
                                    }
                                }else{
                                    if(inputOption == 'modulatingSignal'){
                                        flow.modulatingSignal.node.disconnect(flow.amplitudeControlledModulator.node, undefined, 1);
                                        flow.internalOscillator.node.connect(flow.amplitudeControlledModulator.node, undefined, 1);
                                        inputOption = 'modulatingSignal';
                                    }
                                    flow.internalOscillator.type = a;
                                    flow.internalOscillator.node.type = flow.internalOscillator.type; 
                                }
                            };
                    
                    };
                    this.audio2percentage = function(){
                        return new function(){
                            const analyser = {
                                timeDomainDataArray: null,
                                frequencyData: null,
                                refreshRate: 30,
                                refreshInterval: null,
                                returnedValueLimits: {min:0, max: 256, halfdiff:128},
                                resolution: 128
                            };
                            analyser.analyserNode = _canvas_.library.audio.context.createAnalyser();
                            analyser.analyserNode.fftSize = analyser.resolution;
                            analyser.timeDomainDataArray = new Uint8Array(analyser.analyserNode.fftSize);
                            analyser.frequencyData = new Uint8Array(analyser.analyserNode.fftSize);
                    
                            this.__render = function(){
                                    analyser.analyserNode.getByteTimeDomainData(analyser.timeDomainDataArray);
                    
                                    const numbers = [];
                                    for(let a = 0; a < analyser.timeDomainDataArray.length; a++){
                                        numbers.push(
                                            analyser.timeDomainDataArray[a]/analyser.returnedValueLimits.halfdiff - 1
                                        );
                                    }
                    
                                    let val = 0;
                                    numbers.forEach(function(item){ if(Math.abs(item) > val){val = Math.abs(item);} });
                    
                                    this.newValue(val);
                            }
                    
                            //audio connections
                                this.audioIn = function(){return analyser.analyserNode;};
                    
                            //methods
                                this.start = function(){
                                    analyser.refreshInterval = setInterval( function(that){ that.__render(); }, 1000/30, this );
                                };
                                this.stop = function(){
                                    clearInterval(analyser.refreshInterval);
                                };
                    
                            //callbacks
                                this.newValue = function(a){};
                        };
                    };
                    //replacement for prior synthesizer; this system uses the custom oscillators and implements an ADSR envelope
                    //  oscillators generated on demand
                    //  conservative use of oscillators
                    //  use of custom oscillator with duty cycle
                    //  use of custom oscillator audio worklet (which has ADSR envelope built in for gain, detune and dutyCycle)
                    //  gainWobble provided by internal LFO, or external input
                    //  detuneWobble provided by internal LFO, or external input
                    //  dutyCycleWobble provided by internal LFO, or external input
                    
                    this.synthesizer_3 = function(
                        context,
                        waveType='sine',
                        gain={
                            envelope:{
                                front:[ {destination:1, elapse:0} ],
                                back:[ {destination:0, elapse:0} ],
                            },
                            mode:'manual',
                            manual:{value:1},
                            internalLFO:{depth:0, period:1, periodMin:0.01, periodMax:1},
                        },
                        octave=0,
                        detune={
                            envelope:{
                                front:[ {destination:1, elapse:0} ],
                                back:[ {destination:0, elapse:0} ],
                            },
                            mode:'manual',
                            manual:{value:0},
                            internalLFO:{depth:0, period:1, periodMin:0.01, periodMax:1},
                        },
                        dutyCycle={
                            envelope:{
                                front:[ {destination:1, elapse:0} ],
                                back:[ {destination:0, elapse:0} ],
                            },
                            mode:'manual',
                            manual:{value:0.5},
                            internalLFO:{depth:0, period:1, periodMin:0.01, periodMax:1},
                        },
                    ){    
                        //flow
                            const flow = {
                                controlIn:{
                                    gain: new _canvas_.library.audio.audioWorklet.nothing(context),
                                    detune: new _canvas_.library.audio.audioWorklet.nothing(context),
                                    dutyCycle: new _canvas_.library.audio.audioWorklet.nothing(context),
                                },
                    
                                LFO:{
                                    gain:{
                                        oscillator: new _canvas_.library.audio.audioWorklet.oscillator2(context),
                                        amplitudeModifier: new _canvas_.library.audio.audioWorklet.amplitudeModifier(context),
                                    },
                                    detune:{
                                        oscillator: new _canvas_.library.audio.audioWorklet.oscillator2(context),
                                    },
                                    dutyCycle:{
                                        oscillator: new _canvas_.library.audio.audioWorklet.oscillator2(context),
                                        amplitudeModifier: new _canvas_.library.audio.audioWorklet.amplitudeModifier(context),
                                    },
                                },
                    
                                controlMix:{
                                    gain: new _canvas_.library.audio.audioWorklet.streamAdder(context),
                                    detune: new _canvas_.library.audio.audioWorklet.streamAdder(context),
                                    dutyCycle: new _canvas_.library.audio.audioWorklet.streamAdder(context),
                                },
                    
                                oscillators: [],
                                aggregator: new _canvas_.library.audio.audioWorklet.nothing(context),
                            };
                    
                            flow.LFO.gain.oscillator.frequency.setTargetAtTime(1/gain.internalLFO.period, context.currentTime, 0);
                            flow.LFO.gain.oscillator.gain.setTargetAtTime(gain.internalLFO.depth, context.currentTime, 0);
                            flow.LFO.gain.oscillator.connect(flow.LFO.gain.amplitudeModifier);
                            flow.LFO.gain.amplitudeModifier.divisor.setTargetAtTime(2, context.currentTime, 0);
                            flow.LFO.gain.amplitudeModifier.offset.setTargetAtTime(1 - gain.internalLFO.depth/2, context.currentTime, 0);
                            flow.LFO.gain.amplitudeModifier.connect(flow.controlMix.gain,undefined,0);
                    
                            flow.LFO.detune.oscillator.frequency.setTargetAtTime(1/detune.internalLFO.period, context.currentTime, 0);
                            flow.LFO.detune.oscillator.gain.setTargetAtTime(detune.internalLFO.depth, context.currentTime, 0);
                            flow.LFO.detune.oscillator.connect(flow.controlMix.detune,undefined,0);
                    
                            flow.LFO.dutyCycle.oscillator.frequency.setTargetAtTime(1/dutyCycle.internalLFO.period, context.currentTime, 0);
                            flow.LFO.dutyCycle.oscillator.gain.setTargetAtTime(dutyCycle.internalLFO.depth, context.currentTime, 0);
                            flow.LFO.dutyCycle.oscillator.connect(flow.LFO.dutyCycle.amplitudeModifier);
                            flow.LFO.dutyCycle.amplitudeModifier.divisor.setTargetAtTime(2, context.currentTime, 0);
                            flow.LFO.dutyCycle.amplitudeModifier.offset.setTargetAtTime(0.5, context.currentTime, 0);
                            flow.LFO.dutyCycle.amplitudeModifier.connect(flow.controlMix.dutyCycle,undefined,0);
                    
                            flow.controlIn.gain.connect(flow.controlMix.gain,undefined,1);
                            flow.controlIn.detune.connect(flow.controlMix.detune,undefined,1);
                            flow.controlIn.dutyCycle.connect(flow.controlMix.dutyCycle,undefined,1);
                    
                        //io
                            this.control = new function(){
                                this.gain = function(){
                                    return flow.controlIn.gain;
                                };
                                this.detune = function(){
                                    return flow.controlIn.detune;
                                };
                                this.dutyCycle = function(){
                                    return flow.controlIn.dutyCycle;
                                };
                            };
                            this.out = function(){
                                return flow.aggregator;
                            }
                    
                        //controls
                            this._dump = function(){
                                console.log('flow',flow);
                                console.log('waveType', waveType);
                                console.log('gain', gain);
                                console.log('octave', octave);
                                console.log('detune', detune);
                                console.log('dutyCycle', dutyCycle);
                            };
                    
                            this.perform = function(note){
                                //find the oscillator for this note (if there is one)
                                    const oscillator = flow.oscillators.filter(oscillator => oscillator.noteNumber == note.num )[0];
                    
                                    if( oscillator != undefined && note.velocity == 0 ){ 
                                    //tone stopping
                                        oscillator.stop();
                                    }else if( oscillator != undefined ){
                                    //tone velocity adjustment
                                        _canvas_.library.audio.changeAudioParam(context, oscillator.gain.gain, note.velocity, 0, 'instant');
                                    }else if( oscillator == undefined && note.velocity == 0 ){ 
                                    //don't do anything
                                    }else{
                                    //fresh tone
                                        //get free oscillators
                                            const freeOscillators = flow.oscillators.filter(oscillator => oscillator.noteNumber == undefined);
                                            
                                        //maintain oscillator pool
                                            if( freeOscillators.length < 1 ){
                                                const tmpOSC = new _canvas_.library.audio.audioWorklet.oscillator2(context);
                                                tmpOSC.connect(flow.aggregator);
                                                tmpOSC.waveform = waveType;
                    
                                                tmpOSC.gain_envelope = gain.envelope;
                                                tmpOSC.detune_envelope = detune.envelope;
                                                tmpOSC.dutyCycle_envelope = dutyCycle.envelope;
                    
                                                tmpOSC.detune.setTargetAtTime(detune.manual.value, context.currentTime, 0);
                                                tmpOSC.dutyCycle.setTargetAtTime(dutyCycle.manual.value, context.currentTime, 0);
                    
                                                tmpOSC.gain_useControl = gain.mode != 'manual';
                                                tmpOSC.detune_useControl = detune.mode != 'manual';
                                                tmpOSC.dutyCycle_useControl = dutyCycle.mode != 'manual';
                    
                                                flow.controlMix.gain.connect(tmpOSC,undefined,0);
                                                flow.controlMix.detune.connect(tmpOSC,undefined,1);
                                                flow.controlMix.dutyCycle.connect(tmpOSC,undefined,2);
                    
                                                flow.oscillators.push(tmpOSC);
                                            }
                    
                                        //select oscillator
                                            const freshOscillator = freeOscillators.length == 0;
                                            const oscillatorToUse = freshOscillator ? flow.oscillators[flow.oscillators.length-1] : freeOscillators[0];
                    
                                        //activate oscillator
                                            oscillatorToUse.frequency.setTargetAtTime(_canvas_.library.audio.num2freq(note.num+12*octave), context.currentTime, 0);
                                            oscillatorToUse.noteNumber = note.num;
                                            oscillatorToUse.onEnvelopeEvent = function(event){
                                                if(event == 'off'){
                                                    oscillatorToUse.noteNumber = undefined;
                                                }
                                            };
                                            oscillatorToUse.start();
                                    }
                            };
                            this.panic = function(){
                                flow.oscillators.map(a => a.noteNumber).forEach(a => {
                                    this.perform({num:a,velocity:0});
                                });
                            };
                    
                            this.waveform = function(type){
                                if(type == undefined){return waveType;}
                                waveType = type;
                    
                                flow.oscillators.forEach(oscillator => {
                                    oscillator.waveform = waveType;
                                });
                            };
                            this.octave = function(target){
                                if(target == null){return octave;}
                                octave = target;
                                flow.oscillators.forEach(oscillator => {
                                    if(oscillator.noteNumber == undefined){return;}
                                    oscillator.frequency.setTargetAtTime(_canvas_.library.audio.num2freq(oscillator.noteNumber+12*octave), context.currentTime, 0);
                                });
                            };
                            this.detune = function(target){
                                if(target == null){return detune;}
                                detune = target;
                                flow.oscillators.forEach(oscillator => {
                                    oscillator.detune.setTargetAtTime(target, context.currentTime, 0);
                                });
                            };
                            this.dutyCycle = function(target){
                                if(target == null){return detune;}
                                dutyCycle = target;
                                flow.oscillators.forEach(oscillator => {
                                    oscillator.dutyCycle.setTargetAtTime(target, context.currentTime, 0);
                                });
                            };
                    
                            this.gain = new function(){
                                this.envelope = function(newEnvelope){
                                    if(newEnvelope == null){return envelope;}
                                    gain.envelope = newEnvelope;
                                    flow.oscillators.forEach(oscillator => {
                                        oscillator.gain_envelope = gain.envelope;
                                    });
                                };
                                this.mode = function(mode){ // manual / internalLFO / external
                                    if(mode == null){return gain.mode; }
                                    gain.mode = mode;
                    
                                    switch(mode){
                                        case 'manual': 
                                            flow.LFO.gain.oscillator.stop();
                                            flow.oscillators.forEach(oscillator => {
                                                oscillator.gain_useControl = false;
                                            });
                                        break;
                                        case 'internalLFO':
                                            flow.LFO.gain.oscillator.start();
                                            flow.oscillators.forEach(oscillator => {
                                                oscillator.gain_useControl = true;
                                            });
                    
                                            flow.controlMix.gain.mix.setTargetAtTime(0, context.currentTime, 0);
                                            flow.controlMix.detune.mix.setTargetAtTime(0, context.currentTime, 0);
                                            flow.controlMix.dutyCycle.mix.setTargetAtTime(0, context.currentTime, 0);
                                        break;
                                        case 'external':
                                            flow.LFO.gain.oscillator.stop();
                                            flow.oscillators.forEach(oscillator => {
                                                oscillator.gain_useControl = true;
                                            });
                    
                                            flow.controlMix.gain.mix.setTargetAtTime(1, context.currentTime, 0);
                                            flow.controlMix.detune.mix.setTargetAtTime(1, context.currentTime, 0);
                                            flow.controlMix.dutyCycle.mix.setTargetAtTime(1, context.currentTime, 0);
                                        break;
                                    }
                                };
                                this.value = function(value){
                                    if(value == null){ return gain.manual.value; }
                                    gain.manual.value = value;
                                    flow.oscillators.forEach(oscillator => {
                                        oscillator.gain.setTargetAtTime(gain.manual.value, context.currentTime, 0);
                                    });    
                                };
                                this.internalLFO = new function(){
                                    this.depth = function(value){
                                        if(value == null){return gain.internalLFO.depth; }
                                        if(value < 0){ value = 0; }
                                        else if(value > 1){ value = 1; }
                                        gain.internalLFO.depth = value;
                                        flow.LFO.gain.oscillator.gain.setTargetAtTime(gain.internalLFO.depth, context.currentTime, 0);
                                        flow.LFO.gain.amplitudeModifier.offset.setTargetAtTime(1 - gain.internalLFO.depth/2, context.currentTime, 0);
                                    };
                                    this.period = function(value){
                                        if(value == null){ return gain.internalLFO.period; }
                                        if(value < gain.internalLFO.periodMin){ value = gain.internalLFO.periodMin; }
                                        else if(value > gain.internalLFO.periodMax){ value = gain.internalLFO.periodMax; }
                                        gain.internalLFO.period = value;
                                        flow.LFO.gain.oscillator.frequency.setTargetAtTime(1/gain.internalLFO.period, context.currentTime, 0);
                                    };
                                };
                            };
                            this.detune = new function(){
                                this.envelope = function(newEnvelope){
                                    if(newEnvelope == null){return envelope;}
                                    detune.envelope = newEnvelope;
                                    flow.oscillators.forEach(oscillator => {
                                        oscillator.detune_envelope = detune.envelope;
                                    });
                                };
                                this.mode = function(mode){ // manual / internalLFO / external
                                    if(mode == null){return detune.mode; }
                                    detune.mode = mode;
                    
                                    switch(mode){
                                        case 'manual': 
                                            flow.LFO.detune.oscillator.stop();
                                            flow.oscillators.forEach(oscillator => {
                                                oscillator.detune_useControl = false;
                                            });
                                        break;
                                        case 'internalLFO':
                                            flow.LFO.detune.oscillator.start();
                                            flow.oscillators.forEach(oscillator => {
                                                oscillator.detune_useControl = true;
                                            });    
                                        break;
                                        case 'external':
                                            flow.LFO.detune.oscillator.stop();
                                            flow.oscillators.forEach(oscillator => {
                                                oscillator.detune_useControl = true;
                                            });    
                                        break;
                                    }
                                };
                                this.value = function(value){
                                    if(value == null){ return detune.manual.value; }
                                    detune.manual.value = value;
                                    flow.oscillators.forEach(oscillator => {
                                        oscillator.detune.setTargetAtTime(detune.manual.value, context.currentTime, 0);
                                    });    
                                };
                                this.internalLFO = new function(){
                                    this.depth = function(value){
                                        if(value == null){return detune.internalLFO.depth; }
                                        if(value < 0){ value = 0; }
                                        else if(value > 1){ value = 1; }
                                        detune.internalLFO.depth = value;
                                        flow.LFO.detune.oscillator.gain.setTargetAtTime(detune.internalLFO.depth, context.currentTime, 0);
                                    };
                                    this.period = function(value){
                                        if(value == null){ return detune.internalLFO.period; }
                                        if(value < detune.internalLFO.periodMin){ value = detune.internalLFO.periodMin; }
                                        else if(value > detune.internalLFO.periodMax){ value = detune.internalLFO.periodMax; }
                                        detune.internalLFO.period = value;
                                        flow.LFO.detune.oscillator.frequency.setTargetAtTime(1/detune.internalLFO.period, context.currentTime, 0);
                                    };
                                };
                            };
                            this.dutyCycle = new function(){
                                this.envelope = function(newEnvelope){
                                    if(newEnvelope == null){return envelope;}
                                    dutyCycle.envelope = newEnvelope;
                                    flow.oscillators.forEach(oscillator => {
                                        oscillator.dutyCycle_envelope = dutyCycle.envelope;
                                    });
                                };
                                this.mode = function(mode){ // manual / internalLFO / external
                                    if(mode == null){return dutyCycle.mode; }
                                    dutyCycle.mode = mode;
                    
                                    switch(mode){
                                        case 'manual': 
                                            flow.LFO.dutyCycle.oscillator.stop();
                                            flow.oscillators.forEach(oscillator => {
                                                oscillator.dutyCycle_useControl = false;
                                            });
                                        break;
                                        case 'internalLFO':
                                            flow.LFO.gain.oscillator.start();
                                            flow.oscillators.forEach(oscillator => {
                                                oscillator.dutyCycle_useControl = true;
                                            });    
                                        break;
                                        case 'external':
                                            flow.LFO.gain.oscillator.stop();
                                            flow.oscillators.forEach(oscillator => {
                                                oscillator.dutyCycle_useControl = true;
                                            });    
                                        break;
                                    }
                                };
                                this.value = function(value){
                                    if(value == null){ return dutyCycle.manual.value; }
                                    dutyCycle.manual.value = value;
                                    flow.oscillators.forEach(oscillator => {
                                        oscillator.dutyCycle.setTargetAtTime(dutyCycle.manual.value, context.currentTime, 0);
                                    });    
                                };
                                this.internalLFO = new function(){
                                    this.depth = function(value){
                                        if(value == null){return dutyCycle.internalLFO.depth; }
                                        if(value < 0){ value = 0; }
                                        else if(value > 1){ value = 1; }
                                        dutyCycle.internalLFO.depth = value;
                                        flow.LFO.dutyCycle.oscillator.gain.setTargetAtTime(dutyCycle.internalLFO.depth, context.currentTime, 0);
                                        flow.LFO.dutyCycle.amplitudeModifier.offset.setTargetAtTime(1 - dutyCycle.internalLFO.depth/2, context.currentTime, 0);
                                    };
                                    this.period = function(value){
                                        if(value == null){ return dutyCycle.internalLFO.period; }
                                        if(value < dutyCycle.internalLFO.periodMin){ value = dutyCycle.internalLFO.periodMin; }
                                        else if(value > dutyCycle.internalLFO.periodMax){ value = dutyCycle.internalLFO.periodMax; }
                                        dutyCycle.internalLFO.period = value;
                                        flow.LFO.dutyCycle.oscillator.frequency.setTargetAtTime(1/dutyCycle.internalLFO.period, context.currentTime, 0);
                                    };
                                };
                            };
                    };
                    //replacement for prior synthesizer; this system reuses oscillators
                    //  oscillators generated on demand
                    //  conservitive use of oscillators
                    //  gainWobble provided by internal LFO
                    //  detuneWobble not implemented
                    
                    this.synthesizer = function(
                        context,
                        waveType='sine', periodicWave={'sin':[0,1,0], 'cos':[0,0,1]}, 
                        gain=1, octave=0, detune=0,
                        attack={time:0.01, curve:'linear'}, release={time:0.05, curve:'linear'},
                        gainWobble={depth:0, period:1, periodMin:0.01, periodMax:1},
                        detuneWobble={depth:0, period:1, periodMin:0.01, periodMax:1},
                    ){
                        function createOscillator(){
                            const data = {
                                oscillator: context.createOscillator(),
                                gain: context.createGain(),
                                // active: false,
                            };
                    
                            data.oscillator.connect(data.gain);
                            data.oscillator.start(0);
                            _canvas_.library.audio.changeAudioParam(context, data.gain.gain, 0, 0, 'instant');
                            return data;
                        }
                    
                        //flow chain
                            const flow = {
                                oscillators: [],
                                aggregator: {},
                                LFO: {},
                                amplitudeModifier: {},
                                gain: {},
                            };
                    
                        //flow
                            flow.oscillators[0] = createOscillator();
                    
                            flow.aggregator.node = context.createGain();    
                            flow.aggregator.node.gain.setTargetAtTime(gain, context.currentTime, 0);
                            flow.oscillators[0].gain.connect(flow.aggregator.node);
                    
                            flow.LFO = {
                                oscillator: context.createOscillator(),
                                gain: context.createGain(),
                            };
                            flow.LFO.oscillator.start(0);
                            flow.LFO.oscillator.frequency.setTargetAtTime(1/gainWobble.period, context.currentTime, 0);
                            flow.LFO.gain.gain.setTargetAtTime(gainWobble.depth, context.currentTime, 0);
                            flow.LFO.oscillator.connect(flow.LFO.gain);
                    
                            flow.amplitudeModifier = new _canvas_.library.audio.audioWorklet.amplitudeModifier(_canvas_.library.audio.context);
                            flow.LFO.gain.connect(flow.amplitudeModifier);
                            flow.amplitudeModifier.divisor.setTargetAtTime(2, context.currentTime, 0);
                            flow.amplitudeModifier.offset.setTargetAtTime(1 - gainWobble.depth/2, context.currentTime, 0);
                    
                            flow.gain.node = new _canvas_.library.audio.audioWorklet.gain(_canvas_.library.audio.context);
                            flow.aggregator.node.connect(flow.gain.node,undefined,0);
                            flow.amplitudeModifier.connect(flow.gain.node,undefined,1);
                    
                        //output node
                            this.out = function(){
                                return flow.gain.node;
                            }
                        
                        //controls
                            this.perform = function(note){
                                //find the oscillator for this note (if there is one)
                                    const oscillator = flow.oscillators.filter(oscillator => oscillator.noteNumber == note.num && oscillator.stoppingTimeout == undefined )[0];
                    
                                    if( oscillator != undefined && note.velocity == 0 ){ 
                                    //tone stopping
                                        _canvas_.library.audio.changeAudioParam(context, oscillator.gain.gain, 0, release.time, release.curve);
                                        oscillator.stoppingTimeout = setTimeout(function(){
                                            oscillator.noteNumber = undefined;
                                            oscillator.stoppingTimeout = undefined;
                                        }, release.time*1000);
                                    }else if( oscillator != undefined ){
                                    //tone velocity adjustment
                                        _canvas_.library.audio.changeAudioParam(context, oscillator.gain.gain, note.velocity, 0, 'instant');
                                    }else if( oscillator == undefined && note.velocity == 0 ){ 
                                    //don't do anything
                                    }else{
                                    //fresh tone
                                        //get free oscillators
                                            const freeOscillators = flow.oscillators.filter(oscillator => oscillator.noteNumber == undefined);
                                            
                                        //maintain oscillator pool
                                            if( freeOscillators.length < 1 ){
                                                const tmpOSC = createOscillator();
                                                tmpOSC.gain.connect(flow.aggregator.node);
                                                flow.oscillators.push(tmpOSC);
                                            }
                    
                                        //select oscillator
                                            const freshOscillator = freeOscillators.length == 0;
                                            const oscillatorToUse = freshOscillator ? flow.oscillators[flow.oscillators.length-1] : freeOscillators[0];
                    
                                        //activate oscillator
                                            if(waveType == 'custom'){
                                                oscillatorToUse.oscillator.setPeriodicWave(
                                                    context.createPeriodicWave(new Float32Array(periodicWave.cos),new Float32Array(periodicWave.sin))
                                                );
                                            }else{
                                                oscillatorToUse.oscillator.type = waveType;
                                            }
                                            oscillatorToUse.oscillator.frequency.setTargetAtTime(_canvas_.library.audio.num2freq(note.num+12*octave), context.currentTime, 0);
                                            oscillatorToUse.noteNumber = note.num;
                                            oscillatorToUse.oscillator.detune.setTargetAtTime(detune, context.currentTime, 0);
                                            _canvas_.library.audio.changeAudioParam(context, oscillatorToUse.gain.gain, note.velocity, attack.time, attack.curve, !freshOscillator);
                                    }
                            };
                            this.panic = function(){
                                flow.oscillators.map(a => a.noteNumber).forEach(a => {
                                    this.perform({num:a,velocity:0});
                                });
                            };
                            this.waveType = function(type,periodicWaveData){
                                if(type == undefined && periodicWaveData == undefined){return { type:waveType, periodicWave:periodicWaveData };}
                    
                                if(type != undefined){
                                    waveType = type;
                                }
                                if(periodicWaveData != undefined){
                                    periodicWave = periodicWaveData;
                                }
                    
                                if(type == 'custom'){
                                    flow.oscillators.forEach(oscillator => {
                                        oscillator.oscillator.setPeriodicWave(
                                            context.createPeriodicWave(new Float32Array(periodicWave.cos),new Float32Array(periodicWave.sin))
                                        );
                                    });
                                }else{
                                    flow.oscillators.forEach(oscillator => {
                                        oscillator.oscillator.type = waveType;
                                    });
                                }
                            };
                            this.gain = function(target){
                                flow.aggregator.node.gain.setTargetAtTime(target, context.currentTime, 0);
                            };
                            this.octave = function(o){
                                if(o == null){return octave;}
                                octave = o;
                                flow.oscillators.forEach(oscillator => {
                                    if(oscillator.noteNumber == undefined){return;}
                                    oscillator.oscillator.frequency.setTargetAtTime(_canvas_.library.audio.num2freq(oscillator.noteNumber+12*octave), context.currentTime, 0);
                                });
                            };
                            this.detune = function(target){
                                if(target == null){return detune;}
                                detune = target;
                                flow.oscillators.forEach(oscillator => {
                                    oscillator.oscillator.detune.setTargetAtTime(target, context.currentTime, 0);
                                });
                            };
                            this.attack = function(time,curve){
                                if( time == undefined && curve == undefined ){ return {time:attack.time, curve:attack.curve}; }
                                if(time != undefined){ attack.time = time; }
                                if(curve != undefined){ attack.curve = curve; }
                            };
                            this.release = function(time,curve){
                                if( time == undefined && curve == undefined ){ return {time:release.time, curve:release.curve}; }
                                if(time != undefined){ release.time = time; }
                                if(curve != undefined){ release.curve = curve; }
                            };
                    
                            this.gainWobbleDepth = function(value){
                                if(value == null){return gainWobble.depth; }
                                if(value < 0){ value = 0; }
                                else if(value > 1){ value = 1; }
                                gainWobble.depth = value;
                                flow.LFO.gain.gain.setTargetAtTime(value, context.currentTime, 0);
                                flow.amplitudeModifier.offset.setTargetAtTime(1 - gainWobble.depth/2, context.currentTime, 0);
                            };
                            this.gainWobblePeriod = function(value){
                                if(value == null){return gainWobble.period; }
                                if(value < gainWobble.periodMin){ value = gainWobble.periodMin; }
                                else if(value > gainWobble.periodMax){ value = gainWobble.periodMax; }
                                gainWobble.period = value;
                                flow.LFO.oscillator.frequency.setTargetAtTime(1/value, context.currentTime, 0);
                            };
                            this.detuneWobbleDepth = function(value){
                                if(value == null){return detuneWobble.depth; }
                                if(value < 0){ value = 0; }
                                else if(value > 1){ value = 1; }
                                detuneWobble.depth = value;
                                // to do //
                            };
                            this.detuneWobblePeriod = function(value){
                                if(value == null){return detuneWobble.period; }
                                if(value < detuneWobble.periodMin){ value = detuneWobble.periodMin; }
                                else if(value > detuneWobble.periodMax){ value = detuneWobble.periodMax; }
                                detuneWobble.period = value;
                                // to do //
                            };
                    
                            this._dump = function(){
                                console.log( 'waveType:',waveType );
                                console.log( 'gain:',gain );
                                console.log( 'octave:',octave );
                                console.log( 'detune:',detune );
                                console.log( 'attack:',attack );
                                console.log( 'release:',release );
                                flow.oscillators.forEach((oscillator,index) => {
                                    console.log( 'flow.oscillators['+index+']', oscillator );
                                });
                                console.log( 'flow.aggregator:', flow.aggregator );
                            };
                    };
                    //  oscillators generated on demand
                    
                    // this.synthesizer = function(
                    //     context,
                    //     waveType='sine', periodicWave={'sin':[0,1], 'cos':[0,0]}, 
                    //     gain=1, gainWobbleDepth=0, gainWobblePeriod=0, gainWobbleMin=0.01, gainWobbleMax=1,
                    //     attack={time:0.01, curve:'linear'}, release={time:0.05, curve:'linear'},
                    //     octave=0,
                    //     detune=0, detuneWobbleDepth=0, detuneWobblePeriod=0, detuneWobbleMin=0.01, detuneWobbleMax=1
                    // ){
                    //     //flow chain
                    //         const flow = {
                    //             OSCmaker:{},
                    //             liveOscillators: {},
                    //             wobbler_detune: {},
                    //             aggregator: {},
                    //             wobbler_gain: {},
                    //             mainOut: {}
                    //         };
                    
                    
                    //         flow.OSCmaker.waveType = waveType;
                    //         flow.OSCmaker.periodicWave = periodicWave;
                    //         flow.OSCmaker.attack = attack;
                    //         flow.OSCmaker.release = release;
                    //         flow.OSCmaker.octave  = octave;
                    //         flow.OSCmaker.detune  = detune;
                    //         flow.OSCmaker.func = function(
                    //             context, connection, midinumber,
                    //             type, periodicWave, 
                    //             gain, attack, release,
                    //             detune, octave
                    //         ){
                    //             return new function(){
                    //                 this.generator = context.createOscillator();
                    //                     if(type == 'custom'){ 
                    //                         this.generator.setPeriodicWave(
                    //                             context.createPeriodicWave(new Float32Array(periodicWave.cos),new Float32Array(periodicWave.sin))
                    //                         ); 
                    //                     }else{ this.generator.type = type; }
                    //                     this.generator.frequency.setTargetAtTime(_canvas_.library.audio.num2freq(midinumber+12*octave), context.currentTime, 0);
                    //                     this.generator.detune.setTargetAtTime(detune, context.currentTime, 0);
                    //                     this.generator.start(0);
                    
                    //                 this.gain = context.createGain();
                    //                 this.generator.connect(this.gain);
                    //                 this.gain.gain.setTargetAtTime(0, context.currentTime, 0);
                    //                 _canvas_.library.audio.changeAudioParam(context,this.gain.gain, gain, attack.time, attack.curve, false);
                    //                 this.gain.connect(connection);
                    
                    //                 this.detune = function(target,time,curve){
                    //                     _canvas_.library.audio.changeAudioParam(context,this.generator.detune,target,time,curve);
                    //                 };
                    //                 this.changeVelocity = function(a){
                    //                     _canvas_.library.audio.changeAudioParam(context,this.gain.gain,a,attack.time,attack.curve);
                    //                 };
                    //                 this.stop = function(){
                    //                     _canvas_.library.audio.changeAudioParam(context,this.gain.gain,0,release.time,release.curve);
                    //                     setTimeout(function(that){
                    //                         that.gain.disconnect(); 
                    //                         that.generator.stop(); 
                    //                         that.generator.disconnect(); 
                    //                         that.gain=null; 
                    //                         that.generator=null; 
                    //                         that=null;
                    //                     }, release.time*1000, this);
                    //                 };
                    //             };
                    //         };
                    
                    
                    //         flow.wobbler_detune.depth = detuneWobbleDepth;
                    //         flow.wobbler_detune.period = detuneWobblePeriod;
                    //         flow.wobbler_detune.phase = true;
                    //         flow.wobbler_detune.wave = 's';
                    //         flow.wobbler_detune.interval = null;
                    //         flow.wobbler_detune.start = function(){
                    //             if(flow.wobbler_detune.period < detuneWobbleMin || flow.wobbler_detune.period >= detuneWobbleMax){ return; }
                    //             flow.wobbler_detune.interval = setInterval(function(){
                    //                 const OSCs = Object.keys(flow.liveOscillators);
                    //                 if(flow.wobbler_detune.phase){
                    //                     for(let b = 0; b < OSCs.length; b++){ 
                    //                         flow.liveOscillators[OSCs[b]].detune(flow.wobbler_detune.depth,0.9*flow.wobbler_detune.period,flow.wobbler_detune.wave);
                    //                     }
                    //                 }else{
                    //                     for(let b = 0; b < OSCs.length; b++){ 
                    //                         flow.liveOscillators[OSCs[b]].detune(-flow.wobbler_detune.depth,0.9*flow.wobbler_detune.period,flow.wobbler_detune.wave);
                    //                     }
                    //                 }
                    //                 flow.wobbler_detune.phase = !flow.wobbler_detune.phase;
                    //             }, 1000*flow.wobbler_detune.period);
                    //         };
                    //         flow.wobbler_detune.stop = function(){clearInterval(flow.wobbler_detune.interval);};
                    
                    
                    //         flow.aggregator.node = context.createGain();    
                    //         flow.aggregator.node.gain.setTargetAtTime(1, context.currentTime, 0);
                    
                    
                    //         flow.wobbler_gain.depth = gainWobbleDepth;
                    //         flow.wobbler_gain.period = gainWobblePeriod;
                    //         flow.wobbler_gain.phase = true;
                    //         flow.wobbler_gain.wave = 's';
                    //         flow.wobbler_gain.interval = null;
                    //         flow.wobbler_gain.start = function(){
                    //             if(flow.wobbler_gain.period < gainWobbleMin || flow.wobbler_gain.period >= gainWobbleMax){
                    //                 _canvas_.library.audio.changeAudioParam(context, flow.wobbler_gain.node.gain, 1, 0.01, flow.wobbler_gain.wave );
                    //                 return;
                    //             }
                    //             flow.wobbler_gain.interval = setInterval(function(){
                    //                 if(flow.wobbler_gain.phase){ _canvas_.library.audio.changeAudioParam(context, flow.wobbler_gain.node.gain, 1, 0.9*flow.wobbler_gain.period, flow.wobbler_gain.wave ); }
                    //                 else{                        _canvas_.library.audio.changeAudioParam(context, flow.wobbler_gain.node.gain, 1-flow.wobbler_gain.depth,  0.9*flow.wobbler_gain.period, flow.wobbler_gain.wave ); }
                    //                 flow.wobbler_gain.phase = !flow.wobbler_gain.phase;
                    //             }, 1000*flow.wobbler_gain.period);
                    //         };
                    //         flow.wobbler_gain.stop = function(){clearInterval(flow.wobbler_gain.interval);};
                    //         flow.wobbler_gain.node = context.createGain();
                    //         flow.wobbler_gain.node.gain.setTargetAtTime(1, context.currentTime, 0);
                    //         flow.aggregator.node.connect(flow.wobbler_gain.node);
                    
                            
                    //         flow.mainOut.gain = gain;
                    //         flow.mainOut.node = context.createGain();
                    //         flow.mainOut.node.gain.setTargetAtTime(gain, context.currentTime, 0);
                    //         flow.wobbler_gain.node.connect(flow.mainOut.node);
                    
                    //     //output node
                    //         this.out = function(){return flow.mainOut.node;}
                    
                    //     //controls
                    //         this.perform = function(note){
                    //             if( !flow.liveOscillators[note.num] && note.velocity == 0 ){/*trying to stop a non-existant tone*/return;}
                    //             else if( !flow.liveOscillators[note.num] && note.velocity != 0 ){ 
                    //                 //create new tone
                    //                 flow.liveOscillators[note.num] = flow.OSCmaker.func(
                    //                     context, 
                    //                     flow.aggregator.node, 
                    //                     note.num, 
                    //                     flow.OSCmaker.waveType, 
                    //                     flow.OSCmaker.periodicWave, 
                    //                     note.velocity, 
                    //                     flow.OSCmaker.attack, 
                    //                     flow.OSCmaker.release, 
                    //                     flow.OSCmaker.detune, 
                    //                     flow.OSCmaker.octave
                    //                 );
                    //             }
                    //             else if( note.velocity == 0 ){ 
                    //                 //stop and destroy tone
                    //                 flow.liveOscillators[note.num].stop();
                    //                 delete flow.liveOscillators[note.num];
                    //             }
                    //             else{
                    //                 //adjust tone
                    //                 flow.liveOscillators[note.num].changeVelocity(note.velocity);
                    //             }
                    //         };
                    //         this.panic = function(){
                    //             const OSCs = Object.keys(flow.liveOscillators);
                    //             for(let a = 0; a < OSCs.length; a++){ this.perform( {'num':OSCs[a], 'velocity':0} ); }
                    //         };
                    //         this.waveType = function(a){if(a==null){return flow.OSCmaker.waveType;}flow.OSCmaker.waveType=a;};
                    //         this.periodicWave = function(a){if(a==null){return flow.OSCmaker.periodicWave;}flow.OSCmaker.periodicWave=a;};
                    //         this.gain = function(target,time,curve){ return _canvas_.library.audio.changeAudioParam(context,flow.mainOut.node.gain,target,time,curve); };
                    //         this.attack = function(time,curve){
                    //             if(time==null&&curve==null){return flow.OSCmaker.attack;}
                    //             flow.OSCmaker.attack.time = time ? time : flow.OSCmaker.attack.time;
                    //             flow.OSCmaker.attack.curve = curve ? curve : flow.OSCmaker.attack.curve;
                    //         };
                    //         this.release = function(time,curve){
                    //             if(time==null&&curve==null){return flow.OSCmaker.release;}
                    //             flow.OSCmaker.release.time = time ? time : flow.OSCmaker.release.time;
                    //             flow.OSCmaker.release.curve = curve ? curve : flow.OSCmaker.release.curve;
                    //         };
                    //         this.octave = function(a){if(a==null){return flow.OSCmaker.octave;}flow.OSCmaker.octave=a;};
                    //         this.detune = function(target,time,curve){
                    //             if(target==null){return flow.OSCmaker.detune;}
                    
                    //             //change stored value for any new oscillators that are made
                    //                 const start = flow.OSCmaker.detune;
                    //                 const mux = target-start;
                    //                 const stepsPerSecond = Math.round(Math.abs(mux));
                    //                 const totalSteps = stepsPerSecond*time;
                    
                    //                 let steps = [1];
                    //                 switch(curve){
                    //                     case 'linear': steps = system.utility.math.curveGenerator.linear(totalSteps); break;
                    //                     case 'exponential': steps = system.utility.math.curveGenerator.exponential(totalSteps); break;
                    //                     case 's': steps = system.utility.math.curveGenerator.s(totalSteps,8); break;
                    //                     case 'instant': default: break;
                    //                 }
                                    
                    //                 if(steps.length != 0){
                    //                     const interval = setInterval(function(){
                    //                         flow.OSCmaker.detune = start+(steps.shift()*mux);
                    //                         if(steps.length == 0){clearInterval(interval);}
                    //                     },1000/stepsPerSecond);
                    //                 }
                    
                    //             //instruct liveOscillators to adjust their values
                    //                 const OSCs = Object.keys(flow.liveOscillators);
                    //                 for(let b = 0; b < OSCs.length; b++){ 
                    //                     flow.liveOscillators[OSCs[b]].detune(target,time,curve);
                    //                 }
                    //         };
                    //         this.gainWobbleDepth = function(value){
                    //             if(value==null){return flow.wobbler_gain.depth; }
                    //             flow.wobbler_gain.depth = value;
                    //             flow.wobbler_gain.stop();
                    //             flow.wobbler_gain.start();
                    //         };
                    //         this.gainWobblePeriod = function(value){
                    //             if(value==null){return flow.wobbler_gain.period; }
                    //             flow.wobbler_gain.period = value;
                    //             flow.wobbler_gain.stop();
                    //             flow.wobbler_gain.start();
                    //         };
                    //         this.detuneWobbleDepth = function(value){
                    //             if(value==null){return flow.wobbler_detune.depth; }
                    //             flow.wobbler_detune.depth = value;
                    //             flow.wobbler_detune.stop();
                    //             flow.wobbler_detune.start();
                    //         };
                    //         this.detuneWobblePeriod = function(value){
                    //             if(value==null){return flow.wobbler_detune.period; }
                    //             flow.wobbler_detune.period = value;
                    //             flow.wobbler_detune.stop();
                    //             flow.wobbler_detune.start();
                    //         };
                    // };
                    this.multibandFilter = function(
                        context, bandcount, frames=false
                    ){
                        //saved values
                            const saved = {
                                settings:[], //{Q, gain, frequency, fresh(bool)}
                                responses:[], //{magResponse, phaseResponse, frequencyArray}
                            };
                    
                        //flow chain
                            const flow = {
                                inAggregator: {},
                                filterNodes: [],
                                gainNodes: [],
                                outAggregator: {},
                            };
                    
                            //inAggregator
                                flow.inAggregator.gain = 1;
                                flow.inAggregator.node = context.createGain();
                                _canvas_.library.audio.changeAudioParam(context,flow.inAggregator.node.gain, flow.inAggregator.gain, 0.01, 'instant', true);
                    
                            //filterNodes
                                function makeGenericFilter(type){
                                    const temp = { frequency:110, Q:0.1, node:context.createBiquadFilter() };
                                    temp.node.type = type;
                                    _canvas_.library.audio.changeAudioParam(context, temp.node.frequency,110,0.01,'instant',true);
                                    _canvas_.library.audio.changeAudioParam(context, temp.node.Q,0.1,0.01,'instant',true);
                                    return temp;
                                }
                    
                                if(frames){
                                    if(bandcount < 2){bandcount = 2;}
                                    //lowpass
                                        flow.filterNodes.push(makeGenericFilter('lowpass'));
                                    //bands
                                        for(let a = 1; a < bandcount-1; a++){ flow.filterNodes.push(makeGenericFilter('bandpass')); }
                                    //highpass
                                        flow.filterNodes.push(makeGenericFilter('highpass'));
                                }else{
                                    //bands
                                        for(let a = 0; a < bandcount; a++){ flow.filterNodes.push(makeGenericFilter('bandpass')); }
                                }
                    
                            //gainNodes
                                for(let a = 0; a < bandcount; a++){
                                    const temp = { gain:1, node:context.createGain() };
                                    _canvas_.library.audio.changeAudioParam(context, temp.node.gain, temp.gain, 0.01, 'instant', true);
                                    flow.gainNodes.push(temp);
                                    saved.settings[a] = { Q:0.1, gain:1, frequency:110, fresh:true };
                                }
                    
                            //outAggregator
                                flow.outAggregator.gain = 1;
                                flow.outAggregator.node = context.createGain();
                                _canvas_.library.audio.changeAudioParam(context,flow.outAggregator.node.gain, flow.outAggregator.gain, 0.01, 'instant', true);
                    
                    
                        //do connections
                            for(let a = 0; a < bandcount; a++){
                                flow.inAggregator.node.connect(flow.filterNodes[a].node);
                                flow.filterNodes[a].node.connect(flow.gainNodes[a].node);
                                flow.gainNodes[a].node.connect(flow.outAggregator.node);
                            }
                    
                    
                        //input/output node
                            this.in = function(){return flow.inAggregator.node;}
                            this.out = function(){return flow.outAggregator.node;}
                    
                    
                        //controls
                            this.masterGain = function(value){
                                if(value == undefined){return flow.outAggregator.gain;}
                                flow.outAggregator.gain = value;
                                _canvas_.library.audio.changeAudioParam(context,flow.outAggregator.node.gain, flow.outAggregator.gain, 0.01, 'instant', true);
                            };
                            this.gain = function(band,value){
                                if(band == undefined){ return flow.gainNodes.map(a => a.gain);}
                                if(value == undefined){return flow.gainNodes[band].gain;}
                                flow.gainNodes[band].gain = value;
                                _canvas_.library.audio.changeAudioParam(context, flow.gainNodes[band].node.gain, flow.gainNodes[band].gain, 0.01, 'instant', true);
                    
                                saved.settings[band].gain = value;
                                saved.settings[band].fresh = true;
                            };
                            this.frequency = function(band,value){
                                if(band == undefined){ return flow.filterNodes.map(a => a.frequency);}
                                if(value == undefined){return flow.filterNodes[band].frequency;}
                                flow.filterNodes[band].frequency = value;
                                _canvas_.library.audio.changeAudioParam(context, flow.filterNodes[band].node.frequency,flow.filterNodes[band].frequency,0.01,'instant',true);
                    
                                saved.settings[band].frequency = value;
                                saved.settings[band].fresh = true;
                            };
                            this.Q = function(band,value){
                                if(band == undefined){ return flow.filterNodes.map(a => a.Q);}
                                if(value == undefined){return flow.filterNodes[band].Q;}
                                flow.filterNodes[band].Q = value;
                                _canvas_.library.audio.changeAudioParam(context, flow.filterNodes[band].node.Q,flow.filterNodes[band].Q,0.01,'instant',true);
                    
                                saved.settings[band].Q = value;
                                saved.settings[band].fresh = true;
                            };
                        
                            this.measureFrequencyResponse = function(band, frequencyArray){
                                //if band is undefined, gather the response for all bands
                                    if(band == undefined){ return Array(bandcount).fill(0).map((a,i) => this.measureFrequencyResponse(i,frequencyArray)); }
                    
                                //if band hasn't had it's setttings changed since last time, just return the last values (multiplied by the master gain)
                                    if(!saved.settings[band].fresh){
                                        return [ saved.responses[band].magResponse.map(a => a*flow.outAggregator.gain), saved.responses[band].requencyArray ];
                                    }
                    
                                //do full calculation of band, save and return
                                    const Float32_frequencyArray = new Float32Array(frequencyArray);
                                    const magResponseOutput = new Float32Array(Float32_frequencyArray.length);
                                    const phaseResponseOutput = new Float32Array(Float32_frequencyArray.length);
                                    flow.filterNodes[band].node.getFrequencyResponse(Float32_frequencyArray,magResponseOutput,phaseResponseOutput);
                    
                                    saved.responses[band] = {
                                        magResponse:magResponseOutput.map(a => a*flow.gainNodes[band].gain), 
                                        phaseResponse:phaseResponseOutput, 
                                        frequencyArray:frequencyArray,
                                    };
                                    saved.settings[band].fresh = false;
                                    return [magResponseOutput.map(a => a*flow.gainNodes[band].gain*flow.outAggregator.gain),frequencyArray];
                            };
                    };
                    this.player = function(context){
                    
                        //state
                            const self = this;
                            const state = {
                                fileLoaded:false,
                                playhead:[], //{ position:n, lastSightingTime:n, playing,bool },
                                loop:{ active:false, timeout:[] },
                                rate:1,
                                concurrentPlayCountLimit:1, //'-1' is infinite
                                area:{ percentage_start:0, percentage_end:1, actual_start:0, actual_end:1 },
                            };
                    
                            //flow
                                //flow chain
                                const flow = {
                                    track:{},
                                    bufferSource:[],
                                    channelSplitter:{},
                                    leftOut:{}, rightOut:{}
                                };
                        
                                //channelSplitter
                                    flow.channelSplitter = context.createChannelSplitter(2);
                        
                                //leftOut
                                    flow.leftOut.gain = 1;
                                    flow.leftOut.node = context.createGain();
                                    flow.leftOut.node.gain.setTargetAtTime(flow.leftOut.gain, context.currentTime, 0);
                                    flow.channelSplitter.connect(flow.leftOut.node, 0);
                                //rightOut
                                    flow.rightOut.gain = 1;
                                    flow.rightOut.node = context.createGain();
                                    flow.rightOut.node.gain.setTargetAtTime(flow.rightOut.gain, context.currentTime, 0);
                                    flow.channelSplitter.connect(flow.rightOut.node, 1);
                        
                                //output node
                                    this.out_left  = function(){return flow.leftOut.node;}
                                    this.out_right = function(){return flow.rightOut.node;}
                    
                            
                        //internal functions
                            function unloadRaw(){
                                return flow.track;
                            };
                            function loadRaw(data,callback){
                                if(Object.keys(data).length === 0){return;}
                                self.stop();
                                flow.track = data;
                                state.fileLoaded = true;
                                state.playhead = [];
                                self.area(state.area.percentage_start,state.area.percentage_end);
                                callback(data);
                            }
                            function load(type,callback,url='',errorCallback){
                                _canvas_.library.audio.loadAudioFile( function(data){ 
                                    state.fileLoaded = false;
                                    loadRaw(data,callback)
                                }, type, url, errorCallback);
                            }
                            function generatePlayheadNumber(){
                                let num = 0;
                                while( Object.keys(state.playhead).includes(String(num)) && state.playhead[num] != undefined ){num++;}
                                return num;
                            }
                            function playheadCompute(playhead){
                                if(playhead == undefined){
                                    Object.keys(state.playhead).map(key => playheadCompute(parseInt(key)));
                                    return;
                                }
                    
                                //this code is used to update the playhead position as well as to calculate when the loop end will occur, 
                                //and thus when the playhead should jump to the start of the loop. The actual looping of the audio is 
                                //done by the system, so this process is done solely to update the playhead position data.
                                //  Using the playhead's current position and play rate; the length of time before the playhead is 
                                //scheduled to reach the end bound of the loop is calculated and given to a timeout. When this timeout 
                                //occurs; the playhead will jump to the start bound and the process is run again to calculate the new 
                                //length of time before the playhead reaches the end bound.
                                //  The playhead cannot move beyond the end bound, thus any negative time calculated will be set to
                                //zero, and the playhead will instantly jump back to the start bound (this is to mirror the operation of
                                //the underlying audio system)
                    
                                clearInterval(state.loop.timeout[playhead]);
                    
                                //update playhead position data
                                    const currentTime = self.currentTime(playhead);
                                    //(playhead must exist)
                                        if(state.playhead[playhead] == undefined){return;}
                                        state.playhead[playhead].position = currentTime;
                                        state.playhead[playhead].lastSightingTime = context.currentTime;
                    
                                //obviously, if the loop isn't active or the file isn't playing, don't do any of the work
                                    if(!state.loop.active || !state.playhead[playhead].playing){return;}
                    
                                //calculate time until the timeout should be called
                                    let timeUntil = state.area.actual_end - currentTime;
                                    if(timeUntil < 0){timeUntil = 0;}
                    
                                //the callback (which performs the jump to the start of the loop, and recomputes)
                                    state.loop.timeout[playhead] = setTimeout(
                                        (function(playhead){
                                            return function(){
                                                jumpToTime(playhead,state.area.actual_start,true);
                                                playheadCompute(playhead);
                                            }
                                        })(playhead),
                                        (timeUntil*1000)/state.rate
                                    );
                            }
                            function jumpToTime(playhead=0,value,doNotActuallyAffectTheAudioBuffer=false){
                                //check if we should jump at all
                                //(file must be loaded and playhead must exist)
                                    if(!state.fileLoaded || state.playhead[playhead] == undefined){return;}
                    
                                //if playback is stopped; only adjust the playhead position
                                    if( !state.playhead[playhead].playing ){
                                        state.playhead[playhead].position = value;
                                        state.playhead[playhead].lastSightingTime = context.currentTime;
                                        return;
                                    }
                    
                                //if loop is enabled, and the desired value is beyond the loop's end boundary,
                                //set the value to the start value
                                    if(state.loop.active && value > state.loop.actual_end){value = state.loop.actual_start;}
                    
                                //stop playback, with a callback that will change the playhead position
                                //and then restart playback
                                    if(doNotActuallyAffectTheAudioBuffer){
                                        state.playhead[playhead].position = value;
                                        state.playhead[playhead].lastSightingTime = context.currentTime;
                                        return;
                                    }
                                    self.pause(playhead,
                                        (function(playhead){
                                            return function(){
                                                state.playhead[playhead].position = value;
                                                state.playhead[playhead].lastSightingTime = context.currentTime;
                                                self.resume(playhead);
                                            }
                                        })(playhead)
                                    );
                            }
                            function rejigger(playhead){
                                if(playhead == undefined){
                                    Object.keys(state.playhead).map(key => rejigger(parseInt(key)));
                                    return;
                                }
                    
                                jumpToTime(playhead,state.playhead[playhead].position);
                            }
                    
                        //controls
                            this.concurrentPlayCountLimit = function(value){
                                if(value == undefined){return state.concurrentPlayCountLimit;}
                    
                                state.concurrentPlayCountLimit = value;
                                for(let a = value; a < state.playhead.length; a++){ this.stop(a); }
                            };
                        
                            this.unloadRaw = function(){ 
                                return unloadRaw(); 
                            };
                            this.loadRaw = function(data,callback){ 
                                loadRaw(data,callback); 
                            };
                            this.load = function(type,callback,url='',errorCallback){ 
                                load(type,callback,url,errorCallback); 
                            };
                    
                            // this.generatePlayheadNumber = function(){ 
                            //     return generatePlayheadNumber();
                            // };
                    
                            this.start = function(playhead){
                    
                                //check if we should play at all (file must be loaded)
                                    if(!state.fileLoaded){return;}
                                //if no particular playhead is selected, generate a new one
                                //(unless we've already reached the concurrentPlayCountLimit)
                                    if(playhead == undefined){
                                        if(state.concurrentPlayCountLimit != -1 && state.playhead.filter(() => true).length >= state.concurrentPlayCountLimit){ return -1; }
                                        
                                        playhead = generatePlayheadNumber();
                                        state.playhead[playhead] = { position:0, lastSightingTime:0 };
                                    }
                                //ensure that the playhead is after the start of the area
                                    if(state.playhead[playhead].position < state.area.actual_start){ state.playhead[playhead].position = state.area.actual_start; }
                                    if(state.playhead[playhead].position > state.area.actual_end){ state.playhead[playhead].position = state.area.actual_start; }
                                //load buffer, enter settings and start from playhead position
                                    flow.bufferSource[playhead] = _canvas_.library.audio.loadBuffer(context, flow.track.buffer, flow.channelSplitter, (function(playhead){ return function(){self.stop(playhead);};})(playhead));
                                    flow.bufferSource[playhead].loop = state.loop.active;
                                    flow.bufferSource[playhead].loopStart = state.area.actual_start;
                                    flow.bufferSource[playhead].loopEnd = state.area.actual_end;
                                    flow.bufferSource[playhead].playbackRate.value = state.rate;
                                    flow.bufferSource[playhead].start( 
                                        0, 
                                        state.playhead[playhead].position, 
                                        state.loop.active ? undefined : state.area.actual_end-state.playhead[playhead].position
                                    );
                                //log the starting time, play state
                                    state.playhead[playhead].lastSightingTime = context.currentTime;
                                    state.playhead[playhead].playing = true;
                                    playheadCompute(playhead);
                                //return the playhead number
                                    return playhead;
                            };
                            this.pause = function(playhead,callback){
                                if(playhead == undefined){
                                    Object.keys(state.playhead).map(key => self.pause(parseInt(key)));
                                    return;
                                }
                    
                                //check if we should stop at all (player must be playing)
                                    if( state.playhead[playhead] == undefined || !state.playhead[playhead].playing ){return;}
                                //log play state and run playheadCompute
                                    playheadCompute(playhead);
                                    state.playhead[playhead].playing = false;
                                //actually stop the buffer and destroy it
                                    flow.bufferSource[playhead].onended = callback;
                                    flow.bufferSource[playhead].stop(0);
                            };
                            this.resume = function(playhead){
                                if(playhead == undefined){
                                    Object.keys(state.playhead).map(key => self.resume(parseInt(key)));
                                    return;
                                }
                    
                                //if this playhead is already playing, don't start it again
                                    if( state.playhead[playhead].playing ){return;}
                        
                                this.start(playhead);
                            };
                            this.stop = function(playhead,callback){
                                if(playhead == undefined){
                                    Object.keys(state.playhead).map(key => self.stop(parseInt(key)));
                                    return;
                                }
                    
                                //check if we should stop at all (player must be playing)
                                    if( state.playhead[playhead] == undefined || !state.playhead[playhead].playing ){return;}
                                //actually stop the buffer and destroy it
                                    flow.bufferSource[playhead].onended = callback;
                                    flow.bufferSource[playhead].stop(0);
                                //playheadCompute and delete playhead
                                    state.playhead[playhead].playing = false;
                                    playheadCompute(playhead);
                            };
                            this.restart = function(playhead){
                                this.stop(playhead);
                                this.start(playhead);
                            };
                    
                            this.jumpTo = function(playhead=0,value=0,percentage=true){
                                if(percentage){
                                    value = (value>1 ? 1 : value);
                                    value = (value<0 ? 0 : value);
                                    jumpToTime(playhead,this.duration()*value);
                                }else{
                                    jumpToTime(playhead,value);
                                }
                                playheadCompute(playhead);
                            };
                            this.area = function(start,end,percentage=true){
                                if(start == undefined && end == undefined){ return state.area; }
                                if(start == undefined){ start = percentage ? state.area.percentage_start : state.area.actual_start; }
                                if(end == undefined){ end = percentage ? state.area.percentage_end : state.area.actual_end; }
                    
                                if(percentage){
                                    state.area.percentage_start = start;
                                    state.area.percentage_end = end;
                                    state.area.actual_start = start*this.duration();
                                    state.area.actual_end = end*this.duration();
                                }else{
                                    state.area.percentage_start = start/this.duration();
                                    state.area.percentage_end = end/this.duration();
                                    state.area.actual_start = start;
                                    state.area.actual_end = end;
                                }
                    
                                playheadCompute();
                                rejigger();
                    
                                return state.area;
                            };
                            this.loop = function(active){
                                if(active == undefined){return state.loop.active;}
                    
                                state.loop.active = active;
                    
                                playheadCompute();
                                rejigger();
                            };
                            this.rate = function(value){
                                if(value == undefined){return state.rate;}
                    
                                playheadCompute();
                                state.rate = value;
                                flow.bufferSource.forEach(item => item.playbackRate.value = value);
                                playheadCompute();
                            };
                    
                            this.createPlayhead = function(position){
                                if(state.concurrentPlayCountLimit != -1 && state.playhead.filter(() => true).length >= state.concurrentPlayCountLimit){ return -1; }
                    
                                playhead = generatePlayheadNumber();
                                state.playhead[playhead] = { position:this.duration()*position, lastSightingTime:0 };
                            };
                    
                        //info
                            this._printState = function(){console.log(state);};
                            this.isLoaded = function(){return state.fileLoaded;};
                            this.duration = function(){return !state.fileLoaded ? -1 : flow.track.duration;};
                            this.title = function(){return !state.fileLoaded ? '' : flow.track.name;};
                            this.currentTime = function(playhead){
                                //check if file is loaded
                                    if(!state.fileLoaded){return -1;}
                                //if no playhead is selected, do all of them
                                    if(playhead == undefined){ return Object.keys(state.playhead).map(key => self.currentTime(key)); }
                                //if playback is stopped, return the playhead position, 
                                    if(state.playhead[playhead] == undefined){return -1;}
                                    if(!state.playhead[playhead].playing){return state.playhead[playhead].position;}
                                //otherwise, calculate the current position
                                    return state.playhead[playhead].position + state.rate*(context.currentTime - state.playhead[playhead].lastSightingTime);
                            };
                            this.progress = function(playhead){
                                //if no playhead is selected, do all of them
                                    if(playhead == undefined){ return Object.keys(state.playhead).map(key => self.progress(key)); }
                    
                                const time = this.currentTime(playhead);
                                if(time == -1){return -1;}
                                return time/this.duration();
                            };
                            this.waveformSegment = function(data={start:0,end:1},resolution){
                                if(data==undefined || !state.fileLoaded){return [];}
                                return _canvas_.library.audio.waveformSegment(flow.track.buffer, data, resolution);
                            };
                    };
                    this.channelMultiplier = function(
                        context, outputCount=2
                    ){
                        //flow
                            //flow chain
                                const flow = {
                                    in: {},
                                    outs:[],
                                    out_0: {}, out_1: {},
                                };
                            
                            //in
                                flow.in.gain = 1;
                                flow.in.node = context.createGain();    
                                _canvas_.library.audio.changeAudioParam(context,flow.in.node.gain, flow.in.gain, 0.01, 'instant', true);
                    
                            //outs
                                for(let a = 0; a < outputCount; a++){
                                    const temp = { gain:0.5, node:context.createGain() };
                                    _canvas_.library.audio.changeAudioParam(context,temp.node.gain, temp.gain, 0.01, 'instant', true);
                                    flow.outs.push(temp);
                                    flow.in.node.connect(temp.node);
                                }
                    
                        //input/output node
                            this.in = function(){return flow.in.node;}
                            this.out = function(a){return flow.outs[a].node;}
                    
                        //controls
                            this.inGain = function(a){
                                if(a == undefined){return flow.in.gain;}
                                flow.in.gain = a;
                                _canvas_.library.audio.changeAudioParam(context,flow.in.node.gain, flow.in.gain, 0.01, 'instant', true);
                            };
                            this.outGain = function(a,value){
                                if(value == undefined){ return flow.outs[a].gain; }
                                flow.outs[a].gain = value;
                                _canvas_.library.audio.changeAudioParam(context,flow.outs[a].node.gain, flow.outs[a].gain, 0.01, 'instant', true);
                            };
                    };
                        
                    this.oscillator = function(
                        context
                    ){
                        //flow
                            //flow chain
                                const flow = {
                                    gainControl:{},
                                    detuneControl:{},
                                    dutyCycleControl:{},
                                    oscillator:{},
                                };
                    
                            //control streams
                                flow.gainControl = {
                                    node: new _canvas_.library.audio.audioWorklet.nothing(context),
                                };
                                flow.detuneControl = {
                                    node: new _canvas_.library.audio.audioWorklet.nothing(context),
                                };
                                flow.dutyCycleControl = {
                                    node: new _canvas_.library.audio.audioWorklet.nothing(context),
                                };
                    
                            //oscillator
                                flow.oscillator = {
                                    frequency: 440,
                                    gain: 1,
                                    detune: 0,
                                    dutyCycle: 0.5,
                                    node: new _canvas_.library.audio.audioWorklet.oscillator(context),
                                };
                                
                    
                            flow.gainControl.node.connect(flow.oscillator.node, undefined, 0);
                            flow.detuneControl.node.connect(flow.oscillator.node, undefined, 1);
                            flow.dutyCycleControl.node.connect(flow.oscillator.node, undefined, 2);
                    
                        //input/output
                            this.out = function(){return flow.oscillator.node;}
                            this.gainControl = function(){return flow.gainControl.node;}
                            this.detuneControl = function(){return flow.detuneControl.node;}
                            this.dutyCycleControl = function(){return flow.dutyCycleControl.node;}
                    
                        //controls
                            this.waveform = function(value){ // 0 - sine / 1 - square / 2 - triangle / 3 - noise
                                if(value == undefined){ return flow.oscillator.node.waveform; }
                                flow.oscillator.node.waveform = value;
                            };
                            this.frequency = function(value){
                                if(value == undefined){ return flow.oscillator.frequency; }
                                flow.oscillator.frequency = value;
                                _canvas_.library.audio.changeAudioParam(context, flow.oscillator.node.frequency, value, 0.01, 'instant', true);
                            };
                            this.gain = function(value){
                                if(value == undefined){ return flow.oscillator.gain; }
                                flow.oscillator.gain = value;
                                _canvas_.library.audio.changeAudioParam(context, flow.oscillator.node.gain, value, 0.01, 'instant', true);
                            };
                            this.detune = function(value){
                                if(value == undefined){ return flow.oscillator.detune; }
                                flow.oscillator.detune = value;
                                _canvas_.library.audio.changeAudioParam(context, flow.oscillator.node.detune, value, 0.01, 'instant', true);
                            };
                            this.dutyCycle = function(value){
                                if(value == undefined){ return flow.oscillator.dutyCycle; }
                                flow.oscillator.dutyCycle = value;
                                _canvas_.library.audio.changeAudioParam(context, flow.oscillator.node.dutyCycle, value, 0.01, 'instant', true);
                            };          
                            this.gainMode = function(value){
                                if(value == undefined){ return flow.oscillator.node.gain_mode; }
                                flow.oscillator.node.gain_mode = value;
                            };
                            this.detuneMode = function(value){
                                if(value == undefined){ return flow.oscillator.node.detune_mode; }
                                flow.oscillator.node.detune_mode = value;
                            };
                            this.dutyCycleMode = function(value){
                                if(value == undefined){ return flow.oscillator.node.dutyCycle_mode; }
                                flow.oscillator.node.dutyCycle_mode = value;
                            }
                    };
                    this.recorder = function(context){
                    
                        //state
                            const state = {
                                recordedChunks: [],
                                recordingStartTime: -1,
                                recordingLength: 0,
                            };
                    
                        //flow
                            //flow chain
                                const flow = {
                                    leftIn:{}, rightIn:{},
                                    recordingNode:{},
                                    leftOut:{}, rightOut:{},
                                };
                    
                            //leftIn
                                flow.leftIn.node = context.createAnalyser();
                            //rightIn
                                flow.rightIn.node = context.createAnalyser();
                    
                            //recordingNode
                                flow.recordingNode.audioDest = new MediaStreamAudioDestinationNode(context);
                                flow.recordingNode.node = new MediaRecorder(flow.recordingNode.audioDest.stream, {mimeType : 'audio/webm'});
                    
                                flow.recordingNode.node.onstart = function(){};
                                flow.recordingNode.node.ondataavailable = function(e){
                                    state.recordedChunks.push(e.data);
                                };
                                flow.recordingNode.node.onpause = function(){};
                                flow.recordingNode.node.onresume = function(){};
                                flow.recordingNode.node.onerror = function(error){console.log(error);};
                                flow.recordingNode.node.onstop = function(){};
                    
                                flow.leftIn.node.connect(flow.recordingNode.audioDest);
                                flow.rightIn.node.connect(flow.recordingNode.audioDest);
                    
                            //leftOut
                                flow.leftOut.node = context.createAnalyser();
                                flow.leftIn.node.connect(flow.leftOut.node);
                            //rightIn
                                flow.rightOut.node = context.createAnalyser();
                                flow.rightIn.node.connect(flow.rightOut.node);
                    
                    
                        //internal functions
                            function getRecordingLength(){
                                switch(flow.recordingNode.node.state){
                                    case 'inactive': case 'paused':
                                        return state.recordingLength;
                                    break;
                                    case 'recording':
                                        return context.currentTime - state.recordingStartTime;
                                    break;
                                }            
                            }
                    
                        //controls
                            this.clear =  function(){
                                this.stop();
                                state.recordedChunks = [];
                                state.recordingStartTime = -1;
                                state.recordingLength = 0;
                            };
                            this.start =  function(){
                                this.clear();
                                flow.recordingNode.node.start();
                                state.recordingStartTime = context.currentTime;
                            };
                            this.pause =  function(){
                                if(this.state() == 'inactive'){return;}
                                state.recordingLength = getRecordingLength();
                                flow.recordingNode.node.pause();
                            };
                            this.resume = function(){
                                flow.recordingNode.node.resume();
                                state.recordingStartTime = context.currentTime - state.recordingLength;
                            };
                            this.stop =   function(){
                                if(this.state() == 'inactive'){return;}
                                state.recordingLength = getRecordingLength();
                                flow.recordingNode.node.stop();
                            };
                            this.export = function(){
                                return new Blob(state.recordedChunks, { type: 'audio/ogg; codecs=opus' });
                            };
                            this.save = function(filename='output'){
                                const a = document.createElement('a');
                                a.href = URL.createObjectURL(this.export());
                                a.download = filename+'.ogg';
                                document.body.appendChild(a);
                                a.click();
                                document.body.removeChild(a);
                            };
                    
                            this.state = function(){return flow.recordingNode.node.state;};
                            this.recordingTime = function(){
                                return getRecordingLength();
                            };
                            this.getTrack = function(){return this.export(); };
                    
                        //io
                            this.in_left  =  function(){return flow.leftIn.node;};
                            this.in_right =  function(){return flow.rightIn.node;};
                            this.out_left  = function(){return flow.leftOut.node;};
                            this.out_right = function(){return flow.rightOut.node;};
                    };

                    this.audioIn = function(
                        context, setupConnect=true
                    ){
                        //flow chain
                            const flow = {
                                audioDevice:undefined,
                                outAggregator: {}
                            };
                    
                        //outAggregator
                            flow.outAggregator.gain = 1;
                            flow.outAggregator.node = context.createGain();
                            _canvas_.library.audio.changeAudioParam(context,flow.outAggregator.node.gain, flow.outAggregator.gain);
                    
                    
                        //output node
                            this.out = function(){return flow.outAggregator.node;}
                    
                        //methods
                            this.listDevices = function(callback){
                                navigator.mediaDevices.enumerateDevices().then(
                                    function(devices){
                                        callback(devices.filter((d) => d.kind === 'audioinput'));
                                    }
                                );
                            };
                            this.selectDevice = function(deviceId){
                                const promise = navigator.mediaDevices.getUserMedia({audio: {deviceId: deviceId}});
                                promise.then(
                                    function(source){
                                        if(flow.audioDevice != undefined){ flow.audioDevice.disconnect(); }
                                        flow.audioDevice = _canvas_.library.audio.context.createMediaStreamSource(source);
                                        flow.audioDevice.connect(flow.outAggregator.node);                    
                                    },
                                    function(error){
                                        console.warn('could not find audio input device: "' + deviceId + '"');
                                        console.warn('\terror:',error);
                                    }
                                );
                            };
                            this.gain = function(a){
                                if(a==null){return flow.outAggregator.gain;}
                                flow.outAggregator.gain = a;
                                _canvas_.library.audio.changeAudioParam(context,flow.outAggregator.node.gain,a);
                            };
                    
                        //setup
                            if(setupConnect){this.selectDevice('default');}
                    };
                    // this.gain = function(
                    //     context
                    // ){
                    //     //flow
                    //         //flow chain
                    //             const flow = {
                    //                 gainNode:{}
                    //             };
                    
                    //     //gainNode
                    //         flow.gainNode.gain = 1;
                    //         flow.gainNode.node = context.createGain();    
                    //         _canvas_.library.audio.changeAudioParam(context, flow.gainNode.node.gain, flow.gainNode.gain, 0.01, 'instant', true);
                    
                    //     //input/output node
                    //         this.in = function(){return flow.gainNode.node;}
                    //         this.out = function(a){return flow.gainNode.node;}
                    
                    //     //controls
                    //         this.gain = function(value){
                    //             if(value == undefined){ return flow.gainNode.gain; }
                    //             flow.gainNode.gain = value;
                    //             _canvas_.library.audio.changeAudioParam(context, flow.gainNode.node.gain, flow.gainNode.gain, 0.01, 'instant', true);
                    //         };
                    // };
                    
                    
                    this.gain = function(
                        context
                    ){
                        //flow
                            //flow chain
                                const flow = {
                                    controlIn:{},
                                    gain:{}
                                };
                    
                            //controlIn
                                flow.controlIn = {
                                    node: new _canvas_.library.audio.audioWorklet.nothing(context),
                                };
                            //gain
                                flow.gain = {
                                    mode: false,
                                    gain: 1,
                                    node: new _canvas_.library.audio.audioWorklet.gain(context),
                                };
                    
                            flow.controlIn.node.connect(flow.gain.node, undefined, 1);
                    
                        //input/output
                            this.in = function(){return flow.gain.node;}
                            this.out = function(){return flow.gain.node;}
                            this.control = function(){return flow.controlIn.node;}
                    
                        //controls
                            this.mode = function(value){
                                if(value == undefined){ return flow.gain.mode; }
                                flow.gain.mode = value;
                                flow.gain.node.mode = value;
                            };
                            this.gain = function(value){
                                if(value == undefined){ return flow.gain.gain; }
                                flow.gain.gain = value;
                                _canvas_.library.audio.changeAudioParam(context, flow.gain.node.gain, value, 0.01, 'instant', true);
                            };
                    };
                    this.amplitudeModifier = function(
                        context
                    ){
                        //flow
                            //flow chain
                                const flow = {
                                    amplitudeModifierNode:{}
                                };
                    
                            //amplitudeModifierNode
                                flow.amplitudeModifierNode = {
                                    invert: false,
                                    offset: 0,
                                    divisor: 1,
                                    ceiling: 10,
                                    floor: -10,
                                    node: new _canvas_.library.audio.audioWorklet.amplitudeModifier(context),
                                };
                    
                        //input/output node
                            this.in = function(){return flow.amplitudeModifierNode.node;}
                            this.out = function(a){return flow.amplitudeModifierNode.node;}
                    
                        //controls
                            this.invert = function(value){
                                if(value == undefined){ return flow.amplitudeModifierNode.invert; }
                                flow.amplitudeModifierNode.invert = value;
                                flow.amplitudeModifierNode.node.invert = value;
                            };
                            this.offset = function(value){
                                if(value == undefined){ return flow.amplitudeModifierNode.offset; }
                                flow.amplitudeModifierNode.offset = value;
                                _canvas_.library.audio.changeAudioParam(context, flow.amplitudeModifierNode.node.offset, value, 0.01, 'instant', true);
                            };
                            this.divisor = function(value){
                                if(value == undefined){ return flow.amplitudeModifierNode.divisor; }
                                flow.amplitudeModifierNode.divisor = value;
                                _canvas_.library.audio.changeAudioParam(context, flow.amplitudeModifierNode.node.divisor, value, 0.01, 'instant', true);
                            };
                            this.ceiling = function(value){
                                if(value == undefined){ return flow.amplitudeModifierNode.ceiling; }
                                flow.amplitudeModifierNode.ceiling = value;
                                _canvas_.library.audio.changeAudioParam(context, flow.amplitudeModifierNode.node.ceiling, value, 0.01, 'instant', true);
                            };
                            this.floor = function(value){
                                if(value == undefined){ return flow.amplitudeModifierNode.floor; }
                                flow.amplitudeModifierNode.floor = value;
                                _canvas_.library.audio.changeAudioParam(context, flow.amplitudeModifierNode.node.floor, value, 0.01, 'instant', true);
                            };
                    };
                    this.streamAdder = function(
                        context
                    ){
                        //flow
                            //flow chain
                                const flow = {
                                    input_1:{},
                                    input_2:{},
                                    mixControl:{},
                                    streamAdder:{}
                                };
                    
                            //inputs
                                flow.input_1 = {
                                    node: new _canvas_.library.audio.audioWorklet.nothing(context),
                                };
                                flow.input_2 = {
                                    node: new _canvas_.library.audio.audioWorklet.nothing(context),
                                };
                    
                            //mixControl
                                flow.mixControl = {
                                    node: new _canvas_.library.audio.audioWorklet.nothing(context),
                                };
                                
                            //gain
                                flow.streamAdder = {
                                    mode: false,
                                    mix: 1,
                                    node: new _canvas_.library.audio.audioWorklet.streamAdder(context),
                                };
                    
                            flow.input_1.node.connect(flow.streamAdder.node, undefined, 0);
                            flow.input_2.node.connect(flow.streamAdder.node, undefined, 1);
                            flow.mixControl.node.connect(flow.streamAdder.node, undefined, 2);
                    
                        //input/output
                            this.in_1 = function(){return flow.input_1.node;}
                            this.in_2 = function(){return flow.input_2.node;}
                            this.mixControl = function(){return flow.mixControl.node;}
                            this.out = function(){return flow.streamAdder.node;}
                    
                        //controls
                            this.mode = function(value){
                                if(value == undefined){ return flow.streamAdder.mode; }
                                flow.streamAdder.mode = value;
                                flow.streamAdder.node.mode = value;
                            };
                            this.mix = function(value){
                                if(value == undefined){ return flow.streamAdder.mix; }
                                flow.streamAdder.mix = value;
                                _canvas_.library.audio.changeAudioParam(context, flow.streamAdder.node.mix, value, 0.01, 'instant', true);
                            };
                    };
                    this.sigmoid = function(
                        context
                    ){
                        //flow
                            //flow chain
                                const flow = {
                                    sigmoid:{}
                                };
                    
                        //sigmoid
                            flow.sigmoid = {
                                gain: 1,
                                sharpness: 0,
                                node: new _canvas_.library.audio.audioWorklet.sigmoid(context),
                            };
                    
                        //input/output node
                            this.in = function(){return flow.sigmoid.node;}
                            this.out = function(a){return flow.sigmoid.node;}
                    
                        //controls
                            this.gain = function(value){
                                if(value == undefined){ return flow.sigmoid.gain; }
                                if(value > 1){value = 1;}
                                if(value < 0){value = 0;}
                                flow.sigmoid.gain = value;
                                _canvas_.library.audio.changeAudioParam(context, flow.sigmoid.node.gain, value, 0.01, 'instant', true);
                            };
                            this.sharpness = function(value){
                                if(value == undefined){ return flow.sigmoid.sharpness; }
                                if(value > 1){value = 1;}
                                if(value < 0){value = 0;}
                                flow.sigmoid.sharpness = value;
                                _canvas_.library.audio.changeAudioParam(context, flow.sigmoid.node.sharpness, value, 0.01, 'instant', true);
                            };
                    };
                    this.reverbUnit = function(
                        context,
                    ){
                        //flow chain
                            const flow = {
                                inAggregator: {},
                                reverbGain: {}, bypassGain: {},
                                reverbNode: {},
                                outAggregator: {},
                            };
                    
                        //inAggregator
                            flow.inAggregator.gain = 1;
                            flow.inAggregator.node = context.createGain();
                            _canvas_.library.audio.changeAudioParam(context,flow.inAggregator.node.gain, flow.inAggregator.gain, 0.01, 'instant', true);
                    
                        //reverbGain / bypassGain
                            flow.reverbGain.gain = 0.5;
                            flow.bypassGain.gain = 0.5;
                            flow.reverbGain.node = context.createGain();
                            flow.bypassGain.node = context.createGain();
                            _canvas_.library.audio.changeAudioParam(context,flow.reverbGain.node.gain, flow.reverbGain.gain, 0.01, 'instant', true);
                            _canvas_.library.audio.changeAudioParam(context,flow.bypassGain.node.gain, flow.bypassGain.gain, 0.01, 'instant', true);
                    
                        //reverbNode
                            flow.reverbNode.impulseResponseRepoURL = 'https://metasophiea.com/lib/audio/impulseResponse/';
                            flow.reverbNode.selectedReverbType = 'Musikvereinsaal.wav';
                            flow.reverbNode.node = context.createConvolver();
                    
                            function setReverbType(repoURL,type,callback){
                                const ajaxRequest = new XMLHttpRequest();
                                ajaxRequest.open('GET', repoURL+type, true);
                                ajaxRequest.responseType = 'arraybuffer';
                                ajaxRequest.onload = function(){
                                    //undo connections
                                        flow.reverbNode.node.disconnect();
                                    //create new convolver
                                        flow.reverbNode.node = context.createConvolver();
                                    //redo connections
                                        flow.reverbGain.node.connect(flow.reverbNode.node);
                                        flow.reverbNode.node.connect(flow.outAggregator.node);
                                    //load in new buffer
                                        context.decodeAudioData(ajaxRequest.response, function(buffer){flow.reverbNode.node.buffer = buffer;}, function(e){console.warn("Error with decoding audio data" + e.err);});
                                    //run any callbacks
                                        if(callback){callback();}  
                                };
                                ajaxRequest.send();
                            }
                            function getReverbTypeList(repoURL,callback=null){
                                const ajaxRequest = new XMLHttpRequest();
                                ajaxRequest.open('GET', repoURL+'available2.list', true);
                                ajaxRequest.onload = function() {
                                    const list = ajaxRequest.response.split('\n');
                                    
                                    list[list.length-1] = list[list.length-1].split(''); 
                                    list[list.length-1].pop();
                                    list[list.length-1] = list[list.length-1].join('');		
                    
                                    list.splice(-1,1);
                                    
                                    if(callback == null){console.log(list);}
                                    else{callback(list);}
                                }
                                ajaxRequest.send();
                            }	
                    
                        //outAggregator
                            flow.outAggregator.gain = 1;
                            flow.outAggregator.node = context.createGain();    
                            _canvas_.library.audio.changeAudioParam(context,flow.outAggregator.node.gain, flow.outAggregator.gain, 0.01, 'instant', true);
                    
                        //do connections
                            flow.inAggregator.node.connect(flow.reverbGain.node);
                            flow.inAggregator.node.connect(flow.bypassGain.node);
                            flow.reverbGain.node.connect(flow.reverbNode.node);
                            flow.bypassGain.node.connect(flow.outAggregator.node);
                            flow.reverbNode.node.connect(flow.outAggregator.node);
                    
                        //input/output node
                            this.in = function(){return flow.inAggregator.node;}
                            this.out = function(){return flow.outAggregator.node;}
                        
                        //controls
                            this.getTypes = function(callback){ getReverbTypeList(flow.reverbNode.impulseResponseRepoURL, callback); };
                            this.type = function(name,callback){
                                if(name==null){return flow.reverbNode.selectedReverbType;}
                                flow.reverbNode.selectedReverbType = name;
                                setReverbType(flow.reverbNode.impulseResponseRepoURL, flow.reverbNode.selectedReverbType, callback);
                            };
                            this.outGain = function(a){
                                if(a==null){return flow.outAggregator.gain;}
                                flow.outAggregator.gain=a;
                                _canvas_.library.audio.changeAudioParam(context,flow.outAggregator.node.gain, a, 0.01, 'instant', true);
                            };
                            this.wetdry = function(a,w,d){
                                if(a=='manualControl'){
                                    if(a==null){return {w:flow.reverbGain.gain,d:flow.bypassGain.gain};}
                                    flow.reverbGain.gain=w;
                                    flow.bypassGain.gain=d;
                                }else{
                                    if(a==null){return flow.reverbGain.gain;}
                                    flow.reverbGain.gain=a;
                                    flow.bypassGain.gain=1-a;
                                }
                    
                                _canvas_.library.audio.changeAudioParam(context,flow.reverbGain.node.gain, flow.reverbGain.gain, 0.01, 'instant', true);
                                _canvas_.library.audio.changeAudioParam(context,flow.bypassGain.node.gain, flow.bypassGain.gain, 0.01, 'instant', true);
                            };
                    
                        //setup
                            setReverbType(flow.reverbNode.impulseResponseRepoURL,flow.reverbNode.selectedReverbType);
                    };

                    this.momentaryAmplitudeMeter = function(
                        context
                    ){
                        const self = this;
                    
                        const momentaryAmplitudeMeter = new _canvas_.library.audio.audioWorklet.momentaryAmplitudeMeter(context);
                        
                        //io
                            this.in = function(){ return momentaryAmplitudeMeter; }
                    
                        //methods
                            this.fullSample = function(bool){
                                if(bool == undefined){ return momentaryAmplitudeMeter.fullSample; }
                                momentaryAmplitudeMeter.fullSample = bool;
                            };
                            this.updateMode = function(bool){
                                if(bool == undefined){ return momentaryAmplitudeMeter.updateMode; }
                                momentaryAmplitudeMeter.updateMode = bool;
                            };
                            this.updateDelay = function(value){
                                if(value == undefined){ return momentaryAmplitudeMeter.updateDelay; }
                                momentaryAmplitudeMeter.updateDelay = value;
                            };
                            this.calculationMode = function(mode){
                                if(mode == undefined){ return momentaryAmplitudeMeter.calculationMode; }
                                momentaryAmplitudeMeter.calculationMode = mode;
                            };
                    
                        //callback
                            this.reading = function(){};
                            momentaryAmplitudeMeter.reading = function(data){
                                if(self.reading != undefined){
                                    self.reading(data);
                                }
                            };
                    };
                    this.bitcrusher = function(
                        context
                    ){
                        //bitcrusherNode
                            const bitcrusherNode = new _canvas_.library.audio.audioWorklet.bitcrusher(context);
                    
                        //input/output node
                            this.in = function(){return bitcrusherNode;}
                            this.out = function(a){return bitcrusherNode;}
                    
                        //controls
                            this.amplitudeResolution = function(value){
                                if(value == undefined){ return bitcrusherNode.amplitudeResolution; }
                                bitcrusherNode.amplitudeResolution = value;
                            };
                            this.sampleFrequency = function(value){
                                if(value == undefined){ return bitcrusherNode.sampleFrequency; }
                                bitcrusherNode.sampleFrequency = value;
                            };
                    };
                    this.distortionUnit = function(
                        context,
                    ){
                        //flow chain
                            const flow = {
                                inAggregator: {},
                                distortionNode: {},
                                outAggregator: {},
                            };
                    
                        //inAggregator
                            flow.inAggregator.gain = 0;
                            flow.inAggregator.node = context.createGain();
                            _canvas_.library.audio.changeAudioParam(context,flow.inAggregator.node.gain, flow.inAggregator.gain, 0.01, 'instant', true);
                    
                        //distortionNode
                            flow.distortionNode.distortionAmount = 0;
                            flow.distortionNode.oversample = 'none'; //'none', '2x', '4x'
                            flow.distortionNode.resolution = 100;
                            function makeDistortionNode(){
                                flow.inAggregator.node.disconnect();
                                if(flow.distortionNode.node){flow.distortionNode.node.disconnect();}
                                
                                flow.distortionNode.node = context.createWaveShaper();
                                    flow.distortionNode.curve = new Float32Array(_canvas_.library.math.curveGenerator.s(flow.distortionNode.resolution,-1,1,flow.distortionNode.distortionAmount));
                                    flow.distortionNode.node.curve = flow.distortionNode.curve;
                                    flow.distortionNode.node.oversample = flow.distortionNode.oversample;
                                    
                                flow.inAggregator.node.connect(flow.distortionNode.node);
                                flow.distortionNode.node.connect(flow.outAggregator.node);
                            }
                    
                        //outAggregator
                            flow.outAggregator.gain = 0;
                            flow.outAggregator.node = context.createGain();    
                            _canvas_.library.audio.changeAudioParam(context,flow.outAggregator.node.gain, flow.outAggregator.gain, 0.01, 'instant', true);
                    
                    
                        //input/output node
                            this.in = function(){return flow.inAggregator.node;}
                            this.out = function(){return flow.outAggregator.node;}
                    
                        //controls
                            this.inGain = function(a){
                                if(a==null){return flow.inAggregator.gain;}
                                flow.inAggregator.gain=a;
                                _canvas_.library.audio.changeAudioParam(context,flow.inAggregator.node.gain, a, 0.01, 'instant', true);
                            };
                            this.outGain = function(a){
                                if(a==null){return flow.outAggregator.gain;}
                                flow.outAggregator.gain=a;
                                _canvas_.library.audio.changeAudioParam(context,flow.outAggregator.node.gain, a, 0.01, 'instant', true);
                            };
                            this.distortionAmount = function(a){
                                if(a==null){return flow.distortionNode.distortionAmount;}
                                flow.distortionNode.distortionAmount=a;
                                makeDistortionNode();
                            };
                            this.oversample = function(a){
                                if(a==null){return flow.distortionNode.oversample;}
                                flow.distortionNode.oversample=a;
                                makeDistortionNode();
                            };
                            this.resolution = function(a){
                                if(a==null){return flow.distortionNode.resolution;}
                                flow.distortionNode.resolution = a>=2?a:2;
                                makeDistortionNode();
                            };
                    
                        //setup
                            makeDistortionNode();
                    };
                    this.stableAmplitudeGenerator = function(
                        context
                    ){
                        //flow
                            //flow chain
                                const flow = {
                                    stableAmplitudeGenerator:{}
                                };
                    
                        //stableAmplitudeGenerator
                            flow.stableAmplitudeGenerator = {
                                amplitude: 0,
                                node: new _canvas_.library.audio.audioWorklet.stableAmplitudeGenerator(context),
                            };
                            
                        //input/output node
                            this.out = function(){ return flow.stableAmplitudeGenerator.node; }
                    
                        //controls
                            this.amplitude = function(value){
                                if(value == undefined){ return flow.stableAmplitudeGenerator.amplitude; }
                                flow.stableAmplitudeGenerator.amplitude = value;
                                _canvas_.library.audio.changeAudioParam(context, flow.stableAmplitudeGenerator.node.amplitude, value, 0.01, 'instant', true);
                            };
                    };
                    this.filterUnit = function(
                        context
                    ){
                        //flow chain
                            const flow = {
                                inAggregator: {},
                                filterNode: {},
                                outAggregator: {},
                            };
                    
                        //inAggregator
                            flow.inAggregator.gain = 1;
                            flow.inAggregator.node = context.createGain();
                            _canvas_.library.audio.changeAudioParam(context,flow.inAggregator.node.gain, flow.inAggregator.gain, 0.01, 'instant', true);
                    
                        //filterNode
                            flow.filterNode.node = context.createBiquadFilter();
                    	    flow.filterNode.node.type = "lowpass";
                            _canvas_.library.audio.changeAudioParam(context, flow.filterNode.node.frequency,110,0.01,'instant',true);
                            _canvas_.library.audio.changeAudioParam(context, flow.filterNode.node.gain,1,0.01,'instant',true);
                            _canvas_.library.audio.changeAudioParam(context, flow.filterNode.node.Q,0.1,0.01,'instant',true);
                    
                        //outAggregator
                            flow.outAggregator.gain = 1;
                            flow.outAggregator.node = context.createGain();
                            _canvas_.library.audio.changeAudioParam(context,flow.outAggregator.node.gain, flow.outAggregator.gain, 0.01, 'instant', true);
                    
                    
                        //do connections
                            flow.inAggregator.node.connect(flow.filterNode.node);
                            flow.filterNode.node.connect(flow.outAggregator.node);
                    
                        //input/output node
                            this.in = function(){
                                return flow.inAggregator.node;
                            }
                            this.out = function(){
                                return flow.outAggregator.node;
                            }
                    
                        //methods
                            this.type = function(type){
                                flow.filterNode.node.type = type;
                            };
                            this.frequency = function(value){
                                _canvas_.library.audio.changeAudioParam(context, flow.filterNode.node.frequency,value,0.01,'instant',true);
                            };
                            this.gain = function(value){
                                _canvas_.library.audio.changeAudioParam(context, flow.filterNode.node.gain,value,0.01,'instant',true);
                            };
                            this.Q = function(value){
                                _canvas_.library.audio.changeAudioParam(context, flow.filterNode.node.Q,value,0.01,'instant',true);
                            };
                            this.measureFrequencyResponse = function(start,end,step){
                                const frequencyArray = [];
                                for(let a = start; a < end; a += step){frequencyArray.push(a);}
                            
                                return this.measureFrequencyResponse_values(frequencyArray);
                            };
                            this.measureFrequencyResponse_values = function(frequencyArray){
                                const Float32_frequencyArray = new Float32Array(frequencyArray);
                                const magResponseOutput = new Float32Array(Float32_frequencyArray.length);
                                const phaseResponseOutput = new Float32Array(Float32_frequencyArray.length);
                            
                                flow.filterNode.node.getFrequencyResponse(Float32_frequencyArray,magResponseOutput,phaseResponseOutput);
                                return [magResponseOutput,frequencyArray];
                            };
                    };

                    this.lagProcessor = function(
                        context
                    ){
                        //lagProcessorNode
                            const lagProcessorNode = new _canvas_.library.audio.audioWorklet.lagProcessor(context);
                    
                        //input/output node
                            this.in = function(){return lagProcessorNode;}
                            this.out = function(a){return lagProcessorNode;}
                    
                        //controls
                            this.samples = function(value){
                                if(value == undefined){ return lagProcessorNode.samples; }
                                lagProcessorNode.samples = value;
                            };
                    };
                    this.whiteNoiseGenerator = function(
                        context
                    ){
                        const audioWorklet = new _canvas_.library.audio.audioWorklet.whiteNoiseGenerator(context);
                        this.out = function(){ return audioWorklet; }
                    };
                    this.frequencyAmplitudeResponseAnalyser = function(
                        context
                    ){
                        const self = this;
                        const frequencyAmplitudeResponseAnalyser = new _canvas_.library.audio.audioWorklet.frequencyAmplitudeResponseAnalyser(context);
                    
                        //input/output node
                            this.producer = function(){ return frequencyAmplitudeResponseAnalyser; }
                            this.consumer = function(){ return frequencyAmplitudeResponseAnalyser; }
                    
                        //controls
                            this.start = function(){ frequencyAmplitudeResponseAnalyser.start(); };
                            this.stop = function(){ frequencyAmplitudeResponseAnalyser.stop(); };
                            this.clear = function(){ frequencyAmplitudeResponseAnalyser.clear(); };
                    
                            this.waveform = function(value){
                                if(value == undefined){ return frequencyAmplitudeResponseAnalyser.waveform; }
                                frequencyAmplitudeResponseAnalyser.waveform = value;
                            };
                            this.signalGeneratorGain = function(value){
                                if(value == undefined){ return frequencyAmplitudeResponseAnalyser.signalGeneratorGain; }
                                frequencyAmplitudeResponseAnalyser.signalGeneratorGain = value;
                            };
                            this.dutyCycle = function(value){
                                if(value == undefined){ return frequencyAmplitudeResponseAnalyser.dutyCycle; }
                                frequencyAmplitudeResponseAnalyser.dutyCycle = value;
                            };
                            this.range = function(start,end){
                                if( start == undefined && end == undefined ){
                                    return frequencyAmplitudeResponseAnalyser.range;
                                }
                                frequencyAmplitudeResponseAnalyser.range = {
                                    start: start == undefined ? frequencyAmplitudeResponseAnalyser.range.start : start,
                                    end: end == undefined ? frequencyAmplitudeResponseAnalyser.range.end : end,
                                };
                            };
                            this.stepSize = function(value){
                                if(value == undefined){ return frequencyAmplitudeResponseAnalyser.stepSize; }
                                frequencyAmplitudeResponseAnalyser.stepSize = value;
                            };
                            this.timePerStep = function(value){
                                if(value == undefined){ return frequencyAmplitudeResponseAnalyser.timePerStep; }
                                frequencyAmplitudeResponseAnalyser.timePerStep = value;
                            };
                            
                        //callback
                            frequencyAmplitudeResponseAnalyser.onValue = function(data){
                                if(self.onValue != undefined){ self.onValue(data); }
                            }
                            frequencyAmplitudeResponseAnalyser.onCompletion = function(data){
                                if(self.onCompletion != undefined){ self.onCompletion(data); }
                            }
                            this.onValue = function(){};
                            this.onCompletion = function(){};
                    };
                };
                this.part = new function(){
                    const interfacePart = this;
                    
                    this.partLibrary = {};
                    this.builder = function(collection,type,name,data){
                        if(!data){data={};}
                        if(data.style == undefined){data.style={};}
                    
                        if(collection in this.partLibrary && type in this.partLibrary[collection]){
                            return this.partLibrary[collection][type](name,data);
                        }
                    
                        console.warn('Interface Part Builder :: Unknown element: '+ collection + '::' + type); return null;
                    }
                    const partRegistry = {};
                    this.collection = new function(){
                        this.basic = new function(){
                            interfacePart.partLibrary.basic = {};
                            this.polygon = function(name=null, points=[], pointsAsXYArray=[], ignored=false, colour={r:1,g:0,b:1,a:1}){
                            
                                const element = _canvas_.core.element.create('polygon',name);
                                element.unifiedAttribute({
                                    ignored:ignored,
                                    colour:colour,
                                });
                                if(points.length != 0){ element.points(points); }
                                else{ element.pointsAsXYArray(pointsAsXYArray); }
                                return element;
                            }
                            
                            interfacePart.partLibrary.basic.polygon = function(name,data){ 
                                return interfacePart.collection.basic.polygon(
                                    name, data.points, data.pointsAsXYArray, data.ignored, data.colour
                                );
                            };
                            this.rectangleWithOutline = function(name=null, x=0, y=0, width=10, height=10, angle=0, anchor={x:0,y:0}, ignored=false, colour={r:1,g:0,b:1,a:1}, thickness=1, lineColour={r:0,g:0,b:0,a:1}){
                            
                                const element = _canvas_.core.element.create('rectangleWithOutline',name);
                                element.unifiedAttribute({
                                    x:x, 
                                    y:y, 
                                    width:width, 
                                    height:height, 
                                    angle:angle, 
                                    anchor:anchor, 
                                    ignored:ignored, 
                                    colour:colour,
                                    lineColour:lineColour,
                                    thickness:thickness,
                                });
                                return element;
                            };
                            
                            interfacePart.partLibrary.basic.rectangleWithOutline = function(name,data){ 
                                return interfacePart.collection.basic.rectangleWithOutline(
                                    name, data.x, data.y, data.width, data.height, data.angle, data.anchor, data.ignored, data.colour, data.thickness, data.lineColour
                                );
                            };
                            this.circle = function(name=null, x=0, y=0, radius=10, detail=25, ignored=false, colour={r:1,g:0,b:1,a:1}){
                            
                                const element = _canvas_.core.element.create('circle',name);
                                element.unifiedAttribute({
                                    x:x, 
                                    y:y, 
                                    radius:radius, 
                                    detail:detail, 
                                    ignored:ignored, 
                                    colour:colour
                                });
                                return element;
                            };
                            
                            interfacePart.partLibrary.basic.circle = function(name,data){ 
                                return interfacePart.collection.basic.circle(
                                    name, data.x, data.y, data.radius, data.detail, data.ignored, data.colour
                                );
                            };
                            this.polygonWithOutline = function(name=null, points=[], pointsAsXYArray=[], ignored=false, colour={r:1,g:0,b:1,a:1}, thickness=1, lineColour={r:0,g:0,b:0,a:1}){
                            
                                const element = _canvas_.core.element.create('polygonWithOutline',name);
                                element.unifiedAttribute({
                                    ignored:ignored,
                                    colour:colour,
                                    lineColour:lineColour,
                                    thickness:thickness,
                                });
                                if(points.length != 0){ element.points(points); }
                                else{ element.pointsAsXYArray(pointsAsXYArray); }
                                return element;
                            }
                            
                            interfacePart.partLibrary.basic.polygonWithOutline = function(name,data){ 
                                return interfacePart.collection.basic.polygonWithOutline(
                                    name, data.points, data.pointsAsXYArray, data.ignored, data.colour, data.thickness, data.lineColour
                                );
                            };
                            this.canvas = function(name=null, x=0, y=0, width=10, height=10, angle=0, anchor={x:0,y:0}, ignored=false, resolution=1){
                                    
                                const element = _canvas_.core.element.create('canvas',name);
                                element.unifiedAttribute({
                                    x:x, 
                                    y:y, 
                                    width:width, 
                                    height:height, 
                                    angle:angle, 
                                    anchor:anchor, 
                                    ignored:ignored, 
                                    resolution:resolution,
                                });
                                return element;
                            };
                            
                            interfacePart.partLibrary.basic.canvas = function(name,data){ 
                                return interfacePart.collection.basic.canvas(
                                    name, data.x, data.y, data.width, data.height, data.angle, data.anchor, data.ignored, data.resolution
                                );
                            };
                            this.image = function(name=null, x=0, y=0, width=10, height=10, angle=0, anchor={x:0,y:0}, ignored=false, url=''){
                            
                                const element = _canvas_.core.element.create('image',name);
                                element.unifiedAttribute({
                                    x:x, 
                                    y:y, 
                                    width:width, 
                                    height:height, 
                                    angle:angle, 
                                    anchor:anchor, 
                                    ignored:ignored, 
                                    url:url,
                                });
                                return element;
                            };
                            
                            interfacePart.partLibrary.basic.image = function(name,data){ 
                                return interfacePart.collection.basic.image(
                                    name, data.x, data.y, data.width, data.height, data.angle, data.anchor, data.ignored, data.url
                                );
                            };
                            this.path = function(name=null, points=[], thickness=1, ignored=false, colour={r:0,g:0,b:0,a:1}, pointsAsXYArray=[], jointType='sharp', capType='none', looping=false, jointDetail=25, sharpLimit=4){
                            
                                const element = _canvas_.core.element.create('path',name);
                                element.unifiedAttribute({
                                    ignored:ignored,
                                    colour:colour,
                                    thickness:thickness,
                                    jointType:jointType,
                                    capType:capType,
                                    looping:looping,
                                    jointDetail:jointDetail,
                                    sharpLimit:sharpLimit,
                                });
                                if(points.length != 0){ element.points(points); }
                                else{ element.pointsAsXYArray(pointsAsXYArray); }
                                return element;
                            }
                            
                            interfacePart.partLibrary.basic.path = function(name,data){ 
                                return interfacePart.collection.basic.path(
                                    name, data.points, data.thickness, data.ignored, data.colour, data.pointsAsXYArray, data.jointType, data.capType, data.looping, data.jointDetail, data.sharpLimit
                                );
                            };
                            this.rectangle = function(name=null, x=0, y=0, width=10, height=10, angle=0, anchor={x:0,y:0}, ignored=false, colour={r:1,g:0,b:1,a:1}){
                                
                                const element = _canvas_.core.element.create('rectangle',name);
                                element.unifiedAttribute({
                                    x:x, 
                                    y:y, 
                                    width:width, 
                                    height:height, 
                                    angle:angle, 
                                    anchor:anchor, 
                                    ignored:ignored, 
                                    colour:colour 
                                });
                                return element;
                            };
                            
                            interfacePart.partLibrary.basic.rectangle = function(name,data){ 
                                return interfacePart.collection.basic.rectangle(
                                    name, data.x, data.y, data.width, data.height, data.angle, data.anchor, data.ignored, data.colour
                                );
                            };
                            this.group = function(name=null, x=0, y=0, angle=0, ignored=false, clipActive=false){
                            
                                const element = _canvas_.core.element.create('group',name);
                                element.unifiedAttribute({
                                    x:x, 
                                    y:y, 
                                    angle:angle, 
                                    ignored:ignored,
                                    clipActive:clipActive,
                                });
                                return element;
                            }
                            
                            interfacePart.partLibrary.basic.group = function(name,data){ 
                                return interfacePart.collection.basic.group(
                                    name, data.x, data.y, data.angle, data.ignored, data.clipActive,
                                );
                            };
                            this.text = function(name=null, text='Hello', x=0, y=0, width=10, height=10, angle=0, ignored=false, colour={r:1,g:0,b:1,a:1}, fontName='Roboto-Regular', printingMode={widthCalculation:'filling', horizontal:'left', vertical:'top'}, spacing=0.5, interCharacterSpacing=0.0){
                            
                                const element = _canvas_.core.element.create('characterString',name);
                                element.unifiedAttribute({
                                    x:x, 
                                    y:y, 
                                    width:width,
                                    height:height,
                                    angle:angle,
                                    ignored:ignored, 
                                    colour:colour,
                                    font:fontName,
                                    string:text,
                                    printingMode:printingMode,
                                    spacing:spacing,
                                    interCharacterSpacing:interCharacterSpacing,
                                });
                                return element;
                            };
                            
                            interfacePart.partLibrary.basic.text = function(name,data){ 
                                return interfacePart.collection.basic.text(
                                    name, data.text, data.x, data.y, data.width, data.height, data.angle, data.ignored, data.colour, data.font, data.printingMode, data.spacing, data.interCharacterSpacing
                                );
                            };
                            this.circleWithOutline = function(name=null, x=0, y=0, radius=10, detail=25, ignored=false, colour={r:1,g:0,b:1,a:1}, thickness=1, lineColour={r:0,g:0,b:0,a:1}){
                            
                                const element = _canvas_.core.element.create('circleWithOutline',name);
                                element.unifiedAttribute({
                                    x:x, 
                                    y:y, 
                                    radius:radius, 
                                    detail:detail, 
                                    thickness:thickness,
                                    ignored:ignored, 
                                    colour:colour,
                                    lineColour:lineColour,
                                });
                                return element;
                            };
                            
                            interfacePart.partLibrary.basic.circleWithOutline = function(name,data){ 
                                return interfacePart.collection.basic.circleWithOutline(
                                    name, data.x, data.y, data.radius, data.detail, data.ignored, data.colour, data.thickness, data.lineColour
                                );
                            };
                        };
                        this.display = new function(){
                            interfacePart.partLibrary.display = {};
                            this.glowbox_rectangle = function(
                                name='glowbox_rectangle',
                                x=0, y=0, width=30, height=30, angle=0,
                                glowStyle = {r:0.95,g:0.91,b:0.55,a:1},
                                dimStyle = {r:0.31,g:0.31,b:0.31,a:1},
                            ){
                            
                                //elements 
                                    const object = interfacePart.builder('basic','group',name,{x:x, y:y});
                                    const rectangle = interfacePart.builder('basic','rectangle','light',{ width:width, height:height, angle:angle, colour:dimStyle });
                                        object.append(rectangle);
                            
                                //methods
                                    object.on = function(){
                                        rectangle.colour(glowStyle);
                                    };
                                    object.off = function(){
                                        rectangle.colour(dimStyle);
                                    };
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.display.glowbox_rectangle = function(name,data){ 
                                return interfacePart.collection.display.glowbox_rectangle(
                                    name, data.x, data.y, data.width, data.height, data.angle, data.style.glow, data.style.dim
                                );
                            };
                            this.glowbox_polygon = function(
                                name='glowbox_polygon',
                                x=0, y=0, points=[{x:0,y:5},{x:5,y:0}, {x:25,y:0},{x:30,y:5}, {x:30,y:25},{x:25,y:30}, {x:5,y:30},{x:0,y:25}], angle=0, 
                                glowStyle = {r:0.95,g:0.91,b:0.55,a:1},
                                dimStyle = {r:0.31,g:0.31,b:0.31,a:1},
                            ){
                                
                                //elements 
                                    const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    const polygon = interfacePart.builder('basic','polygon','light',{ pointsAsXYArray:points, colour:dimStyle });
                                        object.append(polygon);
                            
                                //methods
                                    object.on = function(){
                                        polygon.colour(glowStyle);
                                    };
                                    object.off = function(){
                                        polygon.colour(dimStyle);
                                    };
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.display.glowbox_polygon = function(name,data){ 
                                return interfacePart.collection.display.glowbox_polygon(
                                    name, data.x, data.y, data.points, data.angle, data.style.glow, data.style.dim
                                );
                            };
                            this.glowbox_image = function(
                                name='glowbox_image',
                                x=0, y=0, width=30, height=30, angle=0,
                                glowURL='',
                                dimURL='',
                            ){
                                
                                //elements 
                                    const object = interfacePart.builder('basic','group',name,{x:x, y:y});
                                    const backing = interfacePart.builder('basic','image','backing',{width:width, height:height, angle:angle, url:dimURL});
                                    object.append(backing);
                            
                                //methods
                                    object.on = function(){
                                        backing.url(glowURL);
                                    };
                                    object.off = function(){
                                        backing.url(dimURL);
                                    };
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.display.glowbox_image = function(name,data){ 
                                return interfacePart.collection.display.glowbox_image(
                                    name, data.x, data.y, data.width, data.height, data.angle, data.glowURL, data.dimURL
                                );
                            };
                            this.glowbox_circle = function(
                                name='glowbox_circle',
                                x=0, y=0, radius=12.5,
                                glowStyle = {r:0.95,g:0.91,b:0.55,a:1},
                                dimStyle = {r:0.31,g:0.31,b:0.31,a:1},
                            ){
                            
                                //elements 
                                    const object = interfacePart.builder('basic','group',name,{x:x, y:y});
                                    const circle = interfacePart.builder('basic','circle','light',{ radius:radius, colour:dimStyle });
                                        object.append(circle);
                            
                                //methods
                                    object.on = function(){
                                        circle.colour(glowStyle);
                                    };
                                    object.off = function(){
                                        circle.colour(dimStyle);
                                    };
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.display.glowbox_circle = function(name,data){ 
                                return interfacePart.collection.display.glowbox_circle(
                                    name, data.x, data.y, data.radius, data.style.glow, data.style.dim
                                );
                            };
                            this.glowbox_path = function(
                                name='glowbox_path',
                                x=0, y=0, points=[{x:0,y:5},{x:5,y:0}, {x:25,y:0},{x:30,y:5}, {x:30,y:25},{x:25,y:30}, {x:5,y:30},{x:0,y:25}], angle=0, 
                                thickness=1, looping=false, jointType='sharp', capType='none', 
                                glowStyle = {r:0.95,g:0.91,b:0.55,a:1},
                                dimStyle = {r:0.31,g:0.31,b:0.31,a:1},
                            ){
                                
                                //elements 
                                    const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    const path = interfacePart.builder('basic','path','light',{ 
                                        pointsAsXYArray:points, 
                                        thickness:thickness,
                                        looping:looping, 
                                        colour:dimStyle,
                                        jointType:jointType,
                                        capType:capType,
                                    });
                                        object.append(path);
                            
                                //methods
                                    object.on = function(){
                                        path.colour(glowStyle);
                                    };
                                    object.off = function(){
                                        path.colour(dimStyle);
                                    };
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.display.glowbox_path = function(name,data){ 
                                return interfacePart.collection.display.glowbox_path(
                                    name, data.x, data.y, data.points, data.angle, 
                                    data.thickness, data.looping, data.jointType, data.capType,
                                    data.style.glow, data.style.dim
                                );
                            };
                            this.grapher_audioScope = function(
                                name='grapher_audioScope',
                                x, y, width=120, height=60, angle=0, canvasBased=false, resolution=5, 
                            
                                foregroundStyle={colour:{r:0,g:1,b:0,a:1}, thickness:0.5},
                                foregroundTextStyle={colour:{r:0.39,g:1,b:0.39,a:1}, size:7.5, font:'Helvetica'},
                            
                                backgroundStyle_colour={r:0,g:0.39,b:0,a:1},
                                backgroundStyle_lineThickness=0.25,
                                backgroundTextStyle_fill={r:0,g:0.59,b:0,a:1},
                                backgroundTextStyle_size=0.1,
                                backgroundTextStyle_font='Helvetica',
                            
                                backingStyle={r:0.2,g:0.2,b:0.2,a:1},
                            ){
                                //attributes
                                    const attributes = {
                                        analyser:{
                                            analyserNode: _canvas_.library.audio.context.createAnalyser(),
                                            timeDomainDataArray: null,
                                            frequencyData: null,
                                            refreshRate: 10,
                                            scopeRefreshInterval: null,
                                            returnedValueLimits: {min:0, max: 256, halfdiff:128},
                                        },
                                        graph:{
                                            resolution: 256
                                        }
                                    };
                                    attributes.analyser.analyserNode.fftSize = attributes.graph.resolution;
                                    attributes.analyser.timeDomainDataArray = new Uint8Array(attributes.analyser.analyserNode.fftSize);
                                    attributes.analyser.frequencyData = new Uint8Array(attributes.analyser.analyserNode.fftSize);
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    //grapher
                                        const grapher = interfacePart.builder('display','grapher',name,{
                                            x:0, y:0, width:width, height:height, canvasBased:canvasBased, resolution:resolution,
                                            foregroundStyles:[foregroundStyle], foregroundTextStyles:[foregroundTextStyle],
                                            backgroundStyle_colour:backgroundStyle_colour, 
                                            backgroundStyle_lineThickness:backgroundStyle_lineThickness,
                                            backgroundTextStyle_fill:backgroundTextStyle_fill, 
                                            backgroundTextStyle_size:backgroundTextStyle_size,
                                            backgroundTextStyle_font:backgroundTextStyle_font,
                                            backingStyle:backingStyle,
                                        });
                                        object.append(grapher);
                            
                                //utility functions
                                    function render(){
                                        const numbers = [];
                                        attributes.analyser.analyserNode.getByteTimeDomainData(attributes.analyser.timeDomainDataArray);
                                        for(let a = 0; a < attributes.analyser.timeDomainDataArray.length; a++){
                                            numbers.push(
                                                attributes.analyser.timeDomainDataArray[a]/attributes.analyser.returnedValueLimits.halfdiff - 1
                                            );
                                        }
                                        grapher.drawForeground(numbers);
                                    }
                                    function setBackground(){
                                        grapher.viewbox( {'l':-1.1,'h':1.1} );
                                        grapher.horizontalMarkings({points:[1,0.75,0.5,0.25,0,-0.25,-0.5,-0.75,-1],printText:false});
                                        grapher.verticalMarkings({points:[-0.25,-0.5,-0.75,0,0.25,0.5,0.75],printText:false});
                                        grapher.drawBackground();
                                    };
                            
                                //controls
                                    object.start = function(){
                                        if(attributes.analyser.scopeRefreshInterval == null){
                                            attributes.analyser.scopeRefreshInterval = setInterval(function(){render();},1000/attributes.analyser.refreshRate);
                                        }
                                    };
                                    object.stop = function(){
                                        clearInterval(attributes.analyser.scopeRefreshInterval);
                                        attributes.analyser.scopeRefreshInterval = null;
                                    };
                                    object.getNode = function(){return attributes.analyser.analyserNode;};
                                    object.resolution = function(res=null){
                                        if(res==null){return attributes.graph.resolution;}
                                        attributes.graph.resolution = res;
                                        this.stop();
                                        this.start();
                                    };
                                    object.refreshRate = function(a){
                                        if(a==null){return attributes.analyser.refreshRate;}
                                        attributes.analyser.refreshRate = a;
                                        this.stop();
                                        this.start();
                                    };
                            
                                //setup/tear down
                                    object.oncreate = function(){
                                        setBackground();
                                    };
                                    object.ondelete = function(){
                                        object.stop();
                                    };
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.display.grapher_audioScope = function(name,data){ 
                                return interfacePart.collection.display.grapher_audioScope(
                                    name, data.x, data.y, data.width, data.height, data.angle, data.canvasBased, data.resolution,
                                    data.style.foregrounds, data.style.foregroundText,
                                    data.style.background_colour, data.style.background_lineThickness,
                                    data.style.backgroundText_colour, data.style.backgroundText_size, data.style.backgroundText_font,
                                    data.style.backing,
                                ); 
                            };
                            this.grapher = function(
                                name='grapher',
                                x, y, width=120, height=60, angle=0, canvasBased=false, resolution=5,
                            
                                foregroundStyles=[
                                    {colour:{r:0,g:1,b:0,a:1}, thickness:0.5},
                                    {colour:{r:1,g:1,b:0,a:1}, thickness:0.5},
                                    {colour:{r:0,g:1,b:1,a:1}, thickness:0.5},
                                ],
                                foregroundTextStyles=[
                                    {colour:{r:0.39,g:1,b:0.39,a:1}, size:7.5, font:'Helvetica'},
                                    {colour:{r:1,g:1,b:0.39,a:1}, size:7.5, font:'Helvetica'},
                                    {colour:{r:0.39,g:1,b:1,a:1}, size:7.5, font:'Helvetica'},
                                ],
                            
                                backgroundStyle_colour={r:0,g:0.39,b:0,a:1},
                                backgroundStyle_lineThickness=0.25,
                                backgroundTextStyle_colour={r:0,g:0.58,b:0,a:1},
                                backgroundTextStyle_size=7.5,
                                backgroundTextStyle_font='Helvetica',
                                backgroundTextStyle_horizontalMarkings={ points:[0.75,0.5,0.25,0,-0.25,-0.5,-0.75], printingValues:[], mappedPosition:0, textPositionOffset:{x:1,y:-0.5}, printText:true },
                                backgroundTextStyle_verticalMarkings={ points:[0.75,0.5,0.25,0,-0.25,-0.5,-0.75], printingValues:[], mappedPosition:0, textPositionOffset:{x:1,y:-0.5}, printText:true },
                            
                                backingStyle={r:0.2,g:0.2,b:0.2,a:1},
                            ){
                                const viewbox = {'bottom':-1,'top':1,'left':-1,'right':1};
                                const foregroundElementsGroup = [];
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                            
                                //controls
                                    object.viewbox = function(a){
                                        if(a==null){return viewbox;}
                                        if( a.bottom != undefined ){viewbox.bottom = a.bottom;}
                                        if( a.top != undefined ){viewbox.top = a.top;}
                                        if( a.left != undefined ){viewbox.left = a.left;}
                                        if( a.right != undefined ){viewbox.right = a.right;}
                                    };
                                    object.horizontalMarkings = function(a){
                                        if(a==null){return backgroundTextStyle_horizontalMarkings;}
                                        if( a.points != undefined ){backgroundTextStyle_horizontalMarkings.points = a.points;}
                                        if( a.printingValues != undefined ){backgroundTextStyle_horizontalMarkings.printingValues = a.printingValues;}
                                        if( a.textPositionOffset != undefined ){backgroundTextStyle_horizontalMarkings.textPositionOffset = a.textPositionOffset;}
                                        if( a.printText != undefined ){backgroundTextStyle_horizontalMarkings.printText = a.printText;}
                                        if( a.mappedPosition != undefined ){backgroundTextStyle_horizontalMarkings.mappedPosition = a.mappedPosition;}
                                    };
                                    object.verticalMarkings = function(a){
                                        if(a==null){return backgroundTextStyle_verticalMarkings;}
                                        if( a.points != undefined ){backgroundTextStyle_verticalMarkings.points = a.points;}
                                        if( a.printingValues != undefined ){backgroundTextStyle_verticalMarkings.printingValues = a.printingValues;}
                                        if( a.textPositionOffset != undefined ){backgroundTextStyle_verticalMarkings.textPositionOffset = a.textPositionOffset;}
                                        if( a.printText != undefined ){backgroundTextStyle_verticalMarkings.printText = a.printText;}
                                        if( a.mappedPosition != undefined ){backgroundTextStyle_verticalMarkings.mappedPosition = a.mappedPosition;}
                                    };
                            
                                if(canvasBased){
                                    //elements
                                        const backingCanvas = interfacePart.builder('basic','canvas','backingCanvas',{ width:width, height:height, resolution:resolution });
                                            object.append(backingCanvas);
                                        const frontingCanvas = interfacePart.builder('basic','canvas','frontingCanvas',{ width:width, height:height, resolution:resolution });
                                            object.append(frontingCanvas);
                            
                                    //graphics
                                        function clearBackground(){
                                            backingCanvas._.fillStyle = _canvas_.library.math.convertColour.obj2rgba(backingStyle);
                                            backingCanvas._.fillRect(0,0,backingCanvas.$(width),backingCanvas.$(height));
                                            backingCanvas.requestUpdate();
                                        }
                                        function clearForeground(){
                                            frontingCanvas._.clearRect(0,0,frontingCanvas.$(width),frontingCanvas.$(height));
                                            frontingCanvas.requestUpdate();
                                        }
                                        function clearAll(){
                                            clearBackground();
                                            clearForeground();
                                        }
                                        function drawBackground(){
                                            //horizontal lines
                                                //calculate the x value for all parts of this section
                                                    const x = _canvas_.library.math.relativeDistance(width, viewbox.left,viewbox.right, backgroundTextStyle_horizontalMarkings.mappedPosition?backgroundTextStyle_horizontalMarkings.mappedPosition:0 );
                                
                                                //add all horizontal markings
                                                    for(let a = 0; a < backgroundTextStyle_horizontalMarkings.points.length; a++){
                                                        //check if we should draw this line at all
                                                            if( !(backgroundTextStyle_horizontalMarkings.points[a] < viewbox.top || backgroundTextStyle_horizontalMarkings.points[a] > viewbox.bottom) ){ continue; }
                                        
                                                        //calculate the y value for this section
                                                            const y = height - _canvas_.library.math.relativeDistance(height, viewbox.bottom,viewbox.top, backgroundTextStyle_horizontalMarkings.points[a]);
                                
                                                        //add line and text to group
                                                            //lines
                                                                backingCanvas._.fillStyle = 'rgba('+backgroundStyle_colour.r*255+','+backgroundStyle_colour.g*255+','+backgroundStyle_colour.b*255+','+backgroundStyle_colour.a+')';
                                                                backingCanvas._.fillRect(0,backingCanvas.$(y),backingCanvas.$(width),backingCanvas.$(backgroundStyle_lineThickness));
                                
                                                            //text
                                                                if( backgroundTextStyle_horizontalMarkings.printText ){
                                                                    backingCanvas._.fillStyle = 'rgba('+backgroundTextStyle_colour.r*255+','+backgroundTextStyle_colour.g*255+','+backgroundTextStyle_colour.b*255+','+backgroundTextStyle_colour.a+')';
                                                                    backingCanvas._.font = backgroundTextStyle_size*resolution/8 +'pt '+backgroundTextStyle_font;
                                                                    backingCanvas._.fillText(
                                                                        (backgroundTextStyle_horizontalMarkings.printingValues && backgroundTextStyle_horizontalMarkings.printingValues[a] != undefined) ? backgroundTextStyle_horizontalMarkings.printingValues[a] : backgroundTextStyle_horizontalMarkings.points[a],
                                                                        backingCanvas.$(x+backgroundTextStyle_horizontalMarkings.textPositionOffset.x),
                                                                        backingCanvas.$(y+backgroundTextStyle_horizontalMarkings.textPositionOffset.y),
                                                                    );
                                                                }
                                                    }
                                
                                            //vertical lines
                                                //calculate the y value for all parts of this section
                                                    const y = height - _canvas_.library.math.relativeDistance(height, viewbox.bottom,viewbox.top, backgroundTextStyle_verticalMarkings.mappedPosition?backgroundTextStyle_verticalMarkings.mappedPosition:0 );
                                
                                                //add all vertical markings
                                                    for(let a = 0; a < backgroundTextStyle_verticalMarkings.points.length; a++){
                                                        //check if we should draw this line at all
                                                            if( backgroundTextStyle_verticalMarkings.points[a] < viewbox.left || backgroundTextStyle_verticalMarkings.points[a] > viewbox.right ){ continue; }
                                
                                                        //calculate the x value for this section
                                                            const x = _canvas_.library.math.relativeDistance(width, viewbox.left,viewbox.right, backgroundTextStyle_verticalMarkings.points[a]);
                                
                                                        //add line and text to group
                                                            //lines
                                                                backingCanvas._.fillStyle = 'rgba('+backgroundStyle_colour.r*255+','+backgroundStyle_colour.g*255+','+backgroundStyle_colour.b*255+','+backgroundStyle_colour.a+')';
                                                                backingCanvas._.fillRect(backingCanvas.$(x),0,backingCanvas.$(backgroundStyle_lineThickness),backingCanvas.$(height));
                                                        
                                                            //text
                                                                if( backgroundTextStyle_verticalMarkings.printText ){
                                                                    backingCanvas._.fillStyle = 'rgba('+backgroundTextStyle_colour.r*255+','+backgroundTextStyle_colour.g*255+','+backgroundTextStyle_colour.b*255+','+backgroundTextStyle_colour.a+')';
                                                                    backingCanvas._.font = backgroundTextStyle_size*resolution/8 +'pt '+backgroundTextStyle_font;
                                                                    backingCanvas._.fillText(
                                                                        (backgroundTextStyle_verticalMarkings.printingValues && backgroundTextStyle_verticalMarkings.printingValues[a] != undefined) ? backgroundTextStyle_verticalMarkings.printingValues[a] : backgroundTextStyle_verticalMarkings.points[a],
                                                                        backingCanvas.$(x+backgroundTextStyle_verticalMarkings.textPositionOffset.x),
                                                                        backingCanvas.$(y+backgroundTextStyle_verticalMarkings.textPositionOffset.y),
                                                                    );
                                                                }
                                                    }
                                
                                                backingCanvas.requestUpdate();
                                        }
                                        function drawForeground(y,x,layer=0){
                                            //if both data sets of a layer are being set to undefined; set the whole layer to undefined
                                            //otherwise, just update the layer's data sets
                                                if(y == undefined && x == undefined){ foregroundElementsGroup[layer] = undefined; }
                                                else{ foregroundElementsGroup[layer] = {x:x, y:y}; }
                                
                                            //input check
                                                if( foregroundElementsGroup[layer] != undefined && foregroundElementsGroup[layer].y == undefined ){
                                                    console.warn('grapher_canvasBased error',name,'attempting to add line with no y component');
                                                    console.warn('x:',foregroundElementsGroup[layer].x);
                                                    console.warn('y:',foregroundElementsGroup[layer].y);
                                                    return;
                                                }
                                
                                            //draw layers
                                                for(let L = 0; L < foregroundElementsGroup.length; L++){
                                                    if(foregroundElementsGroup[L] == undefined){continue;}
                                
                                                    const layer = foregroundElementsGroup[L];
                                
                                                    //draw path
                                                        if(foregroundStyles[L] == undefined || foregroundStyles[L].colour == undefined){ console.warn('grapher: attempting to draw on layer with no styling information. Action not performed'); break; }
                                                        frontingCanvas._.strokeStyle = 'rgba('+foregroundStyles[L].colour.r*255+','+foregroundStyles[L].colour.g*255+','+foregroundStyles[L].colour.b*255+','+foregroundStyles[L].colour.a+')';
                                                        frontingCanvas._.lineWidth = frontingCanvas.$(foregroundStyles[L].thickness);
                                                        frontingCanvas._.lineJoin = foregroundStyles[L].lineJoin;
                                                        frontingCanvas._.lineCap = foregroundStyles[L].lineJoin;
                                                        frontingCanvas._.beginPath();
                                
                                                        if( layer.y != undefined && layer.x == undefined ){ //auto x print
                                                            frontingCanvas._.moveTo( 0, frontingCanvas.$( height - _canvas_.library.math.relativeDistance(height, viewbox.bottom,viewbox.top, layer.y[0], true) ) );
                                                            for(let a = 1; a < layer.y.length; a++){ 
                                                                frontingCanvas._.lineTo(
                                                                    frontingCanvas.$(a*(width/(layer.y.length-1))),
                                                                    frontingCanvas.$(height - _canvas_.library.math.relativeDistance(height, viewbox.bottom,viewbox.top, layer.y[a], true)),
                                                                );
                                                            }
                                                        }else if( layer.y.length == layer.x.length ){ //straight print
                                                            frontingCanvas._.moveTo( 
                                                                frontingCanvas.$(          _canvas_.library.math.relativeDistance(width, viewbox.left,viewbox.right, layer.x[0], true) ),
                                                                frontingCanvas.$( height - _canvas_.library.math.relativeDistance(height, viewbox.bottom,viewbox.top, layer.y[0], true) )
                                                            );
                                                            for(let a = 1; a < layer.y.length; a++){ 
                                                                frontingCanvas._.lineTo(
                                                                    frontingCanvas.$(          _canvas_.library.math.relativeDistance(width, viewbox.left,viewbox.right, layer.x[a], true) ),
                                                                    frontingCanvas.$( height - _canvas_.library.math.relativeDistance(height, viewbox.bottom,viewbox.top, layer.y[a], true) ),
                                                                );
                                                            }
                                                        }else{console.error('grapher_canvasBased::'+name,':layers are of different length:',layer.y,layer.x);}
                                
                                                        frontingCanvas._.stroke();
                                                }
                                                    
                                            frontingCanvas.requestUpdate();
                                        }
                            
                                    //controls
                                        object.resolution = function(a){
                                            return backingCanvas.resolution(a);
                                        };
                                        object.clearAll = function(){
                                            clearAll();
                                        };
                                        object.drawBackground = function(){
                                            clearBackground();
                                            drawBackground(); 
                                        };
                                        object.drawForeground = function(y,x,layer=0){ 
                                            clearForeground();
                                            drawForeground(y,x,layer); 
                                        };
                                        object.draw = function(y,x,layer=0){ 
                                            clearAll(); 
                                            drawBackground(); 
                                            drawForeground(y,x,layer); 
                                        };
                                }else{
                                    const fontSizeMux = 1/7;
                            
                                    //elements 
                                        //backing
                                            const backing = interfacePart.builder('basic','rectangle','backing',{width:width, height:height, colour:backingStyle});
                                            object.append(backing);
                                        //background group
                                            const backgroundGroup = interfacePart.builder('basic', 'group', 'background');
                                            object.append(backgroundGroup);
                                        //foreground group
                                            const foregroundGroup = interfacePart.builder( 'basic', 'group', 'foreground' );
                                            object.append(foregroundGroup);
                                        //stencil
                                            const stencil = interfacePart.builder('basic','rectangle','stencil',{width:width, height:height});
                                            object.stencil(stencil);
                                            object.clipActive(true);
                            
                                    //graphics
                                        function clearBackground(){
                                            backgroundGroup.clear();
                                        }
                                        function clearForeground(){
                                            foregroundGroup.clear();
                                        }
                                        function clearAll(){
                                            clearBackground();
                                            clearForeground();
                                        }
                                        function drawBackground(){
                                            backgroundGroup.clear();
                            
                                            //horizontal lines
                                                //calculate the x value for all parts of this section
                                                    const x = _canvas_.library.math.relativeDistance(width, viewbox.left,viewbox.right, backgroundTextStyle_horizontalMarkings.mappedPosition?backgroundTextStyle_horizontalMarkings.mappedPosition:0 );
                            
                                                //add all horizontal markings
                                                    for(let a = 0; a < backgroundTextStyle_horizontalMarkings.points.length; a++){
                                                        //check if we should draw this line at all
                                                            if( !(backgroundTextStyle_horizontalMarkings.points[a] < viewbox.top || backgroundTextStyle_horizontalMarkings.points[a] > viewbox.bottom) ){ continue; }
                                        
                                                        //calculate the y value for this section
                                                            const y = height - _canvas_.library.math.relativeDistance(height, viewbox.bottom,viewbox.top, backgroundTextStyle_horizontalMarkings.points[a]);
                            
                                                        //add line and text to group
                                                            //lines
                                                                const path = interfacePart.builder( 'basic', 'rectangle', 'horizontal_line_'+a, {x:0,y:y,width:width,height:backgroundStyle_lineThickness,colour:backgroundStyle_colour} );
                                                                backgroundGroup.append(path);
                            
                                                            //text
                                                                if( backgroundTextStyle_horizontalMarkings.printText ){
                                                                    const text = interfacePart.builder( 'basic', 'text', 'horizontal_text_'+a, {
                                                                        x:x+backgroundTextStyle_horizontalMarkings.textPositionOffset.x, y:y+backgroundTextStyle_horizontalMarkings.textPositionOffset.y - backgroundTextStyle_size*fontSizeMux,
                                                                        text:(backgroundTextStyle_horizontalMarkings.printingValues && backgroundTextStyle_horizontalMarkings.printingValues[a] != undefined) ? backgroundTextStyle_horizontalMarkings.printingValues[a] : backgroundTextStyle_horizontalMarkings.points[a],
                                                                        colour:backgroundTextStyle_colour,
                                                                        font:backgroundTextStyle_font,
                                                                        width:backgroundTextStyle_size*fontSizeMux, height:backgroundTextStyle_size*fontSizeMux,
                                                                        printingMode:{widthCalculation:'absolute',vertical:'top'}
                                                                    } );
                                                                    backgroundGroup.append(text);
                                                                }
                                                    }
                            
                                            //vertical lines
                                                //calculate the y value for all parts of this section
                                                    const y = height - _canvas_.library.math.relativeDistance(height, viewbox.bottom,viewbox.top, backgroundTextStyle_verticalMarkings.mappedPosition?backgroundTextStyle_verticalMarkings.mappedPosition:0 );
                            
                                                //add all vertical markings
                                                    for(let a = 0; a < backgroundTextStyle_verticalMarkings.points.length; a++){
                                                        //check if we should draw this line at all
                                                            if( backgroundTextStyle_verticalMarkings.points[a] < viewbox.left || backgroundTextStyle_verticalMarkings.points[a] > viewbox.right ){ continue; }
                            
                                                        //calculate the x value for this section
                                                            const x = _canvas_.library.math.relativeDistance(width, viewbox.left,viewbox.right, backgroundTextStyle_verticalMarkings.points[a]);
                            
                                                        //add line and text to group
                                                            //lines
                                                                const path = interfacePart.builder( 'basic', 'rectangle', 'vertical_line_'+a, {x:x,y:0,width:backgroundStyle_lineThickness,height:height,colour:backgroundStyle_colour} );
                                                                backgroundGroup.append(path);
                                                        
                                                            //text
                                                                if( backgroundTextStyle_verticalMarkings.printText ){
                                                                    const text = interfacePart.builder( 'basic', 'text', 'vertical_text_'+a, {
                                                                        x:x+backgroundTextStyle_verticalMarkings.textPositionOffset.x, y:y+backgroundTextStyle_horizontalMarkings.textPositionOffset.y - backgroundTextStyle_size*fontSizeMux,
                                                                        text:(backgroundTextStyle_verticalMarkings.printingValues && backgroundTextStyle_verticalMarkings.printingValues[a] != undefined) ? backgroundTextStyle_verticalMarkings.printingValues[a] : backgroundTextStyle_verticalMarkings.points[a],
                                                                        colour:backgroundTextStyle_colour, font:backgroundTextStyle_font,
                                                                        width:backgroundTextStyle_size*fontSizeMux, height:backgroundTextStyle_size*fontSizeMux,
                                                                        printingMode:{widthCalculation:'absolute',vertical:'top'}
                                                                    } );
                                                                    backgroundGroup.append(text);
                                                                }
                                                    }
                                        }
                                        function drawForeground(y,x,layer=0){
                                            foregroundGroup.clear();
                            
                                            //if both data sets of a layer are being set to undefined; set the whole layer to undefined
                                            //otherwise, just update the layer's data sets
                                                if(y == undefined && x == undefined){ foregroundElementsGroup[layer] = undefined; }
                                                else{ foregroundElementsGroup[layer] = {x:x, y:y}; }
                            
                                            //input check
                                                if( foregroundElementsGroup[layer] != undefined && foregroundElementsGroup[layer].y == undefined ){
                                                    console.warn('grapher error',name,'attempting to add line with no y component');
                                                    console.warn('x:',foregroundElementsGroup[layer].x);
                                                    console.warn('y:',foregroundElementsGroup[layer].y);
                                                    return;
                                                }
                            
                                            //draw layers
                                                for(let L = 0; L < foregroundElementsGroup.length; L++){
                                                    if(foregroundElementsGroup[L] == undefined){continue;}
                            
                                                    const layer = foregroundElementsGroup[L];
                                                    const points = [];
                            
                                                    //generate path points
                                                        if( layer.y != undefined && layer.x == undefined ){ //auto x print
                                                            for(let a = 0; a < layer.y.length; a++){ 
                                                                points.push( {
                                                                    x: a*(width/(layer.y.length-1)), 
                                                                    y: height - _canvas_.library.math.relativeDistance(height, viewbox.bottom,viewbox.top, layer.y[a], true),
                                                                } );
                                                            }
                                                        }else if( layer.y.length == layer.x.length ){ //straight print
                                                            for(let a = 0; a < layer.y.length; a++){ 
                                                                points.push( {
                                                                    x:          _canvas_.library.math.relativeDistance(width, viewbox.left,viewbox.right, layer.x[a], true), 
                                                                    y: height - _canvas_.library.math.relativeDistance(height, viewbox.bottom,viewbox.top, layer.y[a], true),
                                                                } );
                                                            }
                                                        }else{console.error('grapher::'+name,':layers are of different length:',layer.y,layer.x);}
                            
                                                    //create path shape and add it to the group
                                                        const tmp = interfacePart.builder( 'basic', 'path', 'layer_'+L, { 
                                                            pointsAsXYArray:points, 
                                                            colour:foregroundStyles[L].colour,
                                                            thickness:foregroundStyles[L].thickness,
                                                        });
                                                        foregroundGroup.append(tmp);
                                                }
                                        }
                            
                                    //controls
                                        object.resolution = function(a){console.warn('this isn\'t the canvasBased version of the grapher part');};
                            
                                        object.clearAll = function(){
                                            clearAll();
                                        };
                                        object.drawBackground = function(){
                                            clearBackground();
                                            drawBackground(); 
                                        };
                                        object.drawForeground = function(y,x,layer=0){ 
                                            clearForeground();
                                            drawForeground(y,x,layer); 
                                        };
                                        object.draw = function(y,x,layer=0){ 
                                            clearAll(); 
                                            drawBackground(); 
                                            drawForeground(y,x,layer); 
                                        };
                                }
                            
                                return(object);
                            };
                            
                            interfacePart.partLibrary.display.grapher = function(name,data){ 
                                return interfacePart.collection.display.grapher(
                                    name, data.x, data.y, data.width, data.height, data.angle, data.canvasBased, data.resolution,
                                    data.style.foregrounds, data.style.foregroundText,
                                    data.style.background_colour, data.style.background_lineThickness,
                                    data.style.backgroundText_colour, data.style.backgroundText_size, data.style.backgroundText_font,
                                    data.backgroundText_horizontalMarkings,
                                    data.backgroundText_verticalMarkings,
                                    data.style.backing,
                                );
                            };
                            this.grapher_periodicWave = function(
                                name='grapher_periodicWave',
                                x, y, width=120, height=60, angle=0, canvasBased=false, resolution=5, 
                            
                                foregroundStyle={colour:{r:0,g:1,b:0,a:1}, thickness:0.5},
                                foregroundTextStyle={colour:{r:0.39,g:1,b:0.39,a:1}, size:7.5, font:'Helvetica'},
                            
                                backgroundStyle_colour={r:0,g:0.39,b:0,a:1},
                                backgroundStyle_lineThickness=0.25,
                                backgroundTextStyle_fill={r:0,g:0.59,b:0,a:1},
                                backgroundTextStyle_size=0.1,
                                backgroundTextStyle_font='Helvetica',
                            
                                backingStyle={r:0.2,g:0.2,b:0.2,a:1},
                            ){
                                let wave = {'sin':[],'cos':[]};
                                let waveResolution = 50;
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    //grapher
                                        const grapher = interfacePart.builder('display','grapher',name,{
                                            x:0, y:0, width:width, height:height, canvasBased:canvasBased, resolution:resolution,
                                            foregroundStyles:[foregroundStyle], foregroundTextStyles:[foregroundTextStyle],
                                            backgroundStyle_colour:backgroundStyle_colour, 
                                            backgroundStyle_lineThickness:backgroundStyle_lineThickness,
                                            backgroundTextStyle_fill:backgroundTextStyle_fill, 
                                            backgroundTextStyle_size:backgroundTextStyle_size,
                                            backgroundTextStyle_font:backgroundTextStyle_font,
                                            backingStyle:backingStyle,
                                        });
                                        object.append(grapher);
                            
                                //controls
                                    object.wave = function(a=null,type=null){
                                        if(a==null){
                                            while(wave.sin.length < wave.cos.length){ wave.sin.push(0); }
                                            while(wave.sin.length > wave.cos.length){ wave.cos.push(0); }
                                            for(let a = 0; a < wave['sin'].length; a++){
                                                if( !wave['sin'][a] ){ wave['sin'][a] = 0; }
                                                if( !wave['cos'][a] ){ wave['cos'][a] = 0; }
                                            }
                                            return wave;
                                        }
                            
                                        if(type==null){
                                            wave = a;
                                        }
                                        switch(type){
                                            case 'sin': wave.sin = a; break;
                                            case 'cos': wave.cos = a; break;
                                            default: break;
                                        }
                                    };
                                    object.waveElement = function(type, mux, a){
                                        if(a==null){return wave[type][mux];}
                                        wave[type][mux] = a;
                                    };
                                    object.waveResolution = function(a=null){
                                        if(a==null){return waveResolution;}
                                        waveResolution = a;
                                    };
                                    object.updateBackground = function(){
                                        grapher.viewbox( {bottom:-1.1,top:1.1, left:0} );
                                        grapher.horizontalMarkings({points:[1,0.75,0.5,0.25,0,-0.25,-0.5,-0.75,-1],printText:true});
                                        grapher.verticalMarkings({points:[0,1/4,1/2,3/4],printText:true});
                                        grapher.drawBackground();
                                    };
                                    object.draw = function(){
                                        const data = [];
                                        let temp = 0;
                                        for(let a = 0; a <= waveResolution; a++){
                                            temp = 0;
                                            for(let b = 0; b < wave['sin'].length; b++){
                                                if(!wave['sin'][b]){wave['sin'][b]=0;} //cover missing elements
                                                temp += Math.sin(b*(2*Math.PI*(a/waveResolution)))*wave['sin'][b]; 
                                            }
                                            for(let b = 0; b < wave['cos'].length; b++){
                                                if(!wave['cos'][b]){wave['cos'][b]=0;} //cover missing elements
                                                temp += Math.cos(b*(2*Math.PI*(a/waveResolution)) )*wave['cos'][b]; 
                                            }
                                            data.push(temp);
                                        }
                                
                                        grapher.drawForeground( data );
                                    };
                                    object.reset = function(){
                                        this.wave({'sin':[],'cos':[]});
                                        this.waveResolution(50);
                                        this.updateBackground();
                                    };
                                    
                                return object;
                            };
                            
                            interfacePart.partLibrary.display.grapher_periodicWave = function(name,data){ 
                                return interfacePart.collection.display.grapher_periodicWave(
                                    name, data.x, data.y, data.width, data.height, data.angle, data.canvasBased, data.resolution,
                                    data.style.foregrounds, data.style.foregroundText,
                                    data.style.background_colour, data.style.background_lineThickness,
                                    data.style.backgroundText_colour, data.style.backgroundText_size, data.style.backgroundText_font,
                                    data.style.backing,
                                ); 
                            };
                            this.gauge = function(
                                name='gauge',
                                x, y, angle=0,
                                width=50, height=30,
                                needleAngleBounds=[{start:-Math.PI/6,end:Math.PI/6}],
                                needleArticulationPoints=[{x:1/2, y:1.2}],
                                backingStyle={r:0.04,g:0.04,b:0.04,a:1},
                                needleColours=[{r:0.98,g:0.98,b:0.98,a:1}],
                            ){
                                
                                const values = [];
                                const defaultBoundingAngles = {
                                    start:-Math.PI/6,
                                    end:Math.PI/6,
                                };
                                const defaultNeedleArticulationPoint = {
                                    x:1/2, y:1.2
                                };
                            
                                //elements
                                    const object = interfacePart.builder('basic', 'group', name, {x:x, y:y, angle:angle});
                                    const backing = interfacePart.builder('basic', 'rectangle', 'backing', {width:width, height:height, colour:backingStyle});
                                    const needleWindow = interfacePart.builder('basic', 'group', 'needleWindow', {});
                                    object.append(backing);
                                    object.append(needleWindow);
                            
                                    const needles = needleColours.map((needleColour,index) => {
                                        values.push(0);
                            
                                        const NAP = needleArticulationPoints[index] == undefined ? defaultNeedleArticulationPoint : needleArticulationPoints[index];
                                        const needleSize = { width: width/100, height: height*NAP.y };
                            
                                        return interfacePart.builder('basic','rectangle','needleBody_'+index,{
                                            x:width*NAP.x - needleSize.width/2, 
                                            y:height*1.1 + (needleSize.height-height), 
                                            width:needleSize.width, height:-needleSize.height, 
                                            colour:needleColour
                                        });
                                    });
                                    needles.forEach(element => needleWindow.prepend(element));
                                    
                                    const stencil = interfacePart.builder('basic','rectangle','stencil',{width:width, height:height});
                                    needleWindow.stencil(stencil);
                                    needleWindow.clipActive(true);
                            
                                //methods
                                    object.needle = function(value,layer=0){
                                        if(value==undefined){return values[layer];}
                            
                                        value = (value>1 ? 1 : value);
                                        value = (value<0 ? 0 : value);
                            
                                        values[layer] = value;
                            
                                        const boundingAngles = needleAngleBounds[layer] == undefined ? defaultBoundingAngles : needleAngleBounds[layer];
                                        needles[layer].angle( boundingAngles.start + (boundingAngles.end-boundingAngles.start)*value );
                                    }
                            
                                //setup
                                    for(let a = 0; a < needleColours.length; a++){
                                        object.needle(0,a);
                                    }
                            
                                return(object);
                            };
                            
                            interfacePart.partLibrary.display.gauge = function(name,data){ 
                                return interfacePart.collection.display.gauge(
                                    name, data.x, data.y, data.angle, data.width, data.height, 
                                    data.needleAngleBounds, data.needleArticulationPoint,
                                    data.style.backing, data.style.needles
                                ); 
                            };
                            this.meter_gauge = function(
                                name='meter_gauge',
                                x, y, angle=0,
                                width=50, height=30,
                            
                                needleAngleBounds=[{start:-Math.PI/6,end:Math.PI/6}],
                                backingStyle={r:0.04,g:0.04,b:0.04,a:1},
                                needleColours=[{r:0.98,g:0.98,b:0.98,a:1},{r:0.65,g:0.65,b:0.65,a:1}],
                            
                                markings={
                                    upper:'ABCDEF'.split(''),
                                    middle:[0,1,2,3,4,5,6,7,8,9,10],
                                    lower:[0,0.25,0.5,0.75,1],
                                },
                                markingStyle_fill={r:0.86,g:0.86,b:0.86,a:1},
                                markingStyle_font='Roboto-Regular',
                                markingStyle_printingMode={widthCalculation:'absolute', horizontal:'middle', vertical:'middle'},
                                markingStyle_size=2,
                            ){
                            
                                const defaultBoundingAngles = {
                                    start:-Math.PI/6,
                                    end:Math.PI/6,
                                };
                            
                                //elements
                                    const object = interfacePart.builder('display', 'gauge', name, {
                                        x:x, y:y, angle:angle,
                                        width:width, height:height, needleAngleBounds:needleAngleBounds,
                                        style:{ backing:backingStyle, needles:needleColours },
                                    });
                            
                                    function generateMark(angle,distance,text,name=''){
                                        const boundingAngles = needleAngleBounds[0] == undefined ? defaultBoundingAngles : needleAngleBounds[0];
                            
                                        const group = interfacePart.builder('basic', 'group', name, {
                                            x:width/2, y:height - height/10 + height/2.5, 
                                            angle:boundingAngles.start + (boundingAngles.end-boundingAngles.start)*angle
                                        });
                                        group.append(interfacePart.builder('basic','text', 'text_'+name+'_'+text, {
                                            x:0, y:-distance, 
                                            height:markingStyle_size, 
                                            width:markingStyle_size, 
                                            text:text, 
                                            colour:markingStyle_fill, 
                                            font:markingStyle_font,
                                            printingMode:markingStyle_printingMode,
                                        }));
                            
                                        return group;
                                    }
                                    Object.keys(markings).map(key => {
                                        markings[key].map((marking,index) => {
                                            const pos = index/(markings[key].length-1);
                                            let heightMux = 1.2;
                                            switch(key){
                                                case 'upper': heightMux = 1.2; break;
                                                case 'middle': heightMux = 1.0; break;
                                                case 'lower': heightMux = 0.8; break;
                                            }
                                            object.append( generateMark(pos, height*heightMux, marking, key+'_'+index) );
                                        });
                                    });
                            
                                //update intervals
                                    let mostRecentSetting = 0;
                                    let interval;
                                    if(needleColours.length > 1){
                                        const framesPerSecond = 25;
                                        const coolDownSpeed = ( 3/4 )/10;
                                        const coolDownSub = coolDownSpeed/framesPerSecond;
                            
                                        let coolDown = 0;
                                        interval = setInterval(function(){
                                            object.needle(mostRecentSetting,0);
                            
                                            if(coolDown>0){coolDown-=coolDownSub;}
                                            object.needle(coolDown,1);
                            
                                            if(mostRecentSetting > coolDown){coolDown = mostRecentSetting;}
                                        },1000/framesPerSecond);
                                    }
                            
                                //method
                                    object.set = function(a){
                                        if(a > 1){a = 1;}else if(a < 0){a = 0;}
                                        if(needleColours.length > 1){ mostRecentSetting = a; }
                                        else{ object.needle(a,0); }
                                    };
                            
                                //setup/tear down
                                    object.ondelete = function(){
                                        clearInterval(interval);
                                    };
                            
                                return(object);
                            };
                            
                            interfacePart.partLibrary.display.meter_gauge = function(name,data){ 
                                return interfacePart.collection.display.meter_gauge(
                                    name, data.x, data.y, data.angle, data.width, data.height,
                            
                                    data.needleAngleBounds,
                                    data.style.backing,
                                    data.style.needleColours,
                                
                                    data.markings,
                                    data.style.markingStyle_fill,
                                    data.style.markingStyle_font,
                                    data.style.markingStyle_printingMode,
                                    data.style.markingStyle_size,
                                ); 
                            };
                            this.meter_gauge_image = function(
                                name='meter_gauge_image',
                                x, y, angle=0,
                                width=50, height=30,
                            
                                needleAngleBounds=[{start:-Math.PI/6,end:Math.PI/6}],
                                backingURL='',
                                needleColours=[{r:0.98,g:0.98,b:0.98,a:1},{r:0.65,g:0.65,b:0.65,a:1}],
                                frontingURL,
                            ){
                                
                                //elements
                                    const object = interfacePart.builder('display', 'gauge_image', name, {
                                        x:x, y:y, angle:angle,
                                        width:width, height:height, needleAngleBounds:needleAngleBounds,
                                        style:{needles:needleColours},
                                        backingURL:backingURL, frontingURL:frontingURL,
                                    });
                            
                                //update intervals
                                    let mostRecentSetting = 0;
                                    let interval;
                                    if(needleColours.length > 1){
                                        const framesPerSecond = 25;
                                        const coolDownSpeed = ( 3/4 )/10;
                                        const coolDownSub = coolDownSpeed/framesPerSecond;
                            
                                        let coolDown = 0;
                                        interval = setInterval(function(){        
                                            object.needle(mostRecentSetting,0);
                            
                                            if(coolDown>0){coolDown-=coolDownSub;}
                                            object.needle(coolDown,1);
                            
                                            if(mostRecentSetting > coolDown){coolDown = mostRecentSetting;}
                                        },1000/framesPerSecond);
                                    }
                            
                                //method
                                    object.set = function(a){
                                        if(a > 1){a = 1;}else if(a < 0){a = 0;}
                                        if(needleColours.length > 1){ mostRecentSetting = a; }
                                        else{ object.needle(a,0); }
                                    };
                            
                                //setup/tear down
                                    object.ondelete = function(){
                                        clearInterval(interval);
                                    };
                            
                                return(object);
                            };
                            
                            interfacePart.partLibrary.display.meter_gauge_image = function(name,data){ 
                                return interfacePart.collection.display.meter_gauge_image(
                                    name, data.x, data.y, data.angle, data.width, data.height,
                            
                                    data.needleAngleBounds,
                                    data.backingURL,
                                    data.style.needleColours,
                                    data.frontingURL,
                                ); 
                            };
                            this.gauge_image = function(
                                name='gauge_image',
                                x, y, angle=0,
                                width=50, height=30,
                                needleAngleBounds=[{start:-Math.PI/6,end:Math.PI/6}],
                                needleArticulationPoints=[{x:1/2, y:1.2}],
                                backingURL='',
                                needleColours=[{r:0.98,g:0.98,b:0.98,a:1}],
                                frontingURL,
                            ){
                                
                                const values = [];
                                const defaultBoundingAngles = {
                                    start:-Math.PI/6,
                                    end:Math.PI/6,
                                };
                                const defaultNeedleArticulationPoint = {
                                    x:1/2, y:1.2
                                };
                            
                                //elements
                                    const object = interfacePart.builder('basic', 'group', name, {x:x, y:y, angle:angle});
                                    const backing = interfacePart.builder('basic','image','backing',{ width:width, height:height, url:backingURL });
                                    const needleWindow = interfacePart.builder('basic', 'group', 'needleWindow', {});
                                    object.append(backing);
                                    object.append(needleWindow);
                            
                                    const needles = needleColours.map((needleColour,index) => {
                                        values.push(0);
                            
                                        const NAP = needleArticulationPoints[index] == undefined ? defaultNeedleArticulationPoint : needleArticulationPoints[index];
                                        const needleSize = { width: width/100, height: height*NAP.y };
                            
                                        return interfacePart.builder('basic','rectangle','needleBody_'+index,{
                                            x:width*NAP.x - needleSize.width/2, 
                                            y:height*1.1 + (needleSize.height-height), 
                                            width:needleSize.width, height:-needleSize.height, 
                                            colour:needleColour
                                        });
                                    });
                                    needles.forEach(element => needleWindow.prepend(element));
                            
                                    const stencil = interfacePart.builder('basic','rectangle','stencil',{width:width, height:height});
                                    needleWindow.stencil(stencil);
                                    needleWindow.clipActive(true);
                            
                                    if(frontingURL != undefined){
                                        const fronting = interfacePart.builder('basic','image','fronting',{ width:width, height:height, url:frontingURL });
                                        object.append(fronting);
                                    }
                            
                                //methods
                                    object.needle = function(value,layer=0){
                                        if(value==undefined){return values[layer];}
                            
                                        value = (value>1 ? 1 : value);
                                        value = (value<0 ? 0 : value);
                            
                                        values[layer] = value;
                            
                                        const boundingAngles = needleAngleBounds[layer] == undefined ? defaultBoundingAngles : needleAngleBounds[layer];
                                        needles[layer].angle( boundingAngles.start + (boundingAngles.end-boundingAngles.start)*value );
                                    }
                            
                                //setup
                                    for(let a = 0; a < needleColours.length; a++){
                                        object.needle(0,a);
                                    }
                            
                                return(object);
                            };
                            
                            interfacePart.partLibrary.display.gauge_image = function(name,data){ 
                                return interfacePart.collection.display.gauge_image(
                                    name, data.x, data.y, data.angle, data.width, data.height,
                                    data.needleAngleBounds, data.needleArticulationPoint,
                                    data.backingURL, data.style.needles, data.frontingURL
                                ); 
                            };
                            this.audio_meter_level = function(
                                name='audio_meter_level',
                                x, y, angle=0,
                                width=20, height=60,
                                markings=[0.125,0.25,0.375,0.5,0.625,0.75,0.875],
                            
                                backingStyle={r:0.04,g:0.04,b:0.04,a:1},
                                levelStyles=[{r:0.98,g:0.98,b:0.98,a:1},{r:0.3,g:0.3,b:0.3,a:1}],
                                markingStyle_fill={r:0.86,g:0.86,b:0.86,a:1},
                                markingStyle_font='Roboto-Regular',
                                markingStyle_printingMode={widthCalculation:'absolute', horizontal:'left', vertical:'top'},
                                markingStyle_size=2,
                            ){
                            
                                //elements
                                    const object = _canvas_.interface.part.builder('display', 'meter_level', name, {
                                        x:x, y:y, angle:angle, width:width, height:height, style:{
                                            backing:backingStyle,
                                            levels:levelStyles,
                                            markingStyle_fill:markingStyle_fill,
                                            markingStyle_font:markingStyle_font,
                                            markingStyle_printingMode:markingStyle_printingMode,
                                            markingStyle_size:markingStyle_size,
                                        }
                                    });
                            
                                //circuitry
                                    const converter = interface.circuit.audio2percentage()
                                    converter.newValue = function(val){object.set(val);};
                            
                                //audio connections
                                    object.audioIn = function(){ return converter.audioIn() };
                            
                                //methods
                                    object.start = function(){
                                        converter.start();
                                    };
                                    object.stop = function(){
                                        converter.stop();
                                    };
                            
                                //setup/tear down
                                    object._ondelete = object.ondelete;
                                    object.ondelete = function(){
                                        object.stop();
                                        object._ondelete();
                                    };
                            
                                return(object);
                            };
                            
                            interfacePart.partLibrary.display.audio_meter_level = function(name,data){ 
                                return interfacePart.collection.display.audio_meter_level(
                                    name, data.x, data.y, data.angle, data.width, data.height, data.markings, 
                                    data.style.backing, data.style.levels, data.style.markingStyle_colour, data.style.markingStyle_font, data.style.markingStyle_printingMode, data.style.markingStyle_size
                                ); 
                            };
                            this.meter_level = function(
                                name='meter_level',
                                x, y, angle=0,
                                width=20, height=60,
                                markings=[0.125,0.25,0.375,0.5,0.625,0.75,0.875],
                            
                                backingStyle={r:0.04,g:0.04,b:0.04,a:1},
                                levelStyles=[{r:0.98,g:0.98,b:0.98,a:1},{r:0.3,g:0.3,b:0.3,a:1}],
                                markingStyle_fill={r:0.86,g:0.86,b:0.86,a:1},
                                markingStyle_font='Roboto-Regular',
                                markingStyle_printingMode={widthCalculation:'absolute', horizontal:'left', vertical:'top'},
                                markingStyle_size=2,
                            ){
                            
                                levelStyles = levelStyles.reverse();
                                
                                //elements
                                    const object = _canvas_.interface.part.builder('display', 'level', name, {x:x, y:y, angle:angle, width:width, height:height, style:{ backing:backingStyle, levels:levelStyles },});
                            
                                    const markThickness = 0.2;
                                    function makeMark(y){
                                        const path = [ {x:width, y:y-markThickness/2}, {x:width-width/4, y:y-markThickness/2}, {x:width-width/4, y:y+markThickness/2}, {x:width, y:y+markThickness/2} ];
                                        return interfacePart.builder('basic','polygon', 'mark_'+y, {
                                            pointsAsXYArray:path,
                                            colour:markingStyle_fill,
                                        });
                                    }
                                    function insertText(y,text){
                                        return interfacePart.builder('basic','text', 'text_'+text, {x:0.5, y:y-0.5, height:markingStyle_size, width:markingStyle_size, text:text, colour:markingStyle_fill, font:markingStyle_font, printingMode:markingStyle_printingMode });
                                    }
                                    const markAndText = markings.map(marking => makeMark(height*(1-marking))).concat( markings.map(marking => insertText(height*(1-marking),marking)) );
                                    markAndText.forEach(element => object.append(element));
                            
                                //update intervals
                                    const framesPerSecond = 15;
                                    const coolDownSpeed = ( 3/4 )/10;
                                    const coolDownSub = coolDownSpeed/framesPerSecond;
                            
                                    let coolDown = 0;
                                    let mostRecentSetting = 0;
                                    const interval = setInterval(function(){        
                                        object.layer(mostRecentSetting,1);
                            
                                        if(coolDown>0){coolDown-=coolDownSub;}
                                        object.layer(coolDown,0);
                            
                                        if(mostRecentSetting > coolDown){coolDown = mostRecentSetting;}
                                    },1000/framesPerSecond);
                                    
                                //method
                                    object.set = function(a){
                                        if(a > 1){a = 1;}else if(a < 0){a = 0;}
                                        mostRecentSetting = a;
                                    };
                            
                                //setup/tear down
                                    object.ondelete = function(){
                                        clearInterval(interval);
                                    };
                            
                                return(object);
                            };
                            
                            interfacePart.partLibrary.display.meter_level = function(name,data){ 
                                return interfacePart.collection.display.meter_level(
                                    name, data.x, data.y, data.angle, data.width, data.height, data.markings,
                                    data.style.backing, data.style.levels, data.style.markingStyle_colour, data.style.markingStyle_font, data.style.markingStyle_printingMode, data.style.markingStyle_size
                                ); 
                            };
                            this.level = function(
                                name='level',
                                x, y, angle=0,
                                width=20, height=60,
                                backingStyle={r:0.04,g:0.04,b:0.04,a:1},
                                levelStyles=[{r:0.98,g:0.98,b:0.98,a:1},{r:0.78,g:0.78,b:0.78,a:1}]
                            ){
                                
                                const values = [];
                            
                                //elements
                                    const object = _canvas_.interface.part.builder('basic', 'group', name, {x:x, y:y, angle:angle});
                                    const rectangle = _canvas_.interface.part.builder('basic', 'rectangle', 'backing', {width:width, height:height, colour:backingStyle});
                                        object.append(rectangle);
                                    
                                    const levels =  levelStyles.map( (levelStyle,index) => {
                                        return _canvas_.interface.part.builder('basic', 'rectangle', 'movingRect_'+index, {y:height, width:width, height:0, colour:levelStyle});
                                    } );
                                    levels.forEach(element => object.append(element));
                            
                                //methods
                                    object.layer = function(value,layer){
                                        if(layer == undefined){return values;}
                                        if(value == null){return values[layer];}
                            
                                        value = (value>1 ? 1 : value);
                                        value = (value<0 ? 0 : value);
                            
                                        values[layer] = value;
                            
                                        levels[layer].height( height*value );
                                        levels[layer].y( height - height*value );
                                    };
                            
                                return(object);
                            };
                            
                            interfacePart.partLibrary.display.level = function(name,data){ 
                                return interfacePart.collection.display.level(
                                    name, data.x, data.y, data.angle, data.width, data.height, 
                                    data.style.backing, data.style.levels
                                ); 
                            };
                            this.rastorDisplay = function(
                                name='rastorDisplay',
                                x, y, angle=0, width=60, height=60,
                                xCount=8, yCount=8, xGappage=0.1, yGappage=0.1,
                                backingColour={r:0.2,g:0.2,b:0.2,a:1}, defaultPixelValue={r:0,g:0,b:0,a:1},
                            ){
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    //backing
                                        const backing = interfacePart.builder('basic','rectangle','backing',{ width:width, height:height, colour:backingColour });
                                        object.append(backing);
                                    //pixels
                                        const pixelGroup = interfacePart.builder('basic','group','pixels');
                                        object.append(pixelGroup);
                            
                                        const pixels = [];
                                        const pixelValues = [];
                                        const pixWidth = width/xCount;
                                        const pixHeight = height/yCount;
                            
                                        for(let x = 0; x < xCount; x++){
                                            const temp_pixels = [];
                                            const temp_pixelValues = [];
                                            for(let y = 0; y < yCount; y++){
                                                let rectangle = interfacePart.builder('basic','rectangle',x+'_'+y,{ 
                                                    x:(x*pixWidth)+xGappage/2,  y:(y*pixHeight)+yGappage/2, 
                                                    width:pixWidth-xGappage,    height:pixHeight-yGappage,
                                                    colour:defaultPixelValue,
                                                });
                                                    
                                                temp_pixels.push(rectangle);
                                                temp_pixelValues.push([0,0,0]);
                                                pixelGroup.append(rectangle);
                                            }
                                            pixels.push(temp_pixels);
                                            pixelValues.push(temp_pixelValues);
                                        }
                            
                                //graphical update
                                    function render(){
                                        for(let x = 0; x < xCount; x++){
                                            for(let y = 0; y < yCount; y++){
                                                pixels[x][y].colour({r:pixelValues[x][y][0],g:pixelValues[x][y][1],b:pixelValues[x][y][2],a:1});
                                            }
                                        }
                                    }
                            
                                //control
                                    object.get = function(x,y){ return pixelValues[x][y]; };
                                    object.set = function(x,y,state){ 
                                        pixelValues[x][y] = state; render();
                                    };
                                    object.import = function(data){
                                        for(let x = 0; x < xCount; x++){
                                            for(let y = 0; y < yCount; y++){
                                                this.set(x,y,data[x][y]);
                                            }
                                        }
                                        render();
                                    };
                                    object.export = function(){ return pixelValues; }
                                    object.setAll = function(value){
                                        for(let x = 0; x < xCount; x++){
                                            for(let y = 0; y < yCount; y++){
                                                this.set(x,y,value);
                                            }
                                        }
                                    }
                                    object.test = function(){
                                        this.setAll([1,1,1]);
                                        this.set(1,1,[1,0.5,0.5]);
                                        this.set(2,2,[0.5,1,0.5]);
                                        this.set(3,3,[0.5,0.5,1]);
                                        this.set(4,4,[1,0.5,1]);
                                        render();
                                    };
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.display.rastorDisplay = function(name,data){ 
                                return interfacePart.collection.display.rastorDisplay(
                                    name, data.x, data.y, data.angle, data.width, data.height, data.xCount, data.yCount, data.xGappage, data.yGappage
                                ); 
                            };
                            this.readout_sevenSegmentDisplay = function(
                                name='readout_sevenSegmentDisplay', canvasBased=false, resolution=1, 
                                x=0, y=0, width=100, height=30, count=5, angle=0, decimalPlaces=!false,
                                backgroundStyle={r:0,g:0,b:0,a:1},
                                glowStyle={r:0.78,g:0.78,b:0.78,a:1},
                                dimStyle={r:0.1,g:0.1,b:0.1,a:1},
                            ){
                                
                                //values
                                    let text = '';
                                    let displayInterval = null;
                                    const displayIntervalTime = 150;
                                //elements 
                                    const object = interfacePart.builder('basic','group',name,{x:x, y:y});
                            
                                if(canvasBased){
                                    const margin = (width/8) / count;
                                    const division = (width/8) / count;
                                    const shapes = {
                                        segments:{
                                            points: {
                                                top:{
                                                    left:[
                                                        {x:division*1.0+margin,         y:division*1.0+margin},
                                                        {x:division*0.5+margin,         y:division*0.5+margin},
                                                        {x:division*1.0+margin,         y:division*0.0+margin},
                                                        {x:division*0.0+margin,         y:division*1.0+margin},
                                                    ],
                                                    right:[
                                                        {x:width/count-division*1.0-margin,   y:division*0.0+margin},
                                                        {x:width/count-division*0.5-margin,   y:division*0.5+margin},
                                                        {x:width/count-division*1.0-margin,   y:division*1.0+margin},
                                                        {x:width/count-division*0.0-margin,   y:division*1.0+margin}
                                                    ]
                                                },
                                                middle: {
                                                    left:[
                                                        {x:division*1.0+margin,         y:height*0.5-division*1.0+margin*0.5},
                                                        {x:division*0.5+margin,         y:height*0.5-division*0.5+margin*0.5},
                                                        {x:division*1.0+margin,         y:height*0.5-division*0.0+margin*0.5},
                                                        {x:division*0.0+margin,         y:height*0.5-division*1.0+margin*0.5},
                                                        {x:division*0.0+margin,         y:height*0.5-division*0.0+margin*0.5},
                                                    ],
                                                    right:[
                                                        {x:width/count-division*1.0-margin,   y:height*0.5-division*0.0+margin*0.5},
                                                        {x:width/count-division*0.5-margin,   y:height*0.5-division*0.5+margin*0.5},
                                                        {x:width/count-division*1.0-margin,   y:height*0.5-division*1.0+margin*0.5},
                                                        {x:width/count-division*0.0-margin,   y:height*0.5-division*1.0+margin*0.5},
                                                        {x:width/count-division*0.0-margin,   y:height*0.5-division*0.0+margin*0.5}
                                                    ]
                                                },
                                                bottom: {
                                                    left:[
                                                        {x:division*1.0+margin,         y:height-division*1.0-margin},
                                                        {x:division*0.5+margin,         y:height-division*0.5-margin},
                                                        {x:division*1.0+margin,         y:height-division*0.0-margin},
                                                        {x:division*0.0+margin,         y:height-division*1.0-margin},
                                                    ],
                                                    right:[
                                                        {x:width/count-division*1.0-margin,   y:height-division*0.0-margin},
                                                        {x:width/count-division*0.5-margin,   y:height-division*0.5-margin},
                                                        {x:width/count-division*1.0-margin,   y:height-division*1.0-margin},
                                                        {x:width/count-division*0.0-margin,   y:height-division*1.0-margin}
                                                    ]
                                                }
                                            }
                                        }
                                    };
                                    const segmentPointArray = [
                                        [
                                            shapes.segments.points.top.left[0],
                                            shapes.segments.points.top.right[2],
                                            shapes.segments.points.top.right[1],
                                            shapes.segments.points.top.right[0],
                                            shapes.segments.points.top.left[2],
                                            shapes.segments.points.top.left[1],
                                        ],
                                        [
                                            shapes.segments.points.top.left[1],
                                            shapes.segments.points.top.left[3],
                                            shapes.segments.points.middle.left[3],
                                            shapes.segments.points.middle.left[1],
                                            shapes.segments.points.middle.left[0],
                                            shapes.segments.points.top.left[0],  
                                        ],
                                        [
                                            shapes.segments.points.top.right[1],  
                                            shapes.segments.points.top.right[3],  
                                            shapes.segments.points.middle.right[3],
                                            shapes.segments.points.middle.right[1],
                                            shapes.segments.points.middle.right[2],
                                            shapes.segments.points.top.right[2],  
                                        ],
                                        [
                                            shapes.segments.points.middle.left[0], 
                                            shapes.segments.points.middle.right[2],
                                            shapes.segments.points.middle.right[1],
                                            shapes.segments.points.middle.right[0],
                                            shapes.segments.points.middle.left[2], 
                                            shapes.segments.points.middle.left[1], 
                                        ],
                                        [
                                            shapes.segments.points.middle.left[1],
                                            shapes.segments.points.middle.left[4],
                                            shapes.segments.points.bottom.left[3],
                                            shapes.segments.points.bottom.left[1],
                                            shapes.segments.points.bottom.left[0],
                                            shapes.segments.points.middle.left[2],
                                        ],
                                        [
                                            shapes.segments.points.middle.right[1],
                                            shapes.segments.points.middle.right[4],
                                            shapes.segments.points.bottom.right[3],
                                            shapes.segments.points.bottom.right[1],
                                            shapes.segments.points.bottom.right[2],
                                            shapes.segments.points.middle.right[0],
                                        ],
                                        [
                                            shapes.segments.points.bottom.left[0],
                                            shapes.segments.points.bottom.right[2],
                                            shapes.segments.points.bottom.right[1],
                                            shapes.segments.points.bottom.right[0],
                                            shapes.segments.points.bottom.left[2],
                                            shapes.segments.points.bottom.left[1],
                                        ]
                                    ];
                                    function getStamp(character){
                                        
                                        switch(character){
                                            case 0: case '0': return [1,1,1,0,1,1,1];
                                            case 1: case '1': return [0,0,1,0,0,1,0];
                                            case 2: case '2': return [1,0,1,1,1,0,1];
                                            case 3: case '3': return [1,0,1,1,0,1,1];
                                            case 4: case '4': return [0,1,1,1,0,1,0];
                                            case 5: case '5': return [1,1,0,1,0,1,1];
                                            case 6: case '6': return [1,1,0,1,1,1,1];
                                            case 7: case '7': return [1,0,1,0,0,1,0];
                                            case 8: case '8': return [1,1,1,1,1,1,1];
                                            case 9: case '9': return [1,1,1,1,0,1,1];
                                            default: return [0,0,0,0,0,0,0];
                                        }
                                    }
                            
                                    //values
                                        const stamps = (new Array(count)).fill().map(() => [0,0,0,0,0,0,0]);
                                        const decimalPoints = (new Array(count-1)).fill().map(() => false);
                                        const decimalPointRadius = height*0.05;
                            
                                    //elements 
                                        const canvas = interfacePart.builder('basic','canvas','backing',{ width:width, height:height, colour:backgroundStyle,resolution:resolution });
                                            object.append(canvas);
                            
                                    //internal
                                        function clear(requestUpdate=true){
                                            canvas._.fillStyle = _canvas_.library.math.convertColour.obj2rgba(backgroundStyle);
                                            canvas._.fillRect(0,0,canvas.$(width),canvas.$(height));
                                            if(requestUpdate){canvas.requestUpdate();}
                                        };
                                        function drawCharacters(){
                            
                                            stamps.forEach((stamp,stampIndex) => {
                                                const xOffset = stampIndex*(width/count);
                            
                                                segmentPointArray.forEach((segmentPoints, segmentPointsIndex) => {
                                                    canvas._.beginPath(); 
                                                    canvas._.moveTo(
                                                        canvas.$(segmentPoints[0].x + xOffset),
                                                        canvas.$(segmentPoints[0].y)
                                                    );
                                                    for(let a = 1; a < segmentPoints.length; a++){
                                                        canvas._.lineTo(
                                                            canvas.$(segmentPoints[a].x + xOffset),
                                                            canvas.$(segmentPoints[a].y)
                                                        );
                                                    }
                                                    canvas._.closePath(); 
                                                    canvas._.fillStyle = stamp[segmentPointsIndex] == 0 ? _canvas_.library.math.convertColour.obj2rgba(dimStyle) : _canvas_.library.math.convertColour.obj2rgba(glowStyle);
                                                    canvas._.fill(); 
                                                });
                                            });
                            
                                            if(decimalPlaces){
                                                decimalPoints.forEach((state,index) => {
                                                    canvas._.beginPath();
                                                    canvas._.arc( canvas.$( (index+1)*(width/count) ), canvas.$(height - 2*decimalPointRadius), canvas.$(decimalPointRadius), 0, 2*Math.PI );
                                                    canvas._.fillStyle = state == 0 ? _canvas_.library.math.convertColour.obj2rgba(dimStyle) : _canvas_.library.math.convertColour.obj2rgba(glowStyle);
                                                    canvas._.fill(); 
                            
                                                });
                                            }
                            
                                            canvas.requestUpdate();
                                        }
                                        function print(style,offset=0,dontClear=false){
                                            
                                            if(decimalPlaces){ decimalPoints.forEach((point,index) => decimalPoints[index] = false); }
                                            if(!dontClear){ clearInterval(displayInterval); }
                            
                                            switch(style){
                                                case 'smart':
                                                    if(decimalPlaces){
                                                        if(text.replace('.','').length > stamps.length){print('r2lSweep');}
                                                        else{print('regular');}
                                                    }else{
                                                        if(text.length > stamps.length){print('r2lSweep');}
                                                        else{print('regular');}
                                                    }
                                                break;
                                                case 'r2lSweep':
                                                    let displayStage = -stamps.length;
                            
                                                    displayInterval = setInterval(function(){
                                                        print('regular',-displayStage,true);
                                                        displayStage++;
                                                        if(text[displayStage] == "."){
                                                            displayStage++;
                                                        }
                                                        if(displayStage > stamps.length+text.length-1){
                                                            displayStage=-stamps.length;
                                                        }
                                                    },displayIntervalTime);
                                                break;
                                                case 'regular': default:
                                                    let textIndex = 0;
                                                    for(let a = offset; a < stamps.length; a++){
                                                        if(stamps[a] == undefined){ textIndex++; continue; }
                            
                                                        if(decimalPlaces && text[textIndex] == '.'){
                                                            if(decimalPoints[a-1] != undefined){
                                                                decimalPoints[a-1] = true;
                                                            }
                                                            a--;
                                                        }else{
                                                            stamps[a] = getStamp(text[textIndex]);
                                                        }
                                                        textIndex++;
                                                    }
                                                break;
                                            }
                            
                                            clear(false);
                                            drawCharacters();
                                        }
                            
                                    //methods
                                        object.text = function(a){
                                            if(a==null){return text;}
                                            text = a;
                                        };
                                        object.print = function(style){
                                            print(style);
                                        };  
                            
                                    //setup/tear down
                                        object.oncreate = function(){
                                            clear();
                                            drawCharacters();
                                        };
                                        object.ondelete = function(){
                                            clearInterval(displayInterval);
                                        };
                                }else{
                                    //elements 
                                        //display units
                                            const units = (new Array(count)).fill().map((a,index) => {
                                                return interfacePart.builder('display', 'sevenSegmentDisplay', ''+index, {
                                                    x:(width/count)*index, width:width/count, height:height, 
                                                    canvasBased:canvasBased, resolution:resolution,
                                                    style:{background:backgroundStyle, glow:glowStyle, dim:dimStyle}
                                                });
                                            });
                                            units.forEach(element => object.append(element));
                                        //decimal point
                                            let decimalPoints = [];
                                            if(decimalPlaces){
                                                decimalPoints = (new Array(count-1)).fill().map((a,index) => {
                                                    return interfacePart.builder('display', 'glowbox_circle', 'decimalPoint_'+index, {
                                                        x:(width/count)*(index+1), y:height*0.9, radius:((width/count)/8)/2,
                                                        style:{glow:glowStyle, dim:dimStyle},
                                                    });
                                                });
                                                decimalPoints.forEach(element => object.append(element));
                                            }
                            
                                    //methods
                                        function print(style,offset=0,dontClear=false){
                                            
                                            decimalPoints.forEach(point => point.off());
                                            if(!dontClear){ clearInterval(displayInterval); }
                            
                                            switch(style){
                                                case 'smart':
                                                    if(decimalPlaces){
                                                        if(text.replace('.','').length > units.length){print('r2lSweep');}
                                                        else{print('regular');}
                                                    }else{
                                                        if(text.length > units.length){print('r2lSweep');}
                                                        else{print('regular');}
                                                    }
                                                break;
                                                case 'r2lSweep':
                                                    let displayStage = -units.length;
                            
                                                    displayInterval = setInterval(function(){
                                                        print('regular',-displayStage,true);
                                                        displayStage++;if(displayStage > units.length+text.length-1){displayStage=-units.length;}
                                                    },displayIntervalTime);
                                                break;
                                                case 'regular': default:
                                                    let textIndex = 0;
                                                    for(let a = offset; a < units.length; a++){
                                                        if(units[a] == undefined){ textIndex++; continue; }
                            
                                                        if(decimalPlaces && text[textIndex] == '.'){
                                                            if(decimalPoints[a-1] != undefined){decimalPoints[a-1].on();}
                                                            a--;
                                                        }else{ units[a].enterCharacter(text[textIndex]); }
                                                        textIndex++;
                                                    }
                                                break;
                                            }
                                        }
                            
                                        object.text = function(a){
                                            if(a==null){return text;}
                                            text = a;
                                        };
                                        object.print = function(style){
                                            print(style);
                                        };  
                                }
                            
                                return(object);
                            };
                            
                            interfacePart.partLibrary.display.readout_sevenSegmentDisplay = function(name,data){ 
                                return interfacePart.collection.display.readout_sevenSegmentDisplay(
                                    name, data.canvasBased, data.resolution, data.x, data.y, data.width, data.height, data.count, data.angle, data.decimalPlaces,
                                    data.style.background, data.style.glow, data.style.dim,
                                ); 
                            };
                            this.sevenSegmentDisplay = function(
                                name='sevenSegmentDisplay', canvasBased=false, resolution=2, 
                                x=0, y=0, width=20, height=30, angle=0,
                                backgroundStyle={r:0,g:0,b:0,a:1},
                                glowStyle={r:0.78,g:0.78,b:0.78,a:1},
                                dimStyle={r:0.1,g:0.1,b:0.1,a:1},
                            ){
                                
                                const margin = width/8;
                                const division = width/8;
                                const shapes = {
                                    segments:{
                                        points: {
                                            top:{
                                                left:[
                                                    {x:division*1.0+margin,         y:division*1.0+margin},
                                                    {x:division*0.5+margin,         y:division*0.5+margin},
                                                    {x:division*1.0+margin,         y:division*0.0+margin},
                                                    {x:division*0.0+margin,         y:division*1.0+margin},
                                                ],
                                                right:[
                                                    {x:width-division*1.0-margin,   y:division*0.0+margin},
                                                    {x:width-division*0.5-margin,   y:division*0.5+margin},
                                                    {x:width-division*1.0-margin,   y:division*1.0+margin},
                                                    {x:width-division*0.0-margin,   y:division*1.0+margin}
                                                ]
                                            },
                                            middle: {
                                                left:[
                                                    {x:division*1.0+margin,         y:height*0.5-division*1.0+margin*0.5},
                                                    {x:division*0.5+margin,         y:height*0.5-division*0.5+margin*0.5},
                                                    {x:division*1.0+margin,         y:height*0.5-division*0.0+margin*0.5},
                                                    {x:division*0.0+margin,         y:height*0.5-division*1.0+margin*0.5},
                                                    {x:division*0.0+margin,         y:height*0.5-division*0.0+margin*0.5},
                                                ],
                                                right:[
                                                    {x:width-division*1.0-margin,   y:height*0.5-division*0.0+margin*0.5},
                                                    {x:width-division*0.5-margin,   y:height*0.5-division*0.5+margin*0.5},
                                                    {x:width-division*1.0-margin,   y:height*0.5-division*1.0+margin*0.5},
                                                    {x:width-division*0.0-margin,   y:height*0.5-division*1.0+margin*0.5},
                                                    {x:width-division*0.0-margin,   y:height*0.5-division*0.0+margin*0.5}
                                                ]
                                            },
                                            bottom: {
                                                left:[
                                                    {x:division*1.0+margin,         y:height-division*1.0-margin},
                                                    {x:division*0.5+margin,         y:height-division*0.5-margin},
                                                    {x:division*1.0+margin,         y:height-division*0.0-margin},
                                                    {x:division*0.0+margin,         y:height-division*1.0-margin},
                                                ],
                                                right:[
                                                    {x:width-division*1.0-margin,   y:height-division*0.0-margin},
                                                    {x:width-division*0.5-margin,   y:height-division*0.5-margin},
                                                    {x:width-division*1.0-margin,   y:height-division*1.0-margin},
                                                    {x:width-division*0.0-margin,   y:height-division*1.0-margin}
                                                ]
                                            }
                                        }
                                    }
                                };
                                const points = [
                                    [
                                        shapes.segments.points.top.left[0],
                                        shapes.segments.points.top.right[2],
                                        shapes.segments.points.top.right[1],
                                        shapes.segments.points.top.right[0],
                                        shapes.segments.points.top.left[2],
                                        shapes.segments.points.top.left[1],
                                    ],
                                    [
                                        shapes.segments.points.top.left[1],
                                        shapes.segments.points.top.left[3],
                                        shapes.segments.points.middle.left[3],
                                        shapes.segments.points.middle.left[1],
                                        shapes.segments.points.middle.left[0],
                                        shapes.segments.points.top.left[0],  
                                    ],
                                    [
                                        shapes.segments.points.top.right[1],  
                                        shapes.segments.points.top.right[3],  
                                        shapes.segments.points.middle.right[3],
                                        shapes.segments.points.middle.right[1],
                                        shapes.segments.points.middle.right[2],
                                        shapes.segments.points.top.right[2],  
                                    ],
                                    [
                                        shapes.segments.points.middle.left[0], 
                                        shapes.segments.points.middle.right[2],
                                        shapes.segments.points.middle.right[1],
                                        shapes.segments.points.middle.right[0],
                                        shapes.segments.points.middle.left[2], 
                                        shapes.segments.points.middle.left[1], 
                                    ],
                                    [
                                        shapes.segments.points.middle.left[1],
                                        shapes.segments.points.middle.left[4],
                                        shapes.segments.points.bottom.left[3],
                                        shapes.segments.points.bottom.left[1],
                                        shapes.segments.points.bottom.left[0],
                                        shapes.segments.points.middle.left[2],
                                    ],
                                    [
                                        shapes.segments.points.middle.right[1],
                                        shapes.segments.points.middle.right[4],
                                        shapes.segments.points.bottom.right[3],
                                        shapes.segments.points.bottom.right[1],
                                        shapes.segments.points.bottom.right[2],
                                        shapes.segments.points.middle.right[0],
                                    ],
                                    [
                                        shapes.segments.points.bottom.left[0],
                                        shapes.segments.points.bottom.right[2],
                                        shapes.segments.points.bottom.right[1],
                                        shapes.segments.points.bottom.right[0],
                                        shapes.segments.points.bottom.left[2],
                                        shapes.segments.points.bottom.left[1],
                                    ]
                                ];
                                function getStamp(character){
                                    
                                    switch(character){
                                        case 0: case '0': return [1,1,1,0,1,1,1];
                                        case 1: case '1': return [0,0,1,0,0,1,0];
                                        case 2: case '2': return [1,0,1,1,1,0,1];
                                        case 3: case '3': return [1,0,1,1,0,1,1];
                                        case 4: case '4': return [0,1,1,1,0,1,0];
                                        case 5: case '5': return [1,1,0,1,0,1,1];
                                        case 6: case '6': return [1,1,0,1,1,1,1];
                                        case 7: case '7': return [1,0,1,0,0,1,0];
                                        case 8: case '8': return [1,1,1,1,1,1,1];
                                        case 9: case '9': return [1,1,1,1,0,1,1];
                            
                                        case 'a': case 'A': return [1,1,1,1,1,1,0];
                                        case 'b': case 'B': return [0,1,0,1,1,1,1];
                                        case 'c': case 'C': return [1,1,0,0,1,0,1];
                                        case 'd': case 'D': return [0,0,1,1,1,1,1];
                                        case 'e': case 'E': return [1,1,0,1,1,0,1];
                                        case 'f': case 'F': return [1,1,0,1,1,0,0];
                            
                                        default: return [0,0,0,0,0,0,0];
                                    }
                                }
                            
                                if(canvasBased){
                                    let stamp = [0,0,0,0,0,0,0];
                            
                                    //elements 
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y});
                                        const canvas = interfacePart.builder('basic','canvas','backing',{ width:width, height:height, colour:backgroundStyle,resolution:resolution });
                                            object.append(canvas);
                            
                                    //graphics
                                        function clear(){
                            
                                            canvas._.fillStyle = _canvas_.library.math.convertColour.obj2rgba(backgroundStyle);
                                            canvas._.fillRect(0,0,canvas.$(width),canvas.$(height));
                                            canvas.requestUpdate();
                                        };
                                        function drawChar(){
                            
                                            //draw segments in 
                                                for(let a = 0; a < points.length; a++){
                                                    canvas._.beginPath(); 
                                                    canvas._.moveTo(canvas.$(points[a][0].x),canvas.$(points[a][0].y));
                                                    for(let b = 1; b < points[a].length; b++){
                                                        canvas._.lineTo(canvas.$(points[a][b].x),canvas.$(points[a][b].y));
                                                    }
                                                    canvas._.closePath(); 
                                                    canvas._.fillStyle = stamp[a] == 0 ? _canvas_.library.math.convertColour.obj2rgba(dimStyle) : _canvas_.library.math.convertColour.obj2rgba(glowStyle);
                                                    canvas._.fill(); 
                                                }
                                                canvas.requestUpdate();
                                        }
                            
                                    //methods
                                        object.set = function(segment,state){
                                            clear();
                                            stamp[segment] = state;
                                            drawChar();
                                        };
                                        object.get = function(segment){ 
                                            if(segment==undefined){
                                                console.error('sevenSegmentDisplay_canvasBased::get: must provide segment value'); 
                                                return;
                                            } 
                                            return stamp[segment].state;
                                        };
                                        object.clear = function(){
                                            clear();
                                            for(let a = 0; a < stamp.length; a++){
                                                this.set(a,false);
                                            }
                                            drawChar();
                                        };
                            
                                        object.enterCharacter = function(char){
                                            stamp = getStamp(char);
                            
                                            clear();
                                            drawChar();
                                        };
                            
                                    //setup
                                        clear();
                                        drawChar();
                            
                                    return object;
                                }else{
                                    //elements 
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y});
                                        const backing = interfacePart.builder('basic','rectangle','backing',{ width:width, height:height, angle:angle, colour:backgroundStyle });
                                            object.append(backing);
                            
                                        //segments
                                            const segments = [];
                                            for(let a = 0; a < points.length; a++){
                                                segments[a] = {
                                                    segment:interfacePart.builder('basic','polygon','segment_'+a,{ pointsAsXYArray:points[a], colour:dimStyle }), 
                                                    state:false
                                                };
                                                object.append(segments[a].segment);
                                            }
                            
                                        //methods
                                            object.set = function(segment,state){
                                                segments[segment].state = state;
                                                if(state){ segments[segment].segment.colour(glowStyle); }
                                                else{ segments[segment].segment.colour(dimStyle); }
                                            };
                                            object.get = function(segment){
                                                return segments[segment].state;
                                            };
                                            object.clear = function(){
                                                for(let a = 0; a < segments.length; a++){
                                                    this.set(a,false);
                                                }
                                            };
                            
                                            object.enterCharacter = function(char){
                                                stamp = getStamp(char);
                            
                                                for(let a = 0; a < stamp.length; a++){
                                                    this.set(a, stamp[a]==1);
                                                }
                                            };
                                                
                                    return object;
                                }
                            };
                            
                            interfacePart.partLibrary.display.sevenSegmentDisplay = function(name,data){ 
                                return interfacePart.collection.display.sevenSegmentDisplay(
                                    name, data.canvasBased, data.resolution, data.x, data.y, data.width, data.height, data.angle,
                                    data.style.background, data.style.glow, data.style.dim
                                );
                            };
                            this.sixteenSegmentDisplay = function(
                                name='sixteenSegmentDisplay', canvasBased=false, resolution=2, 
                                x=0, y=0, width=20, height=30, angle=0,
                                backgroundStyle={r:0,g:0,b:0,a:1},
                                glowStyle={r:0.78,g:0.78,b:0.78,a:1},
                                dimStyle={r:0.1,g:0.1,b:0.1,a:1},
                            ){
                                
                                const margin = width/8;
                                const division = width/8;
                                const shapes = {
                                    segments:{
                                        points: {
                                            top:{
                                                left:[
                                                    {x:division*0.5+margin,         y:division*0.5+margin},  //centre
                                                    {x:division*1.0+margin,         y:division*0.0+margin},  //top
                                                    {x:division*0.0+margin,         y:division*1.0+margin},  //left
                                                    {x:division*1.0+margin,         y:division*1.0+margin},  //inner point
                                                    {x:division*1.75+margin,        y:division*1.0+margin},  //inner point right
                                                    {x:division*1.0+margin,         y:division*1.75+margin}, //inner point down
                                                ],
                                                centre:[
                                                    {x:width/2,                     y:division*0.5+margin}, //central point
                                                    {x:width/2-division*0.5,        y:division*1.0+margin}, //lower left
                                                    {x:width/2+division*0.5,        y:division*1.0+margin}, //lower right
                                                    {x:width/2-division*0.5,        y:division*0.0+margin}, //upper left
                                                    {x:width/2+division*0.5,        y:division*0.0+margin}, //upper right
                                                ],
                                                right:[
                                                    {x:width-division*0.5-margin,   y:division*0.5+margin},  //centre
                                                    {x:width-division*1.0-margin,   y:division*0.0+margin},  //top
                                                    {x:width-division*0.0-margin,   y:division*1.0+margin},  //right
                                                    {x:width-division*1.0-margin,   y:division*1.0+margin},  //inner point
                                                    {x:width-division*1.0-margin,   y:division*1.75+margin}, //inner point down
                                                    {x:width-division*1.75-margin,  y:division*1.0+margin},  //inner point left
                                                ]
                                            },
                                            middle:{
                                                left:[
                                                    {x:division*0.0+margin,         y:height*0.5-division*0.5}, //top left
                                                    {x:division*1.0+margin,         y:height*0.5-division*0.5}, //top right
                                                    {x:division*0.5+margin,         y:height*0.5-division*0.0}, //centre
                                                    {x:division*0.0+margin,         y:height*0.5+division*0.5}, //bottom left
                                                    {x:division*1.0+margin,         y:height*0.5+division*0.5}, //bottom right
                                                ],
                                                centre:[
                                                    {x:width/2,                     y:height/2},                //central point
                                                    {x:width/2-division*0.5,        y:division*0.5+height/2},   //lower left
                                                    {x:width/2-division*0.25,       y:division*1.25+height/2},  //lower left down
                                                    {x:width/2-division*1.0,        y:division*0.5+height/2},   //lower left left
                                                    {x:width/2+division*0.5,        y:division*0.5+height/2},   //lower right
                                                    {x:width/2+division*0.5,        y:division*1.75+height/2},  //lower right down
                                                    {x:width/2+division*1.0,        y:division*0.5+height/2},   //lower right right
                                                    {x:width/2-division*0.5,        y:-division*0.5+height/2},  //upper left
                                                    {x:width/2-division*0.25,       y:-division*1.25+height/2}, //upper left up
                                                    {x:width/2-division*1.0,        y:-division*0.25+height/2}, //upper left left
                                                    {x:width/2+division*0.5,        y:-division*0.5+height/2},  //upper right
                                                    {x:width/2+division*0.5,        y:-division*1.75+height/2}, //upper right up
                                                    {x:width/2+division*1.0,        y:-division*0.25+height/2}, //upper right right
                                                ],
                                                right:[
                                                    {x:width-division*1.0-margin,   y:height*0.5-division*0.5}, //top left
                                                    {x:width-division*0.0-margin,   y:height*0.5-division*0.5}, //top right
                                                    {x:width-division*0.5-margin,   y:height*0.5-division*0.0}, //centre
                                                    {x:width-division*1.0-margin,   y:height*0.5+division*0.5}, //bottom left
                                                    {x:width-division*0.0-margin,   y:height*0.5+division*0.5}  //bottom right
                                                ]
                                            },
                                            bottom: {
                                                left:[
                                                    {x:division*0.5+margin,         y:height-division*0.5-margin}, //centre
                                                    {x:division*0.0+margin,         y:height-division*1.0-margin}, //left
                                                    {x:division*1.0+margin,         y:height-division*0.0-margin}, //bottom
                                                    {x:division*1.0+margin,         y:height-division*1.0-margin}, //inner point
                                                    {x:division*1.0+margin,         y:height-division*1.75-margin},//inner point up
                                                    {x:division*1.75+margin,        y:height-division*1.0-margin}, //inner point right
                                                ],
                                                centre:[
                                                    {x:width/2-division*0.5,        y:height-division*1.0-margin}, //upper left
                                                    {x:width/2+division*0.5,        y:height-division*1.0-margin}, //upper right
                                                    {x:width/2,                     y:height-division*0.5-margin}, //central point
                                                    {x:width/2-division*0.5,        y:height-division*0.0-margin}, //lower left
                                                    {x:width/2+division*0.5,        y:height-division*0.0-margin}, //lower right
                                                ],
                                                right:[
                                                    {x:width-division*0.5-margin,   y:height-division*0.5-margin}, //centre
                                                    {x:width-division*0.0-margin,   y:height-division*1.0-margin}, //right
                                                    {x:width-division*1.0-margin,   y:height-division*0.0-margin}, //bottom
                                                    {x:width-division*1.0-margin,   y:height-division*1.0-margin}, //inner point
                                                    {x:width-division*1.0-margin,   y:height-division*1.75-margin},//inner point up
                                                    {x:width-division*1.75-margin,  y:height-division*1.0-margin}, //inner point left
                                                ]
                                            }
                                        }
                                    }
                                };
                                const points = [
                                    [
                                        shapes.segments.points.top.left[1],
                                        shapes.segments.points.top.left[0],
                                        shapes.segments.points.top.left[3],
                                        shapes.segments.points.top.centre[1],
                                        shapes.segments.points.top.centre[0],
                                        shapes.segments.points.top.centre[3],
                                    ],
                                    [
                                        shapes.segments.points.top.centre[4],
                                        shapes.segments.points.top.centre[0],
                                        shapes.segments.points.top.centre[2],
                                        shapes.segments.points.top.right[3],
                                        shapes.segments.points.top.right[0],
                                        shapes.segments.points.top.right[1],
                                    ],
                            
                                    [
                                        shapes.segments.points.top.left[0],
                                        shapes.segments.points.top.left[2],
                                        shapes.segments.points.middle.left[0],
                                        shapes.segments.points.middle.left[2],
                                        shapes.segments.points.middle.left[1],
                                        shapes.segments.points.top.left[3],
                                    ],
                                    [
                                        shapes.segments.points.top.left[4],
                                        shapes.segments.points.top.left[3],
                                        shapes.segments.points.top.left[5],
                                        shapes.segments.points.middle.centre[9],
                                        shapes.segments.points.middle.centre[7],
                                        shapes.segments.points.middle.centre[8],
                                    ],
                                    [
                                        shapes.segments.points.top.centre[0],
                                        shapes.segments.points.top.centre[1],
                                        shapes.segments.points.middle.centre[7],
                                        shapes.segments.points.middle.centre[0],
                                        shapes.segments.points.middle.centre[10],
                                        shapes.segments.points.top.centre[2],
                                    ],
                                    [
                                        shapes.segments.points.top.right[4],
                                        shapes.segments.points.top.right[3],
                                        shapes.segments.points.top.right[5],
                                        shapes.segments.points.middle.centre[11],
                                        shapes.segments.points.middle.centre[10],
                                        shapes.segments.points.middle.centre[12],
                                    ],
                                    [
                                        shapes.segments.points.top.right[0],
                                        shapes.segments.points.top.right[2],
                                        shapes.segments.points.middle.right[1],
                                        shapes.segments.points.middle.right[2],
                                        shapes.segments.points.middle.right[0],
                                        shapes.segments.points.top.right[3],
                                    ],
                            
                                    [
                                        shapes.segments.points.middle.left[4],
                                        shapes.segments.points.middle.left[2],
                                        shapes.segments.points.middle.left[1],
                                        shapes.segments.points.middle.centre[7],
                                        shapes.segments.points.middle.centre[0],
                                        shapes.segments.points.middle.centre[1],
                                    ],
                                    [
                                        shapes.segments.points.middle.right[3],
                                        shapes.segments.points.middle.right[2],
                                        shapes.segments.points.middle.right[0],
                                        shapes.segments.points.middle.centre[10],
                                        shapes.segments.points.middle.centre[0],
                                        shapes.segments.points.middle.centre[4],
                                    ],
                            
                                    [
                                        shapes.segments.points.bottom.left[0],
                                        shapes.segments.points.bottom.left[1],
                                        shapes.segments.points.middle.left[3],
                                        shapes.segments.points.middle.left[2],
                                        shapes.segments.points.middle.left[4],
                                        shapes.segments.points.bottom.left[3],
                                    ],
                                    [
                                        shapes.segments.points.bottom.left[4],
                                        shapes.segments.points.bottom.left[3],
                                        shapes.segments.points.bottom.left[5],
                                        shapes.segments.points.middle.centre[2],
                                        shapes.segments.points.middle.centre[1],
                                        shapes.segments.points.middle.centre[3],
                                    ],
                                    [
                                        shapes.segments.points.bottom.centre[0],
                                        shapes.segments.points.bottom.centre[2],
                                        shapes.segments.points.bottom.centre[1],
                                        shapes.segments.points.middle.centre[4],
                                        shapes.segments.points.middle.centre[0],
                                        shapes.segments.points.middle.centre[1],
                                    ],
                                    [
                                        shapes.segments.points.bottom.right[4],
                                        shapes.segments.points.bottom.right[3],
                                        shapes.segments.points.bottom.right[5],
                                        shapes.segments.points.middle.centre[5],
                                        shapes.segments.points.middle.centre[4],
                                        shapes.segments.points.middle.centre[6],
                                    ],
                                    [
                                        shapes.segments.points.bottom.right[3],
                                        shapes.segments.points.middle.right[3],
                                        shapes.segments.points.middle.right[2],
                                        shapes.segments.points.middle.right[4],
                                        shapes.segments.points.bottom.right[1],
                                        shapes.segments.points.bottom.right[0],
                                    ],
                            
                                    [
                                        shapes.segments.points.bottom.left[2],
                                        shapes.segments.points.bottom.left[0],
                                        shapes.segments.points.bottom.left[3],
                                        shapes.segments.points.bottom.centre[0],
                                        shapes.segments.points.bottom.centre[2],
                                        shapes.segments.points.bottom.centre[3],
                                    ],
                                    [
                                        shapes.segments.points.bottom.right[2],
                                        shapes.segments.points.bottom.right[0],
                                        shapes.segments.points.bottom.right[3],
                                        shapes.segments.points.bottom.centre[1],
                                        shapes.segments.points.bottom.centre[2],
                                        shapes.segments.points.bottom.centre[4],
                                    ],
                                ];
                                function getStamp(character){
                            
                                    switch(character){
                                        case '!': 
                                            return [
                                                1,1,
                                                0,1,1,1,0,
                                                0,0,
                                                0,0,0,0,0,
                                                1,1,
                                            ]; 
                                        case '?': 
                                            return [
                                                1,1,
                                                0,0,0,0,1,
                                                0,1,
                                                0,0,0,0,0,
                                                1,1,
                                            ]; 
                                        case '.': 
                                            return [
                                                0,0,
                                                0,0,0,0,0,
                                                0,0,
                                                0,0,0,0,0,
                                                1,0,
                                            ]; 
                                        case ',': 
                                            return [
                                                0,0,
                                                0,0,0,0,0,
                                                0,0,
                                                0,0,1,0,0,
                                                0,0,
                                            ]; 
                                        case '\'': 
                                            return [
                                                0,0,
                                                1,0,0,0,0,
                                                0,0,
                                                0,0,0,0,0,
                                                0,0,
                                            ]; 
                                        case ':':
                                            return [
                                                0,0,
                                                0,1,0,1,0,
                                                0,0,
                                                0,1,0,1,0,
                                                0,0,
                                            ]; 
                                        case '"': 
                                            return [
                                                0,0,
                                                1,0,1,0,0,
                                                0,0,
                                                0,0,0,0,0,
                                                0,0,
                                            ]; 
                                        case '_': 
                                            return [
                                                0,0,
                                                0,0,0,0,0,
                                                0,0,
                                                0,0,0,0,0,
                                                1,1,
                                            ]; 
                                        case '-': 
                                            return [
                                                0,0,
                                                0,0,0,0,0,
                                                1,1,
                                                0,0,0,0,0,
                                                0,0,
                                            ]; 
                                        case '\\': 
                                            return [
                                                0,0,
                                                0,1,0,0,0,
                                                0,0,
                                                0,0,0,1,0,
                                                0,0,
                                            ]; 
                                        case '/': 
                                            return [
                                                0,0,
                                                0,0,0,1,0,
                                                0,0,
                                                0,1,0,0,0,
                                                0,0,
                                            ]; 
                                        case '*': 
                                            return [
                                                0,0,
                                                0,1,1,1,0,
                                                1,1,
                                                0,1,1,1,0,
                                                0,0,
                                            ]; 
                                        case '#': 
                                            return [
                                                1,1,
                                                1,0,1,0,1,
                                                1,1,
                                                1,0,1,0,1,
                                                1,1,
                                            ]; 
                                        case '<': 
                                            return [
                                                0,0,
                                                0,0,0,1,0,
                                                0,0,
                                                0,0,0,1,0,
                                                0,0,
                                            ]; 
                                        case '>': 
                                            return [
                                                0,0,
                                                0,1,0,0,0,
                                                0,0,
                                                0,1,0,0,0,
                                                0,0,
                                            ]; 
                                        case '(': 
                                            return [
                                                0,1,
                                                0,0,1,0,0,
                                                0,0,
                                                0,0,1,0,0,
                                                0,1,
                                            ]; 
                                        case ')': 
                                            return [
                                                1,0,
                                                0,0,1,0,0,
                                                0,0,
                                                0,0,1,0,0,
                                                1,0,
                                            ]; 
                                        case '[': 
                                            return [
                                                1,1,
                                                1,0,0,0,0,
                                                0,0,
                                                1,0,0,0,0,
                                                1,1,
                                            ]; 
                                        case ']': 
                                            return [
                                                1,1,
                                                0,0,0,0,1,
                                                0,0,
                                                0,0,0,0,1,
                                                1,1,
                                            ]; 
                                        case '{': 
                                            return [
                                                1,1,
                                                0,1,0,0,0,
                                                1,0,
                                                0,1,0,0,0,
                                                1,1,
                                            ]; 
                                        case '}': 
                                            return [
                                                1,1,
                                                0,0,0,1,0,
                                                0,1,
                                                0,0,0,1,0,
                                                1,1,
                                            ]; 
                            
                                        case '0': case 0: 
                                            return [
                                                1,1,
                                                1,0,0,1,1,
                                                0,0,
                                                1,1,0,0,1,
                                                1,1,
                                            ]; 
                                        case '1': case 1: 
                                            return [
                                                1,0,
                                                0,0,1,0,0,
                                                0,0,
                                                0,0,1,0,0,
                                                1,1,
                                            ]; 
                                        case '2': case 2: 
                                            return [
                                                1,1,
                                                0,0,0,0,1,
                                                0,1,
                                                0,1,0,0,0,
                                                1,1,
                                            ]; 
                                        case '3': case 3:
                                            return [
                                                1,1,
                                                0,0,0,0,1,
                                                1,1,
                                                0,0,0,0,1,
                                                1,1,
                                            ]; 
                                        case '4': case 4:
                                            return [
                                                0,0,
                                                1,0,0,0,1,
                                                1,1,
                                                0,0,0,0,1,
                                                0,0,
                                            ]; 
                                        case '5': case 5:
                                            return [
                                                1,1,
                                                1,0,0,0,0,
                                                1,1,
                                                0,0,0,0,1,
                                                1,1,
                                            ]; 
                                        case '6': case 6:
                                            return [
                                                1,1,
                                                1,0,0,0,0,
                                                1,1,
                                                1,0,0,0,1,
                                                1,1,
                                            ]; 
                                        case '7': case 7:
                                            return [
                                                1,1,
                                                0,0,0,1,0,
                                                0,0,
                                                0,1,0,0,0,
                                                0,0,
                                            ]; 
                                        case '8': case 8:
                                            return [
                                                1,1,
                                                1,0,0,0,1,
                                                1,1,
                                                1,0,0,0,1,
                                                1,1,
                                            ]; 
                                        case '9': case 9:
                                            return [
                                                1,1,
                                                1,0,0,0,1,
                                                1,1,
                                                0,0,0,0,1,
                                                1,1,
                                            ]; 
                            
                                        case 'a': case 'A': 
                                            return [
                                                1,1,
                                                1,0,0,0,1,
                                                1,1,
                                                1,0,0,0,1,
                                                0,0,
                                            ]; 
                                        case 'b': case 'B': 
                                            return [
                                                1,1,
                                                0,0,1,0,1,
                                                0,1,
                                                0,0,1,0,1,
                                                1,1,
                                            ]; 
                                        case 'c': case 'C': 
                                            return [
                                                1,1,
                                                1,0,0,0,0,
                                                0,0,
                                                1,0,0,0,0,
                                                1,1,
                                            ]; 
                                        case 'd': case 'D': 
                                            return [
                                                1,1,
                                                0,0,1,0,1,
                                                0,0,
                                                0,0,1,0,1,
                                                1,1,
                                            ]; 
                                        case 'e': case 'E': 
                                            return [
                                                1,1,
                                                1,0,0,0,0,
                                                1,1,
                                                1,0,0,0,0,
                                                1,1,
                                            ]; 
                                        case 'f': case 'F': 
                                            return [
                                                1,1,
                                                1,0,0,0,0,
                                                1,1,
                                                1,0,0,0,0,
                                                0,0,
                                            ]; 
                                        case 'g': case 'G': 
                                            return [
                                                1,1,
                                                1,0,0,0,0,
                                                0,1,
                                                1,0,0,0,1,
                                                1,1,
                                            ]; 
                                        case 'h': case 'H': 
                                            return [
                                                0,0,
                                                1,0,0,0,1,
                                                1,1,
                                                1,0,0,0,1,
                                                0,0,
                                            ]; 
                                        case 'i': case 'I': 
                                            return [
                                                1,1,
                                                0,0,1,0,0,
                                                0,0,
                                                0,0,1,0,0,
                                                1,1,
                                            ]; 
                                        case 'j': case 'J': 
                                            return [
                                                1,1,
                                                0,0,1,0,0,
                                                0,0,
                                                0,0,1,0,0,
                                                1,0,
                                            ]; 
                                        case 'k': case 'K': 
                                            return [
                                                0,0,
                                                1,0,0,1,0,
                                                1,0,
                                                1,0,0,1,0,
                                                0,0,
                                            ]; 
                                        case 'l': case 'L': 
                                            return [
                                                0,0,
                                                1,0,0,0,0,
                                                0,0,
                                                1,0,0,0,0,
                                                1,1,
                                            ]; 
                                        case 'm': case 'M': 
                                            return [
                                                0,0,
                                                1,1,0,1,1,
                                                0,0,
                                                1,0,0,0,1,
                                                0,0,
                                            ]; 
                                        case 'n': case 'N': 
                                            return [
                                                0,0,
                                                1,1,0,0,1,
                                                0,0,
                                                1,0,0,1,1,
                                                0,0,
                                            ]; 
                                        case 'o': case 'O': 
                                            return [
                                                1,1,
                                                1,0,0,0,1,
                                                0,0,
                                                1,0,0,0,1,
                                                1,1,
                                            ]; 
                                        case 'p': case 'P': 
                                            return [
                                                1,1,
                                                1,0,0,0,1,
                                                1,1,
                                                1,0,0,0,0,
                                                0,0,
                                            ];
                                        case 'q': case 'Q': 
                                            return [
                                                1,1,
                                                1,0,0,0,1,
                                                0,0,
                                                1,0,0,1,1,
                                                1,1,
                                            ]; 
                                        case 'r': case 'R': 
                                            return [
                                                1,1,
                                                1,0,0,0,1,
                                                1,1,
                                                1,0,0,1,0,
                                                0,0,
                                            ]; 
                                        case 's': case 'S': 
                                            return [
                                                1,1,
                                                1,0,0,0,0,
                                                1,1,
                                                0,0,0,0,1,
                                                1,1,
                                            ]; 
                                        case 't': case 'T': 
                                            return [
                                                1,1,
                                                0,0,1,0,0,
                                                0,0,
                                                0,0,1,0,0,
                                                0,0,
                                            ]; 
                                        case 'u': case 'U': 
                                            return [
                                                0,0,
                                                1,0,0,0,1,
                                                0,0,
                                                1,0,0,0,1,
                                                1,1,
                                            ]; 
                                        case 'v': case 'V': 
                                            return [
                                                0,0,
                                                1,0,0,1,0,
                                                0,0,
                                                1,1,0,0,0,
                                                0,0,
                                            ]; 
                                        case 'w': case 'W': 
                                            return [
                                                0,0,
                                                1,0,0,0,1,
                                                0,0,
                                                1,1,0,1,1,
                                                0,0,
                                            ]; 
                                        case 'x': case 'X': 
                                            return [
                                                0,0,
                                                0,1,0,1,0,
                                                0,0,
                                                0,1,0,1,0,
                                                0,0,
                                            ]; 
                                        case 'y': case 'Y': 
                                            return [
                                                0,0,
                                                0,1,0,1,0,
                                                0,0,
                                                0,0,1,0,0,
                                                0,0,
                                            ]; 
                                        case 'z': case 'Z': 
                                            return [
                                                1,1,
                                                0,0,0,1,0,
                                                0,0,
                                                0,1,0,0,0,
                                                1,1,
                                            ]; 
                            
                                        case 'all': 
                                            return [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1];
                                        default:
                                            return [
                                                0,0,
                                                0,0,0,0,0,
                                                0,0,
                                                0,0,0,0,0,
                                                0,0,
                                            ];
                                    }
                                }
                            
                                if(canvasBased){
                                    let stamp = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
                            
                                    //elements 
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y});
                                        const canvas = interfacePart.builder('basic','canvas','backing',{ width:width, height:height, colour:backgroundStyle,resolution:resolution });
                                            object.append(canvas);
                            
                                    //graphics
                                        function clear(){
                            
                                            canvas._.fillStyle = _canvas_.library.math.convertColour.obj2rgba(backgroundStyle);
                                            canvas._.fillRect(0,0,canvas.$(width),canvas.$(height));
                                            canvas.requestUpdate();
                                        };
                                        function drawChar(){
                            
                                            //draw segments in 
                                                for(let a = 0; a < points.length; a++){
                                                    canvas._.beginPath(); 
                                                    canvas._.moveTo(canvas.$(points[a][0].x),canvas.$(points[a][0].y));
                                                    for(let b = 1; b < points[a].length; b++){
                                                        canvas._.lineTo(canvas.$(points[a][b].x),canvas.$(points[a][b].y));
                                                    }
                                                    canvas._.closePath(); 
                                                    canvas._.fillStyle = stamp[a] == 0 ? _canvas_.library.math.convertColour.obj2rgba(dimStyle) : _canvas_.library.math.convertColour.obj2rgba(glowStyle);
                                                    canvas._.fill(); 
                                                }
                                                canvas.requestUpdate();
                                        }
                            
                                    //methods
                                        object.set = function(segment,state){
                                            clear();
                                            stamp[segment] = state;
                                            drawChar();
                                        };
                                        object.get = function(segment){ 
                                            if(segment==undefined){
                                                console.error('sevenSegmentDisplay_canvasBased::get: must provide segment value'); 
                                                return;
                                            } 
                                            return stamp[segment].state;
                                        };
                                        object.clear = function(){
                                            clear();
                                            for(let a = 0; a < stamp.length; a++){
                                                this.set(a,false);
                                            }
                                            drawChar();
                                        };
                            
                                        object.enterCharacter = function(char){
                                            stamp = getStamp(char);
                            
                                            clear();
                                            drawChar();
                                        };
                            
                                    //setup
                                        clear();
                                        drawChar();
                            
                                    return(object);
                                }else{
                                    //elements 
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y});
                                        const backing = interfacePart.builder('basic','rectangle','backing',{ width:width, height:height, angle:angle, colour:backgroundStyle });
                                            object.append(backing);
                            
                                        //segments
                                            const segments = [];
                                            for(let a = 0; a < points.length; a++){
                                                segments[a] = {
                                                    segment:interfacePart.builder('basic','polygon','segment_'+a,{ pointsAsXYArray:points[a], colour:dimStyle }), 
                                                    state:false
                                                };
                                                object.append(segments[a].segment);
                                            }
                            
                                    //methods
                                        object.set = function(segment,state){
                                            segments[segment].state = state;
                                            if(state){ segments[segment].segment.colour(glowStyle); }
                                            else{ segments[segment].segment.colour(dimStyle); }
                                        };
                                        object.get = function(segment){
                                            return segments[segment].state;
                                        };
                                        object.clear = function(){
                                            for(let a = 0; a < segments.length; a++){
                                                this.set(a,false);
                                            }
                                        };
                                        object.enterCharacter = function(char){
                                            stamp = getStamp(char);
                            
                                            for(let a = 0; a < stamp.length; a++){
                                                this.set(a, stamp[a]==1);
                                            }
                                        };
                            
                                    return object;
                                }
                            };
                            
                            interfacePart.partLibrary.display.sixteenSegmentDisplay = function(name,data){ 
                                return interfacePart.collection.display.sixteenSegmentDisplay(
                                    name, data.canvasBased, data.resolution, data.x, data.y, data.width, data.height, data.angle,
                                    data.style.background, data.style.glow, data.style.dim
                                );
                            };
                            this.readout_sixteenSegmentDisplay = function(
                                name='readout_sixteenSegmentDisplay', canvasBased=false, resolution=1, 
                                x=0, y=0, width=100, height=30, count=5, angle=0, decimalPlaces=false,
                                backgroundStyle={r:0,g:0,b:0,a:1},
                                glowStyle={r:0.78,g:0.78,b:0.78,a:1},
                                dimStyle={r:0.1,g:0.1,b:0.1,a:1},
                            ){
                                
                                //values
                                    let text = '';
                                    let displayInterval = null;
                                    const displayIntervalTime = 150;
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic', 'group', name, {x:x, y:y, angle:angle});
                            
                                if(canvasBased){
                                    const margin = (width/count)/8;
                                    const division = (width/count)/8;
                                    const shapes = {
                                        segments:{
                                            points: {
                                                top:{
                                                    left:[
                                                        {x:division*0.5+margin,         y:division*0.5+margin},  //centre
                                                        {x:division*1.0+margin,         y:division*0.0+margin},  //top
                                                        {x:division*0.0+margin,         y:division*1.0+margin},  //left
                                                        {x:division*1.0+margin,         y:division*1.0+margin},  //inner point
                                                        {x:division*1.75+margin,        y:division*1.0+margin},  //inner point right
                                                        {x:division*1.0+margin,         y:division*1.75+margin}, //inner point down
                                                    ],
                                                    centre:[
                                                        {x:(width/count)/2,                     y:division*0.5+margin}, //central point
                                                        {x:(width/count)/2-division*0.5,        y:division*1.0+margin}, //lower left
                                                        {x:(width/count)/2+division*0.5,        y:division*1.0+margin}, //lower right
                                                        {x:(width/count)/2-division*0.5,        y:division*0.0+margin}, //upper left
                                                        {x:(width/count)/2+division*0.5,        y:division*0.0+margin}, //upper right
                                                    ],
                                                    right:[
                                                        {x:(width/count)-division*0.5-margin,   y:division*0.5+margin},  //centre
                                                        {x:(width/count)-division*1.0-margin,   y:division*0.0+margin},  //top
                                                        {x:(width/count)-division*0.0-margin,   y:division*1.0+margin},  //right
                                                        {x:(width/count)-division*1.0-margin,   y:division*1.0+margin},  //inner point
                                                        {x:(width/count)-division*1.0-margin,   y:division*1.75+margin}, //inner point down
                                                        {x:(width/count)-division*1.75-margin,  y:division*1.0+margin},  //inner point left
                                                    ]
                                                },
                                                middle:{
                                                    left:[
                                                        {x:division*0.0+margin,         y:height*0.5-division*0.5}, //top left
                                                        {x:division*1.0+margin,         y:height*0.5-division*0.5}, //top right
                                                        {x:division*0.5+margin,         y:height*0.5-division*0.0}, //centre
                                                        {x:division*0.0+margin,         y:height*0.5+division*0.5}, //bottom left
                                                        {x:division*1.0+margin,         y:height*0.5+division*0.5}, //bottom right
                                                    ],
                                                    centre:[
                                                        {x:(width/count)/2,                     y:height/2},                //central point
                                                        {x:(width/count)/2-division*0.5,        y:division*0.5+height/2},   //lower left
                                                        {x:(width/count)/2-division*0.25,       y:division*1.25+height/2},  //lower left down
                                                        {x:(width/count)/2-division*1.0,        y:division*0.5+height/2},   //lower left left
                                                        {x:(width/count)/2+division*0.5,        y:division*0.5+height/2},   //lower right
                                                        {x:(width/count)/2+division*0.5,        y:division*1.75+height/2},  //lower right down
                                                        {x:(width/count)/2+division*1.0,        y:division*0.5+height/2},   //lower right right
                                                        {x:(width/count)/2-division*0.5,        y:-division*0.5+height/2},  //upper left
                                                        {x:(width/count)/2-division*0.25,       y:-division*1.25+height/2}, //upper left up
                                                        {x:(width/count)/2-division*1.0,        y:-division*0.25+height/2}, //upper left left
                                                        {x:(width/count)/2+division*0.5,        y:-division*0.5+height/2},  //upper right
                                                        {x:(width/count)/2+division*0.5,        y:-division*1.75+height/2}, //upper right up
                                                        {x:(width/count)/2+division*1.0,        y:-division*0.25+height/2}, //upper right right
                                                    ],
                                                    right:[
                                                        {x:(width/count)-division*1.0-margin,   y:height*0.5-division*0.5}, //top left
                                                        {x:(width/count)-division*0.0-margin,   y:height*0.5-division*0.5}, //top right
                                                        {x:(width/count)-division*0.5-margin,   y:height*0.5-division*0.0}, //centre
                                                        {x:(width/count)-division*1.0-margin,   y:height*0.5+division*0.5}, //bottom left
                                                        {x:(width/count)-division*0.0-margin,   y:height*0.5+division*0.5}  //bottom right
                                                    ]
                                                },
                                                bottom: {
                                                    left:[
                                                        {x:division*0.5+margin,         y:height-division*0.5-margin}, //centre
                                                        {x:division*0.0+margin,         y:height-division*1.0-margin}, //left
                                                        {x:division*1.0+margin,         y:height-division*0.0-margin}, //bottom
                                                        {x:division*1.0+margin,         y:height-division*1.0-margin}, //inner point
                                                        {x:division*1.0+margin,         y:height-division*1.75-margin},//inner point up
                                                        {x:division*1.75+margin,        y:height-division*1.0-margin}, //inner point right
                                                    ],
                                                    centre:[
                                                        {x:(width/count)/2-division*0.5,        y:height-division*1.0-margin}, //upper left
                                                        {x:(width/count)/2+division*0.5,        y:height-division*1.0-margin}, //upper right
                                                        {x:(width/count)/2,                     y:height-division*0.5-margin}, //central point
                                                        {x:(width/count)/2-division*0.5,        y:height-division*0.0-margin}, //lower left
                                                        {x:(width/count)/2+division*0.5,        y:height-division*0.0-margin}, //lower right
                                                    ],
                                                    right:[
                                                        {x:(width/count)-division*0.5-margin,   y:height-division*0.5-margin}, //centre
                                                        {x:(width/count)-division*0.0-margin,   y:height-division*1.0-margin}, //right
                                                        {x:(width/count)-division*1.0-margin,   y:height-division*0.0-margin}, //bottom
                                                        {x:(width/count)-division*1.0-margin,   y:height-division*1.0-margin}, //inner point
                                                        {x:(width/count)-division*1.0-margin,   y:height-division*1.75-margin},//inner point up
                                                        {x:(width/count)-division*1.75-margin,  y:height-division*1.0-margin}, //inner point left
                                                    ]
                                                }
                                            }
                                        }
                                    };
                                    const segmentPointArray = [
                                        [
                                            shapes.segments.points.top.left[1],
                                            shapes.segments.points.top.left[0],
                                            shapes.segments.points.top.left[3],
                                            shapes.segments.points.top.centre[1],
                                            shapes.segments.points.top.centre[0],
                                            shapes.segments.points.top.centre[3],
                                        ],
                                        [
                                            shapes.segments.points.top.centre[4],
                                            shapes.segments.points.top.centre[0],
                                            shapes.segments.points.top.centre[2],
                                            shapes.segments.points.top.right[3],
                                            shapes.segments.points.top.right[0],
                                            shapes.segments.points.top.right[1],
                                        ],
                                
                                        [
                                            shapes.segments.points.top.left[0],
                                            shapes.segments.points.top.left[2],
                                            shapes.segments.points.middle.left[0],
                                            shapes.segments.points.middle.left[2],
                                            shapes.segments.points.middle.left[1],
                                            shapes.segments.points.top.left[3],
                                        ],
                                        [
                                            shapes.segments.points.top.left[4],
                                            shapes.segments.points.top.left[3],
                                            shapes.segments.points.top.left[5],
                                            shapes.segments.points.middle.centre[9],
                                            shapes.segments.points.middle.centre[7],
                                            shapes.segments.points.middle.centre[8],
                                        ],
                                        [
                                            shapes.segments.points.top.centre[0],
                                            shapes.segments.points.top.centre[1],
                                            shapes.segments.points.middle.centre[7],
                                            shapes.segments.points.middle.centre[0],
                                            shapes.segments.points.middle.centre[10],
                                            shapes.segments.points.top.centre[2],
                                        ],
                                        [
                                            shapes.segments.points.top.right[4],
                                            shapes.segments.points.top.right[3],
                                            shapes.segments.points.top.right[5],
                                            shapes.segments.points.middle.centre[11],
                                            shapes.segments.points.middle.centre[10],
                                            shapes.segments.points.middle.centre[12],
                                        ],
                                        [
                                            shapes.segments.points.top.right[0],
                                            shapes.segments.points.top.right[2],
                                            shapes.segments.points.middle.right[1],
                                            shapes.segments.points.middle.right[2],
                                            shapes.segments.points.middle.right[0],
                                            shapes.segments.points.top.right[3],
                                        ],
                                
                                        [
                                            shapes.segments.points.middle.left[4],
                                            shapes.segments.points.middle.left[2],
                                            shapes.segments.points.middle.left[1],
                                            shapes.segments.points.middle.centre[7],
                                            shapes.segments.points.middle.centre[0],
                                            shapes.segments.points.middle.centre[1],
                                        ],
                                        [
                                            shapes.segments.points.middle.right[3],
                                            shapes.segments.points.middle.right[2],
                                            shapes.segments.points.middle.right[0],
                                            shapes.segments.points.middle.centre[10],
                                            shapes.segments.points.middle.centre[0],
                                            shapes.segments.points.middle.centre[4],
                                        ],
                                
                                        [
                                            shapes.segments.points.bottom.left[0],
                                            shapes.segments.points.bottom.left[1],
                                            shapes.segments.points.middle.left[3],
                                            shapes.segments.points.middle.left[2],
                                            shapes.segments.points.middle.left[4],
                                            shapes.segments.points.bottom.left[3],
                                        ],
                                        [
                                            shapes.segments.points.bottom.left[4],
                                            shapes.segments.points.bottom.left[3],
                                            shapes.segments.points.bottom.left[5],
                                            shapes.segments.points.middle.centre[2],
                                            shapes.segments.points.middle.centre[1],
                                            shapes.segments.points.middle.centre[3],
                                        ],
                                        [
                                            shapes.segments.points.bottom.centre[0],
                                            shapes.segments.points.bottom.centre[2],
                                            shapes.segments.points.bottom.centre[1],
                                            shapes.segments.points.middle.centre[4],
                                            shapes.segments.points.middle.centre[0],
                                            shapes.segments.points.middle.centre[1],
                                        ],
                                        [
                                            shapes.segments.points.bottom.right[4],
                                            shapes.segments.points.bottom.right[3],
                                            shapes.segments.points.bottom.right[5],
                                            shapes.segments.points.middle.centre[5],
                                            shapes.segments.points.middle.centre[4],
                                            shapes.segments.points.middle.centre[6],
                                        ],
                                        [
                                            shapes.segments.points.bottom.right[3],
                                            shapes.segments.points.middle.right[3],
                                            shapes.segments.points.middle.right[2],
                                            shapes.segments.points.middle.right[4],
                                            shapes.segments.points.bottom.right[1],
                                            shapes.segments.points.bottom.right[0],
                                        ],
                                
                                        [
                                            shapes.segments.points.bottom.left[2],
                                            shapes.segments.points.bottom.left[0],
                                            shapes.segments.points.bottom.left[3],
                                            shapes.segments.points.bottom.centre[0],
                                            shapes.segments.points.bottom.centre[2],
                                            shapes.segments.points.bottom.centre[3],
                                        ],
                                        [
                                            shapes.segments.points.bottom.right[2],
                                            shapes.segments.points.bottom.right[0],
                                            shapes.segments.points.bottom.right[3],
                                            shapes.segments.points.bottom.centre[1],
                                            shapes.segments.points.bottom.centre[2],
                                            shapes.segments.points.bottom.centre[4],
                                        ],
                                    ];
                                    function getStamp(character){
                                
                                        switch(character){
                                            case '!': 
                                                return [
                                                    1,1,
                                                    0,1,1,1,0,
                                                    0,0,
                                                    0,0,0,0,0,
                                                    1,1,
                                                ]; 
                                            case '?': 
                                                return [
                                                    1,1,
                                                    0,0,0,0,1,
                                                    0,1,
                                                    0,0,0,0,0,
                                                    1,1,
                                                ]; 
                                            case '.': 
                                                return [
                                                    0,0,
                                                    0,0,0,0,0,
                                                    0,0,
                                                    0,0,0,0,0,
                                                    1,0,
                                                ]; 
                                            case ',': 
                                                return [
                                                    0,0,
                                                    0,0,0,0,0,
                                                    0,0,
                                                    0,0,1,0,0,
                                                    0,0,
                                                ]; 
                                            case '\'': 
                                                return [
                                                    0,0,
                                                    1,0,0,0,0,
                                                    0,0,
                                                    0,0,0,0,0,
                                                    0,0,
                                                ]; 
                                            case ':':
                                                return [
                                                    0,0,
                                                    0,1,0,1,0,
                                                    0,0,
                                                    0,1,0,1,0,
                                                    0,0,
                                                ]; 
                                            case '"': 
                                                return [
                                                    0,0,
                                                    1,0,1,0,0,
                                                    0,0,
                                                    0,0,0,0,0,
                                                    0,0,
                                                ]; 
                                            case '_': 
                                                return [
                                                    0,0,
                                                    0,0,0,0,0,
                                                    0,0,
                                                    0,0,0,0,0,
                                                    1,1,
                                                ]; 
                                            case '-': 
                                                return [
                                                    0,0,
                                                    0,0,0,0,0,
                                                    1,1,
                                                    0,0,0,0,0,
                                                    0,0,
                                                ]; 
                                            case '\\': 
                                                return [
                                                    0,0,
                                                    0,1,0,0,0,
                                                    0,0,
                                                    0,0,0,1,0,
                                                    0,0,
                                                ]; 
                                            case '/': 
                                                return [
                                                    0,0,
                                                    0,0,0,1,0,
                                                    0,0,
                                                    0,1,0,0,0,
                                                    0,0,
                                                ]; 
                                            case '*': 
                                                return [
                                                    0,0,
                                                    0,1,1,1,0,
                                                    1,1,
                                                    0,1,1,1,0,
                                                    0,0,
                                                ]; 
                                            case '#': 
                                                return [
                                                    1,1,
                                                    1,0,1,0,1,
                                                    1,1,
                                                    1,0,1,0,1,
                                                    1,1,
                                                ]; 
                                            case '<': 
                                                return [
                                                    0,0,
                                                    0,0,0,1,0,
                                                    0,0,
                                                    0,0,0,1,0,
                                                    0,0,
                                                ]; 
                                            case '>': 
                                                return [
                                                    0,0,
                                                    0,1,0,0,0,
                                                    0,0,
                                                    0,1,0,0,0,
                                                    0,0,
                                                ]; 
                                            case '(': 
                                                return [
                                                    0,1,
                                                    0,0,1,0,0,
                                                    0,0,
                                                    0,0,1,0,0,
                                                    0,1,
                                                ]; 
                                            case ')': 
                                                return [
                                                    1,0,
                                                    0,0,1,0,0,
                                                    0,0,
                                                    0,0,1,0,0,
                                                    1,0,
                                                ]; 
                                            case '[': 
                                                return [
                                                    1,1,
                                                    1,0,0,0,0,
                                                    0,0,
                                                    1,0,0,0,0,
                                                    1,1,
                                                ]; 
                                            case ']': 
                                                return [
                                                    1,1,
                                                    0,0,0,0,1,
                                                    0,0,
                                                    0,0,0,0,1,
                                                    1,1,
                                                ]; 
                                            case '{': 
                                                return [
                                                    1,1,
                                                    0,1,0,0,0,
                                                    1,0,
                                                    0,1,0,0,0,
                                                    1,1,
                                                ]; 
                                            case '}': 
                                                return [
                                                    1,1,
                                                    0,0,0,1,0,
                                                    0,1,
                                                    0,0,0,1,0,
                                                    1,1,
                                                ]; 
                                
                                            case '0': case 0: 
                                                return [
                                                    1,1,
                                                    1,0,0,1,1,
                                                    0,0,
                                                    1,1,0,0,1,
                                                    1,1,
                                                ]; 
                                            case '1': case 1: 
                                                return [
                                                    1,0,
                                                    0,0,1,0,0,
                                                    0,0,
                                                    0,0,1,0,0,
                                                    1,1,
                                                ]; 
                                            case '2': case 2: 
                                                return [
                                                    1,1,
                                                    0,0,0,0,1,
                                                    0,1,
                                                    0,1,0,0,0,
                                                    1,1,
                                                ]; 
                                            case '3': case 3:
                                                return [
                                                    1,1,
                                                    0,0,0,0,1,
                                                    1,1,
                                                    0,0,0,0,1,
                                                    1,1,
                                                ]; 
                                            case '4': case 4:
                                                return [
                                                    0,0,
                                                    1,0,0,0,1,
                                                    1,1,
                                                    0,0,0,0,1,
                                                    0,0,
                                                ]; 
                                            case '5': case 5:
                                                return [
                                                    1,1,
                                                    1,0,0,0,0,
                                                    1,1,
                                                    0,0,0,0,1,
                                                    1,1,
                                                ]; 
                                            case '6': case 6:
                                                return [
                                                    1,1,
                                                    1,0,0,0,0,
                                                    1,1,
                                                    1,0,0,0,1,
                                                    1,1,
                                                ]; 
                                            case '7': case 7:
                                                return [
                                                    1,1,
                                                    0,0,0,1,0,
                                                    0,0,
                                                    0,1,0,0,0,
                                                    0,0,
                                                ]; 
                                            case '8': case 8:
                                                return [
                                                    1,1,
                                                    1,0,0,0,1,
                                                    1,1,
                                                    1,0,0,0,1,
                                                    1,1,
                                                ]; 
                                            case '9': case 9:
                                                return [
                                                    1,1,
                                                    1,0,0,0,1,
                                                    1,1,
                                                    0,0,0,0,1,
                                                    1,1,
                                                ]; 
                                
                                            case 'a': case 'A': 
                                                return [
                                                    1,1,
                                                    1,0,0,0,1,
                                                    1,1,
                                                    1,0,0,0,1,
                                                    0,0,
                                                ]; 
                                            case 'b': case 'B': 
                                                return [
                                                    1,1,
                                                    0,0,1,0,1,
                                                    0,1,
                                                    0,0,1,0,1,
                                                    1,1,
                                                ]; 
                                            case 'c': case 'C': 
                                                return [
                                                    1,1,
                                                    1,0,0,0,0,
                                                    0,0,
                                                    1,0,0,0,0,
                                                    1,1,
                                                ]; 
                                            case 'd': case 'D': 
                                                return [
                                                    1,1,
                                                    0,0,1,0,1,
                                                    0,0,
                                                    0,0,1,0,1,
                                                    1,1,
                                                ]; 
                                            case 'e': case 'E': 
                                                return [
                                                    1,1,
                                                    1,0,0,0,0,
                                                    1,1,
                                                    1,0,0,0,0,
                                                    1,1,
                                                ]; 
                                            case 'f': case 'F': 
                                                return [
                                                    1,1,
                                                    1,0,0,0,0,
                                                    1,1,
                                                    1,0,0,0,0,
                                                    0,0,
                                                ]; 
                                            case 'g': case 'G': 
                                                return [
                                                    1,1,
                                                    1,0,0,0,0,
                                                    0,1,
                                                    1,0,0,0,1,
                                                    1,1,
                                                ]; 
                                            case 'h': case 'H': 
                                                return [
                                                    0,0,
                                                    1,0,0,0,1,
                                                    1,1,
                                                    1,0,0,0,1,
                                                    0,0,
                                                ]; 
                                            case 'i': case 'I': 
                                                return [
                                                    1,1,
                                                    0,0,1,0,0,
                                                    0,0,
                                                    0,0,1,0,0,
                                                    1,1,
                                                ]; 
                                            case 'j': case 'J': 
                                                return [
                                                    1,1,
                                                    0,0,1,0,0,
                                                    0,0,
                                                    0,0,1,0,0,
                                                    1,0,
                                                ]; 
                                            case 'k': case 'K': 
                                                return [
                                                    0,0,
                                                    1,0,0,1,0,
                                                    1,0,
                                                    1,0,0,1,0,
                                                    0,0,
                                                ]; 
                                            case 'l': case 'L': 
                                                return [
                                                    0,0,
                                                    1,0,0,0,0,
                                                    0,0,
                                                    1,0,0,0,0,
                                                    1,1,
                                                ]; 
                                            case 'm': case 'M': 
                                                return [
                                                    0,0,
                                                    1,1,0,1,1,
                                                    0,0,
                                                    1,0,0,0,1,
                                                    0,0,
                                                ]; 
                                            case 'n': case 'N': 
                                                return [
                                                    0,0,
                                                    1,1,0,0,1,
                                                    0,0,
                                                    1,0,0,1,1,
                                                    0,0,
                                                ]; 
                                            case 'o': case 'O': 
                                                return [
                                                    1,1,
                                                    1,0,0,0,1,
                                                    0,0,
                                                    1,0,0,0,1,
                                                    1,1,
                                                ]; 
                                            case 'p': case 'P': 
                                                return [
                                                    1,1,
                                                    1,0,0,0,1,
                                                    1,1,
                                                    1,0,0,0,0,
                                                    0,0,
                                                ];
                                            case 'q': case 'Q': 
                                                return [
                                                    1,1,
                                                    1,0,0,0,1,
                                                    0,0,
                                                    1,0,0,1,1,
                                                    1,1,
                                                ]; 
                                            case 'r': case 'R': 
                                                return [
                                                    1,1,
                                                    1,0,0,0,1,
                                                    1,1,
                                                    1,0,0,1,0,
                                                    0,0,
                                                ]; 
                                            case 's': case 'S': 
                                                return [
                                                    1,1,
                                                    1,0,0,0,0,
                                                    1,1,
                                                    0,0,0,0,1,
                                                    1,1,
                                                ]; 
                                            case 't': case 'T': 
                                                return [
                                                    1,1,
                                                    0,0,1,0,0,
                                                    0,0,
                                                    0,0,1,0,0,
                                                    0,0,
                                                ]; 
                                            case 'u': case 'U': 
                                                return [
                                                    0,0,
                                                    1,0,0,0,1,
                                                    0,0,
                                                    1,0,0,0,1,
                                                    1,1,
                                                ]; 
                                            case 'v': case 'V': 
                                                return [
                                                    0,0,
                                                    1,0,0,1,0,
                                                    0,0,
                                                    1,1,0,0,0,
                                                    0,0,
                                                ]; 
                                            case 'w': case 'W': 
                                                return [
                                                    0,0,
                                                    1,0,0,0,1,
                                                    0,0,
                                                    1,1,0,1,1,
                                                    0,0,
                                                ]; 
                                            case 'x': case 'X': 
                                                return [
                                                    0,0,
                                                    0,1,0,1,0,
                                                    0,0,
                                                    0,1,0,1,0,
                                                    0,0,
                                                ]; 
                                            case 'y': case 'Y': 
                                                return [
                                                    0,0,
                                                    0,1,0,1,0,
                                                    0,0,
                                                    0,0,1,0,0,
                                                    0,0,
                                                ]; 
                                            case 'z': case 'Z': 
                                                return [
                                                    1,1,
                                                    0,0,0,1,0,
                                                    0,0,
                                                    0,1,0,0,0,
                                                    1,1,
                                                ]; 
                                
                                            case 'all': 
                                                return [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1];
                                            default:
                                                return [
                                                    0,0,
                                                    0,0,0,0,0,
                                                    0,0,
                                                    0,0,0,0,0,
                                                    0,0,
                                                ];
                                        }
                                    }
                            
                                    //values
                                        const stamps = (new Array(count)).fill().map(() => [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);
                                        const decimalPoints = (new Array(count-1)).fill().map(() => false);
                                        const decimalPointRadius = 1.5;
                            
                                    //elements 
                                        const canvas = interfacePart.builder('basic','canvas','backing',{ width:width, height:height, colour:backgroundStyle,resolution:resolution });
                                            object.append(canvas);
                            
                                    //internal
                                        function clear(requestUpdate=true){
                                            canvas._.fillStyle = _canvas_.library.math.convertColour.obj2rgba(backgroundStyle);
                                            canvas._.fillRect(0,0,canvas.$(width),canvas.$(height));
                                            if(requestUpdate){canvas.requestUpdate();}
                                        };
                                        function drawCharacters(){
                            
                                            stamps.forEach((stamp,stampIndex) => {
                                                const xOffset = stampIndex*(width/count);
                            
                                                segmentPointArray.forEach((segmentPoints, segmentPointsIndex) => {
                                                    canvas._.beginPath(); 
                                                    canvas._.moveTo(
                                                        canvas.$(segmentPoints[0].x + xOffset),
                                                        canvas.$(segmentPoints[0].y)
                                                    );
                                                    for(let a = 1; a < segmentPoints.length; a++){
                                                        canvas._.lineTo(
                                                            canvas.$(segmentPoints[a].x + xOffset),
                                                            canvas.$(segmentPoints[a].y)
                                                        );
                                                    }
                                                    canvas._.closePath(); 
                                                    canvas._.fillStyle = stamp[segmentPointsIndex] == 0 ? _canvas_.library.math.convertColour.obj2rgba(dimStyle) : _canvas_.library.math.convertColour.obj2rgba(glowStyle);
                                                    canvas._.fill(); 
                                                });
                                            });
                            
                                            if(decimalPlaces){
                                                decimalPoints.forEach((state,index) => {
                                                    canvas._.beginPath();
                                                    canvas._.arc( canvas.$( (index+1)*(width/count) ), canvas.$(height - 2*decimalPointRadius), canvas.$(decimalPointRadius), 0, 2*Math.PI );
                                                    canvas._.fillStyle = state == 0 ? _canvas_.library.math.convertColour.obj2rgba(dimStyle) : _canvas_.library.math.convertColour.obj2rgba(glowStyle);
                                                    canvas._.fill(); 
                            
                                                });
                                            }
                            
                                            canvas.requestUpdate();
                                        }
                                        function print(style,offset=0,dontClear=false){
                                            
                                            if(decimalPlaces){ decimalPoints.forEach((point,index) => decimalPoints[index] = false); }
                                            if(!dontClear){ clearInterval(displayInterval); }
                            
                                            switch(style){
                                                case 'smart':
                                                    if(decimalPlaces){
                                                        if(text.replace('.','').length > stamps.length){print('r2lSweep');}
                                                        else{print('regular');}
                                                    }else{
                                                        if(text.length > stamps.length){print('r2lSweep');}
                                                        else{print('regular');}
                                                    }
                                                break;
                                                case 'r2lSweep':
                                                    let displayStage = -stamps.length;
                            
                                                    displayInterval = setInterval(function(){
                                                        print('regular',-displayStage,true);
                                                        displayStage++;
                                                        if(text[displayStage] == "."){
                                                            displayStage++;
                                                        }
                                                        if(displayStage > stamps.length+text.length-1){
                                                            displayStage=-stamps.length;
                                                        }
                                                    },displayIntervalTime);
                                                break;
                                                case 'regular': default:
                                                    let textIndex = 0;
                                                    for(let a = offset; a < stamps.length; a++){
                                                        if(stamps[a] == undefined){ textIndex++; continue; }
                            
                                                        if(decimalPlaces && text[textIndex] == '.'){
                                                            if(decimalPoints[a-1] != undefined){
                                                                decimalPoints[a-1] = true;
                                                            }
                                                            a--;
                                                        }else{
                                                            stamps[a] = getStamp(text[textIndex]);
                                                        }
                                                        textIndex++;
                                                    }
                                                break;
                                            }
                            
                                            clear(false);
                                            drawCharacters();
                                        }
                            
                                    //methods
                                        object.text = function(a){
                                            if(a==null){return text;}
                                            text = a;
                                        };
                                        object.print = function(style){
                                            print(style);
                                        };
                            
                                    //setup/tear down
                                        object.oncreate = function(){
                                            clear();
                                            drawCharacters();
                                        };
                                        object.ondelete = function(){
                                            clearInterval(displayInterval);
                                        };
                                }else{
                                    //elements 
                                        //display units
                                            const units = (new Array(count)).fill().map((a,index) => {
                                                return _canvas_.interface.part.builder('display', 'sixteenSegmentDisplay', ''+index, {
                                                    x:(width/count)*index, width:width/count, height:height, 
                                                    canvasBased:canvasBased, resolution:resolution,
                                                    style:{background:backgroundStyle, glow:glowStyle, dim:dimStyle}
                                                });
                                            });
                                            units.forEach(element => object.append(element));
                                        //decimal point
                                            let decimalPoints = [];
                                            if(decimalPlaces){
                                                decimalPoints = (new Array(count-1)).fill().map((a,index) => {
                                                    return _canvas_.interface.part.builder('display', 'glowbox_circle', 'decimalPoint_'+index, {
                                                        x:(width/count)*(index+1), y:height*0.9, radius:(height/10)/2,
                                                        style:{glow:glowStyle, dim:dimStyle},
                                                    });
                                                });
                                                decimalPoints.forEach(element => object.append(element));
                                            }
                            
                                    //methods
                                        function print(style,offset=0,dontClear=false){
                                            
                                            decimalPoints.forEach(point => point.off());
                                            if(!dontClear){ clearInterval(displayInterval); }
                            
                                            switch(style){
                                                case 'smart':
                                                    if(decimalPlaces){
                                                        if(text.replace('.','').length > units.length){print('r2lSweep');}
                                                        else{print('regular');}
                                                    }else{
                                                        if(text.length > units.length){print('r2lSweep');}
                                                        else{print('regular');}
                                                    }
                                                break;
                                                case 'r2lSweep':
                                                    let displayStage = -units.length;
                            
                                                    displayInterval = setInterval(function(){
                                                        print('regular',-displayStage,true);
                                                        displayStage++; if(displayStage > units.length+text.length-1){displayStage=-units.length;}
                                                    },displayIntervalTime);
                                                break;
                                                case 'regular': default:
                                                    let textIndex = 0;
                                                    for(let a = offset; a < units.length; a++){
                                                        if(units[a] == undefined){ textIndex++; continue; }
                            
                                                        if(decimalPlaces && text[textIndex] == '.'){
                                                            if(decimalPoints[a-1] != undefined){decimalPoints[a-1].on();}
                                                            a--;
                                                        }else{ units[a].enterCharacter(text[textIndex]); }
                                                        textIndex++;
                                                    }
                                                break;
                                            }
                                        }
                            
                                        object.text = function(a){
                                            if(a==null){return text;}
                                            text = a;
                                        };
                                        object.print = function(style){
                                            print(style);
                                        };  
                                }
                            
                                return(object);
                            };
                            
                            interfacePart.partLibrary.display.readout_sixteenSegmentDisplay = function(name,data){ 
                                return interfacePart.collection.display.readout_sixteenSegmentDisplay(
                                    name, data.canvasBased, data.resolution, data.x, data.y, data.width, data.height, data.count, data.angle, data.decimalPlaces,
                                    data.style.background, data.style.glow, data.style.dim,
                                ); 
                            };
                        };
                        this.control = new function(){
                            interfacePart.partLibrary.control = {};
                            this.slidePanel_image = function(
                                name='slidePanel_image', 
                                x, y, width=80, height=95, angle=0, interactable=true,
                                handleHeight=0.1, count=8, startValue=0, resetValue=0.5,
                            
                                handleURL, backingURL, slotURL, overlayURL,
                            
                                onchange=function(){},
                                onrelease=function(){},
                            ){
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    //slides
                                        for(let a = 0; a < count; a++){
                                            const temp = interfacePart.builder(
                                                'control', 'slide_continuous_image', 'slide_'+a, {
                                                    x:a*(width/count), y:0,
                                                    width:width/count, height:height, interactable:interactable, handleHeight:handleHeight,
                                                    value:startValue, resetValue:resetValue,
                                                    handleURL:handleURL, backingURL:backingURL, slotURL:slotURL,
                                                    onchange:function(value){ if(!object.onchange){return;} object.onchange(this.id,value); },
                                                    onrelease:function(value){ if(!object.onrelease){return;} object.onrelease(this.id,value); },
                                                }
                                            );
                                            temp.__calculationAngle = angle;
                                            object.append(temp);
                                        }
                                    //overlay
                                        if(overlayURL != undefined){
                                            const overlay = interfacePart.builder('basic','image','overlay',{width:width, height:height, url:overlayURL});
                                            object.append(overlay);
                                        }
                            
                                    object.interactable = function(bool){
                                        if(bool==undefined){return interactable;}
                                        interactable = bool;
                            
                                        for(let a = 0; a < count; a++){
                                            object.children[a].interactable(bool);
                                        }
                                    };
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.slidePanel_image = function(name,data){ return interfacePart.collection.control.slidePanel_image(
                                name, data.x, data.y, data.width, data.height, data.angle, data.interactable, data.handleHeight, data.count, data.value, data.resetValue, 
                                data.handleURL, data.backingURL, data.overlayURL, data.style.invisibleHandle,
                                data.onchange, data.onrelease
                            ); };
                            this.slide_discrete = function(
                                name='slide_discrete', 
                                x, y, width=10, height=95, angle=0, interactable=true,
                                handleHeight=0.1, value=0, resetValue=-1, optionCount=5,
                                handleStyle = {r:0.78,g:0.78,b:0.78,a:1},
                                backingStyle = {r:0.58,g:0.58,b:0.58,a:1},
                                slotStyle = {r:0.2,g:0.2,b:0.2,a:1},
                                invisibleHandleStyle = {r:1,g:0,b:0,a:0},
                                onchange=function(){},
                                onrelease=function(){},
                            ){
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    
                                    //slide
                                        const slide = interfacePart.builder('control','slide_continuous',name,{
                                            x:0, y:0, width:width, height:height, angle:0, interactable:interactable,
                                            handleHeight:handleHeight,
                                            style:{ handle:handleStyle, slot:slotStyle, backing:backingStyle, invisibleHandle:invisibleHandleStyle }
                                        });
                                        object.append(slide);
                            
                                //graphical adjust
                                    function set(a,update=true){ 
                                        a = (a>(optionCount-1) ? (optionCount-1) : a);
                                        a = (a<0 ? 0 : a);
                            
                                        a = Math.round(a); 
                                        if(update && object.onchange != undefined && value != a){object.onchange(a);}
                                        value = a;
                                        slide.set( value/(optionCount-1) );
                                    };
                                    function currentMousePosition(event){
                                        const calculationAngle = object.getOffset().angle;
                                        return event.Y*Math.cos(calculationAngle) - event.X*Math.sin(calculationAngle);
                                    }
                            
                                //methods
                                    let grappled = false;
                            
                                    object.set = function(value,update){
                                        if(grappled){return;}
                                        set(value,update);
                                    };
                                    object.get = function(){return value;};
                                    object.interactable = function(bool){
                                        if(bool==undefined){return interactable;}
                                        interactable = bool;
                                    };
                            
                                //interaction
                                    let acc = 0;
                            
                                    slide.getChildByName('cover').attachCallback('ondblclick', function(){
                                        if(!interactable){return;}
                                        if(resetValue<0){return;}
                                        if(grappled){return;}
                                        
                                        set(resetValue);
                            
                                        if(object.onrelease != undefined){object.onrelease(value);}
                                    });
                                    slide.getChildByName('cover').attachCallback('onwheel', function(x,y,event){
                                        if(!interactable){return;}
                                        if(grappled){return;}
                            
                                        const move = event.wheelDelta/100;
                            
                                        acc += move;
                                        if( Math.abs(acc) >= 1 ){
                                            set( value +1*Math.sign(acc) );
                                            acc = 0;
                                            if(object.onrelease != undefined){object.onrelease(value);}
                                        }
                                    });
                                    slide.getChildByName('invisibleHandle').attachCallback('onmousedown', function(x,y,event){
                                        if(!interactable){return;}
                                        grappled = true;
                            
                                        const initialValue = value/(optionCount-1);
                                        const initialY = currentMousePosition(event);
                                        const mux = height - height*handleHeight;
                            
                                        _canvas_.system.mouse.mouseInteractionHandler(
                                            function(x,y,event){
                                                const numerator = initialY-currentMousePosition(event);
                                                const divider = _canvas_.core.viewport.scale();
                                                set( (initialValue - (numerator/(divider*mux) ))*(optionCount-1) );
                                            },
                                            function(x,y,event){
                                                grappled = false;
                                            }
                                        );
                                    });
                                    slide.getChildByName('backingAndSlotGroup').getChildByName('backingAndSlotCover').attachCallback('onclick', function(x,y,event){
                                        if(!interactable){return;}
                                        if(grappled){return;}
                            
                                        //calculate the distance the click is from the top of the slider (accounting for angle)
                                            const backingAndSlot = slide.getChildByName('backingAndSlotGroup');
                                            const backingAndSlotCover = backingAndSlot.getChildByName('backingAndSlotCover');
                                            const offset = backingAndSlot.getOffset();
                                            const delta = {
                                                x: x - (backingAndSlot.x() + offset.x),
                                                y: y - (backingAndSlot.y() + offset.y),
                                                a: 0 - (backingAndSlot.angle() + offset.angle),
                                            };
                                            const d = _canvas_.library.math.cartesianAngleAdjust( delta.x/offset.scale, delta.y/offset.scale, delta.a ).y / backingAndSlotCover.height();
                            
                                        //use the distance to calculate the correct value to set the slide to
                                        //taking into account the slide handle's size also
                                            const value = d + 0.5*handleHeight*((2*d)-1);
                            
                                        set(value*(optionCount-1));
                                        if(object.onrelease != undefined){object.onrelease(value);}
                                    });
                            
                                //callbacks
                                    object.onchange = onchange; 
                                    object.onrelease = onrelease;
                            
                                //setup
                                    set(value);
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.slide_discrete = function(name,data){ return interfacePart.collection.control.slide_discrete(
                                name, data.x, data.y, data.width, data.height, data.angle, data.interactable, data.handleHeight, data.value, data.resetValue, data.optionCount,
                                data.style.handle, data.style.backing, data.style.slot, data.style.invisibleHandle,
                                data.onchange, data.onrelease
                            ); };
                            this.slidePanel = function(
                                name='slidePanel', 
                                x, y, width=80, height=95, angle=0, interactable=true,
                                handleHeight=0.1, count=8, startValue=0, resetValue=0.5,
                                handleStyle={r:0.78,g:0.78,b:0.78,a:1},
                                backingStyle={r:0.58,g:0.58,b:0.58,a:1},
                                slotStyle={r:0.2,g:0.2,b:0.2,a:1},
                                onchange=function(){},
                                onrelease=function(){},
                            ){
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    //slides
                                        for(let a = 0; a < count; a++){
                                            const temp = interfacePart.builder(
                                                'control', 'slide_continuous', 'slide_'+a, {
                                                    x:a*(width/count), y:0,
                                                    width:width/count, height:height, interactable:interactable, handleHeight:handleHeight,
                                                    value:startValue, resetValue:resetValue,
                                                    style:{handle:handleStyle, backing:backingStyle, slot:slotStyle},
                                                    onchange:function(value){ if(!object.onchange){return;} object.onchange(this.id,value); },
                                                    onrelease:function(value){ if(!object.onrelease){return;} object.onrelease(this.id,value); },
                                                }
                                            );
                                            temp.__calculationAngle = angle;
                                            object.append(temp);
                                        }
                            
                                    object.interactable = function(bool){
                                        if(bool==undefined){return interactable;}
                                        interactable = bool;
                            
                                        for(let a = 0; a < count; a++){
                                            object.children()[a].interactable(bool);
                                        }
                                    };
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.slidePanel = function(name,data){ return interfacePart.collection.control.slidePanel(
                                name, data.x, data.y, data.width, data.height, data.angle, data.interactable, data.handleHeight, data.count, data.value, data.resetValue, 
                                data.style.handle, data.style.backing, data.style.slot, data.style.invisibleHandle,
                                data.onchange, data.onrelease
                            ); };
                            this.slide_continuous_image = function(
                                name='slide_continuous_image', 
                                x, y, width=10, height=95, angle=0, interactable=true,
                                handleHeight=0.1, value=0, resetValue=-1,
                                
                                handleURL, backingURL,
                            
                                invisibleHandleStyle = {r:1,g:0,b:0,a:0},
                                onchange=function(){},
                                onrelease=function(){},
                            ){
                            
                                //default to non-image version if handle image link is missing
                                    if(handleURL == undefined){
                                        return this.slide(
                                            name, x, y, width, height, angle, interactable,
                                            handleHeight, value, resetValue,
                                            handleURL, backingURL, invisibleHandleStyle,
                                            onchange, onrelease,
                                        );
                                    }
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    //backing and slot group
                                        const backingAndSlot = interfacePart.builder('basic','group','backingAndSlotGroup');
                                        object.append(backingAndSlot);
                                        //backing
                                            if(backingURL != undefined){
                                                const backing = interfacePart.builder('basic','image','backing',{width:width, height:height, url:backingURL});
                                                backingAndSlot.append(backing);
                                            }
                                        //backing and slot cover
                                            const backingAndSlotCover = interfacePart.builder('basic','rectangle','backingAndSlotCover',{width:width, height:height, colour:{r:0,g:0,b:0,a:0}});
                                            backingAndSlot.append(backingAndSlotCover);
                                    //handle
                                        const handle = interfacePart.builder('basic','image','handle',{width:width, height:height*handleHeight, url:handleURL});
                                        object.append(handle);
                                    //invisible handle
                                        const invisibleHandle = interfacePart.builder('basic','rectangle','invisibleHandle',{y:-( height*0.01 )/2, width:width, height:height*(handleHeight+0.01) + handleHeight, colour:invisibleHandleStyle});
                                        object.append(invisibleHandle);
                                    //cover
                                        const cover = interfacePart.builder('basic','rectangle','cover',{width:width, height:height, colour:{r:0,g:0,b:0,a:0}});
                                        object.append(cover);
                            
                                //graphical adjust
                                    function set(a,update=true){
                                        a = (a>1 ? 1 : a);
                                        a = (a<0 ? 0 : a);
                            
                                        if(update && object.onchange != undefined){object.onchange(a);}
                                        
                                        value = a;
                                        handle.y( a*height*(1-handleHeight) );
                                        invisibleHandle.y( handle.y() - ( height*0.01 )/2 );
                                    }
                                    function currentMousePosition(event){
                                        const calculationAngle = object.getOffset().angle;
                                        return event.Y*Math.cos(calculationAngle) - event.X*Math.sin(calculationAngle);
                                    }
                            
                                //methods
                                    let grappled = false;
                            
                                    object.set = function(value,update){
                                        if(grappled){return;}
                                        set(value,update);
                                    };
                                    object.get = function(){return value;};
                                    object.interactable = function(bool){
                                        if(bool==undefined){return interactable;}
                                        interactable = bool;
                                    };
                            
                                //interaction
                                    cover.attachCallback('ondblclick', function(){
                                        if(!interactable){return;}
                                        if(resetValue<0){return;}
                                        if(grappled){return;}
                            
                                        set(resetValue);
                                        if(object.onrelease != undefined){object.onrelease(value);}
                                    });
                                    cover.attachCallback('onwheel', function(x,y,event){
                                        if(!interactable){return;}
                                        if(grappled){return;}
                            
                                        const move = event.wheelDelta/100;
                                        const globalScale = _canvas_.core.viewport.scale();
                                        set( value + move/(10*globalScale) );
                                        if(object.onrelease != undefined){object.onrelease(value);}
                                    });
                                    backingAndSlotCover.attachCallback('onmousedown', function(){}); //to stop unit selection
                                    backingAndSlotCover.attachCallback('onclick', function(x,y,event){
                                        if(!interactable){return;}
                                        if(grappled){return;}
                            
                                        //calculate the distance the click is from the top of the slider (accounting for angle)
                                            const offset = backingAndSlot.getOffset();
                                            const delta = {
                                                x: x - (backingAndSlot.x()+ offset.x),
                                                y: y - (backingAndSlot.y()+ offset.y),
                                                a: 0 - (backingAndSlot.angle() + offset.angle),
                                            };
                                            const d = _canvas_.library.math.cartesianAngleAdjust( delta.x/offset.scale, delta.y/offset.scale, delta.a ).y / backingAndSlotCover.height();
                            
                                        //use the distance to calculate the correct value to set the slide to
                                        //taking into account the slide handle's size also
                                            const value = d + 0.5*handleHeight*((2*d)-1);
                            
                                        set(value);
                                        if(object.onrelease != undefined){object.onrelease(value);}
                                    });
                                    invisibleHandle.attachCallback('onclick', function(x,y,event){});
                                    invisibleHandle.attachCallback('onmousedown', function(x,y,event){
                                        if(!interactable){return;}
                                        grappled = true;
                            
                                        const initialValue = value;
                                        const initialY = currentMousePosition(event);
                                        const mux = height - height*handleHeight;
                            
                                        _canvas_.system.mouse.mouseInteractionHandler(
                                            function(x,y,event){
                                                const numerator = initialY-currentMousePosition(event);
                                                const divider = _canvas_.core.viewport.scale();
                                                set( initialValue - (numerator/(divider*mux) ) );
                                            },
                                            function(x,y,event){
                                                grappled = false;
                                            }
                                        );
                                    });
                            
                                //setup
                                    set(value);
                            
                                //callbacks
                                    object.onchange = onchange; 
                                    object.onrelease = onrelease;
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.slide_continuous_image = function(name,data){ return interfacePart.collection.control.slide_continuous_image(
                                name, data.x, data.y, data.width, data.height, data.angle, data.interactable, data.handleHeight, data.value, data.resetValue, 
                                data.handleURL, data.backingURL, data.style.invisibleHandle,
                                data.onchange, data.onrelease
                            ); };
                            this.slide_continuous = function(
                                name='slide_continuous', 
                                x, y, width=10, height=95, angle=0, interactable=true,
                                handleHeight=0.1, value=0, resetValue=-1,
                                handleStyle = {r:0.78,g:0.78,b:0.78,a:1},
                                backingStyle = {r:0.58,g:0.58,b:0.58,a:1},
                                slotStyle = {r:0.2,g:0.2,b:0.2,a:1},
                                invisibleHandleStyle = {r:1,g:0,b:0,a:0},
                                onchange=function(){},
                                onrelease=function(){},
                            ){
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    //backing and slot group
                                        const backingAndSlot = interfacePart.builder('basic','group','backingAndSlotGroup');
                                        object.append(backingAndSlot);
                                        //backing
                                            const backing = interfacePart.builder('basic','rectangle','backing',{width:width, height:height, colour:backingStyle});
                                            backingAndSlot.append(backing);
                                        //slot
                                            const slot = interfacePart.builder('basic','rectangle','slot',{x:width*0.45, y:(height*(handleHeight/2)), width:width*0.1, height:height*(1-handleHeight), colour:slotStyle});
                                            backingAndSlot.append(slot);
                                        //backing and slot cover
                                            const backingAndSlotCover = interfacePart.builder('basic','rectangle','backingAndSlotCover',{width:width, height:height, colour:{r:0,g:0,b:0,a:0}});
                                            backingAndSlot.append(backingAndSlotCover);
                                    //handle
                                        const handle = interfacePart.builder('basic','rectangle','handle',{width:width, height:height*handleHeight, colour:handleStyle});
                                        object.append(handle);
                                    //invisible handle
                                        const invisibleHandle = interfacePart.builder('basic','rectangle','invisibleHandle',{y:-( height*0.01 )/2, width:width, height: height*(handleHeight+0.01) + handleHeight, colour:invisibleHandleStyle});
                                        object.append(invisibleHandle);
                                    //cover
                                        const cover = interfacePart.builder('basic','rectangle','cover',{width:width, height:height, colour:{r:0,g:0,b:0,a:0}});
                                        object.append(cover);
                            
                                //graphical adjust
                                    function set(a,update=true){
                                        a = (a>1 ? 1 : a);
                                        a = (a<0 ? 0 : a);
                            
                                        if(update && object.onchange != undefined){object.onchange(a);}
                                        
                                        value = a;
                                        handle.y( a*height*(1-handleHeight) );
                                        invisibleHandle.y( handle.y() - ( height*0.01 )/2 );
                                    }
                                    function currentMousePosition(event){
                                        const calculationAngle = object.getOffset().angle;
                                        return event.Y*Math.cos(calculationAngle) - event.X*Math.sin(calculationAngle);
                                    }
                            
                                //methods
                                    let grappled = false;
                            
                                    object.set = function(value,update){
                                        if(grappled){return;}
                                        set(value,update);
                                    };
                                    object.get = function(){return value;};
                                    object.interactable = function(bool){
                                        if(bool==undefined){return interactable;}
                                        interactable = bool;
                                    };
                            
                                //interaction
                                    cover.attachCallback('ondblclick', function(){
                                        if(!interactable){return;}
                                        if(resetValue<0){return;}
                                        if(grappled){return;}
                            
                                        set(resetValue);
                                        if(object.onrelease != undefined){object.onrelease(value);}
                                    });
                                    cover.attachCallback('onwheel', function(x,y,event){
                                        if(!interactable){return;}
                                        if(grappled){return;}
                            
                                        const move = event.wheelDelta/100;
                                        const globalScale = _canvas_.core.viewport.scale();
                                        set( value + move/(10*globalScale) );
                                        if(object.onrelease != undefined){object.onrelease(value);}
                                    });
                                    backingAndSlotCover.attachCallback('onmousedown', function(){});//to stop unit selection
                                    backingAndSlotCover.attachCallback('onclick', function(x,y,event){
                                        if(!interactable){return;}
                                        if(grappled){return;}
                            
                                        //calculate the distance the click is from the top of the slider (accounting for angle)
                                            const offset = backingAndSlot.getOffset();
                                            const delta = {
                                                x: x - (backingAndSlot.x() + offset.x),
                                                y: y - (backingAndSlot.y() + offset.y),
                                                a: 0 - (backingAndSlot.angle() + offset.angle),
                                            };
                                            const d = _canvas_.library.math.cartesianAngleAdjust( delta.x/offset.scale, delta.y/offset.scale, delta.a ).y / cover.height();
                            
                                        //use the distance to calculate the correct value to set the slide to
                                        //taking into account the slide handle's size also
                                            const value = d + 0.5*handleHeight*((2*d)-1);
                            
                                        set(value);
                                        if(object.onrelease != undefined){object.onrelease(value);}
                                    });
                                    invisibleHandle.attachCallback('onclick', function(x,y,event){});
                                    invisibleHandle.attachCallback('onmousedown', function(x,y,event){
                                        if(!interactable){return;}
                                        grappled = true;
                            
                                        const initialValue = value;
                                        const initialY = currentMousePosition(event);
                                        const mux = height - height*handleHeight;
                            
                                        _canvas_.system.mouse.mouseInteractionHandler(
                                            function(x,y,event){
                                                const numerator = initialY-currentMousePosition(event);
                                                const divider = _canvas_.core.viewport.scale();
                                                set( initialValue - (numerator/(divider*mux) ) );
                                            },
                                            function(x,y,event){
                                                grappled = false;
                                            }
                                        );
                                    });
                            
                                //setup
                                    set(value);
                            
                                //callbacks
                                    object.onchange = onchange; 
                                    object.onrelease = onrelease;
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.slide_continuous = function(name,data){ return interfacePart.collection.control.slide_continuous(
                                name, data.x, data.y, data.width, data.height, data.angle, data.interactable, data.handleHeight, data.value, data.resetValue, 
                                data.style.handle, data.style.backing, data.style.slot, data.style.invisibleHandle,
                                data.onchange, data.onrelease
                            ); };
                            this.slide_discrete_image = function(
                                name='slide_discrete_image', 
                                x, y, width=10, height=95, angle=0, interactable=true,
                                handleHeight=0.1, value=0, resetValue=-1, optionCount=5,
                                handleURL, backingURL,
                                invisibleHandleStyle = {r:1,g:0,b:0,a:0},
                                onchange=function(){},
                                onrelease=function(){},
                            ){
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    
                                    //slide
                                        const slide = interfacePart.builder('control','slide_continuous_image',name,{
                                            x:0, y:0, width:width, height:height, angle:0, interactable:interactable,
                                            invisibleHandleStyle:invisibleHandleStyle, handleHeight:handleHeight,
                                            handleURL:handleURL, backingURL:backingURL,
                                        });
                                        object.append(slide);
                            
                                //graphical adjust
                                    function set(a,update=true){ 
                                        a = (a>(optionCount-1) ? (optionCount-1) : a);
                                        a = (a<0 ? 0 : a);
                            
                                        a = Math.round(a); 
                                        if(update && object.onchange != undefined && value != a){object.onchange(a);}
                                        value = a;
                                        slide.set( value/(optionCount-1) );
                                    };
                                    function currentMousePosition(event){
                                        const calculationAngle = object.getOffset().angle;
                                        return event.Y*Math.cos(calculationAngle) - event.X*Math.sin(calculationAngle);
                                    }
                            
                                //methods
                                    let grappled = false;
                            
                                    object.set = function(value,update){
                                        if(grappled){return;}
                                        set(value,update);
                                    };
                                    object.get = function(){return value;};
                                    object.interactable = function(bool){
                                        if(bool==undefined){return interactable;}
                                        interactable = bool;
                                    };
                            
                                //interaction
                                    let acc = 0;
                            
                                    slide.getChildByName('cover').attachCallback('ondblclick', function(){
                                        if(!interactable){return;}
                                        if(resetValue<0){return;}
                                        if(grappled){return;}
                                        
                                        set(resetValue);
                            
                                        if(object.onrelease != undefined){object.onrelease(value);}
                                    });
                                    slide.getChildByName('cover').attachCallback('onwheel', function(x,y,event){
                                        if(!interactable){return;}
                                        if(grappled){return;}
                            
                                        const move = event.wheelDelta/100;
                            
                                        acc += move;
                                        if( Math.abs(acc) >= 1 ){
                                            set( value +1*Math.sign(acc) );
                                            acc = 0;
                                            if(object.onrelease != undefined){object.onrelease(value);}
                                        }
                                    });
                                    slide.getChildByName('invisibleHandle').attachCallback('onmousedown', function(x,y,event){
                                        if(!interactable){return;}
                                        grappled = true;
                            
                                        const initialValue = value/(optionCount-1);
                                        const initialY = currentMousePosition(event);
                                        const mux = height - height*handleHeight;
                            
                                        _canvas_.system.mouse.mouseInteractionHandler(
                                            function(x,y,event){
                                                const numerator = initialY-currentMousePosition(event);
                                                const divider = _canvas_.core.viewport.scale();
                                                set( (initialValue - (numerator/(divider*mux) ))*(optionCount-1) );
                                            },
                                            function(x,y,event){
                                                grappled = false;
                                            }
                                        );
                                    });
                                    slide.getChildByName('backingAndSlotGroup').getChildByName('backingAndSlotCover').attachCallback('onclick', function(x,y,event){
                                        if(!interactable){return;}
                                        if(grappled){return;}
                            
                                        //calculate the distance the click is from the top of the slider (accounting for angle)
                                            const backingAndSlot = slide.getChildByName('backingAndSlotGroup');
                                            const backingAndSlotCover = backingAndSlot.getChildByName('backingAndSlotCover');
                                            const offset = backingAndSlot.getOffset();
                                            const delta = {
                                                x: x - (backingAndSlot.x() + offset.x),
                                                y: y - (backingAndSlot.y() + offset.y),
                                                a: 0 - (backingAndSlot.angle() + offset.angle),
                                            };
                                            const d = _canvas_.library.math.cartesianAngleAdjust( delta.x/offset.scale, delta.y/offset.scale, delta.a ).y / backingAndSlotCover.height();
                            
                                        //use the distance to calculate the correct value to set the slide to
                                        //taking into account the slide handle's size also
                                            const value = d + 0.5*handleHeight*((2*d)-1);
                            
                                        set(value*(optionCount-1));
                                        if(object.onrelease != undefined){object.onrelease(value);}
                                    });
                            
                                //callbacks
                                    object.onchange = onchange; 
                                    object.onrelease = onrelease;
                            
                                //setup
                                    set(value);
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.slide_discrete_image = function(name,data){ return interfacePart.collection.control.slide_discrete_image(
                                name, data.x, data.y, data.width, data.height, data.angle, data.interactable, data.handleHeight, data.value, data.resetValue, data.optionCount,
                                data.handleURL, data.backingURL, data.invisibleHandle,
                                data.onchange, data.onrelease
                            ); };
                            this.checkbox_rectangle = function(
                                name='checkbox_rectangle',
                                x, y, width=20, height=20, angle=0, interactable=true,
                                percentageSize=0.9,
                                checkStyle={r:0.58,g:0.58,b:0.58,a:1},
                                backingStyle={r:0.78,g:0.78,b:0.78,a:1},
                                checkGlowStyle={r:0.86,g:0.86,b:0.86,a:1},
                                backingGlowStyle={r:0.86,g:0.86,b:0.86,a:1},
                                onchange = function(){},
                            ){
                            
                                //adding on the specific shapes
                                    //main
                                        const subject = interfacePart.builder('basic','group',name+'subGroup');
                                    //backing
                                        const backing = interfacePart.builder('basic','rectangle','backing',{width:width, height:height, colour:backingStyle});
                                        subject.append(backing);
                                    //check
                                        const checkrect = interfacePart.builder('basic','rectangle','checkrect',{
                                            x:width*(1-percentageSize),
                                            y:height*(1-percentageSize),
                                            width:width*(percentageSize*2 - 1),
                                            height:height*(percentageSize*2 - 1), 
                                            colour:{r:0,g:0,b:0,a:0}
                                        });
                                        subject.append(checkrect);
                                    //cover
                                        subject.cover = interfacePart.builder('basic','rectangle','cover',{width:width, height:height, colour:{r:0,g:0,b:0,a:0}});
                                        subject.append(subject.cover);
                            
                                //generic checkbox part
                                    const object = interfacePart.builder(
                                        'control', 'checkbox_', name, {
                                            x:x, y:y, angle:angle, interactable:interactable,
                                            onchange:onchange,
                                            subject:subject,
                                        }
                                    );
                            
                                //graphical state adjust
                                    object.updateGraphics = function(state){
                                        if(state.glowing){
                                            backing.colour(backingGlowStyle);
                                            checkrect.colour(state.checked ? checkGlowStyle : {r:0,g:0,b:0,a:0});
                                        }else{
                                            backing.colour(backingStyle);
                                            checkrect.colour(state.checked ? checkStyle : {r:0,g:0,b:0,a:0});
                                        }
                                    };
                                    object.updateGraphics({checked:false,glowing:false});
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.checkbox_rectangle = function(name,data){ return interfacePart.collection.control.checkbox_rectangle(
                                name, data.x, data.y, data.width, data.height, data.angle, data.interactable,
                                data.percentageSize,
                                data.style.check, data.style.backing, data.style.checkGlow, data.style.backingGlow,
                                data.onchange,
                            ); };
                            this.checkbox_image = function(
                                name='checkbox_image',
                                x, y, width=20, height=20, angle=0, interactable=true,
                                uncheckURL='', checkURL='', uncheckGlowURL='', checkGlowStyle='',
                                onchange = function(){},
                            ){
                            
                                //adding on the specific shapes
                                    //main
                                        const subject = interfacePart.builder('basic','group',name+'subGroup');
                                    //backing
                                        const backing = interfacePart.builder('basic','image','backing',{width:width, height:height, url:uncheckURL});
                                        subject.append(backing);
                                    //cover
                                        subject.cover = interfacePart.builder('basic','rectangle','cover',{width:width, height:height, colour:{r:0,g:0,b:0,a:0}});
                                        subject.append(subject.cover);
                            
                                //generic checkbox part
                                    const object = interfacePart.builder(
                                        'control', 'checkbox_', name, {
                                            x:x, y:y, angle:angle, interactable:interactable,
                                            onchange:onchange,
                                            subject:subject,
                                        }
                                    );
                            
                                //graphical state adjust
                                    object.updateGraphics = function(state){
                                        if(state.glowing){
                                            backing.url(state.checked ? checkGlowStyle : uncheckGlowURL);
                                        }else{
                                            backing.url(state.checked ? checkURL : uncheckURL);
                                        }
                                    };
                                    object.updateGraphics({checked:false,glowing:false});
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.checkbox_image = function(name,data){ return interfacePart.collection.control.checkbox_image(
                                name, data.x, data.y, data.width, data.height, data.angle, data.interactable,
                                data.uncheckURL, data.checkURL, data.uncheckGlowURL, data.checkGlowURL,
                                data.onchange,
                            ); };
                            this.checkbox_ = function(
                                name='checkbox_',
                                x, y, angle=0, interactable=true,
                            
                                onchange = function(){},
                            
                                subject
                            ){
                            
                                if(subject == undefined){console.warn('checkbox_ : No subject provided');}
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    //subject
                                        object.append(subject);
                            
                                //state
                                    const state = {
                                        checked:false,
                                        glowing:false,
                                    };
                            
                                //methods
                                    object.get = function(){ return state.checked; };
                                    object.set = function(value, update=true){
                                        state.checked = value;
                                        
                                        object.updateGraphics(state);
                                
                                        if(update && this.onchange){ this.onchange(value); }
                                    };
                                    object.toggle = function(){
                                        object.set(!object.get());
                                    };
                                    object.light = function(a){
                                        if(a == undefined){ return state.glowing; }
                            
                                        state.glowing = a;
                            
                                        object.updateGraphics(state);
                                    };
                                    object.interactable = function(bool){
                                        if(bool == undefined){return interactable;}
                                        interactable = bool;
                                    };
                            
                                //interactivity
                                    subject.cover.attachCallback('onclick', (x,y,event) => { 
                                        if(!interactable){return;}
                                        object.set(!object.get());
                                    });
                                    subject.cover.attachCallback('onmousedown', () => {});
                                    subject.cover.attachCallback('onmouseup', () => {});
                            
                                //callbacks
                                    object.onchange = onchange;
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.checkbox_ = function(name,data){ return interfacePart.collection.control.checkbox_(
                                name, data.x, data.y, data.angle, data.interactable,
                                data.onchange, data.subject,
                            ); };
                            this.checkbox_polygon = function(
                                name='checkbox_polygon',
                                x, y, 
                                outterPoints=[{x:0,y:4},{x:4,y:0}, {x:16,y:0},{x:20,y:4}, {x:20,y:16},{x:16,y:20}, {x:4,y:20},{x:0,y:16}],
                                innerPoints=[ {x:2,y:4},{x:4,y:2}, {x:16,y:2},{x:18,y:4}, {x:18,y:16},{x:16,y:18}, {x:4,y:18},{x:2,y:16}],
                                angle=0, interactable=true,
                                checkStyle={r:0.58,g:0.58,b:0.58,a:1},
                                backingStyle={r:0.78,g:0.78,b:0.78,a:1},
                                checkGlowStyle={r:0.86,g:0.86,b:0.86,a:1},
                                backingGlowStyle={r:0.86,g:0.86,b:0.86,a:1},
                                onchange = function(){},
                            ){
                            
                                //adding on the specific shapes
                                    //main
                                        const subject = interfacePart.builder('basic','group',name+'subGroup',{});
                                    //backing
                                        const backing = interfacePart.builder('basic','polygon','backing',{pointsAsXYArray:outterPoints, colour:backingStyle});
                                        subject.append(backing);
                                    //check
                                        const checkpoly = interfacePart.builder('basic','polygon','checkpoly',{pointsAsXYArray:innerPoints, colour:{r:0,g:0,b:0,a:0}});
                                        subject.append(checkpoly);
                                    //cover
                                        subject.cover = interfacePart.builder('basic','polygon','cover',{pointsAsXYArray:outterPoints, colour:{r:0,g:0,b:0,a:0}});
                                        subject.append(subject.cover);
                            
                                //generic checkbox part
                                    const object = interfacePart.builder(
                                        'control', 'checkbox_', name, {
                                            x:x, y:y, angle:angle, interactable:interactable,
                                            onchange:onchange,
                                            subject:subject,
                                        }
                                    );
                            
                                //graphical state adjust
                                    object.updateGraphics = function(state){
                                        if(state.glowing){
                                            backing.colour(backingGlowStyle);
                                            checkpoly.colour(state.checked ? checkGlowStyle : {r:0,g:0,b:0,a:0});
                                        }else{
                                            backing.colour(backingStyle);
                                            checkpoly.colour(state.checked ? checkStyle : {r:0,g:0,b:0,a:0});
                                        }
                                    };
                                    object.updateGraphics({checked:false,glowing:false});
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.checkbox_polygon = function(name,data){ return interfacePart.collection.control.checkbox_polygon(
                                name, data.x, data.y, data.outterPoints, data.innerPoints, data.angle, data.interactable,
                                data.style.check, data.style.backing, data.style.checkGlow, data.style.backingGlow,
                                data.onchange,
                            ); };
                            this.checkbox_circle = function(
                                name='checkbox_circle',
                                x, y, radius=10, angle=0, interactable=true,
                                percentageSize=0.9,
                                checkStyle={r:0.58,g:0.58,b:0.58,a:1},
                                backingStyle={r:0.78,g:0.78,b:0.78,a:1},
                                checkGlowStyle={r:0.86,g:0.86,b:0.86,a:1},
                                backingGlowStyle={r:0.86,g:0.86,b:0.86,a:1},
                                onchange = function(){},
                            ){
                            
                                //adding on the specific shapes
                                    //main
                                        const subject = interfacePart.builder('basic','group',name+'subGroup');
                                    //backing
                                        const backing = interfacePart.builder('basic','circle','backing',{radius:radius, colour:backingStyle});
                                        subject.append(backing);
                                    //check
                                        const checkcirc = interfacePart.builder('basic','circle','checkcirc',{radius:radius*(percentageSize*2 - 1), colour:{r:0,g:0,b:0,a:0}});
                                        subject.append(checkcirc);
                                    //cover
                                        subject.cover = interfacePart.builder('basic','circle','cover',{radius:radius, colour:{r:0,g:0,b:0,a:0}});
                                        subject.append(subject.cover);
                            
                                //generic checkbox part
                                    const object = interfacePart.builder(
                                        'control', 'checkbox_', name, {
                                            x:x, y:y, angle:angle, interactable:interactable,
                                            onchange:onchange,
                                            subject:subject,
                                        }
                                    );
                            
                                //graphical state adjust
                                    object.updateGraphics = function(state){
                                        if(state.glowing){
                                            backing.colour(backingGlowStyle);
                                            checkcirc.colour(state.checked ? checkGlowStyle : {r:0,g:0,b:0,a:0});
                                        }else{
                                            backing.colour(backingStyle);
                                            checkcirc.colour(state.checked ? checkStyle : {r:0,g:0,b:0,a:0});
                                        }
                                    };
                                    object.updateGraphics({checked:false,glowing:false});
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.checkbox_circle = function(name,data){ return interfacePart.collection.control.checkbox_circle(
                                name, data.x, data.y, data.radius, data.angle, data.interactable,
                                data.percentageSize,
                                data.style.check, data.style.backing, data.style.checkGlow, data.style.backingGlow,
                                data.onchange,
                            ); };
                            this.checkboxgrid = function(
                                name='checkboxgrid', 
                                x, y, width=80, height=80, angle=0, interactable=true,
                                xcount=5, ycount=5, percentageSize=0.9,
                                checkStyle={r:0.58,g:0.58,b:0.58,a:1},
                                backingStyle={r:0.78,g:0.78,b:0.78,a:1},
                                checkGlowStyle={r:0.86,g:0.86,b:0.86,a:1},
                                backingGlowStyle={r:0.86,g:0.86,b:0.86,a:1},
                                onchange = function(){},
                            ){
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    
                                    //checkboxes
                                        for(let y = 0; y < ycount; y++){
                                            for(let x = 0; x < xcount; x++){
                                                const temp = interfacePart.builder('control','checkbox_rectangle',y+'_'+x,{
                                                    x:x*(width/xcount), y:y*(height/ycount), 
                                                    width:width/xcount, height:height/ycount, interactable:interactable, percentageSize:percentageSize,
                                                    style:{ check:checkStyle, backing:backingStyle, checkGlow:checkGlowStyle, backingGlow:backingGlowStyle },
                                                    onchange:function(){ if(object.onchange){object.onchange(object.get());} },
                                                });
                                                object.append(temp);
                                            }
                                        }
                            
                                //methods
                                    object.box = function(x,y){ return object.getChildByName(y+'_'+x); };
                                    object.get = function(){
                                        const outputArray = [];
                                
                                        for(let y = 0; y < ycount; y++){
                                            const temp = [];
                                            for(let x = 0; x < xcount; x++){
                                                temp.push(this.box(x,y).get());
                                            }
                                            outputArray.push(temp);
                                        }
                                
                                        return outputArray;
                                    };
                                    object.set = function(value, update=true){
                                        for(let y = 0; y < ycount; y++){
                                            for(let x = 0; x < xcount; x++){
                                                object.box(x,y).set(value[y][x],false);
                                            }
                                        }
                                    };
                                    object.clear = function(){
                                        for(let y = 0; y < ycount; y++){
                                            for(let x = 0; x < xcount; x++){
                                                object.box(x,y).set(false,false);
                                            }
                                        }
                                    };
                                    object.light = function(x,y,state){
                                        object.box(x,y).light(state);
                                    };
                                    object.interactable = function(bool){
                                        if(bool==undefined){return interactable;}
                                        interactable = bool;
                                        for(let y = 0; y < ycount; y++){
                                            for(let x = 0; x < xcount; x++){
                                                object.getChildByName(y+'_'+x).interactable(bool);
                                            }
                                        }
                                    };
                            
                                //callback
                                    object.onchange = onchange;
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.checkboxgrid = function(name,data){ return interfacePart.collection.control.checkboxgrid(
                                name, data.x, data.y, data.width, data.height, data.angle, data.interactable, data.xCount, data.yCount, data.percentageSize,
                                data.style.check, data.style.backing, data.style.checkGlow, data.style.backingGlow,
                                data.onchange
                            ); };
                            this.dial_continuous_image = function(
                                name='dial_continuous_image',
                                x, y, radius=10, angle=0, interactable=true,
                                value=0, resetValue=-1,
                                startAngle=(3*Math.PI)/4, maxAngle=1.5*Math.PI,
                            
                                handleURL, slotURL, needleURL,
                                
                                onchange=function(){},
                                onrelease=function(){},
                            ){
                            
                                //default to non-image version if image links are missing
                                    if(handleURL == undefined && slotURL == undefined && needleURL == undefined){
                                        return this.dial_1_continuous(
                                            name, x, y, radius, angle, interactable, value, resetValue, startAngle, maxAngle,
                                            undefined, undefined, undefined,
                                            onchange, onrelease
                                        );
                                    }
                            
                            
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    
                                    //slot
                                        if(slotURL != undefined){
                                            const slot = interfacePart.builder('basic','image','slot',{width:2.2*radius, height:2.2*radius, anchor:{x:0.5,y:0.5}, url:slotURL});
                                            object.append(slot);
                                        }
                            
                                    //handle
                                        let handle;
                                        if(handleURL != undefined){
                                            handle = interfacePart.builder('basic','image','handle',{width:2*radius, height:2*radius, anchor:{x:0.5,y:0.5}, url:handleURL});
                                        }else{
                                            handle = interfacePart.builder('basic','circle','handle',{radius:radius, detail:50, colour:{r:0,g:0,b:0,a:0}});
                                        }
                                        object.append(handle);
                            
                                    //needle group
                                        let needleGroup;
                                        if(needleURL != undefined){
                                            needleGroup = interfacePart.builder('basic','group','needleGroup',{ignored:true});
                                            object.append(needleGroup);
                            
                                            //needle
                                                const needleWidth = radius/5;
                                                const needleLength = radius;
                                                const needle = interfacePart.builder('basic','image','needle',{x:needleLength/3, y:-needleWidth/2, height:needleWidth, width:needleLength, url:needleURL});
                                                    needleGroup.append(needle);
                                        }
                            
                                //graphical adjust
                                    function set(a,update=true){
                                        a = (a>1 ? 1 : a);
                                        a = (a<0 ? 0 : a);
                            
                                        if(update && object.onchange != undefined){object.onchange(a);}
                            
                                        value = a;
                                        if(needleURL != undefined){ needleGroup.angle(startAngle + maxAngle*value); }
                                        if(handle != undefined){ handle.angle(startAngle + maxAngle*value); }
                                    }
                            
                                //methods
                                    let grappled = false;
                            
                                    object.set = function(value,update){
                                        if(grappled){return;}
                                        set(value,update);
                                    };
                                    object.get = function(){return value;};
                                    object.interactable = function(bool){
                                        if(bool==undefined){return interactable;}
                                        interactable = bool;
                                    };
                            
                                //interaction
                                    const turningSpeed = radius*32;
                                    
                                    handle.attachCallback('ondblclick', function(){
                                        if(!interactable){return;}
                                        if(resetValue<0){return;}
                                        if(grappled){return;}
                                        
                                        set(resetValue); 
                            
                                        if(object.onrelease != undefined){object.onrelease(value);}
                                    });
                                    handle.attachCallback('onwheel', function(x,y,event){
                                        if(!interactable){return;}
                                        if(grappled){return;}
                                        
                                        const move = event.wheelDelta/100;
                                        const globalScale = _canvas_.core.viewport.scale();
                                        set( value - move/(10*globalScale) );
                            
                                        if(object.onrelease != undefined){object.onrelease(value);}
                                    });
                                    handle.attachCallback('onmousedown', function(x,y,event){
                                        if(!interactable){return;}
                                        const initialValue = value;
                                        const initialY = event.Y;
                            
                                        grappled = true;
                                        _canvas_.system.mouse.mouseInteractionHandler(
                                            function(x,y,event){
                                                const value = initialValue;
                                                const numerator = event.Y - initialY;
                                                const divider = _canvas_.core.viewport.scale();
                                                set( value - (numerator/(divider*turningSpeed) * window.devicePixelRatio), true );
                                            },
                                            function(x,y,event){
                                                grappled = false;
                                                if(object.onrelease != undefined){object.onrelease(value);}
                                            }
                                        );
                                    });
                            
                                //callbacks
                                    object.onchange = onchange; 
                                    object.onrelease = onrelease;
                            
                                //setup
                                    set(value);
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.dial_continuous_image = function(name,data){ return interfacePart.collection.control.dial_continuous_image(
                                name,
                                data.x, data.y, data.radius, data.angle, data.interactable,
                                data.value, data.resetValue,
                                data.startAngle, data.maxAngle,
                                data.handleURL, data.slotURL, data.needleURL,
                                data.onchange, data.onrelease
                            ); };
                            this.dial_1_discrete = function(
                                name='dial_1_discrete',
                                x, y, radius=10, angle=0, interactable=true,
                                value=0, resetValue=0, optionCount=5,
                                startAngle=(3*Math.PI)/4, maxAngle=1.5*Math.PI,
                            
                                handleStyle = {r:0.85, g:0.85, b:0.85, a:1},
                                slotStyle =   {r:0.2,  g:0.2,  b:0.2,  a:1},
                                needleStyle = {r:1,    g:0.4,  b:0.4,  a:1},
                            
                                onchange=function(){},
                                onrelease=function(){},
                            ){
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    
                                    //dial
                                        const dial = interfacePart.builder('control','dial_1_continuous',name,{
                                            x:0, y:0, radius:radius, angle:0, interactable:interactable,
                                            startAngle:startAngle, maxAngle:maxAngle,
                                            style:{ handle:handleStyle, slot:slotStyle, needle:needleStyle }
                                        });
                                        object.append(dial);
                                    
                                //graphical adjust
                                    function set(a,update=true){
                                        a = (a>(optionCount-1) ? (optionCount-1) : a);
                                        a = (a<0 ? 0 : a);
                                        a = Math.round(a);
                                        if(a == value){return;}
                            
                                        if(update && object.onchange != undefined){object.onchange(a);}
                            
                                        value = a;
                                        dial.set( value/(optionCount-1) );
                                    };
                            
                                //methods
                                    let grappled = false;
                            
                                    object.set = function(value,update){
                                        if(grappled){return;}
                                        set(value,update);
                                    };
                                    object.get = function(){return value;};
                                    object.interactable = function(bool){
                                        if(bool==undefined){return interactable;}
                                        interactable = bool;
                                    };
                                    object.nudge = function(amount){
                                        set(value+amount);
                                    };
                            
                                //interaction
                                    let acc = 0;
                            
                                    dial.getChildByName('handle').attachCallback('ondblclick', function(){
                                        if(!interactable){return;}
                                        if(resetValue<0){return;}
                                        if(grappled){return;}
                                        
                                        set(resetValue);
                            
                                        if(object.onrelease != undefined){object.onrelease(value);}
                                    });
                                    dial.getChildByName('handle').attachCallback('onwheel', function(x,y,event){
                                        if(!interactable){return;}
                                        if(grappled){return;}
                            
                                        const move = event.wheelDelta/100;
                            
                                        acc += move;
                                        if( Math.abs(acc) >= 1 ){
                                            set( value -1*Math.sign(acc) );
                                            acc = 0;
                                            if(object.onrelease != undefined){object.onrelease(value);}
                                        }
                                    });
                                    dial.getChildByName('handle').attachCallback('onmousedown', function(x,y,event){
                                        if(!interactable){return;}
                                        const initialValue = value;
                                        const initialY = event.Y;
                            
                                        grappled = true;
                                        _canvas_.system.mouse.mouseInteractionHandler(
                                            function(x,y,event){
                                                const diff = Math.round( (event.Y - initialY)/25 );
                                                set( initialValue - diff );
                                            },
                                            function(x,y,event){
                                                grappled = false;
                                                if(object.onrelease != undefined){object.onrelease(value);}
                                            }
                                        );
                                    });
                            
                                //callbacks
                                    object.onchange = onchange; 
                                    object.onrelease = onrelease;
                            
                                //setup
                                    set(value);
                                    dial.set( Math.round(value)/(optionCount-1) );
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.dial_1_discrete = function(name,data){ return interfacePart.collection.control.dial_1_discrete(
                                name,
                                data.x, data.y, data.radius, data.angle, data.interactable,
                                data.value, data.resetValue, data.optionCount,
                                data.startAngle, data.maxAngle,
                                data.style.handle, data.style.slot, data.style.needle,
                                data.onchange, data.onrelease
                            ); };
                            interfacePart.partLibrary.control.dial_discrete = interfacePart.partLibrary.control.dial_1_discrete;
                            this.dial_1_continuous = function(
                                name='dial_1_continuous',
                                x, y, radius=10, angle=0, interactable=true,
                                value=0, resetValue=-1,
                                startAngle=(3*Math.PI)/4, maxAngle=1.5*Math.PI,
                            
                                handleStyle = {r:0.85, g:0.85, b:0.85, a:1},
                                slotStyle =   {r:0.2,  g:0.2,  b:0.2,  a:1},
                                needleStyle = {r:1,    g:0.4,  b:0.4,  a:1},
                            
                                onchange=function(){},
                                onrelease=function(){},
                            ){
                                
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    
                                    //slot
                                        const slot = interfacePart.builder('basic','circle','slot',{radius:radius*1.1, detail:50, colour:slotStyle});
                                        object.append(slot);
                            
                                    //handle
                                        const handle = interfacePart.builder('basic','circle','handle',{radius:radius, detail:50, colour:handleStyle});
                                        object.append(handle);
                            
                                    //needle group
                                        const needleGroup = interfacePart.builder('basic','group','needleGroup',{ignored:true});
                                        object.append(needleGroup);
                            
                                        //needle
                                            const needleWidth = radius/5;
                                            const needleLength = radius;
                                            const needle = interfacePart.builder('basic','rectangle','needle',{x:needleLength/3, y:-needleWidth/2, height:needleWidth, width:needleLength, colour:needleStyle});
                                            needleGroup.append(needle);
                            
                                //graphical adjust
                                    function set(a,update=true){
                                        a = (a>1 ? 1 : a);
                                        a = (a<0 ? 0 : a);
                            
                                        if(update && object.onchange != undefined){object.onchange(a);}
                            
                                        value = a;
                                        needleGroup.angle(startAngle + maxAngle*value);
                                    }
                            
                                //methods
                                    let grappled = false;
                            
                                    object.set = function(value,update){
                                        if(grappled){return;}
                                        set(value,update);
                                    };
                                    object.get = function(){return value;};
                                    object.interactable = function(bool){
                                        if(bool==undefined){return interactable;}
                                        interactable = bool;
                                    };
                            
                                //interaction
                                    const turningSpeed = radius*32;
                                    
                                    handle.attachCallback('ondblclick', function(){
                                        if(!interactable){return;}
                                        if(resetValue<0){return;}
                                        if(grappled){return;}
                                        
                                        set(resetValue); 
                            
                                        if(object.onrelease != undefined){object.onrelease(value);}
                                    });
                                    handle.attachCallback('onwheel', function(x,y,event){
                                        if(!interactable){return;}
                                        if(grappled){return;}
                                        
                                        const move = event.wheelDelta/100;
                                        const globalScale = _canvas_.core.viewport.scale();
                                        set( value - move/(10*globalScale) );
                            
                                        if(object.onrelease != undefined){object.onrelease(value);}
                                    });
                                    handle.attachCallback('onmousedown', function(x,y,event){
                                        if(!interactable){return;}
                                        const initialValue = value;
                                        const initialY = event.Y;
                            
                                        grappled = true;
                                        _canvas_.system.mouse.mouseInteractionHandler(
                                            function(x,y,event){
                                                const value = initialValue;
                                                const numerator = event.Y - initialY;
                                                const divider = _canvas_.core.viewport.scale();
                                                set( value - (numerator/(divider*turningSpeed) * window.devicePixelRatio), true );
                                            },
                                            function(x,y,event){
                                                grappled = false;
                                                if(object.onrelease != undefined){object.onrelease(value);}
                                            }
                                        );
                                    });
                            
                                //callbacks
                                    object.onchange = onchange; 
                                    object.onrelease = onrelease;
                            
                                //setup
                                    set(value);
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.dial_1_continuous = function(name,data){ return interfacePart.collection.control.dial_1_continuous(
                                name,
                                data.x, data.y, data.radius, data.angle, data.interactable,
                                data.value, data.resetValue,
                                data.startAngle, data.maxAngle,
                                data.style.handle, data.style.slot, data.style.needle,
                                data.onchange, data.onrelease
                            ); };
                            interfacePart.partLibrary.control.dial_continuous = interfacePart.partLibrary.control.dial_1_continuous;
                            this.dial_discrete_image = function(
                                name='dial_discrete_image',
                                x, y, radius=10, angle=0, interactable=true,
                                value=0, resetValue=0, optionCount=5,
                                startAngle=(3*Math.PI)/4, maxAngle=1.5*Math.PI,
                            
                                handleURL, slotURL, needleURL,
                            
                                onchange=function(){},
                                onrelease=function(){},
                            ){
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    
                                    //dial
                                        const dial = interfacePart.builder('control','dial_continuous_image',name,{
                                            x:0, y:0, radius:radius, angle:0, interactable:interactable,
                                            startAngle:startAngle, maxAngle:maxAngle,
                                            handleURL:handleURL, slotURL:slotURL, needleURL:needleURL,
                                        });
                                        object.append(dial);
                            
                                //graphical adjust
                                    function set(a,update=true){ 
                                        a = (a>(optionCount-1) ? (optionCount-1) : a);
                                        a = (a<0 ? 0 : a);
                                        a = Math.round(a);
                                        if(a == value){return;}
                            
                                        if(update && object.onchange != undefined){object.onchange(a);}
                            
                                        value = a;
                                        dial.set( value/(optionCount-1) );
                                    };
                            
                                //methods
                                    let grappled = false;
                            
                                    object.set = function(value,update){
                                        if(grappled){return;}
                                        set(value,update);
                                    };
                                    object.get = function(){return value;};
                                    object.interactable = function(bool){
                                        if(bool==undefined){return interactable;}
                                        interactable = bool;
                                    };
                                    object.nudge = function(amount){
                                        set(value+amount);
                                    };
                            
                                //interaction
                                    let acc = 0;
                            
                                    dial.getChildByName('handle').attachCallback('ondblclick', function(){
                                        if(!interactable){return;}
                                        if(resetValue<0){return;}
                                        if(grappled){return;}
                                        
                                        set(resetValue);
                            
                                        if(object.onrelease != undefined){object.onrelease(value);}
                                    });
                                    dial.getChildByName('handle').attachCallback('onwheel', function(x,y,event){
                                        if(!interactable){return;}
                                        if(grappled){return;}
                            
                                        const move = event.wheelDelta/100;
                            
                                        acc += move;
                                        if( Math.abs(acc) >= 1 ){
                                            set( value -1*Math.sign(acc) );
                                            acc = 0;
                                            if(object.onrelease != undefined){object.onrelease(value);}
                                        }
                                    });
                                    dial.getChildByName('handle').attachCallback('onmousedown', function(x,y,event){
                                        if(!interactable){return;}
                                        const initialValue = value;
                                        const initialY = event.Y;
                            
                                        grappled = true;
                                        _canvas_.system.mouse.mouseInteractionHandler(
                                            function(x,y,event){
                                                const diff = Math.round( (event.Y - initialY)/25 );
                                                set( initialValue - diff );
                                            },
                                            function(x,y,event){
                                                grappled = false;
                                                if(object.onrelease != undefined){object.onrelease(value);}
                                            }
                                        );
                                    });
                            
                                //callbacks
                                    object.onchange = onchange; 
                                    object.onrelease = onrelease;
                            
                                //setup
                                    set(value);
                                    dial.set( Math.round(value)/(optionCount-1) );
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.dial_discrete_image = function(name,data){ return interfacePart.collection.control.dial_discrete_image(
                                name,
                                data.x, data.y, data.radius, data.angle, data.interactable,
                                data.value, data.resetValue, data.optionCount,
                                data.startAngle, data.maxAngle,
                                data.handleURL, data.slotURL, data.needleURL,
                                data.onchange, data.onrelease
                            ); };
                            this.dial_2_discrete = function(
                                name='dial_2_discrete',
                                x, y, radius=10, angle=0, interactable=true,
                                value=0, resetValue=0, optionCount=5,
                                startAngle=(3*Math.PI)/4, maxAngle=1.5*Math.PI,
                            
                                handleStyle = {r:1,g:0.1,b:0.1,a:1},
                                slotStyle =   {r:0,g:0,b:0,a:0},
                                needleStyle = {r:1,g:1,b:1,a:1},
                            
                                onchange=function(){},
                                onrelease=function(){},
                            ){
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    
                                    //dial
                                        const dial = interfacePart.builder('control','dial_2_continuous',name,{
                                            x:0, y:0, radius:radius, angle:0, interactable:interactable,
                                            startAngle:startAngle, maxAngle:maxAngle,
                                            style:{ handle:handleStyle, slot:slotStyle, needle:needleStyle }
                                        });
                                        object.append(dial);
                            
                                //graphical adjust
                                    function set(a,update=true){ 
                                        a = (a>(optionCount-1) ? (optionCount-1) : a);
                                        a = (a<0 ? 0 : a);
                                        a = Math.round(a);
                                        if(a == value){return;}
                            
                                        if(update && object.onchange != undefined){object.onchange(a);}
                            
                                        value = a;
                                        dial.set( value/(optionCount-1) );
                                    };
                            
                                //methods
                                    let grappled = false;
                            
                                    object.set = function(value,update){
                                        if(grappled){return;}
                                        set(value,update);
                                    };
                                    object.get = function(){return value;};
                                    object.interactable = function(bool){
                                        if(bool==undefined){return interactable;}
                                        interactable = bool;
                                    };
                                    object.nudge = function(amount){
                                        set(value+amount);
                                    };
                            
                                //interaction
                                    let acc = 0;
                            
                                    dial.getChildByName('handle').attachCallback('ondblclick', function(){
                                        if(!interactable){return;}
                                        if(resetValue<0){return;}
                                        if(grappled){return;}
                                        
                                        set(resetValue);
                            
                                        if(object.onrelease != undefined){object.onrelease(value);}
                                    });
                                    dial.getChildByName('handle').attachCallback('onwheel', function(x,y,event){
                                        if(!interactable){return;}
                                        if(grappled){return;}
                            
                                        const move = event.wheelDelta/100;
                            
                                        acc += move;
                                        if( Math.abs(acc) >= 1 ){
                                            set( value -1*Math.sign(acc) );
                                            acc = 0;
                                            if(object.onrelease != undefined){object.onrelease(value);}
                                        }
                                    });
                                    dial.getChildByName('handle').attachCallback('onmousedown', function(x,y,event){
                                        if(!interactable){return;}
                                        const initialValue = value;
                                        const initialY = event.Y;
                            
                                        grappled = true;
                                        _canvas_.system.mouse.mouseInteractionHandler(
                                            function(x,y,event){
                                                const diff = Math.round( (event.Y - initialY)/25 );
                                                set( initialValue - diff );
                                            },
                                            function(x,y,event){
                                                grappled = false;
                                                if(object.onrelease != undefined){object.onrelease(value);}
                                            }
                                        );
                                    });
                            
                                //callbacks
                                    object.onchange = onchange; 
                                    object.onrelease = onrelease;
                            
                                //setup
                                    set(value);
                                    dial.set( Math.round(value)/(optionCount-1) );
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.dial_2_discrete = function(name,data){ return interfacePart.collection.control.dial_2_discrete(
                                name,
                                data.x, data.y, data.radius, data.angle, data.interactable,
                                data.value, data.resetValue, data.optionCount,
                                data.startAngle, data.maxAngle,
                                data.style.handle, data.style.slot, data.style.needle,
                                data.onchange, data.onrelease
                            ); };
                            this.dial_2_continuous = function(
                                name='dial_2_continuous',
                                x, y, radius=10, angle=0, interactable=true,
                                value=0, resetValue=-1,
                                startAngle=(3*Math.PI)/4, maxAngle=1.5*Math.PI,
                            
                                handleStyle = {r:1,g:0.1,b:0.1,a:1},
                                slotStyle =   {r:0,g:0,b:0,a:0},
                                needleStyle = {r:1,g:1,b:1,a:1},
                            
                                onchange=function(){},
                                onrelease=function(){},
                            ){
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    
                                    //slot
                                        const slot = interfacePart.builder('basic','circle','slot',{radius:radius*1.1, detail:50, colour:slotStyle});
                                        object.append(slot);
                                    
                                    //handle
                                        const handle = interfacePart.builder('basic','circle','handle',{radius:radius, detail:50, colour:handleStyle});
                                        object.append(handle);
                            
                                    //needle group
                                        const needleGroup = interfacePart.builder('basic','group','needleGroup',{ignored:true});
                                        object.append(needleGroup);
                            
                                        //needle
                                            const needleWidth = radius/8;
                                            const needleLength = radius/2;
                                            const needle = interfacePart.builder('basic','rectangle','needle',{x:radius*0.8-needleLength, y:-needleWidth/2, height:needleWidth, width:needleLength, colour:needleStyle});
                                            needleGroup.append(needle);
                            
                                            const needleTip = interfacePart.builder('basic','circle','needleTip',{x:radius*0.8, radius:needleWidth/2, detail:10, colour:needleStyle});
                                            needleGroup.append(needleTip);
                            
                                            const needleBase = interfacePart.builder('basic','circle','needleBase',{x:radius*0.8-needleLength, radius:needleWidth/2, detail:10, colour:needleStyle});
                                            needleGroup.append(needleBase);
                            
                                //graphical adjust
                                    function set(a,update=true){
                                        a = (a>1 ? 1 : a);
                                        a = (a<0 ? 0 : a);
                            
                                        if(update && object.onchange != undefined){object.onchange(a);}
                            
                                        value = a;
                                        needleGroup.angle(startAngle + maxAngle*value);
                                    }
                            
                                //methods
                                    let grappled = false;
                            
                                    object.set = function(value,update){
                                        if(grappled){return;}
                                        set(value,update);
                                    };
                                    object.get = function(){return value;};
                                    object.interactable = function(bool){
                                        if(bool==undefined){return interactable;}
                                        interactable = bool;
                                    };
                            
                                //interaction
                                    const turningSpeed = radius*32;
                                    
                                    handle.attachCallback('ondblclick',function(){
                                        if(!interactable){return;}
                                        if(resetValue<0){return;}
                                        if(grappled){return;}
                                        
                                        set(resetValue); 
                            
                                        if(object.onrelease != undefined){object.onrelease(value);}
                                    });
                                    handle.attachCallback('onwheel',function(x,y,event){
                                        if(!interactable){return;}
                                        if(grappled){return;}
                                        
                                        const move = event.wheelDelta/100;
                                        const globalScale = _canvas_.core.viewport.scale();
                                        set( value - move/(10*globalScale) );
                            
                                        if(object.onrelease != undefined){object.onrelease(value);}
                                    });
                                    handle.attachCallback('onmousedown',function(x,y,event){
                                        if(!interactable){return;}
                                        const initialValue = value;
                                        const initialY = event.Y;
                            
                                        grappled = true;
                                        _canvas_.system.mouse.mouseInteractionHandler(
                                            function(x,y,event){
                                                const value = initialValue;
                                                const numerator = event.Y - initialY;
                                                const divider = _canvas_.core.viewport.scale();
                                                set( value - (numerator/(divider*turningSpeed) * window.devicePixelRatio), true );
                                            },
                                            function(x,y,event){
                                                grappled = false;
                                                if(object.onrelease != undefined){object.onrelease(value);}
                                            }
                                        );
                                    });
                            
                                //callbacks
                                    object.onchange = onchange; 
                                    object.onrelease = onrelease;
                            
                                //setup
                                    set(value);
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.dial_2_continuous = function(name,data){ return interfacePart.collection.control.dial_2_continuous(
                                name,
                                data.x, data.y, data.radius, data.angle, data.interactable,
                                data.value, data.resetValue,
                                data.startAngle, data.maxAngle,
                                data.style.handle, data.style.slot, data.style.needle,
                                data.onchange, data.onrelease
                            ); };
                            this.rangeslide_image = function(
                                name='rangeslide_image', 
                                x, y, width=10, height=95, angle=0, interactable=true,
                                handleHeight=0.1, spanWidth=0.75, values={start:0,end:1}, resetValues={start:-1,end:-1},
                            
                                handleURL, backingURL,
                                invisibleHandleStyle={r:1,g:0,b:0,a:0},
                                spanURL,
                            
                                onchange=function(){},
                                onrelease=function(){},
                            ){
                            
                                //default to non-image version if handle image link is missing
                                    if(handleURL == undefined){
                                        return this.rangeslide(
                                            name, x, y, width, height, angle, interactable,
                                            handleHeight, spanWidth, values, resetValues,
                                            undefined, undefined, invisibleHandleStyle, undefined,
                                            onchange, onrelease,
                                        );
                                    }
                            
                                let grappled = false;
                                const handleNames = ['start','end'];
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    //backing and slot group
                                        const backingAndSlot = interfacePart.builder('basic','group','backingAndSlotGroup');
                                        object.append(backingAndSlot);
                                        //backing
                                            if(backingURL != undefined){
                                                const backing = interfacePart.builder('basic','image','backing',{width:width, height:height, url:backingURL});
                                                backingAndSlot.append(backing);
                                            }
                                        //backing and slot cover
                                            const backingAndSlotCover = interfacePart.builder('basic','rectangle','backingAndSlotCover',{width:width, height:height, colour:{r:0,g:0,b:0,a:0}});
                                            backingAndSlot.append(backingAndSlotCover);
                            
                                    //span
                                        const span = interfacePart.builder('basic','image','span',{x:width*((1-spanWidth)/2), y:height*handleHeight, width:width*spanWidth, height:height - 2*height*handleHeight, url:spanURL});
                                        object.append(span);
                            
                                    //handles
                                        const handles = {}
                                        for(let a = 0; a < handleNames.length; a++){
                                            //grouping
                                                handles[handleNames[a]] = interfacePart.builder('basic','group','handle_'+a,{})
                                                object.append(handles[handleNames[a]]);
                                            //handle
                                                const handle = interfacePart.builder('basic','image','handle',{width:width, height:height*handleHeight, url:handleURL});
                                                handles[handleNames[a]].append(handle);
                                            //invisible handle
                                                const invisibleHandleHeight = height*handleHeight + height*0.01;
                                                const invisibleHandle = interfacePart.builder('basic','rectangle','invisibleHandle',{y:(height*handleHeight - invisibleHandleHeight)/2, width:width, height:invisibleHandleHeight+handleHeight, colour:invisibleHandleStyle});
                                                handles[handleNames[a]].append(invisibleHandle);
                                        }
                            
                                    //cover
                                        const cover = interfacePart.builder('basic','rectangle','cover',{width:width, height:height, colour:{r:0,g:0,b:0,a:0}});
                                        object.append(cover);
                            
                                //graphical adjust
                                    function set(a,handle,update=true){
                                        a = (a>1 ? 1 : a);
                                        a = (a<0 ? 0 : a);
                            
                                        //make sure the handle order is maintained
                                        //if necessary, one handle should push the other, though not past the ends
                                            switch(handle){
                                                default: console.error('unknown handle to adjust'); break;
                                                case 'start':
                                                    {
                                                        //don't allow start slide to encrouch on end slider's space
                                                            if( a / (1-(handleHeight/(1-handleHeight))) >= 1 ){ a = 1-(handleHeight/(1-handleHeight)); }
                            
                                                        //if start slide bumps up against end slide; move end slide accordingly
                                                            const start_rightEdge = a + (1-a)*handleHeight;
                                                            const end_leftEdge = values.end - (values.end)*handleHeight;
                                                            if( start_rightEdge >= end_leftEdge ){
                                                                values.end = start_rightEdge/(1-handleHeight);
                                                            }
                                                    }
                                                break;
                                                case 'end':
                                                    {
                                                        //don't allow end slide to encrouch on start slider's space
                                                            if( a / (handleHeight/(1-handleHeight)) <= 1 ){ a = handleHeight/(1-handleHeight); }
                            
                                                        //if end slide bumps up against start slide; move start slide accordingly
                                                            const start_rightEdge= values.start + (1-values.start)*handleHeight;
                                                            const end_leftEdge = a - (a)*handleHeight;
                                                            if( start_rightEdge >= end_leftEdge ){
                                                                values.start = (end_leftEdge - handleHeight)/(1-handleHeight);
                                                            }
                                                    }
                                                break;
                                            }
                            
                                        //fill in data
                                            values[handle] = a;
                            
                                        //adjust y positions
                                            handles.start.y( values.start*height*(1-handleHeight) );
                                            handles.end.y( values.end*height*(1-handleHeight) );
                            
                                        //adjust span height (with a little bit of padding so the span is under the handles a little)
                                            span.y( height*(handleHeight + values.start - handleHeight*(values.start + 0.1)) );
                                            span.height( height*( values.end - values.start + handleHeight*(values.start - values.end - 1 + 0.2) ) );
                            
                                        if(update && object.onchange){object.onchange(values);}
                                    }
                                    function pan(a){
                                        const diff = values.end - values.start;
                            
                                        const newPositions = [ a, a+diff ];
                                        if(newPositions[0] <= 0){
                                            newPositions[1] = newPositions[1] - newPositions[0];
                                            newPositions[0] = 0;
                                        }
                                        else if(newPositions[1] >= 1){
                                            newPositions[0] = newPositions[0] - (newPositions[1]-1);
                                            newPositions[1] = 1;
                                        }
                            
                                        set( newPositions[0],'start' );
                                        set( newPositions[1],'end' );
                                    }
                            
                                //methods
                                    object.get = function(){return values;};
                                    object.set = function(values,update){
                                        if(grappled){return;}
                                        if(values.start != undefined){set(values.start,'start',update);}
                                        if(values.end != undefined){set(values.end,'end',update);}
                                    };
                                    object.interactable = function(bool){
                                        if(bool==undefined){return interactable;}
                                        interactable = bool;
                                    };
                            
                                //interaction
                                    function getPositionWithinFromMouse(x,y){
                                        //calculate the distance the click is from the top of the slider (accounting for angle)
                                            const offset = backingAndSlot.getOffset();
                                            const delta = {
                                                x: x - (backingAndSlot.x()     + offset.x),
                                                y: y - (backingAndSlot.y()     + offset.y),
                                                a: 0 - (backingAndSlot.angle() + offset.angle),
                                            };
                            
                                        return _canvas_.library.math.cartesianAngleAdjust( delta.x/offset.scale, delta.y/offset.scale, delta.a ).y / backingAndSlotCover.height();
                                    }
                                    function currentMousePosition(event){
                                        const calculationAngle = object.getOffset().angle;
                                        return event.Y*Math.cos(calculationAngle) - event.X*Math.sin(calculationAngle);
                                    }
                            
                                    //background click
                                        //to stop clicks passing through the span
                                            span.attachCallback('onmousedown', function(){});
                                            span.attachCallback('onclick', function(){});
                                            
                                        backingAndSlotCover.attachCallback('onmousedown', function(){}); //to stop unit selection
                                        backingAndSlotCover.attachCallback('onclick', function(x,y,event){
                                            if(!interactable){return;}
                                            if(grappled){return;}
                            
                                            //calculate the distance the click is from the top of the slider (accounting for angle)
                                                const d = getPositionWithinFromMouse(x,y);
                            
                                            //use the distance to calculate the correct value to set the slide to
                                            //taking into account the slide handle's size also
                                                const value = d + 0.5*handleHeight*((2*d)-1);
                            
                                            //whichever handle is closer; move that handle to the mouse's position
                                                Math.abs(values.start-value) < Math.abs(values.end-value) ? set(value,'start') : set(value,'end');
                                        });
                            
                                    //double-click reset
                                        cover.attachCallback('ondblclick', function(){
                                            if(!interactable){return;}
                                            if(resetValues.start<0 || resetValues.end<0){return;}
                                            if(grappled){return;}
                            
                                            set(resetValues.start,'start');
                                            set(resetValues.end,'end');
                                            object.onrelease(values);
                                        } );
                            
                                    //span panning - expand/shrink
                                        cover.attachCallback('onwheel', function(x,y,event){
                                            if(!interactable){return;}
                                            if(grappled){return;}
                            
                                            const move = event.wheelDelta/100;
                                            const globalScale = _canvas_.core.viewport.scale();
                                            const val = move/(10*globalScale);
                            
                                            set(values.start-val,'start');
                                            set(values.end+val,'end');
                                        } );
                            
                                    //span panning - drag
                                        span.attachCallback('onmousedown', function(x,y,event){
                                            if(!interactable){return;}
                                            grappled = true;
                            
                                            const initialValue = values.start;
                                            const initialY = currentMousePosition(event);
                                            const mux = height - height*handleHeight;
                            
                                            _canvas_.system.mouse.mouseInteractionHandler(
                                                function(x,y,event){
                                                    const numerator = initialY - currentMousePosition(event);
                                                    const divider = _canvas_.core.viewport.scale();
                                                    pan( initialValue - (numerator/(divider*mux)) )
                                                    object.onchange(values);
                                                },
                                                function(x,y,event){
                                                    object.onrelease(values);
                                                    grappled = false;
                                                }
                                            );
                                        } );
                            
                                    //handle movement
                                        for(let a = 0; a < handleNames.length; a++){
                                            handles[handleNames[a]].getChildren()[1].attachCallback('onclick', function(){});
                                            handles[handleNames[a]].getChildren()[1].attachCallback('onmousedown', (function(a){
                                                return function(x,y,event){
                                                    if(!interactable){return;}
                                                    grappled = true;
                            
                                                    const initialValue = values[handleNames[a]];
                                                    const initialY = currentMousePosition(event);
                                                    const mux = height - height*handleHeight;
                            
                                                    _canvas_.system.mouse.mouseInteractionHandler(
                                                        function(x,y,event){
                                                            const numerator = initialY-currentMousePosition(event);
                                                            const divider = _canvas_.core.viewport.scale();
                                                            set( initialValue - (numerator/(divider*mux) ), handleNames[a] );
                                                        },
                                                        function(x,y,event){
                                                            object.onrelease(values);
                                                            grappled = false;
                                                        }
                                                    );
                                                }
                                            })(a) );
                                        }
                                
                                //callbacks
                                    object.onchange = onchange;
                                    object.onrelease = onrelease;  
                            
                                //setup
                                    set(0,'start');
                                    set(1,'end');
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.rangeslide_image = function(name,data){ return interfacePart.collection.control.rangeslide_image(
                                name, data.x, data.y, data.width, data.height, data.angle, data.interactable, data.handleHeight, data.spanWidth, data.values, data.resetValues, 
                                data.handleURL, data.backingURL, data.style.invisibleHandle, data.spanURL,
                                data.onchange, data.onrelease
                            ); };
                            this.rangeslide = function(
                                name='rangeslide', 
                                x, y, width=10, height=95, angle=0, interactable=true,
                                handleHeight=0.1, spanWidth=0.75, values={start:0,end:1}, resetValues={start:-1,end:-1},
                                handleStyle={r:0.78,g:0.78,b:0.78,a:1},
                                backingStyle={r:0.58,g:0.58,b:0.58,a:1},
                                slotStyle={r:0.2,g:0.2,b:0.2,a:1},
                                invisibleHandleStyle={r:1,g:0,b:0,a:0},
                                spanStyle={r:0.78,g:0,b:0.78,a:0.5},
                                onchange=function(){},
                                onrelease=function(){},
                            ){
                            
                                let grappled = false;
                                const handleNames = ['start','end'];
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    //backing and slot group
                                        const backingAndSlot = interfacePart.builder('basic','group','backingAndSlotGroup');
                                        object.append(backingAndSlot);
                                        //backing
                                            const backing = interfacePart.builder('basic','rectangle','backing',{width:width, height:height, colour:backingStyle});
                                            backingAndSlot.append(backing);
                                        //slot
                                            const slot = interfacePart.builder('basic','rectangle','slot',{x:width*0.45, y:(height*(handleHeight/2)), width:width*0.1, height:height*(1-handleHeight), colour:slotStyle});
                                            backingAndSlot.append(slot);
                                        //backing and slot cover
                                            const backingAndSlotCover = interfacePart.builder('basic','rectangle','backingAndSlotCover',{width:width, height:height, colour:{r:0,g:0,b:0,a:0}});
                                            backingAndSlot.append(backingAndSlotCover);
                            
                                    //span
                                        const span = interfacePart.builder('basic','rectangle','span',{x:width*((1-spanWidth)/2), y:height*handleHeight, width:width*spanWidth, height:height - 2*height*handleHeight, colour:spanStyle });
                                        object.append(span);
                            
                                    //handles
                                        const handles = {}
                                        for(let a = 0; a < handleNames.length; a++){
                                            //grouping
                                                handles[handleNames[a]] = interfacePart.builder('basic','group','handle_'+a,{})
                                                object.append(handles[handleNames[a]]);
                                            //handle
                                                const handle = interfacePart.builder('basic','rectangle','handle',{width:width,height:height*handleHeight, colour:handleStyle});
                                                handles[handleNames[a]].append(handle);
                                            //invisible handle
                                                const invisibleHandleHeight = height*handleHeight + height*0.01;
                                                const invisibleHandle = interfacePart.builder('basic','rectangle','invisibleHandle',{y:(height*handleHeight - invisibleHandleHeight)/2, width:width, height:invisibleHandleHeight+handleHeight, colour:invisibleHandleStyle});
                                                handles[handleNames[a]].append(invisibleHandle);
                                        }
                            
                                    //cover
                                        const cover = interfacePart.builder('basic','rectangle','cover',{width:width, height:height, colour:{r:0,g:0,b:0,a:0}});
                                        object.append(cover);
                            
                                //graphical adjust
                                    function set(a,handle,update=true){
                                        a = (a>1 ? 1 : a);
                                        a = (a<0 ? 0 : a);
                            
                                        //make sure the handle order is maintained
                                        //if necessary, one handle should push the other, though not past the ends
                                            switch(handle){
                                                default: console.error('unknown handle to adjust'); break;
                                                case 'start':
                                                    {
                                                        //don't allow start slide to encrouch on end slider's space
                                                            if( a / (1-(handleHeight/(1-handleHeight))) >= 1 ){ a = 1-(handleHeight/(1-handleHeight)); }
                            
                                                        //if start slide bumps up against end slide; move end slide accordingly
                                                            const start_rightEdge = a + (1-a)*handleHeight;
                                                            const end_leftEdge = values.end - (values.end)*handleHeight;
                                                            if( start_rightEdge >= end_leftEdge ){
                                                                values.end = start_rightEdge/(1-handleHeight);
                                                            }
                                                    }
                                                break;
                                                case 'end':
                                                    {
                                                        //don't allow end slide to encrouch on start slider's space
                                                            if( a / (handleHeight/(1-handleHeight)) <= 1 ){ a = handleHeight/(1-handleHeight); }
                            
                                                        //if end slide bumps up against start slide; move start slide accordingly
                                                            const start_rightEdge= values.start + (1-values.start)*handleHeight;
                                                            const end_leftEdge = a - (a)*handleHeight;
                                                            if( start_rightEdge >= end_leftEdge ){
                                                                values.start = (end_leftEdge - handleHeight)/(1-handleHeight);
                                                            }
                                                    }
                                                break;
                                            }
                            
                                        //fill in data
                                            values[handle] = a;
                            
                                        //adjust y positions
                                            handles.start.y( values.start*height*(1-handleHeight) );
                                            handles.end.y( values.end*height*(1-handleHeight) );
                            
                                        //adjust span height (with a little bit of padding so the span is under the handles a little)
                                            span.y( height*(handleHeight + values.start - handleHeight*(values.start + 0.1)) );
                                            span.height( height*( values.end - values.start + handleHeight*(values.start - values.end - 1 + 0.2) ) );
                            
                                        if(update && object.onchange){object.onchange(values);}
                                    }
                                    function pan(a){
                                        const diff = values.end - values.start;
                            
                                        const newPositions = [ a, a+diff ];
                                        if(newPositions[0] <= 0){
                                            newPositions[1] = newPositions[1] - newPositions[0];
                                            newPositions[0] = 0;
                                        }
                                        else if(newPositions[1] >= 1){
                                            newPositions[0] = newPositions[0] - (newPositions[1]-1);
                                            newPositions[1] = 1;
                                        }
                            
                                        set( newPositions[0],'start' );
                                        set( newPositions[1],'end' );
                                    }
                            
                                //methods
                                    object.get = function(){return values;};
                                    object.set = function(values,update){
                                        if(grappled){return;}
                                        if(values.start != undefined){set(values.start,'start',update);}
                                        if(values.end != undefined){set(values.end,'end',update);}
                                    };
                                    object.interactable = function(bool){
                                        if(bool==undefined){return interactable;}
                                        interactable = bool;
                                    };
                                    
                                //interaction
                                    function getPositionWithinFromMouse(x,y){
                                        //calculate the distance the click is from the top of the slider (accounting for angle)
                                            const offset = backingAndSlot.getOffset();
                                            const delta = {
                                                x: x - (backingAndSlot.x()     + offset.x),
                                                y: y - (backingAndSlot.y()     + offset.y),
                                                a: 0 - (backingAndSlot.angle() + offset.angle),
                                            };
                            
                                        return _canvas_.library.math.cartesianAngleAdjust( delta.x/offset.scale, delta.y/offset.scale, delta.a ).y / backingAndSlotCover.height();
                                    }
                                    function currentMousePosition(event){
                                        const calculationAngle = object.getOffset().angle;
                                        return event.Y*Math.cos(calculationAngle) - event.X*Math.sin(calculationAngle);
                                    }
                            
                                    //background click
                                        //to stop clicks passing through the span
                                            span.attachCallback('onmousedown', function(){});
                                            span.attachCallback('onclick', function(){});
                                            
                                        backingAndSlotCover.attachCallback('onmousedown', function(){}); //to stop unit selection
                                        backingAndSlotCover.attachCallback('onclick', function(x,y,event){
                                            if(!interactable){return;}
                                            if(grappled){return;}
                            
                                            //calculate the distance the click is from the top of the slider (accounting for angle)
                                                const d = getPositionWithinFromMouse(x,y);
                            
                                            //use the distance to calculate the correct value to set the slide to
                                            //taking into account the slide handle's size also
                                                const value = d + 0.5*handleHeight*((2*d)-1);
                            
                                            //whichever handle is closer; move that handle to the mouse's position
                                                Math.abs(values.start-value) < Math.abs(values.end-value) ? set(value,'start') : set(value,'end');
                                        });
                            
                                    //double-click reset
                                        cover.attachCallback('ondblclick', function(){
                                            if(!interactable){return;}
                                            if(resetValues.start<0 || resetValues.end<0){return;}
                                            if(grappled){return;}
                            
                                            set(resetValues.start,'start');
                                            set(resetValues.end,'end');
                                            object.onrelease(values);
                                        } );
                            
                                    //span panning - expand/shrink
                                        cover.attachCallback('onwheel', function(x,y,event){
                                            if(!interactable){return;}
                                            if(grappled){return;}
                            
                                            const move = event.wheelDelta/100;
                                            const globalScale = _canvas_.core.viewport.scale();
                                            const val = move/(10*globalScale);
                            
                                            set(values.start-val,'start');
                                            set(values.end+val,'end');
                                        } );
                            
                                    //span panning - drag
                                        span.attachCallback('onmousedown', function(x,y,event){
                                            if(!interactable){return;}
                                            grappled = true;
                            
                                            const initialValue = values.start;
                                            const initialY = currentMousePosition(event);
                                            const mux = height - height*handleHeight;
                            
                                            _canvas_.system.mouse.mouseInteractionHandler(
                                                function(x,y,event){
                                                    const numerator = initialY - currentMousePosition(event);
                                                    const divider = _canvas_.core.viewport.scale();
                                                    pan( initialValue - (numerator/(divider*mux)) )
                                                    object.onchange(values);
                                                },
                                                function(x,y,event){
                                                    object.onrelease(values);
                                                    grappled = false;
                                                }
                                            );
                                        } );
                            
                                    //handle movement
                                        for(let a = 0; a < handleNames.length; a++){
                                            handles[handleNames[a]].getChildren()[1].attachCallback('onclick', function(){});
                                            handles[handleNames[a]].getChildren()[1].attachCallback('onmousedown', (function(a){
                                                return function(x,y,event){
                                                    if(!interactable){return;}
                                                    grappled = true;
                            
                                                    const initialValue = values[handleNames[a]];
                                                    const initialY = currentMousePosition(event);
                                                    const mux = height - height*handleHeight;
                            
                                                    _canvas_.system.mouse.mouseInteractionHandler(
                                                        function(x,y,event){
                                                            const numerator = initialY-currentMousePosition(event);
                                                            const divider = _canvas_.core.viewport.scale();
                                                            set( initialValue - (numerator/(divider*mux) ), handleNames[a] );
                                                        },
                                                        function(x,y,event){
                                                            object.onrelease(values);
                                                            grappled = false;
                                                        }
                                                    );
                                                }
                                            })(a) );
                                        }
                            
                                //callbacks
                                    object.onchange = onchange;
                                    object.onrelease = onrelease;  
                            
                                //setup
                                    set(0,'start');
                                    set(1,'end');
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.rangeslide = function(name,data){ return interfacePart.collection.control.rangeslide(
                                name, data.x, data.y, data.width, data.height, data.angle, data.interactable, data.handleHeight, data.spanWidth, data.values, data.resetValues, 
                                data.style.handle, data.style.backing, data.style.slot, data.style.invisibleHandle, data.style.span,
                                data.onchange, data.onrelease
                            ); };
                            this.button_circle = function(
                                name='button_circle',
                                x, y, radius=15,  angle=0, interactable=true,
                                text_centre='',
                                
                                active=true, hoverable=true, selectable=false, pressable=true,
                            
                                text_font='Arial',
                                text_size=2.5,
                                text_spacing=0.1,
                                text_interCharacterSpacing=0,
                            
                                text__off__colour={r:0,g:0,b:0,a:1},
                                text__up__colour={r:0,g:0,b:0,a:1},
                                text__press__colour={r:0,g:0,b:0,a:1},
                                text__select__colour={r:0,g:0,b:0,a:1},
                                text__select_press__colour={r:0,g:0,b:0,a:1},
                                text__glow__colour={r:0,g:0,b:0,a:1},
                                text__glow_press__colour={r:0,g:0,b:0,a:1},
                                text__glow_select__colour={r:0,g:0,b:0,a:1},
                                text__glow_select_press__colour={r:0,g:0,b:0,a:1},
                                text__hover__colour={r:0,g:0,b:0,a:1},
                                text__hover_press__colour={r:0,g:0,b:0,a:1},
                                text__hover_select__colour={r:0,g:0,b:0,a:1},
                                text__hover_select_press__colour={r:0,g:0,b:0,a:1},
                                text__hover_glow__colour={r:0,g:0,b:0,a:1},
                                text__hover_glow_press__colour={r:0,g:0,b:0,a:1},
                                text__hover_glow_select__colour={r:0,g:0,b:0,a:1},
                                text__hover_glow_select_press__colour={r:0,g:0,b:0,a:1},
                            
                                backing__off__colour=                            {r:180/255,g:180/255,b:180/255,a:1},
                                backing__off__lineColour=                        {r:0/255,g:0/255,b:0/255,a:0},
                                backing__off__lineThickness=                     0,
                                backing__up__colour=                             {r:200/255,g:200/255,b:200/255,a:1},
                                backing__up__lineColour=                         {r:0/255,g:0/255,b:0/255,a:0},
                                backing__up__lineThickness=                      0,
                                backing__press__colour=                          {r:230/255,g:230/255,b:230/255,a:1},
                                backing__press__lineColour=                      {r:0/255,g:0/255,b:0/255,a:0},
                                backing__press__lineThickness=                   0,
                                backing__select__colour=                         {r:200/255,g:200/255,b:200/255,a:1},
                                backing__select__lineColour=                     {r:120/255,g:120/255,b:120/255,a:1},
                                backing__select__lineThickness=                  0.75,
                                backing__select_press__colour=                   {r:230/255,g:230/255,b:230/255,a:1},
                                backing__select_press__lineColour=               {r:120/255,g:120/255,b:120/255,a:1},
                                backing__select_press__lineThickness=            0.75,
                                backing__glow__colour=                           {r:220/255,g:220/255,b:220/255,a:1},
                                backing__glow__lineColour=                       {r:0/255,g:0/255,b:0/255,a:0},
                                backing__glow__lineThickness=                    0,
                                backing__glow_press__colour=                     {r:250/255,g:250/255,b:250/255,a:1},
                                backing__glow_press__lineColour=                 {r:0/255,g:0/255,b:0/255,a:0},
                                backing__glow_press__lineThickness=              0,
                                backing__glow_select__colour=                    {r:220/255,g:220/255,b:220/255,a:1},
                                backing__glow_select__lineColour=                {r:120/255,g:120/255,b:120/255,a:1},
                                backing__glow_select__lineThickness=             0.75,
                                backing__glow_select_press__colour=              {r:250/255,g:250/255,b:250/255,a:1},
                                backing__glow_select_press__lineColour=          {r:120/255,g:120/255,b:120/255,a:1},
                                backing__glow_select_press__lineThickness=       0.75,
                                backing__hover__colour=                          {r:220/255,g:220/255,b:220/255,a:1},
                                backing__hover__lineColour=                      {r:0/255,g:0/255,b:0/255,a:0},
                                backing__hover__lineThickness=                   0,
                                backing__hover_press__colour=                    {r:240/255,g:240/255,b:240/255,a:1},
                                backing__hover_press__lineColour=                {r:0/255,g:0/255,b:0/255,a:0},
                                backing__hover_press__lineThickness=             0,
                                backing__hover_select__colour=                   {r:220/255,g:220/255,b:220/255,a:1},
                                backing__hover_select__lineColour=               {r:120/255,g:120/255,b:120/255,a:1},
                                backing__hover_select__lineThickness=            0.75,
                                backing__hover_select_press__colour=             {r:240/255,g:240/255,b:240/255,a:1},
                                backing__hover_select_press__lineColour=         {r:120/255,g:120/255,b:120/255,a:1},
                                backing__hover_select_press__lineThickness=      0.75,
                                backing__hover_glow__colour=                     {r:240/255,g:240/255,b:240/255,a:1},
                                backing__hover_glow__lineColour=                 {r:0/255,g:0/255,b:0/255,a:0},
                                backing__hover_glow__lineThickness=              0,
                                backing__hover_glow_press__colour=               {r:250/255,g:250/255,b:250/255,a:1},
                                backing__hover_glow_press__lineColour=           {r:0/255,g:0/255,b:0/255,a:0},
                                backing__hover_glow_press__lineThickness=        0,
                                backing__hover_glow_select__colour=              {r:240/255,g:240/255,b:240/255,a:1},
                                backing__hover_glow_select__lineColour=          {r:120/255,g:120/255,b:120/255,a:1},
                                backing__hover_glow_select__lineThickness=       0.75,
                                backing__hover_glow_select_press__colour=        {r:250/255,g:250/255,b:250/255,a:1},
                                backing__hover_glow_select_press__lineColour=    {r:120/255,g:120/255,b:120/255,a:1},
                                backing__hover_glow_select_press__lineThickness= 0.75,
                            
                                onenter = function(event){},
                                onleave = function(event){},
                                onpress = function(event){},
                                onpressrelease = function(event){},
                                ondblpress = function(event){},
                                onrelease = function(event){},
                                onselect = function(event){},
                                ondeselect = function(event){},
                            ){
                            
                                //adding on the specific shapes
                                    //main
                                        const subject = interfacePart.builder('basic','group',name+'subGroup',{});
                                    //backing
                                        const backing = interfacePart.builder('basic','circleWithOutline','backing',{radius:radius, colour:backing__off__colour, thickness:5 });
                                        subject.append(backing);
                                    //text
                                        const textCentreElement = interfacePart.builder('basic','text','centre', {
                                            text:text_centre, 
                                            width:text_size,
                                            height:text_size,
                                            colour:text__up__colour,
                                            font:text_font,
                                            printingMode:{widthCalculation:'absolute',horizontal:'middle',vertical:'middle'},
                                            spacing:text_spacing,
                                            interCharacterSpacing:text_interCharacterSpacing,
                                        });
                                        subject.append(textCentreElement);
                                    //cover
                                        subject.cover = interfacePart.builder('basic','circle','cover',{radius:radius, colour:{r:0,g:0,b:0,a:0}});
                                        subject.append(subject.cover);
                            
                                //generic button part
                                    const object = interfacePart.builder(
                                        'control', 'button_', name, {
                                            x:x, y:y, angle:angle, interactable:interactable,
                                            active:active, hoverable:hoverable, selectable:selectable, pressable:pressable,
                            
                                            onenter:onenter,
                                            onleave:onleave,
                                            onpress:onpress,
                                            onpressrelease:onpressrelease,
                                            ondblpress:ondblpress,
                                            onrelease:onrelease,
                                            onselect:onselect,
                                            ondeselect:ondeselect,
                            
                                            subject:subject,
                                        }
                                    );
                            
                                //graphical state adjust
                                    object.activateGraphicalState = function(state){
                                        if(!active){ 
                                            textCentreElement.colour(text__off__colour);
                                            backing.colour = backing__off__colour;
                                            backing.lineColour = backing__off__lineColour;
                                            backing.thickness( backing__off__lineThickness );
                                            return;
                                        }
                            
                                        const styles = [
                                            { text_colour:text__up__colour,                      colour:backing__up__colour,                      lineColour:backing__up__lineColour,                      lineThickness:backing__up__lineThickness                      },
                                            { text_colour:text__press__colour,                   colour:backing__press__colour,                   lineColour:backing__press__lineColour,                   lineThickness:backing__press__lineThickness                   },
                                            { text_colour:text__select__colour,                  colour:backing__select__colour,                  lineColour:backing__select__lineColour,                  lineThickness:backing__select__lineThickness                  },
                                            { text_colour:text__select_press__colour,            colour:backing__select_press__colour,            lineColour:backing__select_press__lineColour,            lineThickness:backing__select_press__lineThickness            },
                                            { text_colour:text__glow__colour,                    colour:backing__glow__colour,                    lineColour:backing__glow__lineColour,                    lineThickness:backing__glow__lineThickness                    },
                                            { text_colour:text__glow_press__colour,              colour:backing__glow_press__colour,              lineColour:backing__glow_press__lineColour,              lineThickness:backing__glow_press__lineThickness              },
                                            { text_colour:text__glow_select__colour,             colour:backing__glow_select__colour,             lineColour:backing__glow_select__lineColour,             lineThickness:backing__glow_select__lineThickness             },
                                            { text_colour:text__glow_select_press__colour,       colour:backing__glow_select_press__colour,       lineColour:backing__glow_select_press__lineColour,       lineThickness:backing__glow_select_press__lineThickness       },
                                            { text_colour:text__hover__colour,                   colour:backing__hover__colour,                   lineColour:backing__hover__lineColour,                   lineThickness:backing__hover__lineThickness                   },
                                            { text_colour:text__hover_press__colour,             colour:backing__hover_press__colour,             lineColour:backing__hover_press__lineColour,             lineThickness:backing__hover_press__lineThickness             },
                                            { text_colour:text__hover_select__colour,            colour:backing__hover_select__colour,            lineColour:backing__hover_select__lineColour,            lineThickness:backing__hover_select__lineThickness            },
                                            { text_colour:text__hover_select_press__colour,      colour:backing__hover_select_press__colour,      lineColour:backing__hover_select_press__lineColour,      lineThickness:backing__hover_select_press__lineThickness      },
                                            { text_colour:text__hover_glow__colour,              colour:backing__hover_glow__colour,              lineColour:backing__hover_glow__lineColour,              lineThickness:backing__hover_glow__lineThickness              },
                                            { text_colour:text__hover_glow_press__colour,        colour:backing__hover_glow_press__colour,        lineColour:backing__hover_glow_press__lineColour,        lineThickness:backing__hover_glow_press__lineThickness        },
                                            { text_colour:text__hover_glow_select__colour,       colour:backing__hover_glow_select__colour,       lineColour:backing__hover_glow_select__lineColour,       lineThickness:backing__hover_glow_select__lineThickness       },
                                            { text_colour:text__hover_glow_select_press__colour, colour:backing__hover_glow_select_press__colour, lineColour:backing__hover_glow_select_press__lineColour, lineThickness:backing__hover_glow_select_press__lineThickness },
                                        ];
                            
                                        if(!hoverable && state.hovering ){ state.hovering = false; }
                                        if(!selectable && state.selected ){ state.selected = false; }
                            
                                        const i = state.hovering*8 + state.glowing*4 + state.selected*2 + (pressable && state.pressed)*1;
                                        textCentreElement.colour(styles[i].text_colour);
                                        backing.colour(styles[i].colour);
                                        backing.lineColour(styles[i].lineColour);
                                        backing.thickness(styles[i].lineThickness);
                                    };
                                    object.activateGraphicalState({ hovering:false, glowing:false, selected:false, pressed:false });
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.button_circle = function(name,data){ return interfacePart.collection.control.button_circle(
                                name, data.x, data.y, data.r, data.angle, data.interactable,
                                data.text_centre,
                                data.active, data.hoverable, data.selectable, data.pressable,
                            
                                data.style.text_font, 
                                data.style.text_size, 
                                data.style.text_spacing, 
                                data.style.text_interCharacterSpacing,
                            
                                data.style.text__off__colour == undefined ? data.style.text_colour : data.style.text__off__colour,
                                data.style.text__up__colour == undefined ? data.style.text_colour : data.style.text__up__colour,
                                data.style.text__press__colour == undefined ? data.style.text_colour : data.style.text__press__colour,
                                data.style.text__select__colour == undefined ? data.style.text_colour : data.style.text__select__colour,
                                data.style.text__select_press__colour == undefined ? data.style.text_colour : data.style.text__select_press__colour,
                                data.style.text__glow__colour == undefined ? data.style.text_colour : data.style.text__glow__colour,
                                data.style.text__glow_press__colour == undefined ? data.style.text_colour : data.style.text__glow_press__colour,
                                data.style.text__glow_select__colour == undefined ? data.style.text_colour : data.style.text__glow_select__colour,
                                data.style.text__glow_select_press__colour == undefined ? data.style.text_colour : data.style.text__glow_select_press__colour,
                                data.style.text__hover__colour == undefined ? data.style.text_colour : data.style.text__hover__colour,
                                data.style.text__hover_press__colour == undefined ? data.style.text_colour : data.style.text__hover_press__colour,
                                data.style.text__hover_select__colour == undefined ? data.style.text_colour : data.style.text__hover_select__colour,
                                data.style.text__hover_select_press__colour == undefined ? data.style.text_colour : data.style.text__hover_select_press__colour,
                                data.style.text__hover_glow__colour == undefined ? data.style.text_colour : data.style.text__hover_glow__colour,
                                data.style.text__hover_glow_press__colour == undefined ? data.style.text_colour : data.style.text__hover_glow_press__colour,
                                data.style.text__hover_glow_select__colour == undefined ? data.style.text_colour : data.style.text__hover_glow_select__colour,
                                data.style.text__hover_glow_select_press__colour == undefined ? data.style.text_colour : data.style.text__hover_glow_select_press__colour,
                            
                                data.style.background__off__colour,                     data.style.background__off__lineColour,                     data.style.background__off__lineThickness,
                                data.style.background__up__colour,                      data.style.background__up__lineColour,                      data.style.background__up__lineThickness,
                                data.style.background__press__colour,                   data.style.background__press__lineColour,                   data.style.background__press__lineThickness,
                                data.style.background__select__colour,                  data.style.background__select__lineColour,                  data.style.background__select__lineThickness,
                                data.style.background__select_press__colour,            data.style.background__select_press__lineColour,            data.style.background__select_press__lineThickness,
                                data.style.background__glow__colour,                    data.style.background__glow__lineColour,                    data.style.background__glow__lineThickness,
                                data.style.background__glow_press__colour,              data.style.background__glow_press__lineColour,              data.style.background__glow_press__lineThickness,
                                data.style.background__glow_select__colour,             data.style.background__glow_select__lineColour,             data.style.background__glow_select__lineThickness,
                                data.style.background__glow_select_press__colour,       data.style.background__glow_select_press__lineColour,       data.style.background__glow_select_press__lineThickness,
                                data.style.background__hover__colour,                   data.style.background__hover__lineColour,                   data.style.background__hover__lineThickness,
                                data.style.background__hover_press__colour,             data.style.background__hover_press__lineColour,             data.style.background__hover_press__lineThickness,
                                data.style.background__hover_select__colour,            data.style.background__hover_select__lineColour,            data.style.background__hover_select__lineThickness,
                                data.style.background__hover_select_press__colour,      data.style.background__hover_select_press__lineColour,      data.style.background__hover_select_press__lineThickness,
                                data.style.background__hover_glow__colour,              data.style.background__hover_glow__lineColour,              data.style.background__hover_glow__lineThickness,
                                data.style.background__hover_glow_press__colour,        data.style.background__hover_glow_press__lineColour,        data.style.background__hover_glow_press__lineThickness,
                                data.style.background__hover_glow_select__colour,       data.style.background__hover_glow_select__lineColour,       data.style.background__hover_glow_select__lineThickness,
                                data.style.background__hover_glow_select_press__colour, data.style.background__hover_glow_select_press__lineColour, data.style.background__hover_glow_select_press__lineThickness,
                            
                                data.onenter,
                                data.onleave,
                                data.onpress,
                                data.onpressrelease,
                                data.ondblpress,
                                data.onrelease,
                                data.onselect,
                                data.ondeselect,
                            ); };
                            this.button_rectangle = function(
                                name='button_rectangle',
                                x, y, width=30, height=20, angle=0, interactable=true,
                                text_centre='', text_left='', text_right='',
                                textVerticalOffsetMux=0.5, textHorizontalOffsetMux=0.05,
                                
                                active=true, hoverable=true, selectable=false, pressable=true,
                            
                                text_font='Arial',
                                text_size=2.5,
                                text_spacing=0.1,
                                text_interCharacterSpacing=0,
                            
                                text__off__colour={r:0,g:0,b:0,a:1},
                                text__up__colour={r:0,g:0,b:0,a:1},
                                text__press__colour={r:0,g:0,b:0,a:1},
                                text__select__colour={r:0,g:0,b:0,a:1},
                                text__select_press__colour={r:0,g:0,b:0,a:1},
                                text__glow__colour={r:0,g:0,b:0,a:1},
                                text__glow_press__colour={r:0,g:0,b:0,a:1},
                                text__glow_select__colour={r:0,g:0,b:0,a:1},
                                text__glow_select_press__colour={r:0,g:0,b:0,a:1},
                                text__hover__colour={r:0,g:0,b:0,a:1},
                                text__hover_press__colour={r:0,g:0,b:0,a:1},
                                text__hover_select__colour={r:0,g:0,b:0,a:1},
                                text__hover_select_press__colour={r:0,g:0,b:0,a:1},
                                text__hover_glow__colour={r:0,g:0,b:0,a:1},
                                text__hover_glow_press__colour={r:0,g:0,b:0,a:1},
                                text__hover_glow_select__colour={r:0,g:0,b:0,a:1},
                                text__hover_glow_select_press__colour={r:0,g:0,b:0,a:1},
                            
                                backing__off__colour=                            {r:180/255,g:180/255,b:180/255,a:1},
                                backing__off__lineColour=                        {r:0/255,g:0/255,b:0/255,a:0},
                                backing__off__lineThickness=                     0,
                                backing__up__colour=                             {r:200/255,g:200/255,b:200/255,a:1},
                                backing__up__lineColour=                         {r:0/255,g:0/255,b:0/255,a:0},
                                backing__up__lineThickness=                      0,
                                backing__press__colour=                          {r:230/255,g:230/255,b:230/255,a:1},
                                backing__press__lineColour=                      {r:0/255,g:0/255,b:0/255,a:0},
                                backing__press__lineThickness=                   0,
                                backing__select__colour=                         {r:200/255,g:200/255,b:200/255,a:1},
                                backing__select__lineColour=                     {r:120/255,g:120/255,b:120/255,a:1},
                                backing__select__lineThickness=                  0.75,
                                backing__select_press__colour=                   {r:230/255,g:230/255,b:230/255,a:1},
                                backing__select_press__lineColour=               {r:120/255,g:120/255,b:120/255,a:1},
                                backing__select_press__lineThickness=            0.75,
                                backing__glow__colour=                           {r:220/255,g:220/255,b:220/255,a:1},
                                backing__glow__lineColour=                       {r:0/255,g:0/255,b:0/255,a:0},
                                backing__glow__lineThickness=                    0,
                                backing__glow_press__colour=                     {r:250/255,g:250/255,b:250/255,a:1},
                                backing__glow_press__lineColour=                 {r:0/255,g:0/255,b:0/255,a:0},
                                backing__glow_press__lineThickness=              0,
                                backing__glow_select__colour=                    {r:220/255,g:220/255,b:220/255,a:1},
                                backing__glow_select__lineColour=                {r:120/255,g:120/255,b:120/255,a:1},
                                backing__glow_select__lineThickness=             0.75,
                                backing__glow_select_press__colour=              {r:250/255,g:250/255,b:250/255,a:1},
                                backing__glow_select_press__lineColour=          {r:120/255,g:120/255,b:120/255,a:1},
                                backing__glow_select_press__lineThickness=       0.75,
                                backing__hover__colour=                          {r:220/255,g:220/255,b:220/255,a:1},
                                backing__hover__lineColour=                      {r:0/255,g:0/255,b:0/255,a:0},
                                backing__hover__lineThickness=                   0,
                                backing__hover_press__colour=                    {r:240/255,g:240/255,b:240/255,a:1},
                                backing__hover_press__lineColour=                {r:0/255,g:0/255,b:0/255,a:0},
                                backing__hover_press__lineThickness=             0,
                                backing__hover_select__colour=                   {r:220/255,g:220/255,b:220/255,a:1},
                                backing__hover_select__lineColour=               {r:120/255,g:120/255,b:120/255,a:1},
                                backing__hover_select__lineThickness=            0.75,
                                backing__hover_select_press__colour=             {r:240/255,g:240/255,b:240/255,a:1},
                                backing__hover_select_press__lineColour=         {r:120/255,g:120/255,b:120/255,a:1},
                                backing__hover_select_press__lineThickness=      0.75,
                                backing__hover_glow__colour=                     {r:240/255,g:240/255,b:240/255,a:1},
                                backing__hover_glow__lineColour=                 {r:0/255,g:0/255,b:0/255,a:0},
                                backing__hover_glow__lineThickness=              0,
                                backing__hover_glow_press__colour=               {r:250/255,g:250/255,b:250/255,a:1},
                                backing__hover_glow_press__lineColour=           {r:0/255,g:0/255,b:0/255,a:0},
                                backing__hover_glow_press__lineThickness=        0,
                                backing__hover_glow_select__colour=              {r:240/255,g:240/255,b:240/255,a:1},
                                backing__hover_glow_select__lineColour=          {r:120/255,g:120/255,b:120/255,a:1},
                                backing__hover_glow_select__lineThickness=       0.75,
                                backing__hover_glow_select_press__colour=        {r:250/255,g:250/255,b:250/255,a:1},
                                backing__hover_glow_select_press__lineColour=    {r:120/255,g:120/255,b:120/255,a:1},
                                backing__hover_glow_select_press__lineThickness= 0.75,
                            
                                onenter = function(event){},
                                onleave = function(event){},
                                onpress = function(event){},
                                onpressrelease = function(event){},
                                ondblpress = function(event){},
                                onrelease = function(event){},
                                onselect = function(event){},
                                ondeselect = function(event){},
                            ){
                            
                                //adding on the specific shapes
                                    //main
                                        const subject = interfacePart.builder('basic','group',name+'__subGroup');
                                    //backing
                                        const backing = interfacePart.builder('basic','rectangleWithOutline','backing',{width:width, height:height, colour:backing__off__colour, thickness:5 });
                                        subject.append(backing);
                                    //text
                                        const textCentreElement = interfacePart.builder('basic','text','centre', {
                                            x:width/2, 
                                            y:height*textVerticalOffsetMux, 
                                            text:text_centre, 
                                            width:text_size,
                                            height:text_size,
                                            colour:text__up__colour,
                                            font:text_font,
                                            printingMode:{ widthCalculation:'absolute',horizontal:'middle',vertical:'middle' },
                                            spacing:text_spacing,
                                            interCharacterSpacing:text_interCharacterSpacing,
                                        });
                                        subject.append(textCentreElement);
                                        const textLeftElement = interfacePart.builder('basic','text','left', {
                                            x:width*textHorizontalOffsetMux, 
                                            y:height*textVerticalOffsetMux, 
                                            text:text_left, 
                                            width:text_size,
                                            height:text_size,
                                            colour:text__up__colour,
                                            font:text_font,
                                            printingMode:{widthCalculation:'absolute',horizontal:'left',vertical:'middle'},
                                            spacing:text_spacing,
                                            interCharacterSpacing:text_interCharacterSpacing,
                                        });
                                        subject.append(textLeftElement);
                                        const textRightElement = interfacePart.builder('basic','text','right',{
                                            x:width-(width*textHorizontalOffsetMux), 
                                            y:height*textVerticalOffsetMux, 
                                            text:text_right, 
                                            width:text_size,
                                            height:text_size,
                                            colour:text__up__colour,
                                            font:text_font,
                                            printingMode:{widthCalculation:'absolute',horizontal:'right',vertical:'middle'},
                                            spacing:text_spacing,
                                            interCharacterSpacing:text_interCharacterSpacing,
                                        });
                                        subject.append(textRightElement);
                                    //cover
                                        subject.cover = interfacePart.builder('basic','rectangle','cover',{width:width, height:height, colour:{r:0,g:0,b:0,a:0} });
                                        subject.append(subject.cover);
                            
                                //generic button part
                                    const object = interfacePart.builder(
                                        'control', 'button_', name, {
                                            x:x, y:y, angle:angle, interactable:interactable,
                                            active:active, hoverable:hoverable, selectable:selectable, pressable:pressable,
                            
                                            onenter:onenter,
                                            onleave:onleave,
                                            onpress:onpress,
                                            onpressrelease:onpressrelease,
                                            ondblpress:ondblpress,
                                            onrelease:onrelease,
                                            onselect:onselect,
                                            ondeselect:ondeselect,
                            
                                            subject:subject,
                                        }
                                    );
                            
                                //graphical state adjust
                                    object.activateGraphicalState = function(state){
                                        if(!active){ 
                                            textCentreElement.colour(text__off__colour);
                                            textLeftElement.colour(text__off__colour);
                                            textRightElement.colour(text__off__colour);
                                            backing.colour = backing__off__colour;
                                            backing.lineColour = backing__off__lineColour;
                                            backing.thickness( backing__off__lineThickness );
                                            return;
                                        }
                                        
                                        const styles = [
                                            { text_colour:text__up__colour,                      colour:backing__up__colour,                      lineColour:backing__up__lineColour,                      lineThickness:backing__up__lineThickness                      },
                                            { text_colour:text__press__colour,                   colour:backing__press__colour,                   lineColour:backing__press__lineColour,                   lineThickness:backing__press__lineThickness                   },
                                            { text_colour:text__select__colour,                  colour:backing__select__colour,                  lineColour:backing__select__lineColour,                  lineThickness:backing__select__lineThickness                  },
                                            { text_colour:text__select_press__colour,            colour:backing__select_press__colour,            lineColour:backing__select_press__lineColour,            lineThickness:backing__select_press__lineThickness            },
                                            { text_colour:text__glow__colour,                    colour:backing__glow__colour,                    lineColour:backing__glow__lineColour,                    lineThickness:backing__glow__lineThickness                    },
                                            { text_colour:text__glow_press__colour,              colour:backing__glow_press__colour,              lineColour:backing__glow_press__lineColour,              lineThickness:backing__glow_press__lineThickness              },
                                            { text_colour:text__glow_select__colour,             colour:backing__glow_select__colour,             lineColour:backing__glow_select__lineColour,             lineThickness:backing__glow_select__lineThickness             },
                                            { text_colour:text__glow_select_press__colour,       colour:backing__glow_select_press__colour,       lineColour:backing__glow_select_press__lineColour,       lineThickness:backing__glow_select_press__lineThickness       },
                                            { text_colour:text__hover__colour,                   colour:backing__hover__colour,                   lineColour:backing__hover__lineColour,                   lineThickness:backing__hover__lineThickness                   },
                                            { text_colour:text__hover_press__colour,             colour:backing__hover_press__colour,             lineColour:backing__hover_press__lineColour,             lineThickness:backing__hover_press__lineThickness             },
                                            { text_colour:text__hover_select__colour,            colour:backing__hover_select__colour,            lineColour:backing__hover_select__lineColour,            lineThickness:backing__hover_select__lineThickness            },
                                            { text_colour:text__hover_select_press__colour,      colour:backing__hover_select_press__colour,      lineColour:backing__hover_select_press__lineColour,      lineThickness:backing__hover_select_press__lineThickness      },
                                            { text_colour:text__hover_glow__colour,              colour:backing__hover_glow__colour,              lineColour:backing__hover_glow__lineColour,              lineThickness:backing__hover_glow__lineThickness              },
                                            { text_colour:text__hover_glow_press__colour,        colour:backing__hover_glow_press__colour,        lineColour:backing__hover_glow_press__lineColour,        lineThickness:backing__hover_glow_press__lineThickness        },
                                            { text_colour:text__hover_glow_select__colour,       colour:backing__hover_glow_select__colour,       lineColour:backing__hover_glow_select__lineColour,       lineThickness:backing__hover_glow_select__lineThickness       },
                                            { text_colour:text__hover_glow_select_press__colour, colour:backing__hover_glow_select_press__colour, lineColour:backing__hover_glow_select_press__lineColour, lineThickness:backing__hover_glow_select_press__lineThickness },
                                        ];
                            
                                        if(!hoverable && state.hovering ){ state.hovering = false; }
                                        if(!selectable && state.selected ){ state.selected = false; }
                            
                                        const i = state.hovering*8 + state.glowing*4 + state.selected*2 + (pressable && state.pressed)*1;
                                        textCentreElement.colour(styles[i].text_colour);
                                        textLeftElement.colour(styles[i].text_colour);
                                        textRightElement.colour(styles[i].text_colour);
                                        backing.colour(styles[i].colour);
                                        backing.lineColour(styles[i].lineColour);
                                        backing.thickness(styles[i].lineThickness);
                                    };
                                    object.activateGraphicalState({ hovering:false, glowing:false, selected:false, pressed:false });
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.button_rectangle = function(name,data){ return interfacePart.collection.control.button_rectangle(
                                name, data.x, data.y, data.width, data.height, data.angle, data.interactable,
                                data.text_centre, data.text_left, data.text_right,
                                data.textVerticalOffsetMux, data.textHorizontalOffsetMux,
                                data.active, data.hoverable, data.selectable, data.pressable,
                            
                                data.style.text_font, 
                                data.style.text_size, 
                                data.style.text_spacing, 
                                data.style.text_interCharacterSpacing,
                            
                                data.style.text__off__colour == undefined ? data.style.text_colour : data.style.text__off__colour,
                                data.style.text__up__colour == undefined ? data.style.text_colour : data.style.text__up__colour,
                                data.style.text__press__colour == undefined ? data.style.text_colour : data.style.text__press__colour,
                                data.style.text__select__colour == undefined ? data.style.text_colour : data.style.text__select__colour,
                                data.style.text__select_press__colour == undefined ? data.style.text_colour : data.style.text__select_press__colour,
                                data.style.text__glow__colour == undefined ? data.style.text_colour : data.style.text__glow__colour,
                                data.style.text__glow_press__colour == undefined ? data.style.text_colour : data.style.text__glow_press__colour,
                                data.style.text__glow_select__colour == undefined ? data.style.text_colour : data.style.text__glow_select__colour,
                                data.style.text__glow_select_press__colour == undefined ? data.style.text_colour : data.style.text__glow_select_press__colour,
                                data.style.text__hover__colour == undefined ? data.style.text_colour : data.style.text__hover__colour,
                                data.style.text__hover_press__colour == undefined ? data.style.text_colour : data.style.text__hover_press__colour,
                                data.style.text__hover_select__colour == undefined ? data.style.text_colour : data.style.text__hover_select__colour,
                                data.style.text__hover_select_press__colour == undefined ? data.style.text_colour : data.style.text__hover_select_press__colour,
                                data.style.text__hover_glow__colour == undefined ? data.style.text_colour : data.style.text__hover_glow__colour,
                                data.style.text__hover_glow_press__colour == undefined ? data.style.text_colour : data.style.text__hover_glow_press__colour,
                                data.style.text__hover_glow_select__colour == undefined ? data.style.text_colour : data.style.text__hover_glow_select__colour,
                                data.style.text__hover_glow_select_press__colour == undefined ? data.style.text_colour : data.style.text__hover_glow_select_press__colour,
                            
                                data.style.background__off__colour,                     data.style.background__off__lineColour,                     data.style.background__off__lineThickness,
                                data.style.background__up__colour,                      data.style.background__up__lineColour,                      data.style.background__up__lineThickness,
                                data.style.background__press__colour,                   data.style.background__press__lineColour,                   data.style.background__press__lineThickness,
                                data.style.background__select__colour,                  data.style.background__select__lineColour,                  data.style.background__select__lineThickness,
                                data.style.background__select_press__colour,            data.style.background__select_press__lineColour,            data.style.background__select_press__lineThickness,
                                data.style.background__glow__colour,                    data.style.background__glow__lineColour,                    data.style.background__glow__lineThickness,
                                data.style.background__glow_press__colour,              data.style.background__glow_press__lineColour,              data.style.background__glow_press__lineThickness,
                                data.style.background__glow_select__colour,             data.style.background__glow_select__lineColour,             data.style.background__glow_select__lineThickness,
                                data.style.background__glow_select_press__colour,       data.style.background__glow_select_press__lineColour,       data.style.background__glow_select_press__lineThickness,
                                data.style.background__hover__colour,                   data.style.background__hover__lineColour,                   data.style.background__hover__lineThickness,
                                data.style.background__hover_press__colour,             data.style.background__hover_press__lineColour,             data.style.background__hover_press__lineThickness,
                                data.style.background__hover_select__colour,            data.style.background__hover_select__lineColour,            data.style.background__hover_select__lineThickness,
                                data.style.background__hover_select_press__colour,      data.style.background__hover_select_press__lineColour,      data.style.background__hover_select_press__lineThickness,
                                data.style.background__hover_glow__colour,              data.style.background__hover_glow__lineColour,              data.style.background__hover_glow__lineThickness,
                                data.style.background__hover_glow_press__colour,        data.style.background__hover_glow_press__lineColour,        data.style.background__hover_glow_press__lineThickness,
                                data.style.background__hover_glow_select__colour,       data.style.background__hover_glow_select__lineColour,       data.style.background__hover_glow_select__lineThickness,
                                data.style.background__hover_glow_select_press__colour, data.style.background__hover_glow_select_press__lineColour, data.style.background__hover_glow_select_press__lineThickness,
                            
                                data.onenter,
                                data.onleave,
                                data.onpress,
                                data.onpressrelease,
                                data.ondblpress,
                                data.onrelease,
                                data.onselect,
                                data.ondeselect,
                            ); };
                            this.button_ = function(
                                name='',
                                x, y, angle=0, interactable=true,
                                active=true, hoverable=true, selectable=false, pressable=true,
                            
                                onenter = function(event){},
                                onleave = function(event){},
                                onpress = function(event){},
                                onpressrelease = function(event){},
                                ondblpress = function(event){},
                                onrelease = function(event){},
                                onselect = function(event){},
                                ondeselect = function(event){},
                            
                                subject
                            ){
                            
                                if(subject == undefined){console.warn('button_ : No subject provided');}
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    //subject
                                        object.append(subject);
                            
                                //state
                                    object.state = {
                                        hovering:false,
                                        glowing:false,
                                        selected:false,
                                        pressed:false,
                                    };
                            
                                //control
                                    object.press = function(event){
                                        if(!active){return;}
                            
                                        if( pressable ){
                                            if(this.state.pressed){return;}
                                            this.state.pressed = true;
                                            if(this.onpress){this.onpress(this, event);}
                                        }
                                        
                                        this.select( !this.state.selected, event );
                            
                                        object.activateGraphicalState(object.state);
                                    };
                                    object.release = function(event){
                                        if(!active || !pressable){return;}
                            
                                        if(!this.state.pressed){return;}
                                        this.state.pressed = false;
                                        object.activateGraphicalState(object.state);
                                        if(this.onrelease){this.onrelease(this, event);}
                                    };
                                    object.active = function(bool){ if(bool == undefined){return active;} active = bool; object.activateGraphicalState(object.state); };
                                    object.glow = function(bool){   if(bool == undefined){return this.state.glowing;}  this.state.glowing = bool;  object.activateGraphicalState(object.state); };
                                    object.select = function(bool,event,callback=true){
                                        if(!active){return;}
                            
                                        if(bool == undefined){return this.state.selected;}
                                        if(!selectable){return;}
                                        if(this.state.selected == bool){return;}
                                        this.state.selected = bool; object.activateGraphicalState(object.state);
                                        if(callback){ if( this.state.selected ){ this.onselect(this,event); }else{ this.ondeselect(this,event); } }
                                    };
                                    object.hoverable = function(bool){
                                        if(bool==undefined){return hoverable;}
                                        hoverable = bool;
                                        if(!hoverable){
                                            object.state.hovering = false;
                                            object.activateGraphicalState(object.state); 
                                        }
                                    };
                                    object.interactable = function(bool){
                                        if(bool==undefined){return interactable;}
                                        interactable = bool;
                                    };
                                    object.selectable = function(bool){
                                        if(bool==undefined){return selectable;}
                                        selectable = bool;
                                    };
                                    object.forceMouseLeave = function(){
                                        object.state.hovering = false; 
                                        object.release('forced'); 
                                        object.activateGraphicalState(object.state); 
                                        if(object.onleave){object.onleave('forced');}
                                    };
                            
                                //interactivity
                                    subject.cover.attachCallback('onmouseenterelement',(x,y,event) => {
                                        if(hoverable){ object.state.hovering = true; }
                                        object.activateGraphicalState(object.state);
                                        if(object.onenter){object.onenter(event);}
                                        if(event.buttons == 1){subject.cover.getCallback('onmousedown')(x,y,event);} 
                                    });
                                    subject.cover.attachCallback('onmouseleaveelement',(x,y,event) => {
                                        if(hoverable){ object.state.hovering = false; }
                                        object.release(event); 
                                        object.activateGraphicalState(object.state); 
                                        if(object.onleave){object.onleave(event);}
                                    });
                            
                                    subject.cover.attachCallback('onmouseup', (x,y,event) => {   if(!interactable){return;} object.release(event); });
                                    subject.cover.attachCallback('onmousedown', (x,y,event) => { if(!interactable){return;} object.press(event); });
                                    subject.cover.attachCallback('onclick', (x,y,event) => { if(!interactable){return;} object.onpressrelease(event); });
                                    subject.cover.attachCallback('ondblclick', (x,y,event) => { if(!active){return;} if(!interactable){return;} if(object.ondblpress){object.ondblpress(event);} });
                                    
                                //callbacks
                                    object.onenter = onenter;
                                    object.onleave = onleave;
                                    object.onpress = onpress;
                                    object.onpressrelease = onpressrelease;
                                    object.ondblpress = ondblpress;
                                    object.onrelease = onrelease;
                                    object.onselect = onselect;
                                    object.ondeselect = ondeselect;
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.button_ = function(name,data){ return interfacePart.collection.control.button_(
                                name, data.x, data.y, data.angle, data.interactable,
                                data.active, data.hoverable, data.selectable, data.pressable,
                            
                                data.onenter,
                                data.onleave,
                                data.onpress,
                                data.onpressrelease,
                                data.ondblpress,
                                data.onrelease,
                                data.onselect,
                                data.ondeselect,
                                
                                data.subject,
                            ); };
                            this.button_polygon = function(
                                name='button_polygon',
                                x, y, points=[{x:0,y:5},{x:5,y:0}, {x:25,y:0},{x:30,y:5}, {x:30,y:25},{x:25,y:30}, {x:5,y:30},{x:0,y:25}], angle=0, interactable=true,
                                text='',
                                
                                active=true, hoverable=true, selectable=false, pressable=true,
                            
                                text_font = 'Arial',
                                text_size=2.5,
                                text_spacing=0.1,
                                text_interCharacterSpacing=0,
                            
                                text__off__colour={r:0,g:0,b:0,a:1},
                                text__up__colour={r:0,g:0,b:0,a:1},
                                text__press__colour={r:0,g:0,b:0,a:1},
                                text__select__colour={r:0,g:0,b:0,a:1},
                                text__select_press__colour={r:0,g:0,b:0,a:1},
                                text__glow__colour={r:0,g:0,b:0,a:1},
                                text__glow_press__colour={r:0,g:0,b:0,a:1},
                                text__glow_select__colour={r:0,g:0,b:0,a:1},
                                text__glow_select_press__colour={r:0,g:0,b:0,a:1},
                                text__hover__colour={r:0,g:0,b:0,a:1},
                                text__hover_press__colour={r:0,g:0,b:0,a:1},
                                text__hover_select__colour={r:0,g:0,b:0,a:1},
                                text__hover_select_press__colour={r:0,g:0,b:0,a:1},
                                text__hover_glow__colour={r:0,g:0,b:0,a:1},
                                text__hover_glow_press__colour={r:0,g:0,b:0,a:1},
                                text__hover_glow_select__colour={r:0,g:0,b:0,a:1},
                                text__hover_glow_select_press__colour={r:0,g:0,b:0,a:1},
                            
                                backing__off__colour=                            {r:180/255,g:180/255,b:180/255,a:1},
                                backing__off__lineColour=                        {r:0/255,g:0/255,b:0/255,a:0},
                                backing__off__lineThickness=                     0,
                                backing__up__colour=                             {r:200/255,g:200/255,b:200/255,a:1},
                                backing__up__lineColour=                         {r:0/255,g:0/255,b:0/255,a:0},
                                backing__up__lineThickness=                      0,
                                backing__press__colour=                          {r:230/255,g:230/255,b:230/255,a:1},
                                backing__press__lineColour=                      {r:0/255,g:0/255,b:0/255,a:0},
                                backing__press__lineThickness=                   0,
                                backing__select__colour=                         {r:200/255,g:200/255,b:200/255,a:1},
                                backing__select__lineColour=                     {r:120/255,g:120/255,b:120/255,a:1},
                                backing__select__lineThickness=                  0.75,
                                backing__select_press__colour=                   {r:230/255,g:230/255,b:230/255,a:1},
                                backing__select_press__lineColour=               {r:120/255,g:120/255,b:120/255,a:1},
                                backing__select_press__lineThickness=            0.75,
                                backing__glow__colour=                           {r:220/255,g:220/255,b:220/255,a:1},
                                backing__glow__lineColour=                       {r:0/255,g:0/255,b:0/255,a:0},
                                backing__glow__lineThickness=                    0,
                                backing__glow_press__colour=                     {r:250/255,g:250/255,b:250/255,a:1},
                                backing__glow_press__lineColour=                 {r:0/255,g:0/255,b:0/255,a:0},
                                backing__glow_press__lineThickness=              0,
                                backing__glow_select__colour=                    {r:220/255,g:220/255,b:220/255,a:1},
                                backing__glow_select__lineColour=                {r:120/255,g:120/255,b:120/255,a:1},
                                backing__glow_select__lineThickness=             0.75,
                                backing__glow_select_press__colour=              {r:250/255,g:250/255,b:250/255,a:1},
                                backing__glow_select_press__lineColour=          {r:120/255,g:120/255,b:120/255,a:1},
                                backing__glow_select_press__lineThickness=       0.75,
                                backing__hover__colour=                          {r:220/255,g:220/255,b:220/255,a:1},
                                backing__hover__lineColour=                      {r:0/255,g:0/255,b:0/255,a:0},
                                backing__hover__lineThickness=                   0,
                                backing__hover_press__colour=                    {r:240/255,g:240/255,b:240/255,a:1},
                                backing__hover_press__lineColour=                {r:0/255,g:0/255,b:0/255,a:0},
                                backing__hover_press__lineThickness=             0,
                                backing__hover_select__colour=                   {r:220/255,g:220/255,b:220/255,a:1},
                                backing__hover_select__lineColour=               {r:120/255,g:120/255,b:120/255,a:1},
                                backing__hover_select__lineThickness=            0.75,
                                backing__hover_select_press__colour=             {r:240/255,g:240/255,b:240/255,a:1},
                                backing__hover_select_press__lineColour=         {r:120/255,g:120/255,b:120/255,a:1},
                                backing__hover_select_press__lineThickness=      0.75,
                                backing__hover_glow__colour=                     {r:240/255,g:240/255,b:240/255,a:1},
                                backing__hover_glow__lineColour=                 {r:0/255,g:0/255,b:0/255,a:0},
                                backing__hover_glow__lineThickness=              0,
                                backing__hover_glow_press__colour=               {r:250/255,g:250/255,b:250/255,a:1},
                                backing__hover_glow_press__lineColour=           {r:0/255,g:0/255,b:0/255,a:0},
                                backing__hover_glow_press__lineThickness=        0,
                                backing__hover_glow_select__colour=              {r:240/255,g:240/255,b:240/255,a:1},
                                backing__hover_glow_select__lineColour=          {r:120/255,g:120/255,b:120/255,a:1},
                                backing__hover_glow_select__lineThickness=       0.75,
                                backing__hover_glow_select_press__colour=        {r:250/255,g:250/255,b:250/255,a:1},
                                backing__hover_glow_select_press__lineColour=    {r:120/255,g:120/255,b:120/255,a:1},
                                backing__hover_glow_select_press__lineThickness= 0.75,
                            
                                onenter = function(event){},
                                onleave = function(event){},
                                onpress = function(event){},
                                onpressrelease = function(event){},
                                ondblpress = function(event){},
                                onrelease = function(event){},
                                onselect = function(event){},
                                ondeselect = function(event){},
                            ){
                            
                                //adding on the specific shapes
                                    //main
                                        const subject = interfacePart.builder('basic','group',name+'subGroup');
                                    //backing
                                        const backing = interfacePart.builder('basic','polygonWithOutline','backing',{pointsAsXYArray:points, colour:backing__off__colour, thickness:5 });
                                        subject.append(backing);
                                    //text
                                        const avgPoint = _canvas_.library.math.averagePoint(points);
                                        const text_centre = interfacePart.builder('basic','text','centre', {
                                            x:avgPoint.x, y:avgPoint.y,
                                            text:text, 
                                            width:text_size,
                                            height:text_size,
                                            colour:text__up__colour,
                                            font:text_font,
                                            printingMode:{widthCalculation:'absolute',horizontal:'middle',vertical:'middle'},
                                            spacing:text_spacing,
                                            interCharacterSpacing:text_interCharacterSpacing,
                                        });
                                        subject.append(text_centre);
                                    //cover
                                        subject.cover = interfacePart.builder('basic','polygon','cover',{pointsAsXYArray:points, colour:{r:0,g:0,b:0,a:0}});
                                        subject.append(subject.cover);
                            
                                //generic button part
                                    const object = interfacePart.builder(
                                        'control', 'button_', name, {
                                            x:x, y:y, angle:angle, interactable:interactable,
                                            active:active, hoverable:hoverable, selectable:selectable, pressable:pressable,
                            
                                            onenter:onenter,
                                            onleave:onleave,
                                            onpress:onpress,
                                            onpressrelease:onpressrelease,
                                            ondblpress:ondblpress,
                                            onrelease:onrelease,
                                            onselect:onselect,
                                            ondeselect:ondeselect,
                            
                                            subject:subject,
                                        }
                                    );
                            
                                //graphical state adjust
                                    object.activateGraphicalState = function(state){
                                        if(!active){ 
                                            text_centre.colour(text__off__colour);
                                            backing.colour(backing__off__colour);
                                            backing.lineColour(backing__off__lineColour);
                                            backing.thickness( backing__off__lineThickness );
                                            return;
                                        }
                            
                                        const styles = [
                                            { text_colour:text__up__colour,                      colour:backing__up__colour,                      lineColour:backing__up__lineColour,                      lineThickness:backing__up__lineThickness                      },
                                            { text_colour:text__press__colour,                   colour:backing__press__colour,                   lineColour:backing__press__lineColour,                   lineThickness:backing__press__lineThickness                   },
                                            { text_colour:text__select__colour,                  colour:backing__select__colour,                  lineColour:backing__select__lineColour,                  lineThickness:backing__select__lineThickness                  },
                                            { text_colour:text__select_press__colour,            colour:backing__select_press__colour,            lineColour:backing__select_press__lineColour,            lineThickness:backing__select_press__lineThickness            },
                                            { text_colour:text__glow__colour,                    colour:backing__glow__colour,                    lineColour:backing__glow__lineColour,                    lineThickness:backing__glow__lineThickness                    },
                                            { text_colour:text__glow_press__colour,              colour:backing__glow_press__colour,              lineColour:backing__glow_press__lineColour,              lineThickness:backing__glow_press__lineThickness              },
                                            { text_colour:text__glow_select__colour,             colour:backing__glow_select__colour,             lineColour:backing__glow_select__lineColour,             lineThickness:backing__glow_select__lineThickness             },
                                            { text_colour:text__glow_select_press__colour,       colour:backing__glow_select_press__colour,       lineColour:backing__glow_select_press__lineColour,       lineThickness:backing__glow_select_press__lineThickness       },
                                            { text_colour:text__hover__colour,                   colour:backing__hover__colour,                   lineColour:backing__hover__lineColour,                   lineThickness:backing__hover__lineThickness                   },
                                            { text_colour:text__hover_press__colour,             colour:backing__hover_press__colour,             lineColour:backing__hover_press__lineColour,             lineThickness:backing__hover_press__lineThickness             },
                                            { text_colour:text__hover_select__colour,            colour:backing__hover_select__colour,            lineColour:backing__hover_select__lineColour,            lineThickness:backing__hover_select__lineThickness            },
                                            { text_colour:text__hover_select_press__colour,      colour:backing__hover_select_press__colour,      lineColour:backing__hover_select_press__lineColour,      lineThickness:backing__hover_select_press__lineThickness      },
                                            { text_colour:text__hover_glow__colour,              colour:backing__hover_glow__colour,              lineColour:backing__hover_glow__lineColour,              lineThickness:backing__hover_glow__lineThickness              },
                                            { text_colour:text__hover_glow_press__colour,        colour:backing__hover_glow_press__colour,        lineColour:backing__hover_glow_press__lineColour,        lineThickness:backing__hover_glow_press__lineThickness        },
                                            { text_colour:text__hover_glow_select__colour,       colour:backing__hover_glow_select__colour,       lineColour:backing__hover_glow_select__lineColour,       lineThickness:backing__hover_glow_select__lineThickness       },
                                            { text_colour:text__hover_glow_select_press__colour, colour:backing__hover_glow_select_press__colour, lineColour:backing__hover_glow_select_press__lineColour, lineThickness:backing__hover_glow_select_press__lineThickness },
                                        ];
                            
                                        if(!hoverable && state.hovering ){ state.hovering = false; }
                                        if(!selectable && state.selected ){ state.selected = false; }
                            
                                        const i = state.hovering*8 + state.glowing*4 + state.selected*2 + (pressable && state.pressed)*1;
                                        text_centre.colour(styles[i].text_colour);
                                        backing.colour(styles[i].colour);
                                        backing.lineColour(styles[i].lineColour);
                                        backing.thickness( styles[i].lineThickness );
                                    };
                                    object.activateGraphicalState({ hovering:false, glowing:false, selected:false, pressed:false });
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.button_polygon = function(name,data){ return interfacePart.collection.control.button_polygon(
                                name, data.x, data.y, data.points, data.angle, data.interactable,
                                data.text_centre,
                                data.active, data.hoverable, data.selectable, data.pressable,
                            
                                data.style.text_font, 
                                data.style.text_size, 
                                data.style.text_spacing, 
                                data.style.text_interCharacterSpacing,
                            
                                data.style.text__off__colour == undefined ? data.style.text_colour : data.style.text__off__colour,
                                data.style.text__up__colour == undefined ? data.style.text_colour : data.style.text__up__colour,
                                data.style.text__press__colour == undefined ? data.style.text_colour : data.style.text__press__colour,
                                data.style.text__select__colour == undefined ? data.style.text_colour : data.style.text__select__colour,
                                data.style.text__select_press__colour == undefined ? data.style.text_colour : data.style.text__select_press__colour,
                                data.style.text__glow__colour == undefined ? data.style.text_colour : data.style.text__glow__colour,
                                data.style.text__glow_press__colour == undefined ? data.style.text_colour : data.style.text__glow_press__colour,
                                data.style.text__glow_select__colour == undefined ? data.style.text_colour : data.style.text__glow_select__colour,
                                data.style.text__glow_select_press__colour == undefined ? data.style.text_colour : data.style.text__glow_select_press__colour,
                                data.style.text__hover__colour == undefined ? data.style.text_colour : data.style.text__hover__colour,
                                data.style.text__hover_press__colour == undefined ? data.style.text_colour : data.style.text__hover_press__colour,
                                data.style.text__hover_select__colour == undefined ? data.style.text_colour : data.style.text__hover_select__colour,
                                data.style.text__hover_select_press__colour == undefined ? data.style.text_colour : data.style.text__hover_select_press__colour,
                                data.style.text__hover_glow__colour == undefined ? data.style.text_colour : data.style.text__hover_glow__colour,
                                data.style.text__hover_glow_press__colour == undefined ? data.style.text_colour : data.style.text__hover_glow_press__colour,
                                data.style.text__hover_glow_select__colour == undefined ? data.style.text_colour : data.style.text__hover_glow_select__colour,
                                data.style.text__hover_glow_select_press__colour == undefined ? data.style.text_colour : data.style.text__hover_glow_select_press__colour,
                            
                                data.style.background__off__colour,                     data.style.background__off__lineColour,                     data.style.background__off__lineThickness,
                                data.style.background__up__colour,                      data.style.background__up__lineColour,                      data.style.background__up__lineThickness,
                                data.style.background__press__colour,                   data.style.background__press__lineColour,                   data.style.background__press__lineThickness,
                                data.style.background__select__colour,                  data.style.background__select__lineColour,                  data.style.background__select__lineThickness,
                                data.style.background__select_press__colour,            data.style.background__select_press__lineColour,            data.style.background__select_press__lineThickness,
                                data.style.background__glow__colour,                    data.style.background__glow__lineColour,                    data.style.background__glow__lineThickness,
                                data.style.background__glow_press__colour,              data.style.background__glow_press__lineColour,              data.style.background__glow_press__lineThickness,
                                data.style.background__glow_select__colour,             data.style.background__glow_select__lineColour,             data.style.background__glow_select__lineThickness,
                                data.style.background__glow_select_press__colour,       data.style.background__glow_select_press__lineColour,       data.style.background__glow_select_press__lineThickness,
                                data.style.background__hover__colour,                   data.style.background__hover__lineColour,                   data.style.background__hover__lineThickness,
                                data.style.background__hover_press__colour,             data.style.background__hover_press__lineColour,             data.style.background__hover_press__lineThickness,
                                data.style.background__hover_select__colour,            data.style.background__hover_select__lineColour,            data.style.background__hover_select__lineThickness,
                                data.style.background__hover_select_press__colour,      data.style.background__hover_select_press__lineColour,      data.style.background__hover_select_press__lineThickness,
                                data.style.background__hover_glow__colour,              data.style.background__hover_glow__lineColour,              data.style.background__hover_glow__lineThickness,
                                data.style.background__hover_glow_press__colour,        data.style.background__hover_glow_press__lineColour,        data.style.background__hover_glow_press__lineThickness,
                                data.style.background__hover_glow_select__colour,       data.style.background__hover_glow_select__lineColour,       data.style.background__hover_glow_select__lineThickness,
                                data.style.background__hover_glow_select_press__colour, data.style.background__hover_glow_select_press__lineColour, data.style.background__hover_glow_select_press__lineThickness,
                            
                                data.onenter,
                                data.onleave,
                                data.onpress,
                                data.onpressrelease,
                                data.ondblpress,
                                data.onrelease,
                                data.onselect,
                                data.ondeselect,
                            ); };
                            this.button_image = function(
                                name='button_image',
                                x, y, width=30, height=20, angle=0, interactable=true,
                                
                                active=true, hoverable=true, selectable=false, pressable=true,
                            
                                backingURL__off,
                                backingURL__up,
                                backingURL__press,
                                backingURL__select,
                                backingURL__select_press,
                                backingURL__glow,
                                backingURL__glow_press,
                                backingURL__glow_select,
                                backingURL__glow_select_press,
                                backingURL__hover,
                                backingURL__hover_press,
                                backingURL__hover_select,
                                backingURL__hover_select_press,
                                backingURL__hover_glow,
                                backingURL__hover_glow_press,
                                backingURL__hover_glow_select,
                                backingURL__hover_glow_select_press,
                            
                                onenter = function(event){},
                                onleave = function(event){},
                                onpress = function(event){},
                                onpressrelease = function(event){},
                                ondblpress = function(event){},
                                onrelease = function(event){},
                                onselect = function(event){},
                                ondeselect = function(event){},
                            ){
                            
                                //adding on the specific shapes
                                    //main
                                        const subject = interfacePart.builder('basic','group',name+'subGroup',{});
                                    //backing
                                        const backing = interfacePart.builder('basic','image','backing',{width:width, height:height, url:backingURL__off});
                                        subject.append(backing);
                                    //cover
                                        subject.cover = interfacePart.builder('basic','rectangle','cover',{width:width, height:height, colour:{r:0,g:0,b:0,a:0}});
                                        subject.append(subject.cover);
                            
                                //generic button part
                                    const object = interfacePart.builder(
                                        'control', 'button_', name, {
                                            x:x, y:y, angle:angle, interactable:interactable,
                                            active:active, hoverable:hoverable, selectable:selectable, pressable:pressable,
                            
                                            onenter:onenter,
                                            onleave:onleave,
                                            onpress:onpress,
                                            onpressrelease:onpressrelease,
                                            ondblpress:ondblpress,
                                            onrelease:onrelease,
                                            onselect:onselect,
                                            ondeselect:ondeselect,
                            
                                            subject:subject,
                                        }
                                    );
                            
                                //graphical state adjust
                                    object.activateGraphicalState = function(state){
                                        if(!active){ 
                                            backing.url(backingURL__off);
                                            return;
                                        }
                            
                                        if(!hoverable && state.hovering ){ state.hovering = false; }
                                        if(!selectable && state.selected ){ state.selected = false; }
                            
                                        const newImageURL = [
                                            backingURL__up,                     
                                            backingURL__press,                  
                                            backingURL__select,                 
                                            backingURL__select_press,           
                                            backingURL__glow,                   
                                            backingURL__glow_press,             
                                            backingURL__glow_select,            
                                            backingURL__glow_select_press,      
                                            backingURL__hover,                  
                                            backingURL__hover_press,            
                                            backingURL__hover_select,           
                                            backingURL__hover_select_press,     
                                            backingURL__hover_glow,             
                                            backingURL__hover_glow_press,       
                                            backingURL__hover_glow_select,      
                                            backingURL__hover_glow_select_press,
                                        ][ state.hovering*8 + state.glowing*4 + state.selected*2 + (pressable && state.pressed)*1 ];
                            
                                        if( newImageURL != undefined ){backing.url(newImageURL);}
                                    };
                                    object.activateGraphicalState({ hovering:false, glowing:false, selected:false, pressed:false });
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.button_image = function(name,data){ return interfacePart.collection.control.button_image(
                                name, data.x, data.y, data.width, data.height, data.angle, data.interactable,
                                data.active, data.hoverable, data.selectable, data.pressable,
                            
                                data.backingURL__off,
                                data.backingURL__up,
                                data.backingURL__press,
                                data.backingURL__select,
                                data.backingURL__select_press,
                                data.backingURL__glow,
                                data.backingURL__glow_press,
                                data.backingURL__glow_select,
                                data.backingURL__glow_select_press,
                                data.backingURL__hover,
                                data.backingURL__hover_press,
                                data.backingURL__hover_select,
                                data.backingURL__hover_select_press,
                                data.backingURL__hover_glow,
                                data.backingURL__hover_glow_press,
                                data.backingURL__hover_glow_select,
                                data.backingURL__hover_glow_select_press,
                            
                                data.onenter,
                                data.onleave,
                                data.onpress,
                                data.onpressrelease,
                                data.ondblpress,
                                data.onrelease,
                                data.onselect,
                                data.ondeselect,
                            ); };
                            this.needleOverlay = function(
                                name='needleOverlay',
                                x, y, width=120, height=60, angle=0, interactable=true, allowAreaSelection=true, needleWidth=1/Math.pow(2,9), 
                                selectNeedle=true, selectionArea=true, concurrentMarkerCountLimit=-1, //'-1' is infinite
                                needleStyles=[
                                    {r:0.94,g:0.94,b:0.94,a:1},
                                    {r:1,g:0.9,b:0.44,a:1},
                                ],
                                onchange=function(needle,value){}, 
                                onrelease=function(needle,value){}, 
                                selectionAreaToggle=function(bool){},
                            ){
                            
                                const needleData = {};
                                const grappled = {};
                                let markerCount = 0;
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    //backing
                                        const backing = interfacePart.builder('basic','rectangle','backing',{width:width, height:height, colour:{r:0,g:0,b:1,a:0}});
                                        object.append(backing);
                                    //control objects
                                        const controlObjectsGroup = interfacePart.builder('basic','group','controlObjectsGroup');
                                        object.append(controlObjectsGroup);
                            
                                        const invisibleHandleWidth = width*needleWidth + width*0.005;
                                        const controlObjects = {};
                                        const selectionObjects = {};
                            
                                        function generateNeedle(id,colour){
                                            let tmp = interfacePart.builder('basic','group',id);
                                            tmp.append( interfacePart.builder('basic','rectangle','handle',{
                                                width:needleWidth*width, height:height, colour:colour,
                                            }));
                                            tmp.append( interfacePart.builder('basic','rectangle','invisibleHandle',{
                                                x:(width*needleWidth - invisibleHandleWidth)/2, 
                                                width:invisibleHandleWidth, height:height, colour:{r:1,g:0,b:0,a:0},
                                            }));
                            
                                            tmp.getChildByName('invisibleHandle').attachCallback('onmouseenterelement', function(){_canvas_.core.viewport.cursor('col-resize');} );
                                            tmp.getChildByName('invisibleHandle').attachCallback('onmouseleaveelement', function(){_canvas_.core.viewport.cursor('default');} );
                                            tmp.getChildByName('invisibleHandle').attachCallback('onmousedown', (function(needleID){return function(x,y,event){
                                                if(!interactable){return;}
                            
                                                grappled[needleID] = true;
                            
                                                let initialValue = needleData[needleID];
                                                let initialX = currentMousePosition_x(event);
                                                let mux = (width - width*needleWidth);
                            
                                                _canvas_.system.mouse.mouseInteractionHandler(
                                                    function(x,y,event){
                                                        let numerator = initialX - currentMousePosition_x(event);
                                                        let divider = _canvas_.core.viewport.scale();
                                                        let location = initialValue - numerator/(divider*mux);
                                                        location = location < 0 ? 0 : location;
                                                        location = location > 1 ? 1 : location;
                                                        select(needleID,location);
                                                    },
                                                    function(x,y,event){
                                                        let numerator = initialX - currentMousePosition_x(event);
                                                        let divider = _canvas_.core.viewport.scale();
                                                        let location = initialValue - numerator/(divider*mux);
                                                        location = location < 0 ? 0 : location;
                                                        location = location > 1 ? 1 : location;
                                                        grappled[needleID] = false;
                                                        select(needleID,location);
                                                        if(object.onrelease != undefined){object.onrelease(needleID,location);}
                                                    },       
                                                );
                                            }})(id) );
                            
                                            needleData[id] = 0;
                                            grappled[id] = false;
                            
                                            return tmp;
                                        }
                            
                                        //selection_A
                                            selectionObjects.selection_A = generateNeedle('selection_A',needleStyles[1]);
                                            selectionObjects.selection_A.getChildByName('invisibleHandle').attachCallback('onmouseenterelement', function(){_canvas_.core.viewport.cursor('col-resize');} );
                                            selectionObjects.selection_A.getChildByName('invisibleHandle').attachCallback('onmousemove', function(){_canvas_.core.viewport.cursor('col-resize');} );
                                            selectionObjects.selection_A.getChildByName('invisibleHandle').attachCallback('onmouseleaveelement', function(){_canvas_.core.viewport.cursor('default');} );
                                            selectionObjects.selection_A.getChildByName('invisibleHandle').attachCallback('onmousedown', function(x,y,event){
                                                if(!allowAreaSelection){return;}
                                
                                                grappled['selection_A'] = true;
                                
                                                const initialValue = needleData['selection_A'];
                                                const initialX = currentMousePosition_x(event);
                                                const mux = (width - width*needleWidth);
                            
                                                function calculateArea(event){
                                                    const numerator = initialX - currentMousePosition_x(event);
                                                    const divider = _canvas_.core.viewport.scale();
                                                    let location = initialValue - numerator/(divider*mux);
                                                    location = location < 0 ? 0 : location;
                                                    location = location > 1 ? 1 : location;
                                                    area(location,needleData.selection_B);
                                                }
                                
                                                _canvas_.system.mouse.mouseInteractionHandler(
                                                    function(x,y,event){
                                                        calculateArea(event);
                                                    },
                                                    function(x,y,event){
                                                        calculateArea(event);
                                                        grappled['selection_A'] = false;
                                                        if(object.onrelease != undefined){ object.onrelease('selection_A',location); }
                                                    },       
                                                );
                                            } );
                                            needleData['selection_A'] = undefined;
                                        //selection_B
                                            selectionObjects.selection_B = generateNeedle('selection_B',needleStyles[1]);
                                            selectionObjects.selection_B.getChildByName('invisibleHandle').attachCallback('onmouseenterelement', function(){_canvas_.core.viewport.cursor('col-resize');} );
                                            selectionObjects.selection_B.getChildByName('invisibleHandle').attachCallback('onmousemove', function(){_canvas_.core.viewport.cursor('col-resize');} );
                                            selectionObjects.selection_B.getChildByName('invisibleHandle').attachCallback('onmouseleaveelement', function(){_canvas_.core.viewport.cursor('default');} );
                                            selectionObjects.selection_B.getChildByName('invisibleHandle').attachCallback('onmousedown', function(x,y,event){
                                                if(!allowAreaSelection){return;}
                                
                                                grappled['selection_B'] = true;
                                
                                                const initialValue = needleData['selection_B'];
                                                const initialX = currentMousePosition_x(event);
                                                const mux = (width - width*needleWidth);
                            
                                                function calculateArea(event){
                                                    const numerator = initialX - currentMousePosition_x(event);
                                                    const divider = _canvas_.core.viewport.scale();
                                                    let location = initialValue - numerator/(divider*mux);
                                                    location = location < 0 ? 0 : location;
                                                    location = location > 1 ? 1 : location;
                                                    area(needleData.selection_A,location);
                                                }
                                
                                                _canvas_.system.mouse.mouseInteractionHandler(
                                                    function(x,y,event){
                                                        calculateArea(event);
                                                    },
                                                    function(x,y,event){
                                                        calculateArea(event);
                                                        grappled['selection_B'] = false;
                                                        if(object.onrelease != undefined){ object.onrelease('selection_B',location); }
                                                    },       
                                                );
                                            } );
                                            needleData['selection_B'] = undefined;
                                        //selection_area
                                            selectionObjects.selection_area = interfacePart.builder('basic','rectangle','selection_area',{ height:height, colour:_canvas_.library.math.blendColours(needleStyles[1],{r:0,g:0,b:0,a:0},0.5) });
                                            selectionObjects.selection_area.attachCallback('onmouseenterelement', function(){_canvas_.core.viewport.cursor('grab');} );
                                            selectionObjects.selection_area.attachCallback('onmousemove', function(){_canvas_.core.viewport.cursor('grab');} );
                                            selectionObjects.selection_area.attachCallback('onmouseleaveelement', function(){_canvas_.core.viewport.cursor('default');} );
                                            selectionObjects.selection_area.attachCallback('onmousedown', function(x,y,event){
                                                if(!allowAreaSelection){return;}
                                
                                                _canvas_.core.viewport.cursor('grabbing');
                                                grappled['selection_area'] = true;
                                
                                                const areaSize = needleData.selection_B - needleData.selection_A;
                                                const initialValues = {A:needleData.selection_A, B:needleData.selection_B};
                                                const initialX = currentMousePosition_x(event);
                                                const mux = (width - width*needleWidth);
                                
                                                function calculate(event){
                                                    const numerator = initialX - currentMousePosition_x(event);
                                                    const divider = _canvas_.core.viewport.scale();
                                
                                                    let location = {
                                                        A: initialValues.A - numerator/(divider*mux),
                                                        B: initialValues.B - numerator/(divider*mux),
                                                    };
                                
                                                    if( location.A > 1 ){ location.A = 1; location.B = 1 + areaSize; }
                                                    else if( location.A < 0 ){ location.A = 0; location.B = areaSize; }
                                                    if( location.B > 1 ){ location.B = 1; location.A = 1 - areaSize; }
                                                    else if( location.B < 0 ){ location.B = 0; location.A = -areaSize; }
                                
                                                    return location;
                                                }
                                                _canvas_.system.mouse.mouseInteractionHandler(
                                                    function(x,y,event){
                                                        const location = calculate(event);
                                                        area(location.A,location.B);
                                                    },
                                                    function(x,y,event){
                                                        _canvas_.core.viewport.cursor('grab');
                                
                                                        // const location = calculate(event);
                                
                                                        selectionArea_grappled = false;
                                                        // area(location.A,location.B);
                                                        if(object.onrelease != undefined){object.onrelease('selection_A',location.A);}
                                                        if(object.onrelease != undefined){object.onrelease('selection_B',location.B);}
                                                    },
                                                );                    
                                            } );
                            
                                //internal functions
                                    function currentMousePosition_x(event){
                                        return event.X*Math.cos(angle) - event.Y*Math.sin(angle);
                                    }
                                    function getRelativeX(x,y){
                                        const offset = controlObjectsGroup.getOffset();
                                        const delta = {
                                            x: x - (controlObjectsGroup.x()     + offset.x),
                                            y: y - (controlObjectsGroup.y()     + offset.y),
                                            a: 0 - (controlObjectsGroup.angle() + offset.angle),
                                        };
                                        const d = _canvas_.library.math.cartesianAngleAdjust( delta.x/offset.scale, delta.y/offset.scale, delta.a );
                            
                                        return d.x/backing.width();
                                    }
                                    function needleJumpTo(needleID,location,style=needleStyles[0]){
                                        //if the needle doesn't exist, create it
                                            if(controlObjects[needleID] == undefined){
                                                //if there's too many markers, don't make a new one. Just bail
                                                if(concurrentMarkerCountLimit > 0 && markerCount >= concurrentMarkerCountLimit){return -1;}
                            
                                                controlObjects[needleID] = generateNeedle(needleID,style);
                                                markerCount++;
                                            }
                            
                                        //if the needle isn't in the scene, add it
                                            if( !controlObjectsGroup.contains(controlObjects[needleID]) ){
                                                controlObjectsGroup.append(controlObjects[needleID]);
                                            }
                            
                                        //if the location is wrong, remove the needle and return
                                            if(location == undefined || location < 0 || location > 1){
                                                controlObjectsGroup.remove(controlObjects[needleID]);
                                                delete needleData[needleID];
                                                delete grappled[needleID];
                                                markerCount--;
                                                return;
                                            }
                            
                                        //actually set the location of the needle (adjusting for the size of needle)
                                            controlObjects[needleID].x( location*width - width*needleWidth*location );
                                        //save this value
                                            needleData[needleID] = location;
                                    }
                                    function select(needleID,position,update=true){ 
                                        if(!selectNeedle){return;}
                                        //if there's no input, return the value
                                        //if input is out of bounds, remove the needle
                                        //otherwise, set the position
                                        if(position == undefined){ return needleData[needleID]; }
                                        else if(position > 1 || position < 0){ needleJumpTo(needleID); }
                                        else{ needleJumpTo(needleID,position); }
                            
                                        if(update && object.onchange != undefined){object.onchange(needleID,position);}
                                    }
                                    function computeSelectionArea(){
                                        //if the selection needles' data are missing (or they are the same position) remove the area element (if it exists) and return
                                            if(needleData.selection_A == undefined || needleData.selection_B == undefined || needleData.selection_A == needleData.selection_B){
                                                if(controlObjectsGroup.contains(selectionObjects['selection_area'])){ controlObjectsGroup.remove(selectionObjects['selection_area']); }
                                                if(object.selectionAreaToggle){object.selectionAreaToggle(false);}
                                                delete needleData.selection_area;
                                                return;
                                            }
                            
                                        //if the area isn't in the scene, add it
                                            if( !controlObjectsGroup.contains(selectionObjects['selection_area']) ){
                                                controlObjectsGroup.prepend(selectionObjects['selection_area']);
                                                if(object.selectionAreaToggle){object.selectionAreaToggle(true);}
                                            }
                            
                                        //compute area position and size
                                            const A = needleData.selection_A < needleData.selection_B ? needleData.selection_A : needleData.selection_B;
                                            const B = needleData.selection_A < needleData.selection_B ? needleData.selection_B : needleData.selection_A;
                                            const start = A - needleWidth*A + needleWidth
                                            let area = B - needleWidth*B - start; 
                                            if(area < 0){area = 0}
                            
                                            selectionObjects['selection_area'].x(width*start);
                                            selectionObjects['selection_area'].width(width*area);
                                    }
                                    function area(positionA,positionB,update=true){
                                        if(!selectionArea){return;}
                            
                                        //if there's no input, return the values
                                            if(positionA == undefined || positionB == undefined){
                                                return {A:needleData.selection_A, B:needleData.selection_B};
                                            }
                            
                                        //if the needles aren't in the scene, add them
                                            if( !controlObjectsGroup.contains(selectionObjects['selection_A']) ){
                                                controlObjectsGroup.prepend(selectionObjects['selection_A']);
                                                controlObjectsGroup.prepend(selectionObjects['selection_B']);
                                            }
                            
                                        //if input is out of bounds or if both bounds are set to 0, remove the needles
                                        //otherwise, set the position
                                            if(positionA > 1 || positionA < 0 || positionB > 1 || positionB < 0 || (positionA == 0 && positionB == 0) ){
                                                controlObjectsGroup.remove(selectionObjects['selection_A']);
                                                controlObjectsGroup.remove(selectionObjects['selection_B']);
                                                needleData.selection_A = undefined;
                                                needleData.selection_B = undefined;
                                            }else{
                                                selectionObjects['selection_A'].x( positionA*width - width*needleWidth*positionA );
                                                needleData['selection_A'] = positionA;
                                                selectionObjects['selection_B'].x( positionB*width - width*needleWidth*positionB );
                                                needleData['selection_B'] = positionB;
                                            }
                            
                                        //you always gotta compute the selection area
                                            computeSelectionArea();
                            
                                        if(update && object.onchange != undefined){object.onchange('selection_A',positionA);}
                                        if(update && object.onchange != undefined){object.onchange('selection_B',positionB);}
                                    }
                            
                                //interaction
                                    //clear space interaction
                                        backing.attachCallback('onmousedown', function(x,y,event){
                                            if( _canvas_.system.keyboard.pressedKeys.shift && allowAreaSelection ){
                                                const firstPosition = getRelativeX(x,y);
                                                _canvas_.system.mouse.mouseInteractionHandler(
                                                    function(x,y,event){ 
                                                        let secondPosition = getRelativeX(x,y);
                                                        if(secondPosition < 0){secondPosition = 0;}else if(secondPosition > 1){secondPosition = 1;}
                                                        object.area(firstPosition,secondPosition);
                                                    },    
                                                );
                                                return;
                                            }
                            
                                            if(!interactable){return;}
                                            const relX = getRelativeX(x,y);
                                            const markerPositions = Object.keys(controlObjects).map(key => needleData[key]).map(position => Math.abs(position - relX));
                                            let smallest = {value:markerPositions[0], index:0};
                                            for(let a = 1; a < markerPositions.length; a++){ if(smallest.value > markerPositions[a]){ smallest = {value:markerPositions[a], index:a}; } }
                                            select(smallest.index, relX);
                                        } );
                                    //doubleclick to destroy selection area
                                        selectionObjects.selection_A.attachCallback('ondblclick', function(){ if(!interactable){return;} area(-1,-1); _canvas_.core.viewport.cursor('default'); });
                                        selectionObjects.selection_B.attachCallback('ondblclick', selectionObjects.selection_A.getCallback('ondblclick'));
                                        selectionObjects.selection_area.attachCallback('ondblclick', selectionObjects.selection_A.getCallback('ondblclick'));
                                    
                                //control
                                    object.interactable = function(bool){
                                        if(bool == undefined){return interactable;}
                                        interactable = bool;
                                    };
                                    object.allowAreaSelection = function(bool){
                                        if(bool == undefined){return allowAreaSelection;}
                                        allowAreaSelection = bool;
                                    };
                                    object.select = function(needleID,position,update=true){
                                        if(position == undefined){return select(needleID);}
                            
                                        if(grappled[needleID]){return;}
                                        select(needleID,position,update);
                                    };
                                    object.removeAllMarkers = function(){ Object.keys(controlObjects).forEach(ID => object.select(ID,-1)); };
                                    object.area = function(positionA,positionB,update=true){ return area(positionA,positionB,update); };
                                    object.areaIsActive = function(){ return !(needleData.selection_A == undefined && needleData.selection_B == undefined); };
                            
                                    object.list = function(){
                                        const tmp = Object.assign({},needleData);
                                        delete tmp.selection_A;
                                        delete tmp.selection_B;
                                        return tmp;
                                    };
                            
                                //callback
                                    object.onchange = onchange;
                                    object.onrelease = onrelease;
                                    object.selectionAreaToggle = selectionAreaToggle;
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.needleOverlay = function(name,data){ return interfacePart.collection.control.needleOverlay(
                                name, data.x, data.y, data.width, data.height, data.angle, data.interactable, data.allowAreaSelection,
                                data.needleWidth, data.selectNeedle, data.selectionArea, data.concurrentMarkerCountLimit,
                                data.style.needles,
                                data.onchange, data.onrelease, data.selectionAreaToggle,
                            ); };
                            // this.list_image = function(
                            //     name='list_image', 
                            //     x, y, angle=0, interactable=true,
                            //     list=[],
                            
                            //     active=true, multiSelect=false, hoverable=true, selectable=false, pressable=true,
                            
                            //     heightLimit=-1, widthLimit=-1,
                            //     background_url='/images/testImages/expanded-metal-1.jpg',
                            //     break_url='/images/testImages/Dore-munchausen-illustration.jpg',
                            //     image_url='/images/testImages/mikeandbrian.jpg',
                            
                            //     default_item_height=10, default_item_width=47.5,
                            //     default_item_spacingHeight=3/4,
                            //     default_item_horizontalPadding=2,
                            
                            //     default_item__off__url=                     '/images/testImages/buttonStates/off.png',
                            //     default_item__up__url=                      '/images/testImages/buttonStates/up.png',
                            //     default_item__press__url=                   '/images/testImages/buttonStates/press.png',
                            //     default_item__select__url=                  '/images/testImages/buttonStates/select.png',
                            //     default_item__select_press__url=            '/images/testImages/buttonStates/select_press.png',
                            //     default_item__glow__url=                    '/images/testImages/buttonStates/glow.png',
                            //     default_item__glow_press__url=              '/images/testImages/buttonStates/glow_press.png',
                            //     default_item__glow_select__url=             '/images/testImages/buttonStates/glow_select.png',
                            //     default_item__glow_select_press__url=       '/images/testImages/buttonStates/glow_select_press.png',
                            //     default_item__hover__url=                   '/images/testImages/buttonStates/hover.png',
                            //     default_item__hover_press__url=             '/images/testImages/buttonStates/hover_press.png',
                            //     default_item__hover_select__url=            '/images/testImages/buttonStates/hover_select.png',
                            //     default_item__hover_select_press__url=      '/images/testImages/buttonStates/hover_select_press.png',
                            //     default_item__hover_glow__url=              '/images/testImages/buttonStates/hover_glow.png',
                            //     default_item__hover_glow_press__url=        '/images/testImages/buttonStates/hover_glow_press.png',
                            //     default_item__hover_glow_select__url=       '/images/testImages/buttonStates/hover_glow_select.png',
                            //     default_item__hover_glow_select_press__url= '/images/testImages/buttonStates/hover_glow_select_press.png',
                            
                            //     space_height=10/16,
                            //     break_height=10/8,
                            //     break_lineMux=1/5,
                            
                            //     onenter=function(a){/*console.log('onenter >',a);*/},
                            //     onleave=function(a){/*console.log('onleave >',a);*/},
                            //     onpress=function(a){/*console.log('onpress >',a);*/},
                            //     ondblpress=function(a){/*console.log('ondblpress >',a);*/},
                            //     onrelease=function(a){/*console.log('onrelease >',a);*/},
                            //     onselection=function(a){/*console.log('onselection >',a);*/},
                            //     onpositionchange=function(a){/*console.log('onpositionchange >',a);*/},
                            // ){
                            
                            //     //state
                            //         let self = this;
                            //         let itemArray = [];
                            //         let calculatedListHeight = 0;
                            //         const state = {
                            //             position:0,
                            //             lastNonShiftClicked:0,
                            //             selectedItems:[],
                            //         };
                            
                            //     //default style
                            //         const style = {
                            //             default:{
                            //                 heightLimit:heightLimit, widthLimit:widthLimit,
                            //                 background_url:background_url,
                            //                 break_url:break_url,
                            //                 image_url:image_url,
                            
                            //                 height:default_item_height, width:default_item_width,
                            
                            //                 itemSpacingHeight:default_item_spacingHeight,
                            //                 itemHorizontalPadding:default_item_horizontalPadding,
                            
                            //                 item__off__url:                     default_item__off__url,
                            //                 item__up__url:                      default_item__up__url,
                            //                 item__press__url:                   default_item__press__url,
                            //                 item__select__url:                  default_item__select__url,
                            //                 item__select_press__url:            default_item__select_press__url,
                            //                 item__glow__url:                    default_item__glow__url,
                            //                 item__glow_press__url:              default_item__glow_press__url,
                            //                 item__glow_select__url:             default_item__glow_select__url,
                            //                 item__glow_select_press__url:       default_item__glow_select_press__url,
                            //                 item__hover__url:                   default_item__hover__url,
                            //                 item__hover_press__url:             default_item__hover_press__url,
                            //                 item__hover_select__url:            default_item__hover_select__url,
                            //                 item__hover_select_press__url:      default_item__hover_select_press__url,
                            //                 item__hover_glow__url:              default_item__hover_glow__url,
                            //                 item__hover_glow_press__url:        default_item__hover_glow_press__url,
                            //                 item__hover_glow_select__url:       default_item__hover_glow_select__url,
                            //                 item__hover_glow_select_press__url: default_item__hover_glow_select_press__url,
                            //             },
                            //             space:{
                            //                 height:space_height,
                            //             },
                            //             image:{},
                            //             break:{
                            //                 height:break_height,
                            //                 lineMux:break_lineMux,
                            //             },
                            //             checkbox:{},
                            //             button:{},
                            //             list:{
                            //                 heightLimit:-1,
                            //                 space_height:space_height,
                            //                 break_height:break_height,
                            //                 break_lineMux:break_lineMux,
                            //             },
                            //         };
                            
                            
                            //     //generate list content
                            //         function generateListContent(listItems=[]){
                            //             function def(i,t){ return i[t]==undefined ? (style[i.type][t]==undefined ? style.default[t] : style[i.type][t]) : i[t]; }
                            
                            //             const output = {elements:[], calculatedListHeight:0};
                            //             const xOffset = style.default.widthLimit < 0 ? 0 : (style.default.widthLimit-style.default.width)/2;
                            
                            //             listItems.forEach((item,index) => {
                            //                 if(index != 0){output.calculatedListHeight += style.default.itemSpacingHeight;}
                            
                            //                 let newItem;
                            //                 if(item.type == 'image'){
                            //                     newItem = self.list_image.itemTypes.image(
                            //                         index, xOffset, output.calculatedListHeight, def(item,'width'), def(item,'height'), def(item,'image_url'),
                            //                     );
                            //                 }else if(item.type == 'space'){
                            //                     newItem = self.list_image.itemTypes.space(index, xOffset, output.calculatedListHeight, def(item,'height') );
                            //                 }else if(item.type == 'break'){
                            //                     newItem = self.list_image.itemTypes.break(
                            //                         index, xOffset, output.calculatedListHeight, def(item,'width'), 
                            //                         def(item,'height'), def(item,'break_url')
                            //                     );
                            //                 }else if(item.type == 'checkbox'){
                            //                     newItem = self.list_image.itemTypes.checkbox(
                            //                         index, xOffset, output.calculatedListHeight, def(item,'width'), def(item,'height'), def(item,'itemHorizontalPadding'),
                            //                         item.active != undefined ? item.active : active, 
                            //                         item.hoverable != undefined ? item.hoverable : hoverable, 
                            //                         item.selectable != undefined ? item.selectable : selectable, 
                            //                         item.pressable != undefined ? item.pressable : pressable, 
                            
                            //                         def(item,'item__off__url'),
                            //                         def(item,'item__up__url'),
                            //                         def(item,'item__press__url'),
                            //                         def(item,'item__select__url'),
                            //                         def(item,'item__select_press__url'),
                            //                         def(item,'item__glow__url'),
                            //                         def(item,'item__glow_press__url'),
                            //                         def(item,'item__glow_select__url'),
                            //                         def(item,'item__glow_select_press__url'),
                            //                         def(item,'item__hover__url'),
                            //                         def(item,'item__hover_press__url'),
                            //                         def(item,'item__hover_select__url'),
                            //                         def(item,'item__hover_select_press__url'),
                            //                         def(item,'item__hover_glow__url'),
                            //                         def(item,'item__hover_glow_press__url'),
                            //                         def(item,'item__hover_glow_select__url'),
                            //                         def(item,'item__hover_glow_select_press__url'),
                            
                            //                         item.updateFunction, item.onclickFunction,
                            //                     );
                            //                 }else if(item.type == 'button'){
                            //                     newItem = self.list_image.itemTypes.button(
                            //                         index, xOffset, output.calculatedListHeight, def(item,'width'), def(item,'height'), def(item,'itemHorizontalPadding'),
                            //                         item.active != undefined ? item.active : active, 
                            //                         item.hoverable != undefined ? item.hoverable : hoverable, 
                            //                         item.selectable != undefined ? item.selectable : selectable, 
                            //                         item.pressable != undefined ? item.pressable : pressable, 
                            
                            //                         def(item,'item__off__url'),
                            //                         def(item,'item__up__url'),
                            //                         def(item,'item__press__url'),
                            //                         def(item,'item__select__url'),
                            //                         def(item,'item__select_press__url'),
                            //                         def(item,'item__glow__url'),
                            //                         def(item,'item__glow_press__url'),
                            //                         def(item,'item__glow_select__url'),
                            //                         def(item,'item__glow_select_press__url'),
                            //                         def(item,'item__hover__url'),
                            //                         def(item,'item__hover_press__url'),
                            //                         def(item,'item__hover_select__url'),
                            //                         def(item,'item__hover_select_press__url'),
                            //                         def(item,'item__hover_glow__url'),
                            //                         def(item,'item__hover_glow_press__url'),
                            //                         def(item,'item__hover_glow_select__url'),
                            //                         def(item,'item__hover_glow_select_press__url'),
                            
                            //                         function(){ object.onenter([index]); },
                            //                         function(){ object.onleave([index]); },
                            //                         function(){ object.onpress([index]); },
                            //                         function(){ object.ondblpress([index]); },
                            //                         function(){ if(item.function){item.function();} object.onrelease([index]); },
                            //                         function(obj,event){ object.select(index,true,event,false);} ,
                            //                         function(obj,event){ object.select(index,false,event,false); },
                            //                     );
                            //                 }else if(item.type == 'list'){
                            //                     newItem = self.list_image.itemTypes.list(
                            //                         subListGroup,
                            //                         index, xOffset, output.calculatedListHeight,
                                                
                            //                         //internal callbacks
                            //                             function(isOpen){
                            //                                 if(!isOpen){return;}
                            //                                 itemArray.forEach((item,a) => { if(list[a].type == 'list' && a != index && item.isOpen){ item.close(); } });
                            //                                 return -state.position * (style.default.heightLimit > 0 && style.default.heightLimit < calculatedListHeight ? (calculatedListHeight-style.default.heightLimit) : calculatedListHeight);
                            //                             },
                                                    
                            //                         //button
                            //                             def(item,'width'), def(item,'height'), 
                                                
                            //                             def(item,'itemHorizontalPadding'),
                            //                             item.active != undefined ? item.active : active, 
                            //                             item.hoverable != undefined ? item.hoverable : hoverable, 
                            //                             item.pressable != undefined ? item.pressable : pressable, 
                                                
                            //                             def(item,'item__off__url'),
                            //                             def(item,'item__up__url'),
                            //                             def(item,'item__press__url'),
                            //                             def(item,'item__select__url'),
                            //                             def(item,'item__select_press__url'),
                            //                             def(item,'item__glow__url'),
                            //                             def(item,'item__glow_press__url'),
                            //                             def(item,'item__glow_select__url'),
                            //                             def(item,'item__glow_select_press__url'),
                            //                             def(item,'item__hover__url'),
                            //                             def(item,'item__hover_press__url'),
                            //                             def(item,'item__hover_select__url'),
                            //                             def(item,'item__hover_select_press__url'),
                            //                             def(item,'item__hover_glow__url'),
                            //                             def(item,'item__hover_glow_press__url'),
                            //                             def(item,'item__hover_glow_select__url'),
                            //                             def(item,'item__hover_glow_select_press__url'),
                                                
                            //                         //sub list
                            //                             item.list,
                            //                             item.interactable,
                                                
                            //                             item.itemWidth,
                            //                             def(item,'heightLimit'),
                            //                             def(item,'widthLimit'),
                            //                             def(item,'backgroundColour'),
                            //                             def(item,'backgroundMarkingColour'),
                                                
                            //                             def(item,'default_item_spacingHeight'),
                                                
                            //                             def(item,'space_height'),
                            //                             def(item,'break_height'),
                            //                             def(item,'break_lineMux'),
                                                
                            //                             item.onenter,
                            //                             item.onleave,
                            //                             item.onpress,
                            //                             item.ondblpress,
                            //                             item.onrelease,
                            //                             item.onselection,
                            //                             item.onpositionchange,
                            //                     );
                            //                 }else{ //unknown item
                            //                     output.calculatedListHeight -= style.default.itemSpacingHeight;
                            //                     console.warn('interface part "list_image" :: error : unknown list item type:',item);
                            //                     return;
                            //                 }
                            
                            //                 output.elements.push(newItem.item);
                            //                 output.calculatedListHeight += newItem.height;
                            //             });
                            
                            //             return output;
                            //         }
                            
                            //     //refreshing function
                            //         function refresh(){
                            //             itemArray = [];
                            //             calculatedListHeight = 0;
                            //             state.selectedItems = [];
                            //             state.lastNonShiftClicked = 0;
                            //             state.position = 0;
                                        
                            //             results = generateListContent(list);
                            //             calculatedListHeight = results.calculatedListHeight;
                            //             itemArray = results.elements;
                            
                            //             const widthToUse = style.default.widthLimit < 0 ? style.default.width : style.default.widthLimit;
                            //             backing.width(widthToUse);
                            //             cover.width(widthToUse);
                            //             stencil.width(widthToUse);
                            
                            //             const heightToUse = style.default.heightLimit < 0 || style.default.heightLimit > calculatedListHeight ? calculatedListHeight : style.default.heightLimit;
                            //             backing.height(calculatedListHeight);
                            //             cover.height(heightToUse);
                            //             stencil.height(heightToUse);
                            
                            //             itemCollection.clear();
                            //             results.elements.forEach(element => itemCollection.append(element));
                            //         }
                            
                            //     //elements 
                            //         //main
                            //             const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                            //             //stenciled group
                            //                 const stenciledGroup = interfacePart.builder('basic','group','stenciledGroup');
                            //                 object.append(stenciledGroup);
                            //             //sub list group
                            //                 const subListGroup = interfacePart.builder('basic','group','subListGroup');
                            //                 object.append(subListGroup);
                            //             //backing
                            //                 const backing = interfacePart.builder('basic','image','backing',{url:background_url});
                            //                 stenciledGroup.append(backing);
                            //             //item collection
                            //                 const itemCollection = interfacePart.builder('basic','group','itemCollection');
                            //                 stenciledGroup.append(itemCollection);
                            //             //cover
                            //                 const cover = interfacePart.builder('basic','rectangle','cover',{colour:{r:0,g:0,b:0,a:0}});
                            //                 stenciledGroup.append(cover);
                            //             //stencil
                            //                 const stencil = interfacePart.builder('basic','rectangle','stencil');
                            //                 stenciledGroup.stencil(stencil);
                            //                 stenciledGroup.clipActive(true);
                            
                            //     refresh();
                            
                            //     return object;
                            // };
                            
                            // this.list_image.itemTypes = {};
                            // this.list_image.itemTypes.space = function(index, x, y, height){
                            
                            //     const newItem = interfacePart.builder('basic','group',index+'_space',{x:x,y:y});
                            //     return {item:newItem,height:height};
                            // };
                            // this.list_image.itemTypes.break = function(index, x, y, width, height, url){
                            
                            //     const newItem = interfacePart.builder('basic','group',index+'_break',{x:x,y:y});
                            //     const image = interfacePart.builder('basic', 'image', 'image', { width:width, height:height, url:url });
                            //     newItem.append(image);
                            
                            //     return {item:newItem,height:height};
                            // };
                            // this.list_image.itemTypes.image = function(index, x, y, width, height, url){
                            
                            //     const newItem = interfacePart.builder('basic','group',index+'_image',{x:x,y:y});
                            //     const image = interfacePart.builder('basic', 'image', 'image', { width:width, height:height, url:url });
                            //     newItem.append(image);
                            
                            //     return {item:newItem,height:height};
                            // };
                            
                            // interfacePart.partLibrary.control.list_image = function(name,data){ 
                            //     return interfacePart.collection.control.list_image(
                            //         name,
                            //         data.x, 
                            //         data.y, 
                            //         data.angle,
                            //         data.interactable,
                            //         data.list,
                                
                            //         data.active,
                            //         data.multiSelect,
                            //         data.hoverable,
                            //         data.selectable,
                            //         data.pressable,
                                
                            //         data.heightLimit,
                            //         data.widthLimit,
                            //         data.background_url,
                            //         data.break_url,
                                
                            //         data.default_item_height,
                            //         data.default_item_width,
                            //         data.default_item_spacingHeight,
                            //         data.default_item_horizontalPadding,
                                
                            //         data.default_item__off__url,
                            //         data.default_item__up__url,
                            //         data.default_item__press__url,
                            //         data.default_item__select__url,
                            //         data.default_item__select_press__url,
                            //         data.default_item__glow__url,
                            //         data.default_item__glow_press__url,
                            //         data.default_item__glow_select__url,
                            //         data.default_item__glow_select_press__url,
                            //         data.default_item__hover__url,
                            //         data.default_item__hover_press__url,
                            //         data.default_item__hover_select__url,
                            //         data.default_item__hover_select_press__url,
                            //         data.default_item__hover_glow__url,
                            //         data.default_item__hover_glow_press__url,
                            //         data.default_item__hover_glow_select__url,
                            //         data.default_item__hover_glow_select_press__url,
                                
                            //         data.space_height,
                            //         data.break_height,
                            //         data.break_lineMux,
                                
                            //         data.onenter,
                            //         data.onleave,
                            //         data.onpress,
                            //         data.ondblpress,
                            //         data.onrelease,
                            //         data.onselection,
                            //         data.onpositionchange,
                            //     );
                            // };
                            this.list = function(
                                name='list', 
                                x, y, angle=0, interactable=true,
                                list=[],
                            
                                active=true, multiSelect=false, hoverable=true, selectable=false, pressable=true,
                            
                                heightLimit=-1, widthLimit=-1,
                                backgroundColour={r:230/255,g:230/255,b:230/255,a:1},
                                backgroundMarkingColour={r:0.7,g:0.7,b:0.7,a:1},
                            
                                default_item_height=10, default_item_width=47.5,
                                default_item_spacingHeight=3/4,
                                default_item_horizontalPadding=2,
                            
                                default_text__text='Hello',
                                default_text__font='defaultThin',
                                default_text__fontSize=10/4,
                                default_text__printingMode={widthCalculation:'absolute', horizontal:'left', vertical:'middle'},
                                default_text__spacing=1/10,
                                default_text__interCharacterSpacing=0,
                            
                                default_text_colour__off=                                   {r:0.2,g:0.2,b:0.2,a:1},
                                default_text_colour__up=                                    {r:0.2,g:0.2,b:0.2,a:1},
                                default_text_colour__press=                                 {r:0.2,g:0.2,b:0.2,a:1},
                                default_text_colour__select=                                {r:1.0,g:0.2,b:0.2,a:1},
                                default_text_colour__select_press=                          {r:0.2,g:0.2,b:0.2,a:1},
                                default_text_colour__glow=                                  {r:0.2,g:0.2,b:0.2,a:1},
                                default_text_colour__glow_press=                            {r:0.2,g:0.2,b:0.2,a:1},
                                default_text_colour__glow_select=                           {r:0.2,g:0.2,b:0.2,a:1},
                                default_text_colour__glow_select_press=                     {r:0.2,g:0.2,b:0.2,a:1},
                                default_text_colour__hover=                                 {r:1.0,g:0.2,b:1.0,a:1},
                                default_text_colour__hover_press=                           {r:0.2,g:1.0,b:1.0,a:1},
                                default_text_colour__hover_select=                          {r:0.2,g:1.0,b:0.2,a:1},
                                default_text_colour__hover_select_press=                    {r:0.2,g:0.2,b:1.0,a:1},
                                default_text_colour__hover_glow=                            {r:0.2,g:0.2,b:0.2,a:1},
                                default_text_colour__hover_glow_press=                      {r:0.2,g:0.2,b:0.2,a:1},
                                default_text_colour__hover_glow_select=                     {r:0.2,g:0.2,b:0.2,a:1},
                                default_text_colour__hover_glow_select_press=               {r:0.2,g:0.2,b:0.2,a:1},
                            
                                default_item__off__colour=                               {r:180/255,g:180/255,b:180/255,a:1},
                                default_item__off__lineColour=                           {r:0/255,g:0/255,b:0/255,a:0},
                                default_item__off__lineThickness=                        0,
                                default_item__up__colour=                                {r:200/255,g:200/255,b:200/255,a:1},
                                default_item__up__lineColour=                            {r:0/255,g:0/255,b:0/255,a:0},
                                default_item__up__lineThickness=                         0,
                                default_item__press__colour=                             {r:230/255,g:230/255,b:230/255,a:1},
                                default_item__press__lineColour=                         {r:0/255,g:0/255,b:0/255,a:0},
                                default_item__press__lineThickness=                      0,
                                default_item__select__colour=                            {r:220/255,g:220/255,b:220/255,a:1},
                                default_item__select__lineColour=                        {r:120/255,g:120/255,b:120/255,a:1},
                                default_item__select__lineThickness=                     0,
                                default_item__select_press__colour=                      {r:230/255,g:230/255,b:230/255,a:1},
                                default_item__select_press__lineColour=                  {r:120/255,g:120/255,b:120/255,a:1},
                                default_item__select_press__lineThickness=               0,
                                default_item__glow__colour=                              {r:220/255,g:220/255,b:220/255,a:1},
                                default_item__glow__lineColour=                          {r:0/255,g:0/255,b:0/255,a:0},
                                default_item__glow__lineThickness=                       0,
                                default_item__glow_press__colour=                        {r:250/255,g:250/255,b:250/255,a:1},
                                default_item__glow_press__lineColour=                    {r:0/255,g:0/255,b:0/255,a:0},
                                default_item__glow_press__lineThickness=                 0,
                                default_item__glow_select__colour=                       {r:220/255,g:220/255,b:220/255,a:1},
                                default_item__glow_select__lineColour=                   {r:120/255,g:120/255,b:120/255,a:1},
                                default_item__glow_select__lineThickness=                0,
                                default_item__glow_select_press__colour=                 {r:250/255,g:250/255,b:250/255,a:1},
                                default_item__glow_select_press__lineColour=             {r:120/255,g:120/255,b:120/255,a:1},
                                default_item__glow_select_press__lineThickness=          0,
                                default_item__hover__colour=                             {r:220/255,g:220/255,b:220/255,a:1},
                                default_item__hover__lineColour=                         {r:0/255,g:0/255,b:0/255,a:0},
                                default_item__hover__lineThickness=                      0,
                                default_item__hover_press__colour=                       {r:240/255,g:240/255,b:240/255,a:1},
                                default_item__hover_press__lineColour=                   {r:0/255,g:0/255,b:0/255,a:0},
                                default_item__hover_press__lineThickness=                0,
                                default_item__hover_select__colour=                      {r:220/255,g:220/255,b:220/255,a:1},
                                default_item__hover_select__lineColour=                  {r:120/255,g:120/255,b:120/255,a:1},
                                default_item__hover_select__lineThickness=               0,
                                default_item__hover_select_press__colour=                {r:240/255,g:240/255,b:240/255,a:1},
                                default_item__hover_select_press__lineColour=            {r:120/255,g:120/255,b:120/255,a:1},
                                default_item__hover_select_press__lineThickness=         0,
                                default_item__hover_glow__colour=                        {r:250/255,g:250/255,b:250/255,a:1},
                                default_item__hover_glow__lineColour=                    {r:0/255,g:0/255,b:0/255,a:0},
                                default_item__hover_glow__lineThickness=                 0,
                                default_item__hover_glow_press__colour=                  {r:250/255,g:250/255,b:250/255,a:1},
                                default_item__hover_glow_press__lineColour=              {r:0/255,g:0/255,b:0/255,a:0},
                                default_item__hover_glow_press__lineThickness=           0,
                                default_item__hover_glow_select__colour=                 {r:240/255,g:240/255,b:240/255,a:1},
                                default_item__hover_glow_select__lineColour=             {r:120/255,g:120/255,b:120/255,a:1},
                                default_item__hover_glow_select__lineThickness=          0,
                                default_item__hover_glow_select_press__colour=           {r:250/255,g:250/255,b:250/255,a:1},
                                default_item__hover_glow_select_press__lineColour=       {r:120/255,g:120/255,b:120/255,a:1},
                                default_item__hover_glow_select_press__lineThickness=    0,
                            
                                subList_arrowMux=1,
                                space_height=10/16,
                                break_height=10/8,
                                break_lineMux=1/5,
                                textBreak_height=10/8,
                                textBreak_textToLineSpacing=1,
                                textBreak_textHeightMux=1.1,
                                textBreak_lineMux=1/5,
                            
                                onenter=function(a){/*console.log('onenter >',a);*/},
                                onleave=function(a){/*console.log('onleave >',a);*/},
                                onpress=function(a){/*console.log('onpress >',a);*/},
                                ondblpress=function(a){/*console.log('ondblpress >',a);*/},
                                onrelease=function(a){/*console.log('onrelease >',a);*/},
                                onselection=function(a){/*console.log('onselection >',a);*/},
                                onpositionchange=function(a){/*console.log('onpositionchange >',a);*/},
                            ){
                            
                                //state
                                    let self = this;
                                    let itemArray = [];
                                    let calculatedListHeight = 0;
                                    const state = {
                                        position:0,
                                        lastNonShiftClicked:0,
                                        selectedItems:[],
                                    };
                            
                                //default style
                                    const style = {
                                        default:{
                                            heightLimit:heightLimit, widthLimit:widthLimit,
                                            backgroundColour:backgroundColour,
                                            backgroundMarkingColour:backgroundMarkingColour,
                            
                                            height:default_item_height, width:default_item_width,
                            
                                            itemSpacingHeight:default_item_spacingHeight,
                                            itemHorizontalPadding:default_item_horizontalPadding,
                            
                                            text:default_text__text,
                                            font:default_text__font,
                                            fontSize:default_text__fontSize,
                                            printingMode:default_text__printingMode,
                                            spacing:default_text__spacing,
                                            interCharacterSpacing:default_text__interCharacterSpacing,
                            
                                            text_colour__off:default_text_colour__off,
                                            text_colour__up:default_text_colour__up,
                                            text_colour__press:default_text_colour__press,
                                            text_colour__select:default_text_colour__select,
                                            text_colour__select_press:default_text_colour__select_press,
                                            text_colour__glow:default_text_colour__glow,
                                            text_colour__glow_press:default_text_colour__glow_press,
                                            text_colour__glow_select:default_text_colour__glow_select,
                                            text_colour__glow_select_press:default_text_colour__glow_select_press,
                                            text_colour__hover:default_text_colour__hover,
                                            text_colour__hover_press:default_text_colour__hover_press,
                                            text_colour__hover_select:default_text_colour__hover_select,
                                            text_colour__hover_select_press:default_text_colour__hover_select_press,
                                            text_colour__hover_glow:default_text_colour__hover_glow,
                                            text_colour__hover_glow_press:default_text_colour__hover_glow_press,
                                            text_colour__hover_glow_select:default_text_colour__hover_glow_select,
                                            text_colour__hover_glow_select_press:default_text_colour__hover_glow_select_press,
                            
                                            item__off__colour:                            default_item__off__colour,
                                            item__off__lineColour:                        default_item__off__lineColour,
                                            item__off__lineThickness:                     default_item__off__lineThickness,
                                            item__up__colour:                             default_item__up__colour,
                                            item__up__lineColour:                         default_item__up__lineColour,
                                            item__up__lineThickness:                      default_item__up__lineThickness,
                                            item__press__colour:                          default_item__press__colour,
                                            item__press__lineColour:                      default_item__press__lineColour,
                                            item__press__lineThickness:                   default_item__press__lineThickness,
                                            item__select__colour:                         default_item__select__colour,
                                            item__select__lineColour:                     default_item__select__lineColour,
                                            item__select__lineThickness:                  default_item__select__lineThickness,
                                            item__select_press__colour:                   default_item__select_press__colour,
                                            item__select_press__lineColour:               default_item__select_press__lineColour,
                                            item__select_press__lineThickness:            default_item__select_press__lineThickness,
                                            item__glow__colour:                           default_item__glow__colour,
                                            item__glow__lineColour:                       default_item__glow__lineColour,
                                            item__glow__lineThickness:                    default_item__glow__lineThickness,
                                            item__glow_press__colour:                     default_item__glow_press__colour,
                                            item__glow_press__lineColour:                 default_item__glow_press__lineColour,
                                            item__glow_press__lineThickness:              default_item__glow_press__lineThickness,
                                            item__glow_select__colour:                    default_item__glow_select__colour,
                                            item__glow_select__lineColour:                default_item__glow_select__lineColour,
                                            item__glow_select__lineThickness:             default_item__glow_select__lineThickness,
                                            item__glow_select_press__colour:              default_item__glow_select_press__colour,
                                            item__glow_select_press__lineColour:          default_item__glow_select_press__lineColour,
                                            item__glow_select_press__lineThickness:       default_item__glow_select_press__lineThickness,
                                            item__hover__colour:                          default_item__hover__colour,
                                            item__hover__lineColour:                      default_item__hover__lineColour,
                                            item__hover__lineThickness:                   default_item__hover__lineThickness,
                                            item__hover_press__colour:                    default_item__hover_press__colour,
                                            item__hover_press__lineColour:                default_item__hover_press__lineColour,
                                            item__hover_press__lineThickness:             default_item__hover_press__lineThickness,
                                            item__hover_select__colour:                   default_item__hover_select__colour,
                                            item__hover_select__lineColour:               default_item__hover_select__lineColour,
                                            item__hover_select__lineThickness:            default_item__hover_select__lineThickness,
                                            item__hover_select_press__colour:             default_item__hover_select_press__colour,
                                            item__hover_select_press__lineColour:         default_item__hover_select_press__lineColour,
                                            item__hover_select_press__lineThickness:      default_item__hover_select_press__lineThickness,
                                            item__hover_glow__colour:                     default_item__hover_glow__colour,
                                            item__hover_glow__lineColour:                 default_item__hover_glow__lineColour,
                                            item__hover_glow__lineThickness:              default_item__hover_glow__lineThickness,
                                            item__hover_glow_press__colour:               default_item__hover_glow_press__colour,
                                            item__hover_glow_press__lineColour:           default_item__hover_glow_press__lineColour,
                                            item__hover_glow_press__lineThickness:        default_item__hover_glow_press__lineThickness,
                                            item__hover_glow_select__colour:              default_item__hover_glow_select__colour,
                                            item__hover_glow_select__lineColour:          default_item__hover_glow_select__lineColour,
                                            item__hover_glow_select__lineThickness:       default_item__hover_glow_select__lineThickness,
                                            item__hover_glow_select_press__colour:        default_item__hover_glow_select_press__colour,
                                            item__hover_glow_select_press__lineColour:    default_item__hover_glow_select_press__lineColour,
                                            item__hover_glow_select_press__lineThickness: default_item__hover_glow_select_press__lineThickness,
                                        },
                                        space:{
                                            height:space_height,
                                        },
                                        text:{},
                                        break:{
                                            height:break_height,
                                            lineMux:break_lineMux,
                                        },
                                        textbreak:{
                                            height:textBreak_height,
                                            textToLineSpacing:textBreak_textToLineSpacing,
                                            textHeightMux:textBreak_textHeightMux,
                                            lineMux:textBreak_lineMux,
                                        },
                                        checkbox:{},
                                        button:{},
                                        radio:{
                                            arrowMux:subList_arrowMux,
                                        },
                                        list:{
                                            heightLimit:-1,
                                            arrowMux:subList_arrowMux,
                                            space_height:space_height,
                                            break_height:break_height,
                                            break_lineMux:break_lineMux,
                                            textBreak_height:textBreak_height,
                                            textBreak_textToLineSpacing:textBreak_textToLineSpacing,
                                            textBreak_textHeightMux:textBreak_textHeightMux,
                                            textBreak_lineMux:textBreak_lineMux,
                                        },
                                    };
                                    
                                //generate list content
                                    function generateListContent(listItems=[]){
                                        function def(i,t){ return i[t]==undefined ? (style[i.type][t]==undefined ? style.default[t] : style[i.type][t]) : i[t]; }
                            
                                        const output = {elements:[], calculatedListHeight:0};
                                        const xOffset = style.default.widthLimit < 0 ? 0 : (style.default.widthLimit-style.default.width)/2;
                            
                                        listItems.forEach((item,index) => {
                                            if(index != 0){output.calculatedListHeight += style.default.itemSpacingHeight;}
                            
                                            if(item.type == 'item'){
                                                console.warn('"item" item isn\'t an item type you can use for an item. Switching to "button" which is probably what you were looking for');
                                                item.type = 'button';
                                            }
                            
                                            let newItem;
                                            if(item.type == 'text'){
                                                newItem = self.list.itemTypes.text(
                                                    index, xOffset, output.calculatedListHeight, def(item,'width'), def(item,'height'), def(item,'itemHorizontalPadding'),
                                                    (item.text?item.text:item.text_left), item.text_centre, item.text_right,
                                                    def(item,'fontSize'), def(item,'font'), def(item,'text_colour__up'), def(item,'spacing'),
                                                    def(item,'interCharacterSpacing'), def(item,'item__up__colour'),
                                                );
                                            }else if(item.type == 'space'){
                                                newItem = self.list.itemTypes.space(index, xOffset, output.calculatedListHeight, def(item,'height') );
                                            }else if(item.type == 'break'){
                                                newItem = self.list.itemTypes.break(
                                                    index, xOffset, output.calculatedListHeight, def(item,'width'), 
                                                    def(item,'height'), def(item,'backgroundMarkingColour'), def(item,'lineMux')
                                                );
                                            }else if(item.type == 'textbreak'){
                                                newItem = self.list.itemTypes.textbreak(
                                                    index, xOffset, output.calculatedListHeight, def(item,'width'), def(item,'height'), item.text,
                                                    def(item,'backgroundMarkingColour'), def(item,'printingMode'), def(item,'font'), def(item,'spacing'),
                                                    def(item,'interCharacterSpacing'), def(item,'textToLineSpacing'), def(item,'textHeightMux'), def(item,'lineMux')
                                                );
                                            }else if(item.type == 'checkbox'){
                                                newItem = self.list.itemTypes.checkbox(
                                                    index, xOffset, output.calculatedListHeight, def(item,'width'), def(item,'height'), def(item,'itemHorizontalPadding'),
                                                    (item.text?item.text:item.text_left), item.text_centre, item.text_right,
                                                    def(item,'fontSize'), def(item,'font'), def(item,'spacing'), def(item,'interCharacterSpacing'),
                                                    item.active != undefined ? item.active : active, 
                                                    item.hoverable != undefined ? item.hoverable : hoverable, 
                                                    item.selectable != undefined ? item.selectable : selectable, 
                                                    item.pressable != undefined ? item.pressable : pressable, 
                            
                                                    def(item,'text_colour__off'),
                                                    def(item,'text_colour__up'),
                                                    def(item,'text_colour__press'),
                                                    def(item,'text_colour__select'),
                                                    def(item,'text_colour__select_press'),
                                                    def(item,'text_colour__glow'),
                                                    def(item,'text_colour__glow_press'),
                                                    def(item,'text_colour__glow_select'),
                                                    def(item,'text_colour__glow_select_press'),
                                                    def(item,'text_colour__hover'),
                                                    def(item,'text_colour__hover_press'),
                                                    def(item,'text_colour__hover_select'),
                                                    def(item,'text_colour__hover_select_press'),
                                                    def(item,'text_colour__hover_glow'),
                                                    def(item,'text_colour__hover_glow_press'),
                                                    def(item,'text_colour__hover_glow_select'),
                                                    def(item,'text_colour__hover_glow_select_press'),
                            
                                                    def(item,'item__off__colour'),
                                                    def(item,'item__off__lineColour'),
                                                    def(item,'item__off__lineThickness'),
                                                    def(item,'item__up__colour'),
                                                    def(item,'item__up__lineColour'),
                                                    def(item,'item__up__lineThickness'),
                                                    def(item,'item__press__colour'),
                                                    def(item,'item__press__lineColour'),
                                                    def(item,'item__press__lineThickness'),
                                                    def(item,'item__select__colour'),
                                                    def(item,'item__select__lineColour'),
                                                    def(item,'item__select__lineThickness'),
                                                    def(item,'item__select_press__colour'),
                                                    def(item,'item__select_press__lineColour'),
                                                    def(item,'item__select_press__lineThickness'),
                                                    def(item,'item__glow__colour'),
                                                    def(item,'item__glow__lineColour'),
                                                    def(item,'item__glow__lineThickness'),
                                                    def(item,'item__glow_press__colour'),
                                                    def(item,'item__glow_press__lineColour'),
                                                    def(item,'item__glow_press__lineThickness'),
                                                    def(item,'item__glow_select__colour'),
                                                    def(item,'item__glow_select__lineColour'),
                                                    def(item,'item__glow_select__lineThickness'),
                                                    def(item,'item__glow_select_press__colour'),
                                                    def(item,'item__glow_select_press__lineColour'),
                                                    def(item,'item__glow_select_press__lineThickness'),
                                                    def(item,'item__hover__colour'),
                                                    def(item,'item__hover__lineColour'),
                                                    def(item,'item__hover__lineThickness'),
                                                    def(item,'item__hover_press__colour'),
                                                    def(item,'item__hover_press__lineColour'),
                                                    def(item,'item__hover_press__lineThickness'),
                                                    def(item,'item__hover_select__colour'),
                                                    def(item,'item__hover_select__lineColour'),
                                                    def(item,'item__hover_select__lineThickness'),
                                                    def(item,'item__hover_select_press__colour'),
                                                    def(item,'item__hover_select_press__lineColour'),
                                                    def(item,'item__hover_select_press__lineThickness'),
                                                    def(item,'item__hover_glow__colour'),
                                                    def(item,'item__hover_glow__lineColour'),
                                                    def(item,'item__hover_glow__lineThickness'),
                                                    def(item,'item__hover_glow_press__colour'),
                                                    def(item,'item__hover_glow_press__lineColour'),
                                                    def(item,'item__hover_glow_press__lineThickness'),
                                                    def(item,'item__hover_glow_select__colour'),
                                                    def(item,'item__hover_glow_select__lineColour'),
                                                    def(item,'item__hover_glow_select__lineThickness'),
                                                    def(item,'item__hover_glow_select_press__colour'),
                                                    def(item,'item__hover_glow_select_press__lineColour'),
                                                    def(item,'item__hover_glow_select_press__lineThickness'),
                            
                                                    item.updateFunction, item.onclickFunction,
                                                );
                                            }else if(item.type == 'button'){
                                                newItem = self.list.itemTypes.button(
                                                    index, xOffset, output.calculatedListHeight, def(item,'width'), def(item,'height'), def(item,'itemHorizontalPadding'),
                                                    (item.text?item.text:item.text_left), item.text_centre, item.text_right,
                                                    def(item,'fontSize'), def(item,'font'), def(item,'spacing'), def(item,'interCharacterSpacing'),
                                                    item.active != undefined ? item.active : active, 
                                                    item.hoverable != undefined ? item.hoverable : hoverable, 
                                                    item.selectable != undefined ? item.selectable : selectable, 
                                                    item.pressable != undefined ? item.pressable : pressable, 
                            
                                                    def(item,'text_colour__off'),
                                                    def(item,'text_colour__up'),
                                                    def(item,'text_colour__press'),
                                                    def(item,'text_colour__select'),
                                                    def(item,'text_colour__select_press'),
                                                    def(item,'text_colour__glow'),
                                                    def(item,'text_colour__glow_press'),
                                                    def(item,'text_colour__glow_select'),
                                                    def(item,'text_colour__glow_select_press'),
                                                    def(item,'text_colour__hover'),
                                                    def(item,'text_colour__hover_press'),
                                                    def(item,'text_colour__hover_select'),
                                                    def(item,'text_colour__hover_select_press'),
                                                    def(item,'text_colour__hover_glow'),
                                                    def(item,'text_colour__hover_glow_press'),
                                                    def(item,'text_colour__hover_glow_select'),
                                                    def(item,'text_colour__hover_glow_select_press'),
                            
                                                    def(item,'item__off__colour'),
                                                    def(item,'item__off__lineColour'),
                                                    def(item,'item__off__lineThickness'),
                                                    def(item,'item__up__colour'),
                                                    def(item,'item__up__lineColour'),
                                                    def(item,'item__up__lineThickness'),
                                                    def(item,'item__press__colour'),
                                                    def(item,'item__press__lineColour'),
                                                    def(item,'item__press__lineThickness'),
                                                    def(item,'item__select__colour'),
                                                    def(item,'item__select__lineColour'),
                                                    def(item,'item__select__lineThickness'),
                                                    def(item,'item__select_press__colour'),
                                                    def(item,'item__select_press__lineColour'),
                                                    def(item,'item__select_press__lineThickness'),
                                                    def(item,'item__glow__colour'),
                                                    def(item,'item__glow__lineColour'),
                                                    def(item,'item__glow__lineThickness'),
                                                    def(item,'item__glow_press__colour'),
                                                    def(item,'item__glow_press__lineColour'),
                                                    def(item,'item__glow_press__lineThickness'),
                                                    def(item,'item__glow_select__colour'),
                                                    def(item,'item__glow_select__lineColour'),
                                                    def(item,'item__glow_select__lineThickness'),
                                                    def(item,'item__glow_select_press__colour'),
                                                    def(item,'item__glow_select_press__lineColour'),
                                                    def(item,'item__glow_select_press__lineThickness'),
                                                    def(item,'item__hover__colour'),
                                                    def(item,'item__hover__lineColour'),
                                                    def(item,'item__hover__lineThickness'),
                                                    def(item,'item__hover_press__colour'),
                                                    def(item,'item__hover_press__lineColour'),
                                                    def(item,'item__hover_press__lineThickness'),
                                                    def(item,'item__hover_select__colour'),
                                                    def(item,'item__hover_select__lineColour'),
                                                    def(item,'item__hover_select__lineThickness'),
                                                    def(item,'item__hover_select_press__colour'),
                                                    def(item,'item__hover_select_press__lineColour'),
                                                    def(item,'item__hover_select_press__lineThickness'),
                                                    def(item,'item__hover_glow__colour'),
                                                    def(item,'item__hover_glow__lineColour'),
                                                    def(item,'item__hover_glow__lineThickness'),
                                                    def(item,'item__hover_glow_press__colour'),
                                                    def(item,'item__hover_glow_press__lineColour'),
                                                    def(item,'item__hover_glow_press__lineThickness'),
                                                    def(item,'item__hover_glow_select__colour'),
                                                    def(item,'item__hover_glow_select__lineColour'),
                                                    def(item,'item__hover_glow_select__lineThickness'),
                                                    def(item,'item__hover_glow_select_press__colour'),
                                                    def(item,'item__hover_glow_select_press__lineColour'),
                                                    def(item,'item__hover_glow_select_press__lineThickness'),
                            
                                                    function(){ object.onenter([index]); },
                                                    function(){ object.onleave([index]); },
                                                    function(){ object.onpress([index]); },
                                                    function(){ object.ondblpress([index]); },
                                                    function(){ if(item.function){item.function();} object.onrelease([index]); },
                                                    function(obj,event){ object.select(index,true,event,false);} ,
                                                    function(obj,event){ object.select(index,false,event,false); },
                                                );
                                            }else if(item.type == 'radio'){
                                                newItem = self.list.itemTypes.radio(
                                                    subListGroup,
                                                    index, xOffset, output.calculatedListHeight,
                                                                        
                                                    //internal callbacks
                                                        function(isOpen){
                                                            if(!isOpen){return;}
                                                            itemArray.forEach((item,a) => { if(list[a].type == 'list' && a != index && item.isOpen){ item.close(); } });
                                                            return -state.position * (style.default.heightLimit > 0 && style.default.heightLimit < calculatedListHeight ? (calculatedListHeight-style.default.heightLimit) : calculatedListHeight);
                                                        },
                            
                                                    //button
                                                        def(item,'width'), def(item,'height'), 
                                                
                                                        def(item,'itemHorizontalPadding'),
                                                        (item.text?item.text:item.text_left), item.text_centre, item.text_right,
                                                        def(item,'fontSize'), def(item,'font'), def(item,'spacing'), def(item,'interCharacterSpacing'), def(item,'arrowMux'),
                                                        item.active != undefined ? item.active : active, 
                                                        item.hoverable != undefined ? item.hoverable : hoverable, 
                                                        item.pressable != undefined ? item.pressable : pressable, 
                            
                                                        def(item,'text_colour__off'),
                                                        def(item,'text_colour__up'),
                                                        def(item,'text_colour__press'),
                                                        def(item,'text_colour__select'),
                                                        def(item,'text_colour__select_press'),
                                                        def(item,'text_colour__glow'),
                                                        def(item,'text_colour__glow_press'),
                                                        def(item,'text_colour__glow_select'),
                                                        def(item,'text_colour__glow_select_press'),
                                                        def(item,'text_colour__hover'),
                                                        def(item,'text_colour__hover_press'),
                                                        def(item,'text_colour__hover_select'),
                                                        def(item,'text_colour__hover_select_press'),
                                                        def(item,'text_colour__hover_glow'),
                                                        def(item,'text_colour__hover_glow_press'),
                                                        def(item,'text_colour__hover_glow_select'),
                                                        def(item,'text_colour__hover_glow_select_press'),
                                                
                                                        def(item,'item__off__colour'),
                                                        def(item,'item__off__lineColour'),
                                                        def(item,'item__off__lineThickness'),
                                                        def(item,'item__up__colour'),
                                                        def(item,'item__up__lineColour'),
                                                        def(item,'item__up__lineThickness'),
                                                        def(item,'item__press__colour'),
                                                        def(item,'item__press__lineColour'),
                                                        def(item,'item__press__lineThickness'),
                                                        def(item,'item__select__colour'),
                                                        def(item,'item__select__lineColour'),
                                                        def(item,'item__select__lineThickness'),
                                                        def(item,'item__select_press__colour'),
                                                        def(item,'item__select_press__lineColour'),
                                                        def(item,'item__select_press__lineThickness'),
                                                        def(item,'item__glow__colour'),
                                                        def(item,'item__glow__lineColour'),
                                                        def(item,'item__glow__lineThickness'),
                                                        def(item,'item__glow_press__colour'),
                                                        def(item,'item__glow_press__lineColour'),
                                                        def(item,'item__glow_press__lineThickness'),
                                                        def(item,'item__glow_select__colour'),
                                                        def(item,'item__glow_select__lineColour'),
                                                        def(item,'item__glow_select__lineThickness'),
                                                        def(item,'item__glow_select_press__colour'),
                                                        def(item,'item__glow_select_press__lineColour'),
                                                        def(item,'item__glow_select_press__lineThickness'),
                                                        def(item,'item__hover__colour'),
                                                        def(item,'item__hover__lineColour'),
                                                        def(item,'item__hover__lineThickness'),
                                                        def(item,'item__hover_press__colour'),
                                                        def(item,'item__hover_press__lineColour'),
                                                        def(item,'item__hover_press__lineThickness'),
                                                        def(item,'item__hover_select__colour'),
                                                        def(item,'item__hover_select__lineColour'),
                                                        def(item,'item__hover_select__lineThickness'),
                                                        def(item,'item__hover_select_press__colour'),
                                                        def(item,'item__hover_select_press__lineColour'),
                                                        def(item,'item__hover_select_press__lineThickness'),
                                                        def(item,'item__hover_glow__colour'),
                                                        def(item,'item__hover_glow__lineColour'),
                                                        def(item,'item__hover_glow__lineThickness'),
                                                        def(item,'item__hover_glow_press__colour'),
                                                        def(item,'item__hover_glow_press__lineColour'),
                                                        def(item,'item__hover_glow_press__lineThickness'),
                                                        def(item,'item__hover_glow_select__colour'),
                                                        def(item,'item__hover_glow_select__lineColour'),
                                                        def(item,'item__hover_glow_select__lineThickness'),
                                                        def(item,'item__hover_glow_select_press__colour'),
                                                        def(item,'item__hover_glow_select_press__lineColour'),
                                                        def(item,'item__hover_glow_select_press__lineThickness'),
                                                
                                                    //sub list
                                                        item.options,
                                                
                                                        item.itemWidth,
                                                        def(item,'heightLimit'),
                                                        def(item,'widthLimit'),
                                                        def(item,'backgroundColour'),
                                                        def(item,'backgroundMarkingColour'),
                                                
                                                        def(item,'default_item_spacingHeight'),
                            
                                                        item.updateFunction, item.onclickFunction,
                                                );
                                            }else if(item.type == 'list'){
                                                newItem = self.list.itemTypes.list(
                                                    subListGroup,
                                                    index, xOffset, output.calculatedListHeight,
                                                
                                                    //internal callbacks
                                                        function(isOpen){
                                                            if(!isOpen){return;}
                                                            itemArray.forEach((item,a) => { if(list[a].type == 'list' && a != index && item.isOpen){ item.close(); } });
                                                            return -state.position * (style.default.heightLimit > 0 && style.default.heightLimit < calculatedListHeight ? (calculatedListHeight-style.default.heightLimit) : calculatedListHeight);
                                                        },
                                                    
                                                    //button
                                                        def(item,'width'), def(item,'height'), 
                                                
                                                        def(item,'itemHorizontalPadding'),
                                                        (item.text?item.text:item.text_left), item.text_centre, item.text_right,
                                                        def(item,'fontSize'), def(item,'font'), def(item,'spacing'), def(item,'interCharacterSpacing'), def(item,'arrowMux'),
                                                        item.active != undefined ? item.active : active, 
                                                        item.hoverable != undefined ? item.hoverable : hoverable, 
                                                        item.pressable != undefined ? item.pressable : pressable, 
                            
                                                        def(item,'text_colour__off'),
                                                        def(item,'text_colour__up'),
                                                        def(item,'text_colour__press'),
                                                        def(item,'text_colour__select'),
                                                        def(item,'text_colour__select_press'),
                                                        def(item,'text_colour__glow'),
                                                        def(item,'text_colour__glow_press'),
                                                        def(item,'text_colour__glow_select'),
                                                        def(item,'text_colour__glow_select_press'),
                                                        def(item,'text_colour__hover'),
                                                        def(item,'text_colour__hover_press'),
                                                        def(item,'text_colour__hover_select'),
                                                        def(item,'text_colour__hover_select_press'),
                                                        def(item,'text_colour__hover_glow'),
                                                        def(item,'text_colour__hover_glow_press'),
                                                        def(item,'text_colour__hover_glow_select'),
                                                        def(item,'text_colour__hover_glow_select_press'),
                                                
                                                        def(item,'item__off__colour'),
                                                        def(item,'item__off__lineColour'),
                                                        def(item,'item__off__lineThickness'),
                                                        def(item,'item__up__colour'),
                                                        def(item,'item__up__lineColour'),
                                                        def(item,'item__up__lineThickness'),
                                                        def(item,'item__press__colour'),
                                                        def(item,'item__press__lineColour'),
                                                        def(item,'item__press__lineThickness'),
                                                        def(item,'item__select__colour'),
                                                        def(item,'item__select__lineColour'),
                                                        def(item,'item__select__lineThickness'),
                                                        def(item,'item__select_press__colour'),
                                                        def(item,'item__select_press__lineColour'),
                                                        def(item,'item__select_press__lineThickness'),
                                                        def(item,'item__glow__colour'),
                                                        def(item,'item__glow__lineColour'),
                                                        def(item,'item__glow__lineThickness'),
                                                        def(item,'item__glow_press__colour'),
                                                        def(item,'item__glow_press__lineColour'),
                                                        def(item,'item__glow_press__lineThickness'),
                                                        def(item,'item__glow_select__colour'),
                                                        def(item,'item__glow_select__lineColour'),
                                                        def(item,'item__glow_select__lineThickness'),
                                                        def(item,'item__glow_select_press__colour'),
                                                        def(item,'item__glow_select_press__lineColour'),
                                                        def(item,'item__glow_select_press__lineThickness'),
                                                        def(item,'item__hover__colour'),
                                                        def(item,'item__hover__lineColour'),
                                                        def(item,'item__hover__lineThickness'),
                                                        def(item,'item__hover_press__colour'),
                                                        def(item,'item__hover_press__lineColour'),
                                                        def(item,'item__hover_press__lineThickness'),
                                                        def(item,'item__hover_select__colour'),
                                                        def(item,'item__hover_select__lineColour'),
                                                        def(item,'item__hover_select__lineThickness'),
                                                        def(item,'item__hover_select_press__colour'),
                                                        def(item,'item__hover_select_press__lineColour'),
                                                        def(item,'item__hover_select_press__lineThickness'),
                                                        def(item,'item__hover_glow__colour'),
                                                        def(item,'item__hover_glow__lineColour'),
                                                        def(item,'item__hover_glow__lineThickness'),
                                                        def(item,'item__hover_glow_press__colour'),
                                                        def(item,'item__hover_glow_press__lineColour'),
                                                        def(item,'item__hover_glow_press__lineThickness'),
                                                        def(item,'item__hover_glow_select__colour'),
                                                        def(item,'item__hover_glow_select__lineColour'),
                                                        def(item,'item__hover_glow_select__lineThickness'),
                                                        def(item,'item__hover_glow_select_press__colour'),
                                                        def(item,'item__hover_glow_select_press__lineColour'),
                                                        def(item,'item__hover_glow_select_press__lineThickness'),
                                                
                                                    //sub list
                                                        item.list,
                                                        item.interactable,
                                                
                                                        item.itemWidth,
                                                        def(item,'heightLimit'),
                                                        def(item,'widthLimit'),
                                                        def(item,'backgroundColour'),
                                                        def(item,'backgroundMarkingColour'),
                                                
                                                        def(item,'default_item_spacingHeight'),
                                                
                                                        def(item,'space_height'),
                                                        def(item,'break_height'),
                                                        def(item,'break_lineMux'),
                                                        def(item,'textBreak_height'),
                                                        def(item,'textBreak_textToLineSpacing'),
                                                        def(item,'textBreak_textHeightMux'),
                                                        def(item,'textBreak_lineMux'),
                                                
                                                        item.onenter,
                                                        item.onleave,
                                                        item.onpress,
                                                        item.ondblpress,
                                                        item.onrelease,
                                                        item.onselection,
                                                        item.onpositionchange,
                                                );
                                            }else{ //unknown item
                                                output.calculatedListHeight -= style.default.itemSpacingHeight;
                                                console.warn('interface part "list" :: error : unknown list item type:',item);
                                                return;
                                            }
                            
                                            output.elements.push(newItem.item);
                                            output.calculatedListHeight += newItem.height;
                                        });
                            
                                        return output;
                                    }
                            
                                //refreshing function
                                    function refresh(){
                                        itemArray = [];
                                        calculatedListHeight = 0;
                                        state.selectedItems = [];
                                        state.lastNonShiftClicked = 0;
                                        state.position = 0;
                                        
                                        results = generateListContent(list);
                                        calculatedListHeight = results.calculatedListHeight;
                                        itemArray = results.elements;
                            
                                        const widthToUse = style.default.widthLimit < 0 ? style.default.width : style.default.widthLimit;
                                        backing.width(widthToUse);
                                        cover.width(widthToUse);
                                        stencil.width(widthToUse);
                            
                                        const heightToUse = style.default.heightLimit < 0 || style.default.heightLimit > calculatedListHeight ? calculatedListHeight : style.default.heightLimit;
                                        backing.height(heightToUse);
                                        cover.height(heightToUse);
                                        stencil.height(heightToUse);
                            
                                        itemCollection.clear();
                                        results.elements.forEach(element => itemCollection.append(element));
                                    }
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                        //backing
                                            const backing = interfacePart.builder('basic','rectangle','backing',{colour:style.default.backgroundColour});
                                            object.append(backing);
                                        //stenciled group
                                            const stenciledGroup = interfacePart.builder('basic','group','stenciledGroup');
                                            object.append(stenciledGroup);
                                        //sub list group
                                            const subListGroup = interfacePart.builder('basic','group','subListGroup');
                                            object.append(subListGroup);
                                        //item collection
                                            const itemCollection = interfacePart.builder('basic','group','itemCollection');
                                            stenciledGroup.append(itemCollection);
                                        //cover
                                            const cover = interfacePart.builder('basic','rectangle','cover',{colour:{r:0,g:0,b:0,a:0}});
                                            stenciledGroup.append(cover);
                                        //stencil
                                            const stencil = interfacePart.builder('basic','rectangle','stencil');
                                            stenciledGroup.stencil(stencil);
                                            stenciledGroup.clipActive(true);
                            
                                //interaction
                                    cover.attachCallback('onwheel', function(x,y,event){
                                        if(!interactable || !active){return;}
                                        const move = -event.wheelDelta/100;
                                        object.position( object.position() + move/10 );
                                        itemArray.forEach(item => {
                                            if(item.forceMouseLeave != undefined){
                                                item.forceMouseLeave();
                                            }
                                        });
                                    } );
                            
                                //controls
                                    object.position = function(a,update=true){
                                        if(a == undefined){return state.position;}
                                        a = a < 0 ? 0 : a;
                                        a = a > 1 ? 1 : a;
                                        state.position = a;
                            
                                        if(style.default.heightLimit < 0){return;}
                                        const movementSpace = calculatedListHeight - style.default.heightLimit;
                                        itemCollection.y( -a*movementSpace );
                                        
                                        if(update&&this.onpositionchange){this.onpositionchange(a);}
                                    };
                                    object.select = function(a,value,event,update=true){
                                        if(!selectable){return;}
                            
                                            if(!multiSelect){
                                            //where multi selection is not allowed
                                                //where we want to select an item, which is not already selected
                                                    if(value && !state.selectedItems.includes(a) ){
                                                        //deselect all other items
                                                            while( state.selectedItems.length > 0 ){
                                                                itemCollection.getChildren()[state.selectedItems[0]].select(false,undefined,undefined);
                                                                state.selectedItems.shift();
                                                            }
                            
                                                        //select current item
                                                            state.selectedItems.push(a);
                            
                                                //where we want to deselect an item that is selected
                                                    }else if(!value && state.selectedItems.includes(a)){
                                                        state.selectedItems = [];
                                                    }
                            
                                            //do not update the item itself, in the case that it was the item that sent this command
                                            //(which would cause a little loop)
                                                if(update){ itemCollection.getChildByName(a).select(true,undefined,false); }
                                            }else{
                                            //where multi selection is allowed
                                                //where range-selection is to be done
                                                    if( event != undefined && event.shiftKey ){
                                                        //gather top and bottom item
                                                        //(first gather the range positions overall, then compute those positions to indexes on the itemArray)
                                                            a = itemCollection.getChildIndexByName(a);
                            
                                                            let min = Math.min(state.lastNonShiftClicked, a);
                                                            let max = Math.max(state.lastNonShiftClicked, a);
                                                            for(let b = 0; b < itemArray.length; b++){
                                                                if( itemArray[b].name == ''+min ){min = b;}
                                                                if( itemArray[b].name == ''+max ){max = b;}
                                                            }
                            
                                                        //deselect all outside the range
                                                            state.selectedItems = [];
                                                            for(let b = 0; b < itemArray.length; b++){
                                                                if( b > max || b < min ){
                                                                    if( itemArray[b].select != undefined && itemArray[b].select() ){
                                                                        itemArray[b].select(false,undefined,false);
                                                                    }
                                                                }
                                                            }
                            
                                                        //select those within the range (that aren't already selected)
                                                            for(let b = min; b <= max; b++){
                                                                if( itemArray[b].select != undefined && !itemArray[b].select() ){
                                                                    itemArray[b].select(true,undefined,false);
                                                                    state.selectedItems.push(b);
                                                                }
                                                            }
                                                //where range-selection is not to be done
                                                    }else{
                                                        if(update){ itemArray[a].select(value); }
                                                        if(value && !state.selectedItems.includes(a) ){ state.selectedItems.push(a); }
                                                        else if(!value && state.selectedItems.includes(a)){ state.selectedItems.splice( state.selectedItems.indexOf(a), 1 ); }
                                                        state.lastNonShiftClicked = itemCollection.getChildIndexByName(a);
                                                    }
                                            }
                            
                                        object.onselection(state.selectedItems);
                                    };
                                    object.add = function(item){
                                        list.push(item);
                                        refresh();
                                    };
                                    object.getList = function(){
                                        return itemArray;
                                    };
                                    object.remove = function(a){
                                        list.splice(a,1);
                                        refresh();
                                    };
                                    object.interactable = function(bool){
                                        if(bool==undefined){return interactable;}
                                        interactable = bool;
                                        refresh();
                                    };
                                    object.heightLimit = function(value){
                                        if(value==undefined){return style.default.heightLimit;}
                                        style.default.heightLimit = value;
                                        refresh();
                                    };
                                    object.closeAllLists = function(){
                                        list.forEach((item,index) => {
                                            if(item.type != 'list'){return;}
                                            itemArray[index].close();
                                        });
                                    };
                            
                                //info
                                    object.getCalculatedListHeight = function(){return calculatedListHeight;};
                            
                                //callbacks
                                    object.onenter = onenter;
                                    object.onleave = onleave;
                                    object.onpress = onpress;
                                    object.ondblpress = ondblpress;
                                    object.onrelease = onrelease;
                                    object.onselection = onselection;
                                    object.onpositionchange = onpositionchange;
                            
                                refresh();
                            
                                return object;
                            };
                            this.list.itemTypes = {};
                            this.list.itemTypes.space = function( index, x, y, height ){
                            
                                const newItem = interfacePart.builder('basic','group',index+'_space',{x:x,y:y});
                                return {item:newItem,height:height};
                            };
                            this.list.itemTypes.break = function( index, x, y, width, height, colour, lineMux){
                            
                                const newItem = interfacePart.builder('basic','group',index+'_break',{x:x,y:y});
                                const rectangle = interfacePart.builder('basic', 'rectangle', 'rectangle', { y:(height-height*lineMux)/2, width:width, height:height*lineMux, colour:colour });
                                newItem.append(rectangle);
                            
                                return {item:newItem,height:height};
                            };
                            this.list.itemTypes.textbreak = function( index, x, y, width, height, text, fontColour, printingMode, font, spacing, interCharacterSpacing, textToLineSpacing, textHeightMux, lineMux ){
                            
                                const newItem = interfacePart.builder('basic','group',index+'_textbreak',{x:x,y:y});
                                const rectangle = interfacePart.builder('basic', 'rectangle', 'rectangle', { y:(height-height*lineMux)/2, width:width, height:height*lineMux, colour:fontColour });
                                newItem.append(rectangle);
                                const textElement = interfacePart.builder('basic','text', 'text', {
                                    y:height/2, width:height*textHeightMux, height:height*textHeightMux, 
                                    printingMode:printingMode,
                                    text:text, font:font, colour:fontColour, spacing:spacing, 
                                    interCharacterSpacing:interCharacterSpacing
                                });
                                textElement.attachCallback('onFontUpdateCallback', function(){
                                    rectangle.x( textElement.resultingWidth() + textToLineSpacing );
                                    rectangle.width( width - textElement.resultingWidth() - textToLineSpacing );
                                } );
                                newItem.append(textElement);
                            
                                return {item:newItem,height:height};
                            }
                            this.list.itemTypes.text = function( 
                                index, x, y, width, height, itemHorizontalPadding,
                                text_left, text_centre, text_right,
                                size, font, fontColour, spacing, interCharacterSpacing, itemColour
                            ){
                            
                                const newItem = interfacePart.builder('basic','group',index+'_text',{x:x,y:y});
                                const backing = interfacePart.builder('basic','rectangle','backing',{ width:width, height:height, colour:itemColour });
                                newItem.append(backing);
                            
                                if(text_left != undefined){
                                    const text = interfacePart.builder('basic','text', 'text_left', {
                                        x:itemHorizontalPadding, y:height/2, width:size, height:size, 
                                        printingMode:{widthCalculation:'absolute', horizontal:'left', vertical:'middle'},
                                        text:text_left, font:font, colour:fontColour, spacing:spacing, 
                                        interCharacterSpacing:interCharacterSpacing
                                    });
                                    newItem.append(text);
                                }
                                if(text_centre != undefined){
                                    const text = interfacePart.builder('basic','text', 'text_centre', {
                                        x:width/2, y:height/2, width:size, height:size, 
                                        printingMode:{widthCalculation:'absolute', horizontal:'middle', vertical:'middle'},
                                        text:text_centre, font:font, colour:fontColour, spacing:spacing, 
                                        interCharacterSpacing:interCharacterSpacing
                                    });
                                    newItem.append(text);
                                }
                                if(text_right != undefined){
                                    const text = interfacePart.builder('basic','text', 'text_right', {
                                        x:width-itemHorizontalPadding, y:height/2, width:size, height:size, 
                                        printingMode:{widthCalculation:'absolute', horizontal:'right', vertical:'middle'},
                                        text:text_right, font:font, colour:fontColour, spacing:spacing, 
                                        interCharacterSpacing:interCharacterSpacing
                                    });
                                    newItem.append(text);
                                }
                            
                                return {item:newItem,height:height};
                            };
                            this.list.itemTypes.checkbox = function( 
                                index, x, y, width, height, itemHorizontalPadding,
                                text_left, text_centre, text_right,
                                fontSize, font, spacing, interCharacterSpacing,
                                active, hoverable, selectable, pressable, 
                            
                                text_colour__off,
                                text_colour__up,
                                text_colour__press,
                                text_colour__select,
                                text_colour__select_press,
                                text_colour__glow,
                                text_colour__glow_press,
                                text_colour__glow_select,
                                text_colour__glow_select_press,
                                text_colour__hover,
                                text_colour__hover_press,
                                text_colour__hover_select,
                                text_colour__hover_select_press,
                                text_colour__hover_glow,
                                text_colour__hover_glow_press,
                                text_colour__hover_glow_select,
                                text_colour__hover_glow_select_press,
                            
                                item__off__colour,
                                item__off__lineColour,
                                item__off__lineThickness,
                                item__up__colour,
                                item__up__lineColour,
                                item__up__lineThickness,
                                item__press__colour,
                                item__press__lineColour,
                                item__press__lineThickness,
                                item__select__colour,
                                item__select__lineColour,
                                item__select__lineThickness,
                                item__select_press__colour,
                                item__select_press__lineColour,
                                item__select_press__lineThickness,
                                item__glow__colour,
                                item__glow__lineColour,
                                item__glow__lineThickness,
                                item__glow_press__colour,
                                item__glow_press__lineColour,
                                item__glow_press__lineThickness,
                                item__glow_select__colour,
                                item__glow_select__lineColour,
                                item__glow_select__lineThickness,
                                item__glow_select_press__colour,
                                item__glow_select_press__lineColour,
                                item__glow_select_press__lineThickness,
                                item__hover__colour,
                                item__hover__lineColour,
                                item__hover__lineThickness,
                                item__hover_press__colour,
                                item__hover_press__lineColour,
                                item__hover_press__lineThickness,
                                item__hover_select__colour,
                                item__hover_select__lineColour,
                                item__hover_select__lineThickness,
                                item__hover_select_press__colour,
                                item__hover_select_press__lineColour,
                                item__hover_select_press__lineThickness,
                                item__hover_glow__colour,
                                item__hover_glow__lineColour,
                                item__hover_glow__lineThickness,
                                item__hover_glow_press__colour,
                                item__hover_glow_press__lineColour,
                                item__hover_glow_press__lineThickness,
                                item__hover_glow_select__colour,
                                item__hover_glow_select__lineColour,
                                item__hover_glow_select__lineThickness,
                                item__hover_glow_select_press__colour,
                                item__hover_glow_select_press__lineColour,
                                item__hover_glow_select_press__lineThickness,
                            
                                updateFunction, onclickFunction,
                            ){
                            
                                const newItem = interfacePart.builder('basic','group',index+'_checkbox',{x:x,y:y});
                                    newItem.state = false;
                                const button = interfacePart.builder('control', 'button_rectangle', 'button', {
                                    width:width, height:height,
                                    text_left:text_left,
                                    text_centre:text_centre,
                                    text_right:text_right,
                            
                                    textVerticalOffsetMux:0.5, textHorizontalOffsetMux:itemHorizontalPadding/width,
                                    active:active, hoverable:hoverable, selectable:selectable, pressable:pressable,
                            
                                    style:{
                                        text_font:font,
                                        text_size:fontSize,
                                        text_spacing:spacing,
                                        text_interCharacterSpacing:interCharacterSpacing,
                            
                                        text__off__colour:                                  text_colour__off,
                                        text__up__colour:                                   text_colour__up,
                                        text__press__colour:                                text_colour__press,
                                        text__select__colour:                               text_colour__select,
                                        text__select_press__colour:                         text_colour__select_press,
                                        text__glow__colour:                                 text_colour__glow,
                                        text__glow_press__colour:                           text_colour__glow_press,
                                        text__glow_select__colour:                          text_colour__glow_select,
                                        text__glow_select_press__colour:                    text_colour__glow_select_press,
                                        text__hover__colour:                                text_colour__hover,
                                        text__hover_press__colour:                          text_colour__hover_press,
                                        text__hover_select__colour:                         text_colour__hover_select,
                                        text__hover_select_press__colour:                   text_colour__hover_select_press,
                                        text__hover_glow__colour:                           text_colour__hover_glow,
                                        text__hover_glow_press__colour:                     text_colour__hover_glow_press,
                                        text__hover_glow_select__colour:                    text_colour__hover_glow_select,
                                        text__hover_glow_select_press__colour:              text_colour__hover_glow_select_press,
                            
                                        background__off__colour:                            item__off__colour,
                                        background__off__lineColour:                        item__off__lineColour,
                                        background__off__lineThickness:                     item__off__lineThickness,
                                        background__up__colour:                             item__up__colour,
                                        background__up__lineColour:                         item__up__lineColour,
                                        background__up__lineThickness:                      item__up__lineThickness,
                                        background__press__colour:                          item__press__colour,
                                        background__press__lineColour:                      item__press__lineColour,
                                        background__press__lineThickness:                   item__press__lineThickness,
                                        background__select__colour:                         item__select__colour,
                                        background__select__lineColour:                     item__select__lineColour,
                                        background__select__lineThickness:                  item__select__lineThickness,
                                        background__select_press__colour:                   item__select_press__colour,
                                        background__select_press__lineColour:               item__select_press__lineColour,
                                        background__select_press__lineThickness:            item__select_press__lineThickness,
                                        background__glow__colour:                           item__glow__colour,
                                        background__glow__lineColour:                       item__glow__lineColour,
                                        background__glow__lineThickness:                    item__glow__lineThickness,
                                        background__glow_press__colour:                     item__glow_press__colour,
                                        background__glow_press__lineColour:                 item__glow_press__lineColour,
                                        background__glow_press__lineThickness:              item__glow_press__lineThickness,
                                        background__glow_select__colour:                    item__glow_select__colour,
                                        background__glow_select__lineColour:                item__glow_select__lineColour,
                                        background__glow_select__lineThickness:             item__glow_select__lineThickness,
                                        background__glow_select_press__colour:              item__glow_select_press__colour,
                                        background__glow_select_press__lineColour:          item__glow_select_press__lineColour,
                                        background__glow_select_press__lineThickness:       item__glow_select_press__lineThickness,
                                        background__hover__colour:                          item__hover__colour,
                                        background__hover__lineColour:                      item__hover__lineColour,
                                        background__hover__lineThickness:                   item__hover__lineThickness,
                                        background__hover_press__colour:                    item__hover_press__colour,
                                        background__hover_press__lineColour:                item__hover_press__lineColour,
                                        background__hover_press__lineThickness:             item__hover_press__lineThickness,
                                        background__hover_select__colour:                   item__hover_select__colour,
                                        background__hover_select__lineColour:               item__hover_select__lineColour,
                                        background__hover_select__lineThickness:            item__hover_select__lineThickness,
                                        background__hover_select_press__colour:             item__hover_select_press__colour,
                                        background__hover_select_press__lineColour:         item__hover_select_press__lineColour,
                                        background__hover_select_press__lineThickness:      item__hover_select_press__lineThickness,
                                        background__hover_glow__colour:                     item__hover_glow__colour,
                                        background__hover_glow__lineColour:                 item__hover_glow__lineColour,
                                        background__hover_glow__lineThickness:              item__hover_glow__lineThickness,
                                        background__hover_glow_press__colour:               item__hover_glow_press__colour,
                                        background__hover_glow_press__lineColour:           item__hover_glow_press__lineColour,
                                        background__hover_glow_press__lineThickness:        item__hover_glow_press__lineThickness,
                                        background__hover_glow_select__colour:              item__hover_glow_select__colour,
                                        background__hover_glow_select__lineColour:          item__hover_glow_select__lineColour,
                                        background__hover_glow_select__lineThickness:       item__hover_glow_select__lineThickness,
                                        background__hover_glow_select_press__colour:        item__hover_glow_select_press__colour,
                                        background__hover_glow_select_press__lineColour:    item__hover_glow_select_press__lineColour,
                                        background__hover_glow_select_press__lineThickness: item__hover_glow_select_press__lineThickness,
                                    },
                                });
                                newItem.append(button);
                                const tick = interfacePart.builder('basic', 'circle', 'tick', {
                                    x:width-height/2, y:height/2, radius:height/4, colour:{r:0,g:0,b:0,a:0},
                                });
                                newItem.append(tick);
                                    const tickState = { hovering:false, glowing:false, selected:false, pressed:false };
                                    function updateTickColour(){
                                        if(!newItem.state){ tick.colour({r:0,g:0,b:0,a:0}); return; }
                                        if(!active){ tick.colour(text_colour__off); return; }
                            
                                        const styles = [
                                            text_colour__up,
                                            text_colour__press,
                                            text_colour__select,
                                            text_colour__select_press,
                                            text_colour__glow,
                                            text_colour__glow_press,
                                            text_colour__glow_select,
                                            text_colour__glow_select_press,
                                            text_colour__hover,
                                            text_colour__hover_press,
                                            text_colour__hover_select,
                                            text_colour__hover_select_press,
                                            text_colour__hover_glow,
                                            text_colour__hover_glow_press,
                                            text_colour__hover_glow_select,
                                            text_colour__hover_glow_select_press,
                                        ];
                            
                                        if(!hoverable && tickState.hovering ){ tickState.hovering = false; }
                                        if(!selectable && tickState.selected ){ tickState.selected = false; }
                            
                                        const i = tickState.hovering*8 + tickState.glowing*4 + tickState.selected*2 + (pressable && tickState.pressed)*1;
                                        tick.colour(styles[i]);
                                    } updateTickColour();
                                    button.onenter = function(){tickState.hovering = true; updateTickColour();};
                                    button.onleave = function(){tickState.hovering = false; updateTickColour();};
                                    button.onpress = function(){tickState.pressed = true; updateTickColour();};
                                    button.onrelease = function(){tickState.pressed = false; updateTickColour();};
                                    button.onselect = function(){tickState.selected = true; updateTickColour();};
                                    button.ondeselect = function(){tickState.selected = false; updateTickColour();};
                            
                                newItem.set = function(state){
                                    newItem.state = state;
                                    updateTickColour();
                                    // tick.colour = newItem.state ? text_colour__hover : {r:0,g:0,b:0,a:0};
                                };
                            
                                button.onpressrelease = function(){
                                    newItem.set(!newItem.state);
                                    if(onclickFunction){onclickFunction(newItem.state);}
                                };
                            
                                if(updateFunction != undefined){
                                    try{ newItem.set(updateFunction()); }catch(error){ console.warn('control::list:"'+name+'":error : "updateFunction" returns error for '+index+'_checkbox'); console.warn(error); }
                                }
                            
                                return {item:newItem,height:height};
                            };
                            this.list.itemTypes.button = function(
                                index, x, y, width, height, itemHorizontalPadding, 
                                text_left, text_centre, text_right,
                                fontSize, font, spacing, interCharacterSpacing,
                                active, hoverable, selectable, pressable,
                            
                                text__off__colour,
                                text__up__colour,
                                text__press__colour,
                                text__select__colour,
                                text__select_press__colour,
                                text__glow__colour,
                                text__glow_press__colour,
                                text__glow_select__colour,
                                text__glow_select_press__colour,
                                text__hover__colour,
                                text__hover_press__colour,
                                text__hover_select__colour,
                                text__hover_select_press__colour,
                                text__hover_glow__colour,
                                text__hover_glow_press__colour,
                                text__hover_glow_select__colour,
                                text__hover_glow_select_press__colour,
                            
                                item__off__colour,
                                item__off__lineColour,
                                item__off__lineThickness,
                                item__up__colour,
                                item__up__lineColour,
                                item__up__lineThickness,
                                item__press__colour,
                                item__press__lineColour,
                                item__press__lineThickness,
                                item__select__colour,
                                item__select__lineColour,
                                item__select__lineThickness,
                                item__select_press__colour,
                                item__select_press__lineColour,
                                item__select_press__lineThickness,
                                item__glow__colour,
                                item__glow__lineColour,
                                item__glow__lineThickness,
                                item__glow_press__colour,
                                item__glow_press__lineColour,
                                item__glow_press__lineThickness,
                                item__glow_select__colour,
                                item__glow_select__lineColour,
                                item__glow_select__lineThickness,
                                item__glow_select_press__colour,
                                item__glow_select_press__lineColour,
                                item__glow_select_press__lineThickness,
                                item__hover__colour,
                                item__hover__lineColour,
                                item__hover__lineThickness,
                                item__hover_press__colour,
                                item__hover_press__lineColour,
                                item__hover_press__lineThickness,
                                item__hover_select__colour,
                                item__hover_select__lineColour,
                                item__hover_select__lineThickness,
                                item__hover_select_press__colour,
                                item__hover_select_press__lineColour,
                                item__hover_select_press__lineThickness,
                                item__hover_glow__colour,
                                item__hover_glow__lineColour,
                                item__hover_glow__lineThickness,
                                item__hover_glow_press__colour,
                                item__hover_glow_press__lineColour,
                                item__hover_glow_press__lineThickness,
                                item__hover_glow_select__colour,
                                item__hover_glow_select__lineColour,
                                item__hover_glow_select__lineThickness,
                                item__hover_glow_select_press__colour,
                                item__hover_glow_select_press__lineColour,
                                item__hover_glow_select_press__lineThickness,
                            
                                onenter,
                                onleave,
                                onpress,
                                ondblpress,
                                onrelease,
                                onselect,
                                ondeselect,
                            ){
                            
                                const button_rectangle = interfacePart.builder('control', 'button_rectangle', index+'_button', {
                                    x:x,y:y,
                                    width:width, height:height,
                                    text_left:text_left,
                                    text_centre:text_centre,
                                    text_right:text_right,
                            
                                    textVerticalOffsetMux:0.5, textHorizontalOffsetMux:itemHorizontalPadding/width,
                                    active:active, hoverable:hoverable, selectable:selectable, pressable:pressable,
                            
                                    style:{
                                        text_font:font,
                                        text_size:fontSize,
                                        text_spacing:spacing,
                                        text_interCharacterSpacing:interCharacterSpacing,
                            
                                        text__off__colour:                                  text__off__colour,
                                        text__up__colour:                                   text__up__colour,
                                        text__press__colour:                                text__press__colour,
                                        text__select__colour:                               text__select__colour,
                                        text__select_press__colour:                         text__select_press__colour,
                                        text__glow__colour:                                 text__glow__colour,
                                        text__glow_press__colour:                           text__glow_press__colour,
                                        text__glow_select__colour:                          text__glow_select__colour,
                                        text__glow_select_press__colour:                    text__glow_select_press__colour,
                                        text__hover__colour:                                text__hover__colour,
                                        text__hover_press__colour:                          text__hover_press__colour,
                                        text__hover_select__colour:                         text__hover_select__colour,
                                        text__hover_select_press__colour:                   text__hover_select_press__colour,
                                        text__hover_glow__colour:                           text__hover_glow__colour,
                                        text__hover_glow_press__colour:                     text__hover_glow_press__colour,
                                        text__hover_glow_select__colour:                    text__hover_glow_select__colour,
                                        text__hover_glow_select_press__colour:              text__hover_glow_select_press__colour,
                            
                                        background__off__colour:                            item__off__colour,
                                        background__off__lineColour:                        item__off__lineColour,
                                        background__off__lineThickness:                     item__off__lineThickness,
                                        background__up__colour:                             item__up__colour,
                                        background__up__lineColour:                         item__up__lineColour,
                                        background__up__lineThickness:                      item__up__lineThickness,
                                        background__press__colour:                          item__press__colour,
                                        background__press__lineColour:                      item__press__lineColour,
                                        background__press__lineThickness:                   item__press__lineThickness,
                                        background__select__colour:                         item__select__colour,
                                        background__select__lineColour:                     item__select__lineColour,
                                        background__select__lineThickness:                  item__select__lineThickness,
                                        background__select_press__colour:                   item__select_press__colour,
                                        background__select_press__lineColour:               item__select_press__lineColour,
                                        background__select_press__lineThickness:            item__select_press__lineThickness,
                                        background__glow__colour:                           item__glow__colour,
                                        background__glow__lineColour:                       item__glow__lineColour,
                                        background__glow__lineThickness:                    item__glow__lineThickness,
                                        background__glow_press__colour:                     item__glow_press__colour,
                                        background__glow_press__lineColour:                 item__glow_press__lineColour,
                                        background__glow_press__lineThickness:              item__glow_press__lineThickness,
                                        background__glow_select__colour:                    item__glow_select__colour,
                                        background__glow_select__lineColour:                item__glow_select__lineColour,
                                        background__glow_select__lineThickness:             item__glow_select__lineThickness,
                                        background__glow_select_press__colour:              item__glow_select_press__colour,
                                        background__glow_select_press__lineColour:          item__glow_select_press__lineColour,
                                        background__glow_select_press__lineThickness:       item__glow_select_press__lineThickness,
                                        background__hover__colour:                          item__hover__colour,
                                        background__hover__lineColour:                      item__hover__lineColour,
                                        background__hover__lineThickness:                   item__hover__lineThickness,
                                        background__hover_press__colour:                    item__hover_press__colour,
                                        background__hover_press__lineColour:                item__hover_press__lineColour,
                                        background__hover_press__lineThickness:             item__hover_press__lineThickness,
                                        background__hover_select__colour:                   item__hover_select__colour,
                                        background__hover_select__lineColour:               item__hover_select__lineColour,
                                        background__hover_select__lineThickness:            item__hover_select__lineThickness,
                                        background__hover_select_press__colour:             item__hover_select_press__colour,
                                        background__hover_select_press__lineColour:         item__hover_select_press__lineColour,
                                        background__hover_select_press__lineThickness:      item__hover_select_press__lineThickness,
                                        background__hover_glow__colour:                     item__hover_glow__colour,
                                        background__hover_glow__lineColour:                 item__hover_glow__lineColour,
                                        background__hover_glow__lineThickness:              item__hover_glow__lineThickness,
                                        background__hover_glow_press__colour:               item__hover_glow_press__colour,
                                        background__hover_glow_press__lineColour:           item__hover_glow_press__lineColour,
                                        background__hover_glow_press__lineThickness:        item__hover_glow_press__lineThickness,
                                        background__hover_glow_select__colour:              item__hover_glow_select__colour,
                                        background__hover_glow_select__lineColour:          item__hover_glow_select__lineColour,
                                        background__hover_glow_select__lineThickness:       item__hover_glow_select__lineThickness,
                                        background__hover_glow_select_press__colour:        item__hover_glow_select_press__colour,
                                        background__hover_glow_select_press__lineColour:    item__hover_glow_select_press__lineColour,
                                        background__hover_glow_select_press__lineThickness: item__hover_glow_select_press__lineThickness,
                                    },
                            
                                    onenter:onenter,
                                    onleave:onleave,
                                    onpress:onpress,
                                    ondblpress:ondblpress,
                                    onrelease:onrelease,
                                    onselect:onselect,
                                    ondeselect:ondeselect,
                                });
                            
                                return {item:button_rectangle,height:height};
                            };
                            this.list.itemTypes.radio = function(
                                subListGroup,
                                index, x, y, 
                            
                                //interal callbacks
                                    buttonClick,
                                
                                //button
                                    width, height,
                            
                                    itemHorizontalPadding, 
                                    text_left, text_centre, text_right,
                                    fontSize, font, spacing, interCharacterSpacing, arrowMux,
                                    active, hoverable, pressable,
                            
                                    text_colour__off,
                                    text_colour__up,
                                    text_colour__press,
                                    text_colour__select,
                                    text_colour__select_press,
                                    text_colour__glow,
                                    text_colour__glow_press,
                                    text_colour__glow_select,
                                    text_colour__glow_select_press,
                                    text_colour__hover,
                                    text_colour__hover_press,
                                    text_colour__hover_select,
                                    text_colour__hover_select_press,
                                    text_colour__hover_glow,
                                    text_colour__hover_glow_press,
                                    text_colour__hover_glow_select,
                                    text_colour__hover_glow_select_press,
                            
                                    item__off__colour,
                                    item__off__lineColour,
                                    item__off__lineThickness,
                                    item__up__colour,
                                    item__up__lineColour,
                                    item__up__lineThickness,
                                    item__press__colour,
                                    item__press__lineColour,
                                    item__press__lineThickness,
                                    item__select__colour,
                                    item__select__lineColour,
                                    item__select__lineThickness,
                                    item__select_press__colour,
                                    item__select_press__lineColour,
                                    item__select_press__lineThickness,
                                    item__glow__colour,
                                    item__glow__lineColour,
                                    item__glow__lineThickness,
                                    item__glow_press__colour,
                                    item__glow_press__lineColour,
                                    item__glow_press__lineThickness,
                                    item__glow_select__colour,
                                    item__glow_select__lineColour,
                                    item__glow_select__lineThickness,
                                    item__glow_select_press__colour,
                                    item__glow_select_press__lineColour,
                                    item__glow_select_press__lineThickness,
                                    item__hover__colour,
                                    item__hover__lineColour,
                                    item__hover__lineThickness,
                                    item__hover_press__colour,
                                    item__hover_press__lineColour,
                                    item__hover_press__lineThickness,
                                    item__hover_select__colour,
                                    item__hover_select__lineColour,
                                    item__hover_select__lineThickness,
                                    item__hover_select_press__colour,
                                    item__hover_select_press__lineColour,
                                    item__hover_select_press__lineThickness,
                                    item__hover_glow__colour,
                                    item__hover_glow__lineColour,
                                    item__hover_glow__lineThickness,
                                    item__hover_glow_press__colour,
                                    item__hover_glow_press__lineColour,
                                    item__hover_glow_press__lineThickness,
                                    item__hover_glow_select__colour,
                                    item__hover_glow_select__lineColour,
                                    item__hover_glow_select__lineThickness,
                                    item__hover_glow_select_press__colour,
                                    item__hover_glow_select_press__lineColour,
                                    item__hover_glow_select_press__lineThickness,
                            
                                //sub list
                                    options, 
                            
                                    itemWidth,
                                    heightLimit,
                                    widthLimit,
                                    backgroundColour,
                                    backgroundMarkingColour,
                            
                                    default_item_spacingHeight,
                            
                                    updateFunction, onclickFunction,
                            ){
                            
                                const newItem = interfacePart.builder('basic','group',index+'_list',{x:x,y:y});
                                const button = interfacePart.builder('control', 'button_rectangle', 'button', {
                                    width:width, height:height,
                                    text_left:text_left,
                                    text_centre:text_centre,
                                    text_right:text_right,
                            
                                    textVerticalOffsetMux:0.5, textHorizontalOffsetMux:itemHorizontalPadding/width,
                                    active:active, hoverable:hoverable, selectable:true, pressable:pressable,
                            
                                    style:{
                                        text_font:font,
                                        text_size:fontSize,
                                        text_spacing:spacing,
                                        text_interCharacterSpacing:interCharacterSpacing,
                            
                                        text__off__colour:                                  text_colour__off,
                                        text__up__colour:                                   text_colour__up,
                                        text__press__colour:                                text_colour__press,
                                        text__select__colour:                               text_colour__select,
                                        text__select_press__colour:                         text_colour__select_press,
                                        text__glow__colour:                                 text_colour__glow,
                                        text__glow_press__colour:                           text_colour__glow_press,
                                        text__glow_select__colour:                          text_colour__glow_select,
                                        text__glow_select_press__colour:                    text_colour__glow_select_press,
                                        text__hover__colour:                                text_colour__hover,
                                        text__hover_press__colour:                          text_colour__hover_press,
                                        text__hover_select__colour:                         text_colour__hover_select,
                                        text__hover_select_press__colour:                   text_colour__hover_select_press,
                                        text__hover_glow__colour:                           text_colour__hover_glow,
                                        text__hover_glow_press__colour:                     text_colour__hover_glow_press,
                                        text__hover_glow_select__colour:                    text_colour__hover_glow_select,
                                        text__hover_glow_select_press__colour:              text_colour__hover_glow_select_press,
                            
                                        background__off__colour:                            item__off__colour,
                                        background__off__lineColour:                        item__off__lineColour,
                                        background__off__lineThickness:                     item__off__lineThickness,
                                        background__up__colour:                             item__up__colour,
                                        background__up__lineColour:                         item__up__lineColour,
                                        background__up__lineThickness:                      item__up__lineThickness,
                                        background__press__colour:                          item__press__colour,
                                        background__press__lineColour:                      item__press__lineColour,
                                        background__press__lineThickness:                   item__press__lineThickness,
                                        background__select__colour:                         item__select__colour,
                                        background__select__lineColour:                     item__select__lineColour,
                                        background__select__lineThickness:                  item__select__lineThickness,
                                        background__select_press__colour:                   item__select_press__colour,
                                        background__select_press__lineColour:               item__select_press__lineColour,
                                        background__select_press__lineThickness:            item__select_press__lineThickness,
                                        background__glow__colour:                           item__glow__colour,
                                        background__glow__lineColour:                       item__glow__lineColour,
                                        background__glow__lineThickness:                    item__glow__lineThickness,
                                        background__glow_press__colour:                     item__glow_press__colour,
                                        background__glow_press__lineColour:                 item__glow_press__lineColour,
                                        background__glow_press__lineThickness:              item__glow_press__lineThickness,
                                        background__glow_select__colour:                    item__glow_select__colour,
                                        background__glow_select__lineColour:                item__glow_select__lineColour,
                                        background__glow_select__lineThickness:             item__glow_select__lineThickness,
                                        background__glow_select_press__colour:              item__glow_select_press__colour,
                                        background__glow_select_press__lineColour:          item__glow_select_press__lineColour,
                                        background__glow_select_press__lineThickness:       item__glow_select_press__lineThickness,
                                        background__hover__colour:                          item__hover__colour,
                                        background__hover__lineColour:                      item__hover__lineColour,
                                        background__hover__lineThickness:                   item__hover__lineThickness,
                                        background__hover_press__colour:                    item__hover_press__colour,
                                        background__hover_press__lineColour:                item__hover_press__lineColour,
                                        background__hover_press__lineThickness:             item__hover_press__lineThickness,
                                        background__hover_select__colour:                   item__hover_select__colour,
                                        background__hover_select__lineColour:               item__hover_select__lineColour,
                                        background__hover_select__lineThickness:            item__hover_select__lineThickness,
                                        background__hover_select_press__colour:             item__hover_select_press__colour,
                                        background__hover_select_press__lineColour:         item__hover_select_press__lineColour,
                                        background__hover_select_press__lineThickness:      item__hover_select_press__lineThickness,
                                        background__hover_glow__colour:                     item__hover_glow__colour,
                                        background__hover_glow__lineColour:                 item__hover_glow__lineColour,
                                        background__hover_glow__lineThickness:              item__hover_glow__lineThickness,
                                        background__hover_glow_press__colour:               item__hover_glow_press__colour,
                                        background__hover_glow_press__lineColour:           item__hover_glow_press__lineColour,
                                        background__hover_glow_press__lineThickness:        item__hover_glow_press__lineThickness,
                                        background__hover_glow_select__colour:              item__hover_glow_select__colour,
                                        background__hover_glow_select__lineColour:          item__hover_glow_select__lineColour,
                                        background__hover_glow_select__lineThickness:       item__hover_glow_select__lineThickness,
                                        background__hover_glow_select_press__colour:        item__hover_glow_select_press__colour,
                                        background__hover_glow_select_press__lineColour:    item__hover_glow_select_press__lineColour,
                                        background__hover_glow_select_press__lineThickness: item__hover_glow_select_press__lineThickness,
                                    },
                                });
                                newItem.append(button);
                                const arrow = interfacePart.builder('basic', 'polygon', 'arrow', {
                                    pointsAsXYArray:[
                                        {x:width-fontSize*arrowMux-itemHorizontalPadding,y:(height-fontSize*arrowMux)/2}, 
                                        {x:width-fontSize*arrowMux-itemHorizontalPadding,y:(height+fontSize*arrowMux)/2}, 
                                        {x:width-itemHorizontalPadding,y:height/2}
                                    ],
                                    colour:text_colour__up,
                                });
                                newItem.append(arrow);
                                    const arrowState = { hovering:false, glowing:false, selected:false, pressed:false };
                                    function updateArrowColour(){
                                        if(!active){ arrow.colour(text_colour__off); return; }
                            
                                        const styles = [
                                            text_colour__up,
                                            text_colour__press,
                                            text_colour__select,
                                            text_colour__select_press,
                                            text_colour__glow,
                                            text_colour__glow_press,
                                            text_colour__glow_select,
                                            text_colour__glow_select_press,
                                            text_colour__hover,
                                            text_colour__hover_press,
                                            text_colour__hover_select,
                                            text_colour__hover_select_press,
                                            text_colour__hover_glow,
                                            text_colour__hover_glow_press,
                                            text_colour__hover_glow_select,
                                            text_colour__hover_glow_select_press,
                                        ];
                            
                                        if(!hoverable && arrowState.hovering ){ arrowState.hovering = false; }
                            
                                        const i = arrowState.hovering*8 + arrowState.glowing*4 + arrowState.selected*2 + (pressable && arrowState.pressed)*1;
                                        arrow.colour(styles[i]);
                                    } updateArrowColour();
                                    button.onenter = function(){arrowState.hovering = true; updateArrowColour();};
                                    button.onleave = function(){arrowState.hovering = false; updateArrowColour();};
                                    button.onpress = function(){arrowState.pressed = true; updateArrowColour();};
                                    button.onrelease = function(){arrowState.pressed = false; updateArrowColour();};
                            
                                let sublist;
                            
                                function selectOption(number){
                                    sublist.getChildByName('stenciledGroup').getChildByName('itemCollection').getChildren().forEach((checkbox,index) => {
                                        if(number == index){return;}
                                        checkbox.set(false);
                                    });
                                    if(onclickFunction){onclickFunction(number);}
                                }
                            
                                newItem.open = function(yOffset){
                                    if(this.isOpen){return;}
                                    this.isOpen = true;
                                    button.select(true);
                            
                                    const list = options.map((option,index) => {
                                        return {
                                            type:'checkbox',
                                            text:option,
                                            onclickFunction:function(val){
                                                if(!val){
                                                    sublist.getChildByName('stenciledGroup').getChildByName('itemCollection').getChildren()[index].set(true);
                                                }
                                                selectOption(index);
                                            },
                                        };
                                    });
                            
                                    sublist = interfacePart.builder('control', 'list', 'list', {
                                        x:x+width, y:y+yOffset, list:list,
                            
                                        heightLimit:heightLimit,
                                        widthLimit:widthLimit,
                                        backgroundColour:backgroundColour,
                                        backgroundMarkingColour:backgroundMarkingColour,
                                    
                                        default_item_height:height,
                                        default_item_width:itemWidth!=undefined?itemWidth:width,
                                        default_item_spacingHeight:default_item_spacingHeight,
                                        default_item_horizontalPadding:itemHorizontalPadding,
                                    
                                        default_text__text:text_left,
                                        default_text__font:font,
                                        default_text__fontSize:fontSize,
                                        default_text__printingMode:undefined,
                                        default_text__spacing:spacing,
                                        default_text__interCharacterSpacing:interCharacterSpacing,
                            
                                        default_text_colour__off:text_colour__off,
                                        default_text_colour__up:text_colour__up,
                                        default_text_colour__press:text_colour__press,
                                        default_text_colour__select:text_colour__select,
                                        default_text_colour__select_press:text_colour__select_press,
                                        default_text_colour__glow:text_colour__glow,
                                        default_text_colour__glow_press:text_colour__glow_press,
                                        default_text_colour__glow_select:text_colour__glow_select,
                                        default_text_colour__glow_select_press:text_colour__glow_select_press,
                                        default_text_colour__hover:text_colour__hover,
                                        default_text_colour__hover_press:text_colour__hover_press,
                                        default_text_colour__hover_select:text_colour__hover_select,
                                        default_text_colour__hover_select_press:text_colour__hover_select_press,
                                        default_text_colour__hover_glow:text_colour__hover_glow,
                                        default_text_colour__hover_glow_press:text_colour__hover_glow_press,
                                        default_text_colour__hover_glow_select:text_colour__hover_glow_select,
                                        default_text_colour__hover_glow_select_press:text_colour__hover_glow_select_press,
                                  
                                        default_item__off__colour:item__off__colour,
                                        default_item__off__lineColour:item__off__lineColour,
                                        default_item__off__lineThickness:item__off__lineThickness,
                                        default_item__up__colour:item__up__colour,
                                        default_item__up__lineColour:item__up__lineColour,
                                        default_item__up__lineThickness:item__up__lineThickness,
                                        default_item__press__colour:item__press__colour,
                                        default_item__press__lineColour:item__press__lineColour,
                                        default_item__press__lineThickness:item__press__lineThickness,
                                        default_item__select__colour:item__select__colour,
                                        default_item__select__lineColour:item__select__lineColour,
                                        default_item__select__lineThickness:item__select__lineThickness,
                                        default_item__select_press__colour:item__select_press__colour,
                                        default_item__select_press__lineColour:item__select_press__lineColour,
                                        default_item__select_press__lineThickness:item__select_press__lineThickness,
                                        default_item__glow__colour:item__glow__colour,
                                        default_item__glow__lineColour:item__glow__lineColour,
                                        default_item__glow__lineThickness:item__glow__lineThickness,
                                        default_item__glow_press__colour:item__glow_press__colour,
                                        default_item__glow_press__lineColour:item__glow_press__lineColour,
                                        default_item__glow_press__lineThickness:item__glow_press__lineThickness,
                                        default_item__glow_select__colour:item__glow_select__colour,
                                        default_item__glow_select__lineColour:item__glow_select__lineColour,
                                        default_item__glow_select__lineThickness:item__glow_select__lineThickness,
                                        default_item__glow_select_press__colour:item__glow_select_press__colour,
                                        default_item__glow_select_press__lineColour:item__glow_select_press__lineColour,
                                        default_item__glow_select_press__lineThickness:item__glow_select_press__lineThickness,
                                        default_item__hover__colour:item__hover__colour,
                                        default_item__hover__lineColour:item__hover__lineColour,
                                        default_item__hover__lineThickness:item__hover__lineThickness,
                                        default_item__hover_press__colour:item__hover_press__colour,
                                        default_item__hover_press__lineColour:item__hover_press__lineColour,
                                        default_item__hover_press__lineThickness:item__hover_press__lineThickness,
                                        default_item__hover_select__colour:item__hover_select__colour,
                                        default_item__hover_select__lineColour:item__hover_select__lineColour,
                                        default_item__hover_select__lineThickness:item__hover_select__lineThickness,
                                        default_item__hover_select_press__colour:item__hover_select_press__colour,
                                        default_item__hover_select_press__lineColour:item__hover_select_press__lineColour,
                                        default_item__hover_select_press__lineThickness:item__hover_select_press__lineThickness,
                                        default_item__hover_glow__colour:item__hover_glow__colour,
                                        default_item__hover_glow__lineColour:item__hover_glow__lineColour,
                                        default_item__hover_glow__lineThickness:item__hover_glow__lineThickness,
                                        default_item__hover_glow_press__colour:item__hover_glow_press__colour,
                                        default_item__hover_glow_press__lineColour:item__hover_glow_press__lineColour,
                                        default_item__hover_glow_press__lineThickness:item__hover_glow_press__lineThickness,
                                        default_item__hover_glow_select__colour:item__hover_glow_select__colour,
                                        default_item__hover_glow_select__lineColour:item__hover_glow_select__lineColour,
                                        default_item__hover_glow_select__lineThickness:item__hover_glow_select__lineThickness,
                                        default_item__hover_glow_select_press__colour:item__hover_glow_select_press__colour,
                                        default_item__hover_glow_select_press__lineColour:item__hover_glow_select_press__lineColour,
                                        default_item__hover_glow_select_press__lineThickness:item__hover_glow_select_press__lineThickness,
                                    });
                                    subListGroup.append(sublist);
                            
                                    if( updateFunction ){
                                        sublist.getChildByName('stenciledGroup').getChildByName('itemCollection').getChildren()[updateFunction()].set(true);
                                    }else{
                                        sublist.getChildByName('stenciledGroup').getChildByName('itemCollection').getChildren()[0].set(true);
                                    }
                                };
                                newItem.close = function(){
                                    if(!this.isOpen){return;}
                                    this.isOpen = false;
                                    button.select(false);
                            
                                    subListGroup.remove(sublist);
                                };
                            
                                button.onselect = function(){
                                    const yOffset = buttonClick(true);
                                    newItem.open(yOffset);
                                    arrowState.selected = true; 
                                    updateArrowColour();
                                };
                                button.ondeselect = function(){
                                    buttonClick(false);
                                    newItem.close();
                                    arrowState.selected = false; 
                                    updateArrowColour();
                                };
                            
                                return {item:newItem,height:height};
                            };
                            this.list.itemTypes.list = function(
                                subListGroup,
                                index, x, y, 
                            
                                //interal callbacks
                                    buttonClick,
                                
                                //button
                                    width, height,
                            
                                    itemHorizontalPadding, 
                                    text_left, text_centre, text_right,
                                    fontSize, font, spacing, interCharacterSpacing, arrowMux,
                                    active, hoverable, pressable,
                            
                                    text_colour__off,
                                    text_colour__up,
                                    text_colour__press,
                                    text_colour__select,
                                    text_colour__select_press,
                                    text_colour__glow,
                                    text_colour__glow_press,
                                    text_colour__glow_select,
                                    text_colour__glow_select_press,
                                    text_colour__hover,
                                    text_colour__hover_press,
                                    text_colour__hover_select,
                                    text_colour__hover_select_press,
                                    text_colour__hover_glow,
                                    text_colour__hover_glow_press,
                                    text_colour__hover_glow_select,
                                    text_colour__hover_glow_select_press,
                            
                                    item__off__colour,
                                    item__off__lineColour,
                                    item__off__lineThickness,
                                    item__up__colour,
                                    item__up__lineColour,
                                    item__up__lineThickness,
                                    item__press__colour,
                                    item__press__lineColour,
                                    item__press__lineThickness,
                                    item__select__colour,
                                    item__select__lineColour,
                                    item__select__lineThickness,
                                    item__select_press__colour,
                                    item__select_press__lineColour,
                                    item__select_press__lineThickness,
                                    item__glow__colour,
                                    item__glow__lineColour,
                                    item__glow__lineThickness,
                                    item__glow_press__colour,
                                    item__glow_press__lineColour,
                                    item__glow_press__lineThickness,
                                    item__glow_select__colour,
                                    item__glow_select__lineColour,
                                    item__glow_select__lineThickness,
                                    item__glow_select_press__colour,
                                    item__glow_select_press__lineColour,
                                    item__glow_select_press__lineThickness,
                                    item__hover__colour,
                                    item__hover__lineColour,
                                    item__hover__lineThickness,
                                    item__hover_press__colour,
                                    item__hover_press__lineColour,
                                    item__hover_press__lineThickness,
                                    item__hover_select__colour,
                                    item__hover_select__lineColour,
                                    item__hover_select__lineThickness,
                                    item__hover_select_press__colour,
                                    item__hover_select_press__lineColour,
                                    item__hover_select_press__lineThickness,
                                    item__hover_glow__colour,
                                    item__hover_glow__lineColour,
                                    item__hover_glow__lineThickness,
                                    item__hover_glow_press__colour,
                                    item__hover_glow_press__lineColour,
                                    item__hover_glow_press__lineThickness,
                                    item__hover_glow_select__colour,
                                    item__hover_glow_select__lineColour,
                                    item__hover_glow_select__lineThickness,
                                    item__hover_glow_select_press__colour,
                                    item__hover_glow_select_press__lineColour,
                                    item__hover_glow_select_press__lineThickness,
                            
                                //sub list
                                    list, 
                                    interactable,
                            
                                    itemWidth,
                                    heightLimit,
                                    widthLimit,
                                    backgroundColour,
                                    backgroundMarkingColour,
                            
                                    default_item_spacingHeight,
                            
                                    space_height,
                                    break_height,
                                    break_lineMux,
                                    textBreak_height,
                                    textBreak_textToLineSpacing,
                                    textBreak_textHeightMux,
                                    textBreak_lineMux,
                            
                                    onenter,
                                    onleave,
                                    onpress,
                                    ondblpress,
                                    onrelease,
                                    onselection,
                                    onpositionchange,
                            ){
                            
                                const newItem = interfacePart.builder('basic','group',index+'_list',{x:x,y:y});
                                const button = interfacePart.builder('control', 'button_rectangle', 'button', {
                                    width:width, height:height,
                                    text_left:text_left,
                                    text_centre:text_centre,
                                    text_right:text_right,
                            
                                    textVerticalOffsetMux:0.5, textHorizontalOffsetMux:itemHorizontalPadding/width,
                                    active:active, hoverable:hoverable, selectable:true, pressable:pressable,
                            
                                    style:{
                                        text_font:font,
                                        text_size:fontSize,
                                        text_spacing:spacing,
                                        text_interCharacterSpacing:interCharacterSpacing,
                            
                                        text__off__colour:                                  text_colour__off,
                                        text__up__colour:                                   text_colour__up,
                                        text__press__colour:                                text_colour__press,
                                        text__select__colour:                               text_colour__select,
                                        text__select_press__colour:                         text_colour__select_press,
                                        text__glow__colour:                                 text_colour__glow,
                                        text__glow_press__colour:                           text_colour__glow_press,
                                        text__glow_select__colour:                          text_colour__glow_select,
                                        text__glow_select_press__colour:                    text_colour__glow_select_press,
                                        text__hover__colour:                                text_colour__hover,
                                        text__hover_press__colour:                          text_colour__hover_press,
                                        text__hover_select__colour:                         text_colour__hover_select,
                                        text__hover_select_press__colour:                   text_colour__hover_select_press,
                                        text__hover_glow__colour:                           text_colour__hover_glow,
                                        text__hover_glow_press__colour:                     text_colour__hover_glow_press,
                                        text__hover_glow_select__colour:                    text_colour__hover_glow_select,
                                        text__hover_glow_select_press__colour:              text_colour__hover_glow_select_press,
                            
                                        background__off__colour:                            item__off__colour,
                                        background__off__lineColour:                        item__off__lineColour,
                                        background__off__lineThickness:                     item__off__lineThickness,
                                        background__up__colour:                             item__up__colour,
                                        background__up__lineColour:                         item__up__lineColour,
                                        background__up__lineThickness:                      item__up__lineThickness,
                                        background__press__colour:                          item__press__colour,
                                        background__press__lineColour:                      item__press__lineColour,
                                        background__press__lineThickness:                   item__press__lineThickness,
                                        background__select__colour:                         item__select__colour,
                                        background__select__lineColour:                     item__select__lineColour,
                                        background__select__lineThickness:                  item__select__lineThickness,
                                        background__select_press__colour:                   item__select_press__colour,
                                        background__select_press__lineColour:               item__select_press__lineColour,
                                        background__select_press__lineThickness:            item__select_press__lineThickness,
                                        background__glow__colour:                           item__glow__colour,
                                        background__glow__lineColour:                       item__glow__lineColour,
                                        background__glow__lineThickness:                    item__glow__lineThickness,
                                        background__glow_press__colour:                     item__glow_press__colour,
                                        background__glow_press__lineColour:                 item__glow_press__lineColour,
                                        background__glow_press__lineThickness:              item__glow_press__lineThickness,
                                        background__glow_select__colour:                    item__glow_select__colour,
                                        background__glow_select__lineColour:                item__glow_select__lineColour,
                                        background__glow_select__lineThickness:             item__glow_select__lineThickness,
                                        background__glow_select_press__colour:              item__glow_select_press__colour,
                                        background__glow_select_press__lineColour:          item__glow_select_press__lineColour,
                                        background__glow_select_press__lineThickness:       item__glow_select_press__lineThickness,
                                        background__hover__colour:                          item__hover__colour,
                                        background__hover__lineColour:                      item__hover__lineColour,
                                        background__hover__lineThickness:                   item__hover__lineThickness,
                                        background__hover_press__colour:                    item__hover_press__colour,
                                        background__hover_press__lineColour:                item__hover_press__lineColour,
                                        background__hover_press__lineThickness:             item__hover_press__lineThickness,
                                        background__hover_select__colour:                   item__hover_select__colour,
                                        background__hover_select__lineColour:               item__hover_select__lineColour,
                                        background__hover_select__lineThickness:            item__hover_select__lineThickness,
                                        background__hover_select_press__colour:             item__hover_select_press__colour,
                                        background__hover_select_press__lineColour:         item__hover_select_press__lineColour,
                                        background__hover_select_press__lineThickness:      item__hover_select_press__lineThickness,
                                        background__hover_glow__colour:                     item__hover_glow__colour,
                                        background__hover_glow__lineColour:                 item__hover_glow__lineColour,
                                        background__hover_glow__lineThickness:              item__hover_glow__lineThickness,
                                        background__hover_glow_press__colour:               item__hover_glow_press__colour,
                                        background__hover_glow_press__lineColour:           item__hover_glow_press__lineColour,
                                        background__hover_glow_press__lineThickness:        item__hover_glow_press__lineThickness,
                                        background__hover_glow_select__colour:              item__hover_glow_select__colour,
                                        background__hover_glow_select__lineColour:          item__hover_glow_select__lineColour,
                                        background__hover_glow_select__lineThickness:       item__hover_glow_select__lineThickness,
                                        background__hover_glow_select_press__colour:        item__hover_glow_select_press__colour,
                                        background__hover_glow_select_press__lineColour:    item__hover_glow_select_press__lineColour,
                                        background__hover_glow_select_press__lineThickness: item__hover_glow_select_press__lineThickness,
                                    },
                                });
                                newItem.append(button);
                                const arrow = interfacePart.builder('basic', 'polygon', 'arrow', {
                                    pointsAsXYArray:[ 
                                        {x:width-fontSize*arrowMux-itemHorizontalPadding,y:(height-fontSize*arrowMux)/2}, 
                                        {x:width-fontSize*arrowMux-itemHorizontalPadding,y:(height+fontSize*arrowMux)/2}, 
                                        {x:width-itemHorizontalPadding,y:height/2}
                                    ],
                                    colour:text_colour__up,
                                });
                                newItem.append(arrow);
                                    const arrowState = { hovering:false, glowing:false, selected:false, pressed:false };
                                    function updateArrowColour(){
                                        if(!active){ arrow.colour(text_colour__off); return; }
                            
                                        const styles = [
                                            text_colour__up,
                                            text_colour__press,
                                            text_colour__select,
                                            text_colour__select_press,
                                            text_colour__glow,
                                            text_colour__glow_press,
                                            text_colour__glow_select,
                                            text_colour__glow_select_press,
                                            text_colour__hover,
                                            text_colour__hover_press,
                                            text_colour__hover_select,
                                            text_colour__hover_select_press,
                                            text_colour__hover_glow,
                                            text_colour__hover_glow_press,
                                            text_colour__hover_glow_select,
                                            text_colour__hover_glow_select_press,
                                        ];
                            
                                        if(!hoverable && arrowState.hovering ){ arrowState.hovering = false; }
                            
                                        const i = arrowState.hovering*8 + arrowState.glowing*4 + arrowState.selected*2 + (pressable && arrowState.pressed)*1;
                                        arrow.colour(styles[i]);
                                    } updateArrowColour();
                                    button.onenter = function(){arrowState.hovering = true; updateArrowColour();};
                                    button.onleave = function(){arrowState.hovering = false; updateArrowColour();};
                                    button.onpress = function(){arrowState.pressed = true; updateArrowColour();};
                                    button.onrelease = function(){arrowState.pressed = false; updateArrowColour();};
                            
                                let sublist;
                            
                                newItem.open = function(yOffset){
                                    if(this.isOpen){return;}
                                    this.isOpen = true;
                                    button.select(true);
                            
                                    sublist = interfacePart.builder('control', 'list', 'list', {
                                        x:x+width, y:y+yOffset, interactable:interactable, list:list,
                            
                                        heightLimit:heightLimit,
                                        widthLimit:widthLimit,
                                        backgroundColour:backgroundColour,
                                        backgroundMarkingColour:backgroundMarkingColour,
                                    
                                        default_item_height:height,
                                        default_item_width:itemWidth!=undefined?itemWidth:width,
                                        default_item_spacingHeight:default_item_spacingHeight,
                                        default_item_horizontalPadding:itemHorizontalPadding,
                                    
                                        default_text__text:text_left,
                                        default_text__font:font,
                                        default_text__fontSize:fontSize,
                                        default_text__printingMode:undefined,
                                        default_text__spacing:spacing,
                                        default_text__interCharacterSpacing:interCharacterSpacing,
                            
                                        default_text_colour__off:text_colour__off,
                                        default_text_colour__up:text_colour__up,
                                        default_text_colour__press:text_colour__press,
                                        default_text_colour__select:text_colour__select,
                                        default_text_colour__select_press:text_colour__select_press,
                                        default_text_colour__glow:text_colour__glow,
                                        default_text_colour__glow_press:text_colour__glow_press,
                                        default_text_colour__glow_select:text_colour__glow_select,
                                        default_text_colour__glow_select_press:text_colour__glow_select_press,
                                        default_text_colour__hover:text_colour__hover,
                                        default_text_colour__hover_press:text_colour__hover_press,
                                        default_text_colour__hover_select:text_colour__hover_select,
                                        default_text_colour__hover_select_press:text_colour__hover_select_press,
                                        default_text_colour__hover_glow:text_colour__hover_glow,
                                        default_text_colour__hover_glow_press:text_colour__hover_glow_press,
                                        default_text_colour__hover_glow_select:text_colour__hover_glow_select,
                                        default_text_colour__hover_glow_select_press:text_colour__hover_glow_select_press,
                                  
                                        default_item__off__colour:item__off__colour,
                                        default_item__off__lineColour:item__off__lineColour,
                                        default_item__off__lineThickness:item__off__lineThickness,
                                        default_item__up__colour:item__up__colour,
                                        default_item__up__lineColour:item__up__lineColour,
                                        default_item__up__lineThickness:item__up__lineThickness,
                                        default_item__press__colour:item__press__colour,
                                        default_item__press__lineColour:item__press__lineColour,
                                        default_item__press__lineThickness:item__press__lineThickness,
                                        default_item__select__colour:item__select__colour,
                                        default_item__select__lineColour:item__select__lineColour,
                                        default_item__select__lineThickness:item__select__lineThickness,
                                        default_item__select_press__colour:item__select_press__colour,
                                        default_item__select_press__lineColour:item__select_press__lineColour,
                                        default_item__select_press__lineThickness:item__select_press__lineThickness,
                                        default_item__glow__colour:item__glow__colour,
                                        default_item__glow__lineColour:item__glow__lineColour,
                                        default_item__glow__lineThickness:item__glow__lineThickness,
                                        default_item__glow_press__colour:item__glow_press__colour,
                                        default_item__glow_press__lineColour:item__glow_press__lineColour,
                                        default_item__glow_press__lineThickness:item__glow_press__lineThickness,
                                        default_item__glow_select__colour:item__glow_select__colour,
                                        default_item__glow_select__lineColour:item__glow_select__lineColour,
                                        default_item__glow_select__lineThickness:item__glow_select__lineThickness,
                                        default_item__glow_select_press__colour:item__glow_select_press__colour,
                                        default_item__glow_select_press__lineColour:item__glow_select_press__lineColour,
                                        default_item__glow_select_press__lineThickness:item__glow_select_press__lineThickness,
                                        default_item__hover__colour:item__hover__colour,
                                        default_item__hover__lineColour:item__hover__lineColour,
                                        default_item__hover__lineThickness:item__hover__lineThickness,
                                        default_item__hover_press__colour:item__hover_press__colour,
                                        default_item__hover_press__lineColour:item__hover_press__lineColour,
                                        default_item__hover_press__lineThickness:item__hover_press__lineThickness,
                                        default_item__hover_select__colour:item__hover_select__colour,
                                        default_item__hover_select__lineColour:item__hover_select__lineColour,
                                        default_item__hover_select__lineThickness:item__hover_select__lineThickness,
                                        default_item__hover_select_press__colour:item__hover_select_press__colour,
                                        default_item__hover_select_press__lineColour:item__hover_select_press__lineColour,
                                        default_item__hover_select_press__lineThickness:item__hover_select_press__lineThickness,
                                        default_item__hover_glow__colour:item__hover_glow__colour,
                                        default_item__hover_glow__lineColour:item__hover_glow__lineColour,
                                        default_item__hover_glow__lineThickness:item__hover_glow__lineThickness,
                                        default_item__hover_glow_press__colour:item__hover_glow_press__colour,
                                        default_item__hover_glow_press__lineColour:item__hover_glow_press__lineColour,
                                        default_item__hover_glow_press__lineThickness:item__hover_glow_press__lineThickness,
                                        default_item__hover_glow_select__colour:item__hover_glow_select__colour,
                                        default_item__hover_glow_select__lineColour:item__hover_glow_select__lineColour,
                                        default_item__hover_glow_select__lineThickness:item__hover_glow_select__lineThickness,
                                        default_item__hover_glow_select_press__colour:item__hover_glow_select_press__colour,
                                        default_item__hover_glow_select_press__lineColour:item__hover_glow_select_press__lineColour,
                                        default_item__hover_glow_select_press__lineThickness:item__hover_glow_select_press__lineThickness,
                                    
                                        subList_arrowMux:arrowMux,
                                        space_height:space_height,
                                        break_height:break_height,
                                        break_lineMux:break_lineMux,
                                        textBreak_height:textBreak_height,
                                        textBreak_textToLineSpacing:textBreak_textToLineSpacing,
                                        textBreak_textHeightMux:textBreak_textHeightMux,
                                        textBreak_lineMux:textBreak_lineMux,
                            
                                        onenter:onenter,
                                        onleave:onleave,
                                        onpress:onpress,
                                        ondblpress:ondblpress,
                                        onrelease:onrelease,
                                        onselection:onselection,
                                        onpositionchange:onpositionchange,
                                    });
                                    subListGroup.append(sublist);
                                };
                                newItem.close = function(){
                                    if(!this.isOpen){return;}
                                    this.isOpen = false;
                                    button.select(false);
                            
                                    subListGroup.remove(sublist);
                                };
                            
                                button.onselect = function(){
                                    const yOffset = buttonClick(true);
                                    newItem.open(yOffset);
                                    arrowState.selected = true; 
                                    updateArrowColour();
                                };
                                button.ondeselect = function(){
                                    buttonClick(false);
                                    newItem.close();
                                    arrowState.selected = false; 
                                    updateArrowColour();
                                };
                            
                                return {item:newItem,height:height};
                            };
                            
                            interfacePart.partLibrary.control.list = function(name,data){ 
                                return interfacePart.collection.control.list(
                                    name, data.x, data.y, data.angle, data.interactable, data.list,
                            
                                    data.active, data.multiSelect, data.hoverable, data.selectable, data.pressable,
                                
                                    data.heightLimit,
                                    data.widthLimit,
                                    data.backgroundColour,
                                    data.backgroundMarkingColour,
                                
                                    data.default_item_height,
                                    data.default_item_width,
                                    data.default_item_spacingHeight,
                                    data.default_item_horizontalPadding,
                                
                                    data.default_text__text,
                                    data.default_text__font,
                                    data.default_text__fontSize,
                                    data.default_text__printingMode,
                                    data.default_text__spacing,
                                    data.default_text__interCharacterSpacing,
                            
                                    data.default_text_colour__off,
                                    data.default_text_colour__up,
                                    data.default_text_colour__press,
                                    data.default_text_colour__select,
                                    data.default_text_colour__select_press,
                                    data.default_text_colour__glow,
                                    data.default_text_colour__glow_press,
                                    data.default_text_colour__glow_select,
                                    data.default_text_colour__glow_select_press,
                                    data.default_text_colour__hover,
                                    data.default_text_colour__hover_press,
                                    data.default_text_colour__hover_select,
                                    data.default_text_colour__hover_select_press,
                                    data.default_text_colour__hover_glow,
                                    data.default_text_colour__hover_glow_press,
                                    data.default_text_colour__hover_glow_select,
                                    data.default_text_colour__hover_glow_select_press,
                                
                                    data.default_item__off__colour,
                                    data.default_item__off__lineColour,
                                    data.default_item__off__lineThickness,
                                    data.default_item__up__colour,
                                    data.default_item__up__lineColour,
                                    data.default_item__up__lineThickness,
                                    data.default_item__press__colour,
                                    data.default_item__press__lineColour,
                                    data.default_item__press__lineThickness,
                                    data.default_item__select__colour,
                                    data.default_item__select__lineColour,
                                    data.default_item__select__lineThickness,
                                    data.default_item__select_press__colour,
                                    data.default_item__select_press__lineColour,
                                    data.default_item__select_press__lineThickness,
                                    data.default_item__glow__colour,
                                    data.default_item__glow__lineColour,
                                    data.default_item__glow__lineThickness,
                                    data.default_item__glow_press__colour,
                                    data.default_item__glow_press__lineColour,
                                    data.default_item__glow_press__lineThickness,
                                    data.default_item__glow_select__colour,
                                    data.default_item__glow_select__lineColour,
                                    data.default_item__glow_select__lineThickness,
                                    data.default_item__glow_select_press__colour,
                                    data.default_item__glow_select_press__lineColour,
                                    data.default_item__glow_select_press__lineThickness,
                                    data.default_item__hover__colour,
                                    data.default_item__hover__lineColour,
                                    data.default_item__hover__lineThickness,
                                    data.default_item__hover_press__colour,
                                    data.default_item__hover_press__lineColour,
                                    data.default_item__hover_press__lineThickness,
                                    data.default_item__hover_select__colour,
                                    data.default_item__hover_select__lineColour,
                                    data.default_item__hover_select__lineThickness,
                                    data.default_item__hover_select_press__colour,
                                    data.default_item__hover_select_press__lineColour,
                                    data.default_item__hover_select_press__lineThickness,
                                    data.default_item__hover_glow__colour,
                                    data.default_item__hover_glow__lineColour,
                                    data.default_item__hover_glow__lineThickness,
                                    data.default_item__hover_glow_press__colour,
                                    data.default_item__hover_glow_press__lineColour,
                                    data.default_item__hover_glow_press__lineThickness,
                                    data.default_item__hover_glow_select__colour,
                                    data.default_item__hover_glow_select__lineColour,
                                    data.default_item__hover_glow_select__lineThickness,
                                    data.default_item__hover_glow_select_press__colour,
                                    data.default_item__hover_glow_select_press__lineColour,
                                    data.default_item__hover_glow_select_press__lineThickness,
                                
                                    data.subList_arrowMux,
                                    data.space_height,
                                    data.break_height,
                                    data.break_lineMux,
                                    data.textBreak_height,
                                    data.textBreak_textToLineSpacing,
                                    data.textBreak_textHeightMux,
                                    data.textBreak_lineMux,
                                
                                    data.onenter,
                                    data.onleave,
                                    data.onpress,
                                    data.ondblpress,
                                    data.onrelease,
                                    data.onselection,
                                    data.onpositionchange,
                                );
                            };
                            this.sequencer = function(
                                name='sequencer',
                                x, y, width=300, height=100, angle=0, interactable=true,
                                
                                xCount=64, yCount=16,
                                zoomLevel_x=1/1, zoomLevel_y=1/1,
                            
                                backingStyle={r:20/255,g:20/255,b:20/255,a:1},
                                selectionAreaStyle={r:209/255,g:189/255,b:222/255,a:0.5},
                            
                                signalStyle_body=[
                                    {colour:{r:138/255,g:138/255,b:138/255,a:0.6}, lineColour:{r:175/255,g:175/255,b:175/255,a:0.95}, lineThickness:0.5},
                                    {colour:{r:130/255,g:199/255,b:208/255,a:0.6}, lineColour:{r:130/255,g:199/255,b:208/255,a:0.95}, lineThickness:0.5},
                                    {colour:{r:129/255,g:209/255,b:173/255,a:0.6}, lineColour:{r:129/255,g:209/255,b:173/255,a:0.95}, lineThickness:0.5},
                                    {colour:{r:234/255,g:238/255,b:110/255,a:0.6}, lineColour:{r:234/255,g:238/255,b:110/255,a:0.95}, lineThickness:0.5},
                                    {colour:{r:249/255,g:178/255,b:103/255,a:0.6}, lineColour:{r:249/255,g:178/255,b:103/255,a:0.95}, lineThickness:0.5},
                                    {colour:{r:255/255,g: 69/255,b: 69/255,a:0.6}, lineColour:{r:255/255,g: 69/255,b: 69/255,a:0.95}, lineThickness:0.5},
                                ],
                                signalStyle_bodyGlow=[
                                    {colour:{r:138/255,g:138/255,b:138/255,a:0.8}, lineColour:{r:175/255,g:175/255,b:175/255,a:1}, lineThickness:0.5},
                                    {colour:{r:130/255,g:199/255,b:208/255,a:0.8}, lineColour:{r:130/255,g:199/255,b:208/255,a:1}, lineThickness:0.5},
                                    {colour:{r:129/255,g:209/255,b:173/255,a:0.8}, lineColour:{r:129/255,g:209/255,b:173/255,a:1}, lineThickness:0.5},
                                    {colour:{r:234/255,g:238/255,b:110/255,a:0.8}, lineColour:{r:234/255,g:238/255,b:110/255,a:1}, lineThickness:0.5},
                                    {colour:{r:249/255,g:178/255,b:103/255,a:0.8}, lineColour:{r:249/255,g:178/255,b:103/255,a:1}, lineThickness:0.5},
                                    {colour:{r:255/255,g: 69/255,b: 69/255,a:0.8}, lineColour:{r:255/255,g: 69/255,b: 69/255,a:1}, lineThickness:0.5},
                                ],    
                                signalStyle_handle={r:200/255,g:0/255,b:0/255,a:0},
                                signalStyle_handleWidth=3,
                            
                                horizontalStripStyle_pattern=[0,1],
                                horizontalStripStyle_glow={colour:{r:120/255,g:120/255,b:120/255,a:0.8}, lineColour:{r:120/255,g:120/255,b:120/255,a:1}, lineThickness:0.5},
                                horizontalStripStyle_styles=[
                                    {colour:{r:120/255,g:120/255,b:120/255,a:0.5}, lineColour:{r:120/255,g:120/255,b:120/255,a:1}, lineThickness:0.5},
                                    {colour:{r:100/255,g:100/255,b:100/255,a:0.0}, lineColour:{r:120/255,g:120/255,b:120/255,a:1}, lineThickness:0.5},
                                ],
                                verticalStripStyle_pattern=[0],
                                verticalStripStyle_glow={colour:{r:229/255,g: 221/255,b: 112/255,a:0.25}, lineColour:{r:252/255,g:244/255,b:128/255,a:0.5}, lineThickness:0.5},
                                verticalStripStyle_styles=[
                                    {colour:{r:30/255,g:30/255,b:30/255,a:0.5}, lineColour:{r:120/255,g:120/255,b:120/255,a:1}, lineThickness:0.5},
                                ],
                            
                                playheadStyle={r:240/255,g: 240/255,b: 240/255, a:1},
                            
                                onpan=function(data){},
                                onchangeviewarea=function(data){},
                                event=function(events){},
                            ){
                            
                                const self = this;
                            
                                //settings
                                    const viewport = {
                                        totalSize:{
                                            width:  width/zoomLevel_x,
                                            height: height/zoomLevel_y,
                                        },
                                        viewposition: {x:0,y:0},
                                        viewArea:{
                                            topLeft:     {x:0, y:0},
                                            bottomRight: {x:zoomLevel_x, y:zoomLevel_y},
                                        }
                                    };
                                    const signals = {
                                        step:1/1,
                                        snapping: true,
                                        defaultStrength: 0.5,
                                        selectedSignals: [],
                                        activeSignals: [],
                                        signalRegistry: new _canvas_.library.structure.signalRegistry(xCount,yCount),
                                    };
                                    const loop = {
                                        active:false, 
                                        period:{
                                            start:0, 
                                            end:xCount
                                        },
                                    };
                                    const playhead = {
                                        present:false,
                                        width:0.75,
                                        invisibleHandleMux:4,
                                        position:-1,
                                        held:false,
                                        automoveViewposition:false,
                                    };
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    //static backing
                                        const backing = interfacePart.builder('basic','rectangle','backing',{width:width, height:height, colour:backingStyle});
                                        object.append(backing);
                                    //viewport stencil
                                        const stencil = interfacePart.builder('basic','rectangle','stencil',{width:width, height:height});
                                        object.stencil(stencil);
                                        object.clipActive(true);
                            
                                    //workarea
                                        const workarea = interfacePart.builder('basic','group','workarea');
                                        object.append(workarea);
                                        //moveable background
                                            const backgroundDrawArea = interfacePart.builder('basic','group','backgroundDrawArea');
                                            workarea.append(backgroundDrawArea);
                                            const backgroundDrawArea_horizontal = interfacePart.builder('basic','group','backgroundDrawArea_horizontal');
                                            backgroundDrawArea_horizontal.stopAttributeStartedExtremityUpdate = true;
                                            backgroundDrawArea.append(backgroundDrawArea_horizontal);
                                            const backgroundDrawArea_vertical = interfacePart.builder('basic','group','backgroundDrawArea_vertical');
                                            backgroundDrawArea_vertical.stopAttributeStartedExtremityUpdate = true;
                                            backgroundDrawArea.append(backgroundDrawArea_vertical);
                                        //interaction pane back
                                            const interactionPlane_back = interfacePart.builder('basic','rectangle','interactionPlane_back',{width:viewport.totalSize.width, height:viewport.totalSize.height, colour:{r:1,g:0,b:0,a:0}});
                                            workarea.append(interactionPlane_back);
                                            interactionPlane_back.onwheel = function(){};
                                        //signal block area
                                            const signalPane = interfacePart.builder('basic','group','signalPane');
                                            workarea.append(signalPane);
                                        //interaction pane front
                                            const interactionPlane_front = interfacePart.builder('basic','rectangle','interactionPlane_front',{width:viewport.totalSize.width, height:viewport.totalSize.height, colour:{r:0,g:0,b:0,a:0}});
                                            workarea.append(interactionPlane_front);
                                            interactionPlane_front.onwheel = function(){};
                                //internal
                                    object.__calculationAngle = angle;
                                    function currentMousePosition(x,y){
                                        const offset = object.getOffset();
                                        const delta = {
                                            x: x - (backing.x()     + offset.x),
                                            y: y - (backing.y()     + offset.y),
                                            a: 0 - (backing.angle() + offset.angle),
                                        };
                                        const d = _canvas_.library.math.cartesianAngleAdjust( delta.x/offset.scale, delta.y/offset.scale, delta.a );
                            
                                        return { x:d.x/backing.width(), y:d.y/backing.height() };
                                    }
                                    function viewportPosition2internalPosition(xy){
                                        return {x: viewport.viewArea.topLeft.x + xy.x*zoomLevel_x, y:viewport.viewArea.topLeft.y + xy.y*zoomLevel_y};
                                    }
                                    function visible2coordinates(xy){
                                        return {
                                            x: zoomLevel_x*(xy.x - viewport.viewposition.x) + viewport.viewposition.x,
                                            y: zoomLevel_y*(xy.y - viewport.viewposition.y) + viewport.viewposition.y,
                                        };
                                    }
                                    function coordinates2lineposition(xy){
                                        xy.y = Math.floor(xy.y*yCount);
                                        if(xy.y >= yCount){xy.y = yCount-1;}
                                    
                                        xy.x = signals.snapping ? Math.round((xy.x*xCount)/signals.step)*signals.step : xy.x*xCount;
                                        if(xy.x < 0){xy.x =0;}
                                    
                                        return {line:xy.y, position:xy.x};
                                    }
                                    function drawBackground(){
                                        //horizontal strips
                                            backgroundDrawArea_horizontal.clear();
                                            for(let a = 0; a < yCount; a++){
                                                const style = horizontalStripStyle_styles[horizontalStripStyle_pattern[a%horizontalStripStyle_pattern.length]];
                                                const tmp = interfacePart.builder('basic','rectangleWithOutline', 'strip_horizontal_'+a,
                                                    {
                                                        x:0, y:a*(height/(yCount*zoomLevel_y)),
                                                        width:viewport.totalSize.width, height:height/(yCount*zoomLevel_y),
                                                        colour:style.colour, lineColour:style.lineColour, thickness:style.lineThickness,
                                                    }
                                                );
                                                tmp.stopAttributeStartedExtremityUpdate = true;
                                                backgroundDrawArea_horizontal.append(tmp);
                                            }
                            
                                        //vertical strips
                                            backgroundDrawArea_vertical.clear();
                                            for(let a = 0; a < xCount; a++){
                                                const style = verticalStripStyle_styles[verticalStripStyle_pattern[a%verticalStripStyle_pattern.length]];
                                                const tmp = interfacePart.builder('basic','rectangleWithOutline', 'strip_vertical_'+a,
                                                    {
                                                        x:a*(width/(xCount*zoomLevel_x)), y:0,
                                                        width:width/(xCount*zoomLevel_x), height:viewport.totalSize.height,
                                                        colour:style.colour, lineColour:style.lineColour, thickness:style.lineThickness,
                                                    }
                                                );
                                                tmp.stopAttributeStartedExtremityUpdate = true;
                                                backgroundDrawArea_vertical.append(tmp);
                                            }
                                    }
                                    function setViewposition(x,y,update=true){
                                        if(x == undefined && y == undefined){return viewport.viewposition;}
                                        if(x == undefined || isNaN(x)){ x = viewport.viewposition.x; }
                                        if(y == undefined || isNaN(y)){ y = viewport.viewposition.y; }
                            
                                        //make sure things are between 0 and 1
                                            x = x<0?0:x; x = x>1?1:x;
                                            y = y<0?0:y; y = y>1?1:y;
                            
                                        //perform transform
                                            viewport.viewposition.x = x;
                                            viewport.viewposition.y = y;
                                            workarea.x( -viewport.viewposition.x*(viewport.totalSize.width - width) );
                                            workarea.y( -viewport.viewposition.y*(viewport.totalSize.height - height) );
                            
                                        //update viewport.viewArea
                                            viewport.viewArea = {
                                                topLeft:     { x:x - zoomLevel_x*x,     y:y - zoomLevel_y*y     },
                                                bottomRight: { x:x + zoomLevel_x*(1-x), y:y + zoomLevel_y*(1-y) },
                                            };
                            
                                        //callback
                                            if(update){
                                                object.onpan(viewport.viewArea);
                                            }
                                    }
                                    function adjustZoom(x,y){
                                        
                                        if(x == undefined && y == undefined){return {x:zoomLevel_x, y:zoomLevel_y};}
                                        const maxZoom = 0.01;
                            
                                        //(in a bid for speed, I've written the following code in an odd way, so that if both x and y scales are being changed, then
                                        //all the elements will be adjusted together (instead of having to repeat resizings of shapes))
                                        if(x != undefined && x != zoomLevel_x && y != undefined && y != zoomLevel_y ){
                                            //make sure things are between 0.01 and 1
                                                x = x<maxZoom?maxZoom:x; x = x>1?1:x;
                                                y = y<maxZoom?maxZoom:y; y = y>1?1:y;
                            
                                            //update state
                                                zoomLevel_x = x;
                                                zoomLevel_y = y;
                                                viewport.totalSize.width = width/zoomLevel_x;
                                                viewport.totalSize.height = height/zoomLevel_y;
                            
                                            //update interactionPlane_back
                                                interactionPlane_back.width( viewport.totalSize.width );
                                                interactionPlane_back.height( viewport.totalSize.height );
                            
                                            //update interactionPlane_front
                                                interactionPlane_front.width( viewport.totalSize.width );
                                                interactionPlane_front.height( viewport.totalSize.height );
                            
                                            //update background strips
                                                backgroundDrawArea_vertical.getChildren().forEach(function(item,index){
                                                    item.x( index*(width/(xCount*zoomLevel_x)) );
                                                    item.width( width/(xCount*zoomLevel_x) );
                                                    item.height( viewport.totalSize.height );
                                                });
                                                backgroundDrawArea_horizontal.getChildren().forEach(function(item,index){
                                                    item.y( index*(height/(yCount*zoomLevel_y)) );
                                                    item.height( height/(yCount*zoomLevel_y) );
                                                    item.width( viewport.totalSize.width );
                                                });
                            
                                            //update signals
                                                signalPane.getChildren().forEach( item => item.unit(width/(xCount*zoomLevel_x), height/(yCount*zoomLevel_y)) );
                            
                                            //update playhead (if there is one)
                                                if(playhead.present){
                                                    workarea.getChildByName('playhead').getChildByName('main').height(viewport.totalSize.height);
                                                    workarea.getChildByName('playhead').getChildByName('invisibleHandle').height(viewport.totalSize.height);
                                                    workarea.getChildByName('playhead').x( playhead.position*(viewport.totalSize.width/xCount) );
                                            }
                                        }else if( x != undefined && x != zoomLevel_x ){
                                            //make sure things are between maxZoom and 1
                                                x = x<maxZoom?maxZoom:x; x = x>1?1:x;
                            
                                            //update state
                                                zoomLevel_x = x;
                                                viewport.totalSize.width = width/zoomLevel_x;
                            
                                            //update interactionPlane_back
                                                interactionPlane_back.width( viewport.totalSize.width );
                                            //update interactionPlane_front
                                                interactionPlane_front.width( viewport.totalSize.width );
                            
                                            //update background strips
                                                backgroundDrawArea_vertical.getChildren().forEach(function(item,index){
                                                    item.x( index*(width/(xCount*zoomLevel_x)) );
                                                    item.width( width/(xCount*zoomLevel_x) );
                                                });
                                                backgroundDrawArea_horizontal.getChildren().forEach( item => item.width( viewport.totalSize.width ) );
                            
                                            //update signals
                                                signalPane.getChildren().forEach( item => item.unit(width/(xCount*zoomLevel_x), undefined) );
                            
                                            //update playhead (if there is one)
                                                if(playhead.present){
                                                    workarea.getChildByName('playhead').x( playhead.position*(viewport.totalSize.width/xCount) );
                                                }
                                        }else if( y != undefined && y != zoomLevel_y ){
                                            //make sure things are between maxZoom and 1
                                                y = y<maxZoom?maxZoom:y; y = y>1?1:y;
                            
                                            //update state
                                                zoomLevel_y = y;
                                                viewport.totalSize.height = height/zoomLevel_y;
                            
                                            //update interactionPlane_back
                                                interactionPlane_back.height( viewport.totalSize.height );
                                            //update interactionPlane_front
                                                interactionPlane_front.height( viewport.totalSize.height );
                            
                                            //update background strips
                                                backgroundDrawArea_vertical.getChildren().forEach( item => item.height( viewport.totalSize.height ) );
                                                backgroundDrawArea_horizontal.getChildren().forEach(function(item,index){
                                                    item.y( index*(height/(yCount*zoomLevel_y)) );
                                                    item.height( height/(yCount*zoomLevel_y) );
                                                });
                            
                                            //update signals
                                                signalPane.getChildren().forEach( item => item.unit(undefined, height/(yCount*zoomLevel_y)) );
                            
                                            //update playhead (if there is one)
                                                if(playhead.present){
                                                    workarea.getChildByName('playhead').getChildByName('main').height(viewport.totalSize.height);
                                                    workarea.getChildByName('playhead').getChildByName('invisibleHandle').height(viewport.totalSize.height);
                                                }
                                        }
                                    }
                                    function setViewArea(d,update=true){
                                        //clean off input
                                            if(d == undefined || (d.topLeft == undefined && d.bottomRight == undefined)){return viewport.viewArea;}
                                            else{
                                                if(d.topLeft == undefined){ d.topLeft = {x: viewport.viewArea.topLeft.x, y: viewport.viewArea.topLeft.y}; }
                                                else{
                                                    if(d.topLeft.x == undefined){ d.topLeft.x = viewport.viewArea.topLeft.x; }
                                                    if(d.topLeft.y == undefined){ d.topLeft.y = viewport.viewArea.topLeft.y; }
                                                }
                                                if(d.bottomRight == undefined){ d.bottomRight = {x: viewport.bottomRight.topLeft.x, y: viewport.bottomRight.topLeft.ys}; }
                                                else{
                                                    if(d.bottomRight.x == undefined){ d.bottomRight.x = viewport.viewArea.bottomRight.x; }
                                                    if(d.bottomRight.y == undefined){ d.bottomRight.y = viewport.viewArea.bottomRight.y; }
                                                }
                                            }
                            
                                        //first adjust the zoom, if the distance between the areas changed
                                            const x = (viewport.viewArea.bottomRight.x-viewport.viewArea.topLeft.x) != (d.bottomRight.x-d.topLeft.x);
                                            const y = (d.bottomRight.y-d.topLeft.y)!=(viewport.viewArea.bottomRight.y-viewport.viewArea.topLeft.y);
                                            
                                            if(x && y){ adjustZoom( (d.bottomRight.x-d.topLeft.x),(d.bottomRight.y-d.topLeft.y) ); }
                                            else if(x){ adjustZoom( (d.bottomRight.x-d.topLeft.x),undefined ); }
                                            else if(y){ adjustZoom( undefined,(d.bottomRight.y-d.topLeft.y) ); }
                            
                                        //update pan
                                            let newX = 0; let newY = 0;
                                            if( (1-(d.bottomRight.x-d.topLeft.x)) != 0 ){ newX = d.topLeft.x + d.topLeft.x*((d.bottomRight.x-d.topLeft.x)/(1-(d.bottomRight.x-d.topLeft.x))); }
                                            if( (1-(d.bottomRight.y-d.topLeft.y)) != 0 ){ newY = d.topLeft.y + d.topLeft.y*((d.bottomRight.y-d.topLeft.y)/(1-(d.bottomRight.y-d.topLeft.y))); }
                                            setViewposition(newX,newY,update);
                            
                                        //update state
                                            viewport.viewArea = Object.assign(d,{});
                            
                                        //callback
                                            if(update){
                                                object.onchangeviewarea(viewport.viewArea);
                                            }
                                    }
                                    function makeSignal(line, position, length, strength=signals.defaultStrength){
                            
                                        //register signal and get new id. From the registry, get the approved signal values
                                            const newID = signals.signalRegistry.add({ line:line, position:position, length:length, strength:strength });
                                            const approvedData = signals.signalRegistry.getSignal(newID);
                            
                                        //create graphical signal with approved values and append it to the pane
                                            const newSignalBlock = self.sequencer.signalBlock(
                                                newID, width/(xCount*zoomLevel_x), height/(yCount*zoomLevel_y), 
                                                approvedData.line, approvedData.position, approvedData.length, approvedData.strength, 
                                                false, signalStyle_body, signalStyle_bodyGlow, signalStyle_handle, signalStyle_handleWidth
                                            );
                                            signalPane.append(newSignalBlock);
                            
                                        //add signal controls to graphical signal block
                                            newSignalBlock.select = function(remainSelected=false){
                                                if(signals.selectedSignals.indexOf(this) != -1){ if(!remainSelected){this.deselect();} return; }
                                                this.selected(true);
                                                signals.selectedSignals.push(this);
                                                this.glow(true);
                                            };
                                            newSignalBlock.deselect = function(){
                                                signals.selectedSignals.splice(signals.selectedSignals.indexOf(this),1);
                                                this.selected(false);
                                                this.glow(false);
                                            };
                                            newSignalBlock.delete = function(){
                                                this.deselect();
                                                signals.signalRegistry.remove(parseInt(this.getName()));
                                                this.parent.remove(newSignalBlock);
                                            };
                            
                                        //add interactions to graphical signal block
                                            newSignalBlock.body.attachCallback('ondblclick', function(){
                                                if(!_canvas_.system.keyboard.pressedKeys.control && !_canvas_.system.keyboard.pressedKeys.command){return;}
                                                for(let a = 0; a < signals.selectedSignals.length; a++){
                                                    signals.selectedSignals[a].strength(signals.defaultStrength);
                                                    signals.signalRegistry.update(parseInt(signals.selectedSignals[a].getName()), {strength: signals.defaultStrength});
                                                }
                                            });
                                            newSignalBlock.body.attachCallback('onmousedown', function(x,y,event){
                                                if(!interactable){return;}
                            
                                                //if spacebar is pressed; ignore all of this, and redirect to the interaction pane (for panning)
                                                    if(_canvas_.system.keyboard.pressedKeys.Space){
                                                        interactionPlane_back.onmousedown(x,y,event); return;
                                                    }
                            
                                                //if the shift key is not pressed and this signal is not already selected; deselect everything
                                                    if(!_canvas_.system.keyboard.pressedKeys.shift && !newSignalBlock.selected()){
                                                        while(signals.selectedSignals.length > 0){
                                                            signals.selectedSignals[0].deselect();
                                                        }
                                                    }
                            
                                                //select this block
                                                    newSignalBlock.select(true);
                            
                                                //gather data for all the blocks that we're about to affect
                                                    const activeBlocks = [];
                                                    for(let a = 0; a < signals.selectedSignals.length; a++){
                                                        activeBlocks.push({
                                                            name: parseInt(signals.selectedSignals[a].getName()),
                                                            block: signals.selectedSignals[a],
                                                            starting: signals.signalRegistry.getSignal(parseInt(signals.selectedSignals[a].getName())),
                                                        });
                                                    }
                            
                                                //if control/command key is pressed; this is a strength-change operation
                                                    if(_canvas_.system.keyboard.pressedKeys.control || _canvas_.system.keyboard.pressedKeys.command){
                                                        const mux = 4;
                                                        const initialStrengths = activeBlocks.map(a => a.block.strength());
                                                        const initial = event.Y;
                                                        _canvas_.system.mouse.mouseInteractionHandler(
                                                            function(x,y,event){
                                                                //check if ctrl/command is still pressed
                                                                    if( !_canvas_.system.keyboard.pressedKeys.ControlLeft && !_canvas_.system.keyboard.pressedKeys.ControlRight && !_canvas_.system.keyboard.pressedKeys.command ){ 
                                                                        _canvas_.system.mouse.forceMouseUp();
                                                                    }
                            
                                                                const diff = (initial - event.Y)/(_canvas_.core.viewport.scale()*height*mux);
                                                                for(let a = 0; a < activeBlocks.length; a++){
                                                                    activeBlocks[a].block.strength(initialStrengths[a] + diff);
                                                                    signals.signalRegistry.update(activeBlocks[a].name, { strength: initialStrengths[a] + diff });
                                                                }
                                                            }
                                                        );
                                                        return;
                                                    }
                            
                                                //if the alt key is pressed, clone the block
                                                //(but don't select it, this is the 'alt-click-and-drag to clone' trick)
                                                //this function isn't run until the first sign of movement
                                                    let cloned = false;
                                                    function cloneFunc(){
                                                        if(cloned){return;} cloned = true;
                                                        if(_canvas_.system.keyboard.pressedKeys.alt){
                                                            for(let a = 0; a < signals.selectedSignals.length; a++){
                                                                const temp = signals.signalRegistry.getSignal(parseInt(signals.selectedSignals[a].getName()));
                                                                makeSignal(temp.line, temp.position, temp.length, temp.strength);
                                                            }
                                                        }
                                                    }
                            
                                                //block movement
                                                    const initialPosition = coordinates2lineposition( viewportPosition2internalPosition( currentMousePosition(x,y) ) );
                                                    _canvas_.system.mouse.mouseInteractionHandler(
                                                        function(x,y,event){
                                                            //clone that block (maybe)
                                                                cloneFunc();
                            
                                                            const livePosition = coordinates2lineposition( viewportPosition2internalPosition( currentMousePosition(x,y) ) );
                                                            const diff = {
                                                                line: livePosition.line - initialPosition.line,
                                                                position: livePosition.position - initialPosition.position,
                                                            };
                                    
                                                            for(let a = 0; a < activeBlocks.length; a++){
                                                                signals.signalRegistry.update(activeBlocks[a].name, {
                                                                    line:activeBlocks[a].starting.line+diff.line,
                                                                    position:activeBlocks[a].starting.position+diff.position,
                                                                });
                                    
                                                                const temp = signals.signalRegistry.getSignal(activeBlocks[a].name);
                                    
                                                                activeBlocks[a].block.line( temp.line );
                                                                activeBlocks[a].block.position( temp.position );
                                                            }
                                                        }
                                                    );
                                            });
                                            newSignalBlock.body.attachCallback('onmousemove', function(){
                                                const pressedKeys = _canvas_.system.keyboard.pressedKeys;
                            
                                                let cursor = 'default';
                                                if( pressedKeys.alt ){ cursor = 'copy'; }
                                                else if( pressedKeys.Space ){ cursor = 'grab'; }
                            
                                                _canvas_.core.viewport.cursor( cursor );
                                            });
                                            newSignalBlock.body.attachCallback('onkeydown', function(){
                                                if(!interactable){return;}
                            
                                                const pressedKeys = _canvas_.system.keyboard.pressedKeys;
                                                if(pressedKeys.alt){ _canvas_.core.viewport.cursor('copy'); }
                                            });
                                            newSignalBlock.body.attachCallback('onkeyup', function(){
                                                if(!interactable){return;}
                            
                                                const pressedKeys = _canvas_.system.keyboard.pressedKeys;
                                                if(!(pressedKeys.alt)){ _canvas_.core.viewport.cursor('default'); }
                                            });
                                            newSignalBlock.leftHandle.attachCallback('onmousedown', function(x,y,event){
                                                if(!interactable){return;}
                            
                                                //if spacebar is pressed; ignore all of this, and redirect to the interaction pane (for panning)
                                                    if(_canvas_.system.keyboard.pressedKeys.Space){
                                                        interactionPlane_back.onmousedown(x,y,event); return;
                                                    }
                                                    
                                                //cloning situation
                                                    if(_canvas_.system.keyboard.pressedKeys.alt){
                                                        newSignalBlock.body.onmousedown(x,y,event);
                                                        return;
                                                    }
                            
                                                //if the shift key is not pressed and this block wasn't selected; deselect everything and select this one
                                                    if(!_canvas_.system.keyboard.pressedKeys.shift && !newSignalBlock.selected()){
                                                        while(signals.selectedSignals.length > 0){
                                                            signals.selectedSignals[0].deselect();
                                                        }
                                                    }
                                            
                                                //select this block
                                                    newSignalBlock.select(true);
                            
                                                //gather data for all the blocks that we're about to affect
                                                    const activeBlocks = [];
                                                    for(let a = 0; a < signals.selectedSignals.length; a++){
                                                        activeBlocks.push({
                                                            name: parseInt(signals.selectedSignals[a].getName()),
                                                            block: signals.selectedSignals[a],
                                                            starting: signals.signalRegistry.getSignal(parseInt(signals.selectedSignals[a].getName())),
                                                        });
                                                    }
                                                
                                                //perform block length adjustment 
                                                    const initialPosition = coordinates2lineposition( viewportPosition2internalPosition( currentMousePosition(x,y) ) );
                                                    _canvas_.system.mouse.mouseInteractionHandler(
                                                        function(x,y,event){
                                                            const livePosition = coordinates2lineposition( viewportPosition2internalPosition( currentMousePosition(x,y) ) );
                                                            const diff = {position: initialPosition.position-livePosition.position};
                                    
                                                            for(let a = 0; a < activeBlocks.length; a++){
                                                                if( activeBlocks[a].starting.position-diff.position < 0 ){ continue; } //this stops a block from getting longer, when it is unable to move any further to the left
                                                                
                                                                signals.signalRegistry.update(activeBlocks[a].name, {
                                                                    length: activeBlocks[a].starting.length+diff.position,
                                                                    position: activeBlocks[a].starting.position-diff.position,
                                                                });
                                                                const temp = signals.signalRegistry.getSignal(activeBlocks[a].name);
                                                                activeBlocks[a].block.position( temp.position );
                                                                activeBlocks[a].block.length( temp.length );
                                                            }
                                                        }
                                                    );
                                            });
                                            newSignalBlock.leftHandle.attachCallback('onmousemove', function(){
                                                const pressedKeys = _canvas_.system.keyboard.pressedKeys;
                            
                                                let cursor = 'col-resize';
                                                if( pressedKeys.alt ){ cursor = 'copy'; }
                                                else if( pressedKeys.Space ){ cursor = 'grab'; }
                            
                                                _canvas_.core.viewport.cursor( cursor );
                                            });
                                            newSignalBlock.leftHandle.attachCallback('onmouseleaveelement', function(){_canvas_.core.viewport.cursor('default');});
                                            newSignalBlock.rightHandle.attachCallback('onmousedown', function(x,y,event,ignoreCloning=false){
                                                if(!interactable){return;}
                            
                                                //if spacebar is pressed; ignore all of this, and redirect to the interaction pane (for panning)
                                                    if(_canvas_.system.keyboard.pressedKeys.Space){
                                                        interactionPlane_back.getCallback('onmousedown')(x,y,event); return;
                                                    }
                            
                                                //cloning situation
                                                    if(!ignoreCloning && _canvas_.system.keyboard.pressedKeys.alt){
                                                        newSignalBlock.body.getCallback('onmousedown')(x,y,event);
                                                        return;
                                                    }
                            
                                                //if the shift key is not pressed and this block wasn't selected; deselect everything and select this one
                                                    if(!_canvas_.system.keyboard.pressedKeys.shift && !newSignalBlock.selected()){
                                                        while(signals.selectedSignals.length > 0){
                                                            signals.selectedSignals[0].deselect();
                                                        }
                                                    }
                                                
                                                //select this block
                                                    newSignalBlock.select(true);
                            
                                                //gather data for all the blocks that we're about to affect
                                                    const activeBlocks = [];
                                                    for(let a = 0; a < signals.selectedSignals.length; a++){
                                                        activeBlocks.push({
                                                            name: parseInt(signals.selectedSignals[a].getName()),
                                                            block: signals.selectedSignals[a],
                                                            starting: signals.signalRegistry.getSignal(parseInt(signals.selectedSignals[a].getName())),
                                                        });
                                                    }
                            
                                                //perform block length adjustment 
                                                    const initialPosition = coordinates2lineposition( viewportPosition2internalPosition(currentMousePosition(x,y) ) );
                                                    _canvas_.system.mouse.mouseInteractionHandler(
                                                        function(x,y,event){
                                                            const livePosition = coordinates2lineposition( viewportPosition2internalPosition(currentMousePosition(x,y) ) );
                                                            const diff = {position: livePosition.position - initialPosition.position};
                                
                                                            for(let a = 0; a < activeBlocks.length; a++){
                                                                signals.signalRegistry.update(activeBlocks[a].name, {length: activeBlocks[a].starting.length+diff.position});
                                                                const temp = signals.signalRegistry.getSignal(activeBlocks[a].name);
                                                                activeBlocks[a].block.position( temp.position );
                                                                activeBlocks[a].block.length( temp.length );
                                                            }
                                                        }
                                                    );
                                            });
                                            newSignalBlock.rightHandle.attachCallback('onmousemove', function(){
                                                const pressedKeys = _canvas_.system.keyboard.pressedKeys;
                            
                                                let cursor = 'col-resize';
                                                if( pressedKeys.alt ){ cursor = 'copy'; }
                                                else if( pressedKeys.Space ){ cursor = 'grab'; }
                            
                                                _canvas_.core.viewport.cursor( cursor );
                                            });
                                            newSignalBlock.rightHandle.attachCallback('onmouseleaveelement', function(){_canvas_.core.viewport.cursor('default');});
                            
                                        return {id:newID, signalBlock:newSignalBlock};
                                    }
                                    function deleteSelectedSignals(){
                                        while(signals.selectedSignals.length > 0){
                                            signals.selectedSignals[0].delete();
                                        }
                                    }
                                    function makePlayhead(){
                                        const newPlayhead = interfacePart.builder('basic','group','playhead');
                                        workarea.append(newPlayhead);
                            
                                        newPlayhead.main = interfacePart.builder('basic','rectangle','main',{
                                            x: -playhead.width/2,
                                            width:playhead.width,
                                            height:viewport.totalSize.height,
                                            colour:playheadStyle
                                        });
                                        newPlayhead.append(newPlayhead.main);
                            
                                        newPlayhead.invisibleHandle = interfacePart.builder('basic','rectangle','invisibleHandle',{
                                            x:-playhead.width*playhead.invisibleHandleMux/2 + playhead.width/2, 
                                            width: playhead.width*playhead.invisibleHandleMux,
                                            height:viewport.totalSize.height,
                                            colour:{r:1,g:0,b:0,a:0}
                                        })
                                        newPlayhead.append(newPlayhead.invisibleHandle);
                            
                                        newPlayhead.invisibleHandle.onmousedown = function(){
                                            if(!interactable){return;}
                            
                                            playhead.held = true;
                                            _canvas_.system.mouse.mouseInteractionHandler(
                                                function(event){ object.playheadPosition(coordinates2lineposition(viewportPosition2internalPosition(currentMousePosition(event))).position); },
                                                function(){playhead.held = false;}
                                            );
                                        };
                            
                                        newPlayhead.invisibleHandle.onmouseenter = function(){_canvas_.core.viewport.cursor('col-resize');};
                                        newPlayhead.invisibleHandle.onmousemove = function(){_canvas_.core.viewport.cursor('col-resize');};
                                        newPlayhead.invisibleHandle.onmouseleave = function(){_canvas_.core.viewport.cursor('default');};
                            
                                        playhead.present = true;
                            
                                        return newPlayhead;
                                    }
                            
                                //controls
                                    object.viewposition = setViewposition;
                                    object.viewarea = setViewArea;
                                    object.step = function(a){
                                        if(a == undefined){return signals.step;}
                                        signals.step = a;
                                    };
                                    object.interactable = function(bool){
                                        if(bool==undefined){return interactable;}
                                        interactable = bool;
                                    };
                            
                                    //background
                                        object.glowHorizontal = function(state,start,end){
                                            if(end == undefined){end = start+1;}
                            
                                            for(let a = start; a <= end; a++){
                                                const tmp = state ? horizontalStripStyle_glow : horizontalStripStyle_styles[horizontalStripStyle_pattern[a%horizontalStripStyle_pattern.length]];
                                                backgroundDrawArea_horizontal.getChildren()[a].colour(tmp.colour);
                                                backgroundDrawArea_horizontal.getChildren()[a].lineColour(tmp.lineColour);
                                                backgroundDrawArea_horizontal.getChildren()[a].thickness(tmp.thickness);
                                            }
                                        };
                                        object.glowVertical = function(state,start,end){
                                            if(end == undefined){end = start+1;}
                            
                                            for(let a = start; a < end; a++){
                                                const tmp = state ? verticalStripStyle_glow : verticalStripStyle_styles[verticalStripStyle_pattern[a%verticalStripStyle_pattern.length]];
                                                backgroundDrawArea_vertical.getChildren()[a].colour(tmp.colour);
                                                backgroundDrawArea_vertical.getChildren()[a].lineColour(tmp.lineColour);
                                                backgroundDrawArea_vertical.getChildren()[a].thickness(tmp.thickness);
                                            }
                                        };
                                    
                                    //looping
                                        object.loopActive = function(bool){
                                            if(bool == undefined){return loop.active;}
                                            loop.active = bool;
                            
                                            object.glowVertical(false,0,xCount);
                                            if( loop.active ){
                                                object.glowVertical(true, 
                                                    loop.period.start < 0 ? 0 : loop.period.start, 
                                                    loop.period.end > xCount ? xCount : loop.period.end,
                                                );
                                            }
                                        };
                                        object.loopPeriod = function(start,end){
                                            if(start == undefined || end == undefined){return loop.period;}
                                            if(start > end || start < 0 || end < 0){return;}
                            
                                            loop.period = {start:start, end:end};
                            
                                            if( loop.active ){
                                                object.glowVertical(false,0,xCount);
                                                object.glowVertical(true,
                                                    start < 0 ? 0 : start, 
                                                    end > xCount ? xCount : end,
                                                );
                                            }
                                        };
                            
                                    //signals
                                        object.export = function(){return signals.signalRegistry.export();};
                                        object.import = function(data){signals.signalRegistry.import(data);};
                                        object.getAllSignals = function(){return signals.signalRegistry.getAllSignals(); };
                                        object.addSignal = function(line, position, length, strength=1){ makeSignal(line, position, length, strength); };
                                        object.addSignals = function(data){ 
                                            for(let a = 0; a < data.length; a++){
                                                if( data[a] == undefined || data[a] == null ){continue;}
                                                this.addSignal(data[a].line, data[a].position, data[a].length, data[a].strength);
                                            }
                                        };
                                        object.eventsBetween = function(start,end){ return signals.signalRegistry.eventsBetween(start,end); };
                                        
                                    //playhead
                                        object.automove = function(a){
                                            if(a == undefined){return playhead.automoveViewposition;}
                                            playhead.automoveViewposition = a;
                                        };
                                        object.playheadPosition = function(val,stopActive=true){
                                            if(val == undefined){return playhead.position;}
                                
                                            playhead.position = val;
                                
                                            //send stop events for all active signals
                                                if(stopActive){
                                                    const events = [];
                                                    for(let a = 0; a < signals.activeSignals.length; a++){
                                                        const tmp = signals.signalRegistry.getSignal(signals.activeSignals[a]); if(tmp == null){continue;}
                                                        events.unshift( {signalID:signals.activeSignals[a], line:tmp.line, position:loop.period.start, strength:0} );
                                                    }
                                                    signals.activeSignals = [];
                                                    if(object.event && events.length > 0){object.event(events);}
                                                }
                                
                                            //reposition graphical playhead
                                                let playheadObject = workarea.getChildByName('playhead');
                                                if(playhead.position < 0 || playhead.position > xCount){
                                                    //outside viable bounds, so remove
                                                        if( playheadObject != undefined ){ playheadObject.parent.remove(playheadObject); }
                                                }else{ 
                                                    //within viable bounds, so either create or adjust
                                                        if( playheadObject == undefined ){ playheadObject = makePlayhead(); }
                                                        playheadObject.x( playhead.position*(viewport.totalSize.width/xCount) );
                                                    //if the new position is beyond the view in the viewport, adjust the viewport (putting the playhead on the leftmost side)
                                                    //(assuming automoveViewposition is set)
                                                        if(playhead.automoveViewposition){
                                                            const remainderSpace = xCount-(xCount*zoomLevel_x);
                                                            if( playhead.position < Math.floor(viewport.viewposition.x*remainderSpace) || 
                                                                playhead.position > Math.floor(viewport.viewposition.x*remainderSpace) + (xCount*zoomLevel_x)  
                                                            ){ object.viewposition( (playhead.position > remainderSpace ? remainderSpace : playhead.position)/remainderSpace ); }
                                                        }
                                                }
                                        };
                                        object.progress = function(){
                                            //if the playhead is being held, just bail completely
                                                if(playhead.held){return;}
                                                
                                            //gather together all the current events
                                                const events = object.eventsBetween(playhead.position, playhead.position+signals.step);
                            
                                            //upon loop; any signals that are still active are to be ended
                                            //(so create end events for them, and push those into the current events list)
                                                if(loop.active && playhead.position == loop.period.start){
                                                    for(let a = 0; a < signals.activeSignals.length; a++){
                                                        const tmp = signals.signalRegistry.getSignal(signals.activeSignals[a]); if(tmp == null){continue;}
                                                        events.unshift( {signalID:signals.activeSignals[a], line:tmp.line, position:loop.period.start, strength:0} );
                                                    }
                                                    signals.activeSignals = [];
                                                }
                            
                                            //add newly started signals to - and remove newly finished signals from - 'signals.activeSignals'
                                                for(let a = 0; a < events.length; a++){
                                                    const index = signals.activeSignals.indexOf(events[a].signalID);
                                                    if(index != -1 && events[a].strength == 0){
                                                        signals.activeSignals.splice(index);
                                                    }else{
                                                        if( events[a].strength > 0 ){
                                                            signals.activeSignals.push(events[a].signalID);
                                                        }
                                                    }
                                                }
                            
                                            //progress position
                                                if( loop.active && (playhead.position+signals.step == loop.period.end) ){
                                                    playhead.position = loop.period.start;
                                                }else{
                                                    playhead.position = playhead.position+signals.step;
                                                }
                            
                                            //update graphical playhead
                                                object.playheadPosition(playhead.position,false);
                            
                                            //perform event callback
                                                if(object.event && events.length > 0){object.event(events);}
                                        };
                            
                                //interaction
                                    let viewareaInMotion = false;
                                    interactionPlane_back.attachCallback('onmousedown', function(x,y,event){ 
                                        if(!interactable){return;}
                                        
                                        const pressedKeys = _canvas_.system.keyboard.pressedKeys;
                            
                                        if( pressedKeys.alt && pressedKeys.Space ){return;}
                            
                                        if(pressedKeys.shift){//group select 
                                            const initialPositionData = currentMousePosition(x,y);
                                            let livePositionData =    currentMousePosition(x,y);
                                
                                            const selectionArea = interfacePart.builder('basic','rectangle','selectionArea',{
                                                x:initialPositionData.x*width, y:initialPositionData.y*height,
                                                width:0, height:0,
                                                colour:selectionAreaStyle,
                                            });
                                            object.append(selectionArea);
                                
                                            _canvas_.system.mouse.mouseInteractionHandler(
                                                function(x,y,event){
                                                    //get live position, and correct it so it's definitely within in the relevant area
                                                        livePositionData = currentMousePosition(x,y);
                                                        livePositionData.x = livePositionData.x < 0 ? 0 : livePositionData.x;
                                                        livePositionData.y = livePositionData.y < 0 ? 0 : livePositionData.y;
                                                        livePositionData.x = livePositionData.x > 1 ? 1 : livePositionData.x;
                                                        livePositionData.y = livePositionData.y > 1 ? 1 : livePositionData.y;
                                                        
                                                    //gather difference between this point and the initial
                                                        const diff = {
                                                            x:livePositionData.x - initialPositionData.x, 
                                                            y:livePositionData.y - initialPositionData.y
                                                        };
                                
                                                    //account for an inverse rectangle
                                                        const transform = {
                                                            x: initialPositionData.x, y: initialPositionData.y, 
                                                            width: 1, height: 1,
                                                        };
                                                        
                                                        if(diff.x < 0){ transform.width = -1;  transform.x += diff.x; }
                                                        if(diff.y < 0){ transform.height = -1; transform.y += diff.y; }
                                
                                                    //update rectangle
                                                        selectionArea.x(transform.x*width);
                                                        selectionArea.y(transform.y*height);
                                                        selectionArea.width(  transform.width  * diff.x*width  );
                                                        selectionArea.height( transform.height * diff.y*height );
                                                },
                                                function(x,y,event){
                                                    //remove selection box
                                                        selectionArea.parent.remove(selectionArea);
                                
                                                    //gather the corner points
                                                        const finishingPositionData = {
                                                            a: visible2coordinates(initialPositionData),
                                                            b: visible2coordinates(livePositionData),
                                                        };
                                                        finishingPositionData.a.x *= viewport.totalSize.width; finishingPositionData.b.y *= viewport.totalSize.height;
                                                        finishingPositionData.b.x *= viewport.totalSize.width; finishingPositionData.a.y *= viewport.totalSize.height;
                                
                                                        const selectionBox = { topLeft:{ x:0, y:0 }, bottomRight:{ x:0, y:0 } };
                                                        if( finishingPositionData.a.x < finishingPositionData.b.x ){
                                                            selectionBox.topLeft.x =     finishingPositionData.a.x;
                                                            selectionBox.bottomRight.x = finishingPositionData.b.x;
                                                        }else{
                                                            selectionBox.topLeft.x =     finishingPositionData.b.x;
                                                            selectionBox.bottomRight.x = finishingPositionData.a.x;
                                                        }
                                                        if( finishingPositionData.a.y < finishingPositionData.b.y ){
                                                            selectionBox.topLeft.y =     finishingPositionData.a.y;
                                                            selectionBox.bottomRight.y = finishingPositionData.b.y;
                                                        }else{
                                                            selectionBox.topLeft.y =     finishingPositionData.b.y;
                                                            selectionBox.bottomRight.y = finishingPositionData.a.y;
                                                        }
                                
                                                    //deselect everything
                                                        while(signals.selectedSignals.length > 0){
                                                            signals.selectedSignals[0].deselect();
                                                        }
                                
                                                    //select the signals that overlap with the selection area
                                                        const children = signalPane.getChildren();
                                                        for(let a = 0; a < children.length; a++){
                                                            const temp = signals.signalRegistry.getSignal(parseInt(children[a].getName()));
                                                            const block = { 
                                                                    topLeft:{
                                                                        x:temp.position * (viewport.totalSize.width/xCount), 
                                                                        y:temp.line *     (viewport.totalSize.height/yCount)},
                                                                    bottomRight:{
                                                                        x:(temp.position+temp.length) * (viewport.totalSize.width/xCount), 
                                                                        y:(temp.line+1)*                (viewport.totalSize.height/yCount)
                                                                    },
                                                            };
                                
                                                            if( _canvas_.library.math.detectOverlap.boundingBoxes( block, selectionBox ) ){children[a].select(true);}
                                                        }
                                                },
                                            );
                                        }else if(pressedKeys.alt){//draw signal
                                            //deselect everything
                                                while(signals.selectedSignals.length > 0){
                                                    signals.selectedSignals[0].deselect();
                                                }
                                                
                                            //get the current location and make a new signal there (with length 0)
                                                const position = coordinates2lineposition( viewportPosition2internalPosition( currentMousePosition(x,y) ) );
                                                const temp = makeSignal(position.line,position.position,0);
                            
                                            //select this new block, and direct the mouse-down to the right handle (for user lengthening)
                                                temp.signalBlock.select();
                                                temp.signalBlock.rightHandle.getCallback('onmousedown')(x,y,event,true);
                                        }else if(pressedKeys.Space){//pan
                                            viewareaInMotion = true;
                                            _canvas_.core.viewport.cursor('grabbing');
                            
                                            const initialPosition = currentMousePosition(x,y);
                                            const old_viewport = {x:viewport.viewposition.x, y:viewport.viewposition.y};
                            
                                            _canvas_.system.mouse.mouseInteractionHandler(
                                                function(x,y,event){
                                                    const livePosition = currentMousePosition(x,y);
                                                    const diffPosition = {x:initialPosition.x-livePosition.x, y:initialPosition.y-livePosition.y};
                                                    setViewposition(
                                                        old_viewport.x - (diffPosition.x*zoomLevel_x)/(zoomLevel_x-1),
                                                        old_viewport.y - (diffPosition.y*zoomLevel_y)/(zoomLevel_y-1),
                                                    );
                                                },
                                                function(x,y,event){
                                                    viewareaInMotion = false;
                                                    if( 
                                                        _canvas_.library.math.detectOverlap.pointWithinBoundingBox( 
                                                            viewportPosition2internalPosition(currentMousePosition(x,y)), 
                                                            viewport.viewArea 
                                                        ) && _canvas_.system.keyboard.pressedKeys.Space
                                                    ){
                                                        _canvas_.core.viewport.cursor('grab');
                                                    }else{
                                                        _canvas_.core.viewport.cursor('default');
                                                    }
                                                },
                                            );
                                        }else{//elsewhere click
                                            //deselect everything
                                                while(signals.selectedSignals.length > 0){
                                                    signals.selectedSignals[0].deselect();
                                                }
                                        }
                                    });
                                    interactionPlane_back.attachCallback('onmousemove', function(){
                                        if(!interactable){return;}
                            
                                        const pressedKeys = _canvas_.system.keyboard.pressedKeys;
                                        if( pressedKeys.alt ){ _canvas_.core.viewport.cursor('crosshair'); }
                                        else if( pressedKeys.shift ){ _canvas_.core.viewport.cursor('pointer'); }
                                        else if( pressedKeys.Space ){ _canvas_.core.viewport.cursor('grab'); }
                                        else{ _canvas_.core.viewport.cursor('default'); }
                                    });
                                    interactionPlane_front.attachCallback('onkeydown', function(x,y,event){
                                        if(!interactable){return;}
                            
                                        const pressedKeys = _canvas_.system.keyboard.pressedKeys;
                                        if( pressedKeys.Backspace || pressedKeys.Delete ){ deleteSelectedSignals(); }
                                        if( pressedKeys.Space ){ _canvas_.core.viewport.cursor(viewareaInMotion ? 'grabbing' : 'grab'); }
                                        if( pressedKeys.alt ){
                                            signalPane.getElementsUnderPoint(event.X,event.Y).then(result => {
                                                if( result[0] != undefined ){
                                                    _canvas_.core.viewport.cursor('copy');
                                                }else{
                                                    _canvas_.core.viewport.cursor('crosshair');
                                                }
                                            });
                                        }
                                    });
                                    interactionPlane_front.attachCallback('onkeyup', function(){
                                        if(!interactable){return;}
                            
                                        _canvas_.core.viewport.cursor('default');
                                    });
                            
                                //callbacks
                                    object.onpan = onpan;
                                    object.onchangeviewarea = onchangeviewarea;
                                    object.event = event;
                            
                                //setup
                                    drawBackground();
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.sequencer = function(name,data){ return interfacePart.collection.control.sequencer(
                                name, data.x, data.y, data.width, data.height, data.angle, data.interactable,             
                                data.xCount, data.yCount, data.zoomLevel_x, data.zoomLevel_y,
                                data.backingStyle, data.selectionAreaStyle,
                                data.blockStyle_body, data.blockStyle_bodyGlow, data.blockStyle_handle, data.blockStyle_handleWidth,
                                data.horizontalStripStyle_pattern, data.horizontalStripStyle_glow, data.horizontalStripStyle_styles,
                                data.verticalStripStyle_pattern,   data.verticalStripStyle_glow,   data.verticalStripStyle_styles,
                                data.playheadStyle,
                                data.onpan, data.onchangeviewarea, data.event,
                            ); };
                            
                            
                            
                            
                            
                            
                            this.sequencer.signalBlock = function(
                                name, unit_x, unit_y,
                                line, position, length, strength=1, glow=false, 
                                bodyStyle=[
                                    {colour:{r:138/255,g:138/255,b:138/255,a:0.6}, lineColour:{r:175/255,g:175/255,b:175/255,a:0.95}, lineThickness:0.5},
                                    {colour:{r:130/255,g:199/255,b:208/255,a:0.6}, lineColour:{r:130/255,g:199/255,b:208/255,a:0.95}, lineThickness:0.5},
                                    {colour:{r:129/255,g:209/255,b:173/255,a:0.6}, lineColour:{r:129/255,g:209/255,b:173/255,a:0.95}, lineThickness:0.5},
                                    {colour:{r:234/255,g:238/255,b:110/255,a:0.6}, lineColour:{r:234/255,g:238/255,b:110/255,a:0.95}, lineThickness:0.5},
                                    {colour:{r:249/255,g:178/255,b:103/255,a:0.6}, lineColour:{r:249/255,g:178/255,b:103/255,a:0.95}, lineThickness:0.5},
                                    {colour:{r:255/255,g: 69/255,b: 69/255,a:0.6}, lineColour:{r:255/255,g: 69/255,b: 69/255,a:0.95}, lineThickness:0.5},
                                ],
                                bodyGlowStyle=[
                                    {colour:{r:138/255,g:138/255,b:138/255,a:0.8}, lineColour:{r:175/255,g:175/255,b:175/255,a:1}, lineThickness:0.5},
                                    {colour:{r:130/255,g:199/255,b:208/255,a:0.8}, lineColour:{r:130/255,g:199/255,b:208/255,a:1}, lineThickness:0.5},
                                    {colour:{r:129/255,g:209/255,b:173/255,a:0.8}, lineColour:{r:129/255,g:209/255,b:173/255,a:1}, lineThickness:0.5},
                                    {colour:{r:234/255,g:238/255,b:110/255,a:0.8}, lineColour:{r:234/255,g:238/255,b:110/255,a:1}, lineThickness:0.5},
                                    {colour:{r:249/255,g:178/255,b:103/255,a:0.8}, lineColour:{r:249/255,g:178/255,b:103/255,a:1}, lineThickness:0.5},
                                    {colour:{r:255/255,g: 69/255,b: 69/255,a:0.8}, lineColour:{r:255/255,g: 69/255,b: 69/255,a:1}, lineThickness:0.5},
                                ],
                                handleStyle={r:1,g:1,b:0,a:1},
                                handleWidth=5,
                            ){
                            
                                let selected = false;
                                const minLength = handleWidth/4;
                                let currentStyles = {
                                    body:getBlendedColour(bodyStyle,strength),
                                    glow:getBlendedColour(bodyGlowStyle,strength),
                                };
                                
                                //elements
                                    const object = interfacePart.builder('basic','group',String(name),{x:position*unit_x, y:line*unit_y});
                                    object.body = interfacePart.builder('basic','rectangleWithOutline','body',{width:length*unit_x, height:unit_y, colour:currentStyles.body.colour, lineColour:currentStyles.body.lineColour, lineThickness:currentStyles.body.lineThickness});
                                    object.leftHandle = interfacePart.builder('basic','rectangle','leftHandle',{x:-handleWidth/2, width:handleWidth, height:unit_y, colour:handleStyle});
                                    object.rightHandle = interfacePart.builder('basic','rectangle','rightHandle',{x:length*unit_x-handleWidth/2, width:handleWidth, height:unit_y, colour:handleStyle});
                                    object.append(object.body);
                                    object.append(object.leftHandle);
                                    object.append(object.rightHandle);
                            
                                //internal functions
                                    function updateHeight(){
                                        object.body.height(unit_y);
                                        object.leftHandle.height(unit_y);
                                        object.rightHandle.height(unit_y);
                                    }
                                    function updateLength(){
                                        object.body.width(length*unit_x);
                                        object.rightHandle.x(length*unit_x-handleWidth/2);
                                    }
                                    function updateLineAndPosition(){ updateLine(); updatePosition(); }
                                    function updateLengthAndHeight(){ updateLength(); updateHeight(); }
                                    function updateLine(){ object.y(line*unit_y); }
                                    function updatePosition(){ object.x(position*unit_x); }
                                    function getBlendedColour(swatch,ratio){
                                        const outputStyle = Object.assign({},swatch[0]);
                            
                                        //if there's a colour attribute; blend it and add it to the output 
                                            if( swatch[0].hasOwnProperty('colour') ){
                                                outputStyle.colour = _canvas_.library.math.multiBlendColours(swatch.map(a => a.colour),ratio);
                                            }
                            
                                        //if there's a lineColour attribute; blend it and add it to the output
                                            if( swatch[0].hasOwnProperty('lineColour') ){
                                                outputStyle.lineColour = _canvas_.library.math.multiBlendColours(swatch.map(a => a.lineColour),ratio);
                                            }
                            
                                        return outputStyle;
                                    }
                            
                                //controls
                                    object.unit = function(x,y){
                                        if(x == undefined && y == undefined){return {x:unit_x,y:unit_y};}
                            
                                        //(awkward bid for speed)
                                        if( x == undefined ){
                                            unit_y = y;
                                            updateHeight();
                                            updateLine();
                                        }else if( y == undefined ){
                                            unit_x = x;
                                            updateLength();
                                            updatePosition();
                                        }else{
                                            unit_x = x;
                                            unit_y = y;
                                            updateLengthAndHeight();
                                            updateLineAndPosition();
                                        }
                                    };
                                    object.line = function(a){
                                        if(a == undefined){return line;}
                                        line = a;
                                        updateLine();
                                    };
                                    object.position = function(a){
                                        if(a == undefined){return position;}
                                        position = a;
                                        updatePosition();
                                    };
                                    object.length = function(a){
                                        if(a == undefined){return length;}
                                        length = a < (minLength/unit_x) ? (minLength/unit_x) : a;
                                        updateLength();
                                    };
                                    object.strength = function(a){
                                        if(a == undefined){return strength;}
                                        a = a > 1 ? 1 : a; a = a < 0 ? 0 : a;
                                        strength = a;
                                        currentStyles = {
                                            body:getBlendedColour(bodyStyle,strength),
                                            glow:getBlendedColour(bodyGlowStyle,strength),
                                        };
                                        object.glow(glow);
                                    };
                                    object.glow = function(a){
                                        if(a == undefined){return glow;}
                                        glow = a;
                                        if(glow){ 
                                            object.body.colour(currentStyles.glow.colour);
                                            object.body.lineColour(currentStyles.glow.lineColour);
                                            object.body.thickness(currentStyles.glow.thickness);
                                        }else{    
                                            object.body.colour(currentStyles.body.colour);
                                            object.body.lineColour(currentStyles.body.lineColour);
                                            object.body.thickness(currentStyles.body.thickness);
                                        }            
                                    };
                                    object.selected = function(a){
                                        if(a == undefined){return selected;}
                                        selected = a;
                                    };
                            
                                return object;
                            };
                            this.grapher_waveWorkspace = function(
                                name='grapher_waveWorkspace',
                                x, y, width=120, height=60, angle=0, interactable=true, selectNeedle=true, selectionArea=true,
                            
                                foregroundStyles=[
                                    {colour:{r:0,g:1,b:0,a:1}, thickness:0.25},
                                    {colour:{r:1,g:1,b:0,a:1}, thickness:0.25},
                                ],
                                foregroundTextStyles=[
                                    {colour:{r:0.39,g:1,b:0.39,a:1}, size:7.5, font:'Helvetica'},
                                    {colour:{r:1,g:1,b:0.39,a:1}, size:7.5, font:'Helvetica'},
                                ],
                            
                                backgroundStyle_colour={r:0,g:0.39,b:0,a:1},
                                backgroundStyle_lineThickness=0.25,
                                backgroundTextStyle_colour={r:0,g:0.58,b:0,a:1},
                                backgroundTextStyle_size=10,
                                backgroundTextStyle_font='Helvetica',
                            
                                backingStyle={r:0.2,g:0.2,b:0.2,a:1},
                            
                                onchange=function(needle,value){}, 
                                onrelease=function(needle,value){}, 
                                selectionAreaToggle=function(bool){},
                            ){
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                    //main graph
                                        const graph = interfacePart.builder('display','grapher', 'graph', {
                                            canvasBased:true, resolution:10,
                                            width:width, height:height,
                                            backgroundText_horizontalMarkings:{ points:[0.75,0.5,0.25,0,-0.25,-0.5,-0.75], printingValues:['3/4','1/2','1/4','0','-1/4','-1/2','-3/4'], textPositionOffset:{x:1,y:-0.5}, printText:true },
                                            backgroundText_verticalMarkings:{  points:[0.75,0.5,0.25,0], printText:false },
                                            style:{
                                                foregrounds:foregroundStyles,   
                                                foregroundText:foregroundTextStyles,
                                                background_colour:backgroundStyle_colour,
                                                background_lineThickness:backgroundStyle_lineThickness,
                                                backgroundText_colour:backgroundTextStyle_colour,
                                                backgroundText_size:backgroundTextStyle_size,
                                                backgroundText_font:backgroundTextStyle_font,
                                                backing:backingStyle,
                                            }
                                        });
                                        object.append(graph);
                                    //needle overlay
                                        const overlay = interfacePart.builder('control','needleOverlay', 'overlay', {
                                            width:width, height:height, interactable:interactable, selectNeedle:selectNeedle, selectionArea:selectionArea,
                                        });
                                        object.append(overlay);
                            
                                //controls
                                    //grapher
                                        object.horizontalMarkings = graph.horizontalMarkings;
                                        object.verticalMarkings = graph.verticalMarkings;
                                        object.drawBackground = graph.drawBackground;
                                        object.drawForeground = graph.drawForeground;
                                        object.draw = graph.draw;
                                    //needle overlay
                                        object.removeAllMarkers = overlay.removeAllMarkers;
                                        object.select = overlay.select;
                                        object.area = overlay.area;
                                        object.interactable = overlay.interactable;
                                        object.areaIsActive = overlay.areaIsActive;
                                        object.list = overlay.list;
                            
                                //callbacks
                                    object.onchange = onchange;
                                    object.onrelease = onrelease;
                                    object.selectionAreaToggle = selectionAreaToggle;
                                    overlay.onchange = function(needle,value){ if(object.onchange){object.onchange(needle,value);} };
                                    overlay.onrelease = function(needle,value){ if(object.onrelease){object.onrelease(needle,value);} };
                                    overlay.selectionAreaToggle = function(toggle){ if(object.selectionAreaToggle){object.selectionAreaToggle(toggle);} };
                            
                                //setup
                                    graph.viewbox({left:0});
                                    graph.drawBackground();
                                    overlay.select(0);
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.control.grapher_waveWorkspace = function(name,data){ return interfacePart.collection.control.grapher_waveWorkspace(
                                name, data.x, data.y, data.width, data.height, data.angle, data.interactable, data.selectNeedle, data.selectionArea,
                                data.style.foregrounds, data.style.foregroundText,
                                data.style.background_colour, data.style.background_lineThickness,
                                data.style.backgroundText_colour, data.style.backgroundText_size, data.style.backgroundText_font,
                                data.style.backing,
                                data.onchange, data.onrelease, data.selectionAreaToggle
                            ); };
                        };
                        this.dynamic = new function(){
                            interfacePart.partLibrary.dynamic = {};
                            this.connectionNode_voltage = function(
                                name='connectionNode_voltage',
                                x, y, angle=0, width=20, height=20,
                                allowConnections=true, allowDisconnections=true,
                                dimStyle={r:0.86,g:1,b:0.86,a:1},
                                glowStyle={r:0.94,g:0.98,b:0.93,a:1},
                                cable_dimStyle={r:0.32,g:0.96,b:0.43,a:1},
                                cable_glowStyle={r:0.62,g:0.98,b:0.68,a:1},
                                cableConnectionPosition={x:1/2,y:1/2},
                                cableVersion=1,
                                onchange=function(value){},
                                onconnect=function(instigator){},
                                ondisconnect=function(instigator){},
                            ){
                                //elements
                                    const object = interfacePart.builder('dynamic','connectionNode',name,{
                                        x:x, y:y, angle:angle, width:width, height:height, allowConnections:allowConnections, allowDisconnections:allowDisconnections, type:'voltage',
                                        cableConnectionPosition:cableConnectionPosition, cableVersion:cableVersion,
                                        style:{ dim:dimStyle, glow:glowStyle, cable_dim:cable_dimStyle, cable_glow:cable_glowStyle },
                                        onconnect, ondisconnect
                                    });
                            
                                //circuitry
                                    let localValue = 0;
                            
                                    object._getLocalValue = function(){ return localValue; };
                                    object._update = function(a){
                                        if(a>0){ object.activate(); }
                                        else{ object.deactivate(); }
                                        try{object.onchange(a);}catch(error){console.log('connectionNode_voltage::'+name+'::onchange error:',error);}
                                    }
                            
                                    object.set = function(a){
                                        if(typeof a != 'number'){return;}
                            
                                        localValue = a;
                            
                                        const val = object.read();
                                        object._update(val);
                                        if(object.getForeignNode()!=undefined){ object.getForeignNode()._update(val); }
                                    };
                                    object.read = function(){ return localValue + (object.getForeignNode() != undefined ? object.getForeignNode()._getLocalValue() : 0); };
                            
                                    object._onconnect = function(instigator){
                                        const forignValue = object.getForeignNode()._getLocalValue();
                                        if(forignValue>0){ object.activate(); }
                                        try{object.onchange(forignValue);}catch(error){console.log('connectionNode_voltage::'+name+'::onchange error:',error);}
                                    };
                                    object._ondisconnect = function(instigator){
                                        if(localValue==0){ object.deactivate(); }
                                        try{object.onchange(localValue);}catch(error){console.log('connectionNode_voltage::'+name+'::onchange error:',error);}
                                    };
                            
                                //callbacks
                                    object.onchange = onchange;
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.dynamic.connectionNode_voltage = function(name,data){ 
                                return interfacePart.collection.dynamic.connectionNode_voltage(
                                    name, data.x, data.y, data.angle, data.width, data.height, data.allowConnections, data.allowDisconnections,
                                    data.style.dim, data.style.glow, data.style.cable_dim, data.style.cable_glow, data.cableConnectionPosition, data.cableVersion,
                                    data.onchange, data.onconnect, data.ondisconnect,
                                ); 
                            };
                            // this.connectionNode_audio = function(
                            //     name='connectionNode_audio',
                            //     x, y, angle=0, width=20, height=20, allowConnections=true, allowDisconnections=true,
                            //     isAudioOutput=false, audioContext,
                            //     cableConnectionPosition={x:1/2,y:1/2},
                            //     cableVersion=1,
                            //     dimStyle={r:255/255, g:244/255, b:220/255, a:1},
                            //     glowStyle={r:255/255, g:244/255, b:244/255, a:1},
                            //     cable_dimStyle={r:247/255, g:146/255, b:84/255, a:1},
                            //     cable_glowStyle={r:242/255, g:168/255, b:123/255, a:1},
                            //     onconnect=function(instigator){},
                            //     ondisconnect=function(instigator){},
                            // ){
                            //     //elements
                            //         const object = interfacePart.builder('dynamic','connectionNode',name,{
                            //             x:x, y:y, angle:angle, width:width, height:height, allowConnections:allowConnections, allowDisconnections:allowDisconnections, type:'audio', direction:(isAudioOutput ? 'out' : 'in'),
                            //             cableConnectionPosition:cableConnectionPosition, cableVersion:cableVersion,
                            //             style:{ dim:dimStyle, glow:glowStyle, cable_dim:cable_dimStyle, cable_glow:cable_glowStyle },
                            //             onconnect, ondisconnect
                            //         });
                            //         object._direction = isAudioOutput ? 'out' : 'in';
                            
                            //     //circuitry
                            //         object.audioNode = audioContext.createAnalyser();
                            //         // object.audioNode = new _canvas_.library.audio.audioWorklet.nothing(_canvas_.library.audio.context);
                            
                            //         //audio connections
                            //             object.out = function(){return object.audioNode;};
                            //             object.in = function(){return object.audioNode;};
                            
                            //         object._onconnect = function(instigator){
                            //             if(object._direction == 'out'){ object.audioNode.connect(object.getForeignNode().audioNode); }
                            //         };
                            //         object._ondisconnect = function(instigator){
                            //             if(object._direction == 'out'){ object.audioNode.disconnect(object.getForeignNode().audioNode); }
                            //         };
                            
                            //     return object;
                            // };
                            
                            // interfacePart.partLibrary.dynamic.connectionNode_audio = function(name,data){
                            //     return interfacePart.collection.dynamic.connectionNode_audio(
                            //         name, data.x, data.y, data.angle, data.width, data.height, data.allowConnections, data.allowDisconnections, data.isAudioOutput, _canvas_.library.audio.context, data.cableConnectionPosition, data.cableVersion,
                            //         data.style.dim, data.style.glow, data.style.cable_dim, data.style.cable_glow, 
                            //         data.onconnect, data.ondisconnect,
                            //     ); 
                            // };
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            this.connectionNode_audio = function(
                                name='connectionNode_audio',
                                x, y, angle=0, width=20, height=20, allowConnections=true, allowDisconnections=true,
                                isAudioOutput=false, audioContext,
                                cableConnectionPosition={x:1/2,y:1/2},
                                cableVersion=1,
                                dimStyle={r:255/255, g:244/255, b:220/255, a:1},
                                glowStyle={r:255/255, g:244/255, b:244/255, a:1},
                                cable_dimStyle={r:247/255, g:146/255, b:84/255, a:1},
                                cable_glowStyle={r:242/255, g:168/255, b:123/255, a:1},
                                onconnect=function(instigator){},
                                ondisconnect=function(instigator){},
                            ){
                                //elements
                                    const object = interfacePart.builder('dynamic','connectionNode',name,{
                                        x:x, y:y, angle:angle, width:width, height:height, allowConnections:allowConnections, allowDisconnections:allowDisconnections, type:'audio', direction:(isAudioOutput ? 'out' : 'in'),
                                        cableConnectionPosition:cableConnectionPosition, cableVersion:cableVersion,
                                        style:{ dim:dimStyle, glow:glowStyle, cable_dim:cable_dimStyle, cable_glow:cable_glowStyle },
                                        onconnect, ondisconnect
                                    });
                                    object._direction = isAudioOutput ? 'out' : 'in';
                            
                                //circuitry
                                    object.audioNode = undefined; //audioContext.createAnalyser();
                            
                                    object._onconnect = function(instigator){
                                        if( object.audioNode == undefined ){
                                            console.warn('local audioNode missing');
                                            return;
                                        }
                                        if( object.getForeignNode().audioNode == undefined ){
                                            console.warn('foreign audioNode missing');
                                            return;
                                        }
                                        
                                        if(object._direction == 'out'){
                                            object.audioNode.connect(object.getForeignNode().audioNode);
                                        }
                                    };
                                    object._ondisconnect = function(instigator){
                                        if( object.audioNode == undefined ){
                                            console.warn('local audioNode missing');
                                            return;
                                        }
                                        if( object.getForeignNode().audioNode == undefined ){
                                            console.warn('foreign audioNode missing');
                                            return;
                                        }
                                        
                                        if(object._direction == 'out'){
                                            object.audioNode.disconnect(object.getForeignNode().audioNode);
                                        }
                                    };
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.dynamic.connectionNode_audio = function(name,data){
                                return interfacePart.collection.dynamic.connectionNode_audio(
                                    name, data.x, data.y, data.angle, data.width, data.height, data.allowConnections, data.allowDisconnections, data.isAudioOutput, _canvas_.library.audio.context, data.cableConnectionPosition, data.cableVersion,
                                    data.style.dim, data.style.glow, data.style.cable_dim, data.style.cable_glow, 
                                    data.onconnect, data.ondisconnect,
                                ); 
                            };
                            this.connectionNode_data = function(
                                name='connectionNode_data',
                                x, y, angle=0, width=20, height=20, 
                                allowConnections=true, allowDisconnections=true,
                                dimStyle={r:220/255, g:244/255, b:255/255, a:1},
                                glowStyle={r:244/255, g:244/255, b:255/255, a:1},
                                cable_dimStyle={r:84/255, g:146/255, b:247/255, a:1},
                                cable_glowStyle={r:123/255, g:168/255, b:242/255, a:1},
                                cableConnectionPosition={x:1/2,y:1/2},
                                cableVersion=1,
                                onreceive=function(address, data){},
                                ongive=function(address){},
                                onconnect=function(instigator){},
                                ondisconnect=function(instigator){},
                            ){
                                //elements
                                    const object = interfacePart.builder('dynamic','connectionNode',name,{
                                        x:x, y:y, angle:angle, width:width, height:height, allowConnections:allowConnections, allowDisconnections:allowDisconnections, type:'data',
                                        cableConnectionPosition:cableConnectionPosition, cableVersion:cableVersion,
                                        style:{ dim:dimStyle, glow:glowStyle, cable_dim:cable_dimStyle, cable_glow:cable_glowStyle },
                                        onconnect, ondisconnect
                                    });
                            
                                //circuitry
                                    object._flash = function(){
                                        this.activate();
                                        setTimeout(function(){ object.deactivate(); },100);
                                    };
                            
                                    object.send = function(address,data){
                                        object._flash();
                                        if(object.getForeignNode()!=undefined){ object.getForeignNode()._flash(); }
                            
                                        if(object.getForeignNode()!=undefined){ try{object.getForeignNode().onreceive(address,data);}catch(error){console.log('connectionNode_data::'+name+' onreceive error:',error);} }
                                    };
                                    object.request = function(address){
                                        object._flash();
                                        if(object.getForeignNode()!=undefined){ object.getForeignNode()._flash(); }
                            
                                        if(object.getForeignNode()!=undefined){ try{object.getForeignNode().ongive(address);}catch(error){console.log('connectionNode_data::'+name+' ongive error:',error);} }
                                    };
                            
                                    object.onreceive = onreceive;
                                    object.ongive = ongive;
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.dynamic.connectionNode_data = function(name,data){ 
                                return interfacePart.collection.dynamic.connectionNode_data(
                                    name, data.x, data.y, data.angle, data.width, data.height, data.allowConnections, data.allowDisconnections,
                                    data.style.dim, data.style.glow, data.style.cable_dim, data.style.cable_glow, data.cableConnectionPosition, data.cableVersion,
                                    data.onreceive, data.ongive, data.onconnect, data.ondisconnect,
                                ); 
                            };
                            this.connectionNode = function(
                                name='connectionNode',
                                x, y, angle=0, width=20, height=20, type='none', direction='',
                                allowConnections=true, allowDisconnections=true,
                                dimStyle={r:0.86,g:0.86,b:0.86,a:1},
                                glowStyle={r:0.95,g:0.95,b:0.95,a:1},
                                cable_dimStyle={r:0.57,g:0.57,b:0.57,a:1},
                                cable_glowStyle={r:0.84,g:0.84,b:0.84,a:1},
                                cableConnectionPosition={x:1/2,y:1/2},
                                cableVersion=1, proximityThreshold={distance:15, hysteresisDistance:1},
                                onconnect=function(instigator){},
                                ondisconnect=function(instigator){},
                            ){
                            
                                //elements
                                    //main
                                        const object = interfacePart.builder('basic','group',name,{x:x, y:y, angle:angle});
                                        object._connectionNode = true;
                                        object._type = type;
                                        object._direction = direction;
                                    //node
                                        const rectangle = interfacePart.builder('basic','rectangle','node',{ width:width, height:height, colour:dimStyle });
                                            object.append(rectangle);
                            
                                //network functions
                                    let foreignNode = undefined;
                            
                                    object._onconnect = function(instigator){};
                                    object._ondisconnect = function(instigator){};
                            
                                    object.isConnected = function(){ return cable != undefined; };
                                    object.canDisconnect = function(){ return this.allowDisconnections() && (foreignNode!=undefined && foreignNode.allowDisconnections()); };
                                    object.isAppropiateConnectionNode = function(potentialConnectionNode){
                                        if( object._type != potentialConnectionNode._type ){ return false; }
                                        if( (object._direction == '' || potentialConnectionNode._direction == '') && object._direction != potentialConnectionNode._direction ){ return false; }
                                        if( object._direction != '' && (potentialConnectionNode._direction == object._direction) ){ return false; }
                                        return true;
                                    };
                                    object.allowConnections = function(bool){
                                        if(bool == undefined){return allowConnections;}
                                        allowConnections = bool;
                                    };
                                    object.allowDisconnections = function(bool){
                                        if(bool == undefined){return allowDisconnections;}
                                        allowDisconnections = bool;
                                    };
                                    object.connectTo = function(new_foreignNode){
                            
                                        if( new_foreignNode == undefined){ return; }
                                        if( new_foreignNode == this ){ return; }
                                        if( new_foreignNode._type != this._type ){ return; }
                                        if( !this.isAppropiateConnectionNode(new_foreignNode) ){ return; }
                            
                                        if( new_foreignNode == foreignNode ){ return; }
                                        if( new_foreignNode.isConnected() && !new_foreignNode.canDisconnect() ){ return; }
                            
                                        this.disconnect();
                            
                                        foreignNode = new_foreignNode;
                                        this._onconnect(true);
                                        if(object.onconnect!=undefined){ try{object.onconnect(true);}catch(error){console.log('connectionNode::'+name+'::onconnect error',error);} }
                                        foreignNode._receiveConnection(this);
                            
                                        this._addCable(this);
                                    };
                                    object._receiveConnection = function(new_foreignNode){
                                        this.disconnect();
                                        foreignNode = new_foreignNode;
                                        this._onconnect(false);
                                        if(object.onconnect!=undefined){ try{object.onconnect(false);}catch(error){console.log('connectionNode::'+name+'::onconnect error:',error);} }
                                    };
                                    object.disconnect = function(){
                                        if( foreignNode == undefined ){return;}
                            
                                        this._removeCable();
                                        this._ondisconnect(true);
                                        if(object.ondisconnect!=undefined){try{object.ondisconnect(true);}catch(error){console.log('connectionNode::'+name+'::ondisconnect error:',error);}}
                                        foreignNode._receiveDisconnection();
                                        foreignNode = null;
                                    };
                                    object._receiveDisconnection = function(){
                                        this._ondisconnect(false);
                                        if(object.ondisconnect!=undefined){try{object.ondisconnect(false);}catch(error){console.log('connectionNode::'+name+'::ondisconnect error:',error);}}
                                        foreignNode = null;
                                    };
                                    object.getForeignNode = function(){ return foreignNode; };
                            
                                //cabling
                                    let cable;
                            
                                    object._addCable = function(){
                                        cable = interfacePart.builder('dynamic', 'cable', 'cable-'+object.getAddress().replace(/\//g, '_'),{ 
                                            x1:0,y1:0,x2:100,y2:100, angle:angle, version:cableVersion, 
                                            style:{dim:cable_dimStyle, glow:cable_glowStyle}
                                        });
                                        
                                        foreignNode._receiveCable(cable);
                                        const pane = _canvas_.system.pane.getMiddlegroundPane(this);
                                        pane.append(cable);
                                        object.draw();
                                        if(isActive){ cable.activate(); }
                                    }
                                    object._receiveCable = function(new_cable){
                                        cable = new_cable;
                                    };
                                    object._removeCable = function(){
                                        cable.parent.remove(cable);
                                        cable = undefined;
                                        foreignNode._loseCable();
                                    };
                                    object._loseCable = function(){
                                        cable = undefined;
                                    };
                                    object.getAttachmentPoint = function(){
                                        const offset = object.getOffset();
                                        const diagonalLength = Math.sqrt( Math.pow((rectangle.height()),2)/4 + Math.pow((rectangle.width()),2)/4 ) * offset.scale;
                                        const collectedAngle = offset.angle + Math.atan( rectangle.height()/rectangle.width() );
                            
                                        return {
                                            x: offset.x + (diagonalLength*Math.cos(collectedAngle))*cableConnectionPosition.x*2, 
                                            y: offset.y + (diagonalLength*Math.sin(collectedAngle))*cableConnectionPosition.y*2,
                                            angle: offset.angle
                                        };
                                    };
                                    object.draw = function(){
                                        if( cable == undefined ){return;}
                            
                                        const pointA = this.getAttachmentPoint();
                                        const pointB = foreignNode.getAttachmentPoint();
                            
                                        cable.draw(pointA.x,pointA.y,pointB.x,pointB.y,pointA.angle,pointB.angle);
                                    };
                            
                                //mouse interaction
                                    rectangle.attachCallback('onmousedown', function(x,y,event){
                                        let displacedNode = undefined;
                            
                                        let liveCable;
                                        function createLiveCable(){
                                            const pointA = object.getAttachmentPoint();
                                            const liveCable = interfacePart.builder(
                                                'dynamic', 'cable','liveCable-'+object.getAddress().replace(/\//g, '_'),
                                                { x1:pointA.x,y1:pointA.y,x2:x,y2:y, version:cableVersion, angle:angle, style:{dim:cable_dimStyle, glow:cable_glowStyle}}
                                            );
                                            _canvas_.system.pane.getMiddlegroundPane(object).append(liveCable);
                                            return liveCable;
                                        }
                            
                                        _canvas_.system.mouse.mouseInteractionHandler(
                                            function(x,y,event){
                                                if( !object.allowConnections() ){return;}
                                                if( object.isConnected() && !object.canDisconnect() ){return;}
                                                if( object.getForeignNode() != undefined && object.getForeignNode().isConnected() && !object.getForeignNode().canDisconnect() ){return;}
                            
                                                const mousePoint = _canvas_.core.viewport.adapter.windowPoint2workspacePoint(event.X,event.Y);
                            
                                                //gather connection nodes within proximity
                                                    const nodesWithinProximity = interfacePart.collection.dynamic.connectionNode.registry.map(node => {
                                                        if(node === object){return;}
                                                        const point = node.getAttachmentPoint();
                                                        const distance = Math.pow((Math.pow((point.x-mousePoint.x),2) + Math.pow((point.y-mousePoint.y),2)),1/2);
                                                        if(distance < proximityThreshold.distance){ return {node:node,distance:distance}; }
                                                    }).filter(item => item!=undefined).sort((a, b) => {return a.distance-b.distance});
                            
                                                //select node to snap to
                                                    let snapToNode = undefined;
                                                    if(nodesWithinProximity.length == 0){
                                                        if( object.isConnected() ){
                                                            const point = object.getForeignNode().getAttachmentPoint();
                                                            const distance = Math.pow((Math.pow((point.x-mousePoint.x),2) + Math.pow((point.y-mousePoint.y),2)),1/2);
                                                            snapToNode = distance > proximityThreshold.distance + proximityThreshold.hysteresisDistance ? undefined : object.getForeignNode();
                                                        }
                                                    }else if( nodesWithinProximity.length == 1 ){
                                                        if( object.isConnected() ){
                                                            const point = object.getForeignNode().getAttachmentPoint();
                                                            const distance = Math.pow((Math.pow((point.x-mousePoint.x),2) + Math.pow((point.y-mousePoint.y),2)),1/2);
                                                            snapToNode = distance > proximityThreshold.distance + proximityThreshold.hysteresisDistance ? nodesWithinProximity[0].node : object.getForeignNode();
                                                        }else{
                                                            snapToNode = nodesWithinProximity[0].node;
                                                        }
                                                    }else{
                                                        if(!object.isConnected()){
                                                            snapToNode = nodesWithinProximity[0].node;
                                                        }else{
                                                            const point = object.getForeignNode().getAttachmentPoint();
                                                            const currentlyConnectedNode = { node:object.getForeignNode(), distance:Math.pow((Math.pow((point.x-mousePoint.x),2) + Math.pow((point.y-mousePoint.y),2)),1/2) };
                                                            const relevantNodes = nodesWithinProximity.filter(node => node.node != object.getForeignNode() );
                            
                                                            snapToNode = currentlyConnectedNode.distance > relevantNodes[0].distance + proximityThreshold.hysteresisDistance ? relevantNodes[0].node : currentlyConnectedNode.node;
                                                        }
                                                    }
                                                
                                                //if no node is to be snapped to; use the liveCable, otherwise remove the live cable and attempt a connection
                                                    if( snapToNode == undefined || !snapToNode.allowConnections() || !object.isAppropiateConnectionNode(snapToNode) ){
                                                        if( liveCable == undefined ){
                                                            if( object.isConnected() && displacedNode!=undefined ){
                                                                object.getForeignNode().connectTo(displacedNode);
                                                                displacedNode = undefined;
                                                            }else{
                                                                object.disconnect();
                                                            }
                                                            liveCable = createLiveCable();
                                                        }
                            
                                                        const thisNode_point = object.getAttachmentPoint();
                                                        mousePoint.angle = _canvas_.library.math.getAngleOfTwoPoints(mousePoint,thisNode_point);
                                                        liveCable.draw( thisNode_point.x,thisNode_point.y, mousePoint.x,mousePoint.y, thisNode_point.angle,mousePoint.angle, false );
                                                    }else{
                                                        if(liveCable != undefined){
                                                            liveCable.parent.remove(liveCable);
                                                            liveCable = undefined;
                                                        }
                            
                                                        if( object.getForeignNode() != snapToNode ){
                                                            if( object.isConnected() && displacedNode != undefined ){
                                                                object.getForeignNode().connectTo(displacedNode);
                                                                displacedNode = undefined;
                                                            }
                                                            if( snapToNode.isConnected() ){
                                                                displacedNode = snapToNode.getForeignNode();
                                                            }
                                                            
                                                            object.connectTo(snapToNode);
                                                        }
                                                    }
                                            },
                                            function(x,y,event){
                                                if(liveCable != undefined){ liveCable.parent.remove(liveCable); liveCable = undefined; }
                                            }
                                        );
                                    } );
                                    rectangle.attachCallback('ondblclick', function(x,y,event){
                                        if(foreignNode == undefined || !(allowDisconnections && foreignNode.allowDisconnections()) ){return;}
                                        object.disconnect();
                                    } );
                            
                                //graphical
                                    let isActive = false;
                                    object.activate = function(){ 
                                        rectangle.colour(glowStyle);
                                        if(cable!=undefined){ cable.activate(); }
                                        isActive = true;
                                    }
                                    object.deactivate = function(){ 
                                        rectangle.colour(dimStyle);
                                        if(cable!=undefined){ cable.deactivate(); }
                                        isActive = false;
                                    }
                            
                                //callbacks
                                    object.onconnect = onconnect;
                                    object.ondisconnect = ondisconnect;
                            
                                //register self
                                    object.attachCallback('onadd', function(){
                                        interfacePart.collection.dynamic.connectionNode.registry.push(object);
                                    });
                                    object.attachCallback('onremove', function(){
                                        interfacePart.collection.dynamic.connectionNode.registry.splice(
                                            interfacePart.collection.dynamic.connectionNode.registry.indexOf(object), 
                                            1
                                        );
                                    });
                            
                                return object;
                            };
                            this.connectionNode.registry = [];
                            interfacePart.partLibrary.dynamic.connectionNode = function(name,data){ 
                                return interfacePart.collection.dynamic.connectionNode(
                                    name, data.x, data.y, data.angle, data.width, data.height, data.type, data.direction, data.allowConnections, data.allowDisconnections,
                                    data.style.dim, data.style.glow, data.style.cable_dim, data.style.cable_glow, data.cableConnectionPosition, data.cableVersion, data.proximityThreshold,
                                    data.onconnect, data.ondisconnect,
                                ); 
                            };
                            this.connectionNode_signal = function(
                                name='connectionNode_signal',
                                x, y, angle=0, width=20, height=20,
                                allowConnections=true, allowDisconnections=true,
                                dimStyle={r:1,g:0.86,b:0.95,a:1},
                                glowStyle={r:1,g:0.95,b:0.95,a:1},
                                cable_dimStyle={r:0.96,g:0.32,b:0.57,a:1},
                                cable_glowStyle={r:0.96,g:0.76,b:0.84,a:1},
                                cableConnectionPosition={x:1/2,y:1/2},
                                cableVersion=1,
                                onchange=function(value){},
                                onconnect=function(instigator){},
                                ondisconnect=function(instigator){},
                            ){
                                //elements
                                    const object = interfacePart.builder('dynamic','connectionNode',name,{
                                        x:x, y:y, angle:angle, width:width, height:height, allowConnections:allowConnections, allowDisconnections:allowDisconnections, type:'signal',
                                        cableConnectionPosition:cableConnectionPosition, cableVersion:cableVersion,
                                        style:{ dim:dimStyle, glow:glowStyle, cable_dim:cable_dimStyle, cable_glow:cable_glowStyle },
                                        onconnect, ondisconnect
                                    });
                            
                                //circuitry
                                    let localValue = false;
                            
                                    object._getLocalValue = function(){ return localValue; };
                                    object._update = function(){
                                        const val = object.read();
                                        if(val){ object.activate(); }
                                        else{ object.deactivate(); }
                                        try{object.onchange(val);}catch(error){console.log('connectionNode_signal::'+name+'::onchange error:',error);}
                                    }
                            
                                    object.set = function(a){
                                        if(typeof a != 'boolean'){return;}
                            
                                        localValue = a;
                            
                                        object._update();
                                        if(object.getForeignNode()!=undefined){ object.getForeignNode()._update(); }
                                    };
                                    object.read = function(){ return localValue || (object.getForeignNode() != undefined ? object.getForeignNode()._getLocalValue() : false); };
                            
                                    object._onconnect = function(instigator){
                                        if(object.getForeignNode()._getLocalValue()){object.activate();}
                                        try{object.onchange(object.getForeignNode()._getLocalValue());}catch(error){console.log('connectionNode_signal::'+name+'::onchange error:',error);}
                                    };
                                    object._ondisconnect = function(instigator){
                                        if(!localValue){object.deactivate();}
                                        try{object.onchange(localValue);}catch(error){console.log('connectionNode_signal::'+name+'::onchange error:',error);}
                                    };
                            
                                //callbacks
                                    object.onchange = onchange;
                            
                                return object;
                            };
                            
                            interfacePart.partLibrary.dynamic.connectionNode_signal = function(name,data){ 
                                return interfacePart.collection.dynamic.connectionNode_signal(
                                    name, data.x, data.y, data.angle, data.width, data.height, data.allowConnections, data.allowDisconnections,
                                    data.style.dim, data.style.glow, data.style.cable_dim, data.style.cable_glow, data.cableConnectionPosition, data.cableVersion,
                                    data.onchange, data.onconnect, data.ondisconnect,
                                ); 
                            };
                            this.cable = function(
                                name='cable', 
                                x1=0, y1=0, x2=0, y2=0,
                                dimStyle={r:1,g:0,b:0,a:1},
                                glowStyle={r:1,g:0.39,b:0.39,a:1},
                            ){
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name);
                                    //cable shape
                                        const path = interfacePart.builder('basic','path','cable',{ points:[x1,y1,x2,y2], colour:dimStyle, thickness:5 });
                                        object.append(path);
                                
                                //controls
                                    object.activate = function(){ path.colour(glowStyle); };
                                    object.deactivate = function(){ path.colour(dimStyle); };
                                    object.draw = function(new_x1,new_y1,new_x2,new_y2){
                                        x1 = (new_x1!=undefined ? new_x1 : x1); 
                                        y1 = (new_y1!=undefined ? new_y1 : y1);
                                        x2 = (new_x2!=undefined ? new_x2 : x2); 
                                        y2 = (new_y2!=undefined ? new_y2 : y2);
                                        path.points([x1,y1,x2,y2]);
                                    };
                                    object.draw();
                            
                                //identifier
                                    object._isCable = true;
                            
                                return object;
                            };
                            interfacePart.partLibrary.dynamic.cable = function(name,data){ 
                                switch(data.version){
                                    case 1: default:
                                        return interfacePart.collection.dynamic.cable(
                                            name, data.x1, data.y1, data.x2, data.y2,
                                            data.style.dim, data.style.glow,
                                        ); 
                                    case 2:
                                        return interfacePart.collection.dynamic.cable2(
                                            name, data.x1, data.y1, data.x2, data.y2, data.a1, data.a2, 
                                            data.style.dim, data.style.glow,
                                        ); 
                                }
                            };
                            this.cable2 = function(
                                name='cable2', 
                                x1=0, y1=0, x2=0, y2=0, a1=0, a2=0,
                                dimStyle={r:1,g:0,b:0,a:1},
                                glowStyle={r:1,g:0.39,b:0.39,a:1},
                            ){
                            
                                const push = 20;
                            
                                //elements 
                                    //main
                                        const object = interfacePart.builder('basic','group',name);
                                    //cable shape
                                        const pathShape = interfacePart.builder('basic','path','cable',{ points:[x1,y1,x2,y2], colour:dimStyle, thickness:5 });
                                        object.append(pathShape);
                                
                                //controls
                                    object.activate = function(){ pathShape.colour(glowStyle); };
                                    object.deactivate = function(){ pathShape.colour(dimStyle); };
                                    object.draw = function(new_x1,new_y1,new_x2,new_y2,new_angle1,new_angle2,avoidUnits=true,generateVisibilityGraph=true){
                                        x1 = new_x1==undefined ? x1 : new_x1;
                                        y1 = new_y1==undefined ? y1 : new_y1;
                                        a1 = new_angle1==undefined ? a1 : new_angle1;
                                        x2 = new_x2==undefined ? x2 : new_x2;
                                        y2 = new_y2==undefined ? y2 : new_y2;
                                        a2 = new_angle2==undefined ? a2 : new_angle2;
                            
                                        const offset_1 = _canvas_.library.math.cartesianAngleAdjust(push,0,a1);
                                        const offset_2 = _canvas_.library.math.cartesianAngleAdjust(push,0,a2);
                                        pathShape.points([
                                            x1,y1,
                                            x1+offset_1.x, y1+offset_1.y,
                                            x2+offset_2.x, y2+offset_2.y,
                                            x2,y2,
                                        ]);
                            
                                        // //if we're not to avoid units, just calculate the simple line between the two points (with push of course)
                                        //     if(!avoidUnits){
                                        //         const offset_1 = _canvas_.library.math.cartesianAngleAdjust(push,0,a1);
                                        //         const offset_2 = _canvas_.library.math.cartesianAngleAdjust(push,0,a2);
                                        //         pathShape.points([
                                        //             x1,y1,
                                        //             x1+offset_1.x, y1+offset_1.y,
                                        //             x2+offset_2.x, y2+offset_2.y,
                                        //             x2,y2,
                                        //         ]);
                                        //         return;
                                        //     }
                            
                                        // //calculate route while avoiding units
                                        //     let path = [];
                                        //     function calculateRoute(startPoint,endPoint,environment){
                                        //         //generate visibility graph
                                        //             const path = [];
                                        //             const startAndEndPoints = [ [startPoint], [endPoint] ].map(points => ({points:points, boundingBox:_canvas_.library.math.boundingBoxFromPoints(points)}) );
                                        //             const field = startAndEndPoints.concat(environment);
                                        //             const visibilityGraph = _canvas_.library.math.polygonsToVisibilityGraph( field );
                            
                                        //         //determine shortest route from visibility graph
                                        //             let generatedPath = _canvas_.library.math.shortestRouteFromVisibilityGraph(visibilityGraph, 0, 1);
                                        //             if(generatedPath.length == 1){
                                        //                 return generatedPath;
                                        //             }
                                        //             generatedPath.forEach(index => {
                                        //                 const tmp = visibilityGraph[index];
                                        //                 const point = field[tmp.polyIndex].points[tmp.pointIndex];
                                        //                 path.push(point.x,point.y);
                                        //             });
                            
                                        //         return path;
                                        //     }
                            
                                        //     //place initial point
                                        //         path.push(x1,y1);
                            
                                        //         if( _canvas_.system.pane.getMiddlegroundPane(this) == undefined ){ 
                                        //             pathShape.points( [x1,y1,x2,y2] );
                                        //             return;
                                        //         }
                            
                                        //         const offset_1 = _canvas_.library.math.cartesianAngleAdjust(push,0,a1);
                                        //         const offset_2 = _canvas_.library.math.cartesianAngleAdjust(push,0,a2);
                                        //         const environment = _canvas_.system.pane.getMiddlegroundPane(this).getChildren().filter(a => !a._isCable).map(a => a.space);
                                        //         const generatedPath = calculateRoute( {x:x1+offset_1.x, y:y1+offset_1.y}, {x:x2+offset_2.x, y:y2+offset_2.y}, environment );
                                        //         if(generatedPath.length == 0){
                                        //         }else if(generatedPath.length == 1){
                                        //             if(generatedPath[0] == 0){
                                        //                 const offset_2 = _canvas_.library.math.cartesianAngleAdjust(0,0,a2);
                                        //             }
                                        //             if(generatedPath[0] == 1){
                                        //                 const offset_1 = _canvas_.library.math.cartesianAngleAdjust(0,0,a1);
                                        //             }
                                        //             if(generatedPath[0] != 0 && generatedPath[0] != 1){
                                        //                 console.error('cable2.draw: major error: unknown path point in error');
                                        //                 pathShape.points( [x1,y1,x2,y2] );
                                        //                 return;
                                        //             }
                            
                                        //             const secondGeneratedPath = calculateRoute( {x:x1+offset_1.x, y:y1+offset_1.y}, {x:x2+offset_2.x, y:y2+offset_2.y}, environment );
                                        //             if(secondGeneratedPath.length == 1){
                                        //                 pathShape.points( [x1,y1,x2,y2] );
                                        //                 return;
                                        //             }
                                        //             path = path.concat( secondGeneratedPath );
                                        //         }else{
                                        //             path = path.concat( generatedPath );
                                        //         }
                            
                                        //     //place final point
                                        //         path.push(x2,y2);
                            
                                        //     pathShape.points(path);
                                    };
                                    object.draw();
                            
                                //identifier
                                    object._isCable = true;
                            
                                return object;
                            };
                            this.cable2.visibilityGraph = [];
                            this.cable2.globalDraw = function(pane=_canvas_.system.pane.mm){
                                // pane.getChildren().filter(a => a._isCable).forEach(cable => cable.draw());
                                // pane.getChildren().filter(a => a._isCable).forEach(cable => cable.draw(undefined,undefined,undefined,undefined,undefined,undefined,undefined,false));
                            };
                        };
                    };

                };
                this.unit = new function(){
                    this.collection = new function(){
                        this.test = new function(){
                            const testUnit = this;
                            
                            this.testUnit_1 = function(name,x,y,angle){
                                const design = {
                                    name: name,
                                    model: 'testUnit_1',
                                    collection: 'test',
                                    x:x, y:y, angle:angle,
                                    space: [
                                        {x:-5,y:-5}, 
                                        {x:280,y:-5}, 
                                        {x:280,y:30}, 
                                        {x:605,y:30}, 
                                        {x:605,y:130}, 
                                        {x:705,y:130}, 
                                        {x:705,y:210}, 
                                        {x:240,y:210}, 
                                        {x:240,y:325}, 
                                        {x:430,y:325}, 
                                        {x:430,y:435}, 
                                        {x:-5,y:445}
                                    ],
                                    // spaceOutline: true,
                                    elements:[
                                        //basic
                                            {collection:'basic', type:'rectangle', name:'testRectangle', data:{ x:5, y:5, width:30, height:30, colour:{r:1,g:0,b:0,a:1} }},
                                            {collection:'basic', type:'circle', name:'testCircle', data:{ x:20, y:55, radius:15 }},
                                            {collection:'basic', type:'polygon', name:'testPolygon', data:{ points:[55,5, 70,35, 40,35], colour:{r:0,g:1,b:0,a:1} }},
                                            {collection:'basic', type:'path', name:'testPath', data:{ points:[0,0, 0,90, 2.5,90, 2.5,72.5, 75,72.5], thickness:1.25, jointType:'round', capType:'round' }},
                                            {collection:'basic', type:'image', name:'testImage', data:{ x:40, y:40, width:30, height:30, url:'/images/testImages/Dore-munchausen-illustration.jpg' }},
                                            {collection:'basic', type:'text', name: 'testText', data:{ x:5, y:75, text:'Hello', height:15, width:70, colour:{r:150/255,g:150/255,b:1,a:1} }},
                                            {collection:'basic', type:'rectangleWithOutline', name:'testRectangleWithOutline', data:{ x:105, y:60, width:30, height:30 }},
                                            {collection:'basic', type:'circleWithOutline', name:'testCircleWithOutline', data:{ x:90, y:70, radius:10 }},
                                            {collection:'basic', type:'polygonWithOutline', name:'testPolygonWithOutline', data:{ points:[75,15, 75,55, 115,55], thickness:1, colour:{r:1,g:0,b:0.5,a:1}, lineColour:{r:0,g:0,b:0,a:1} }},
                                            {collection:'basic', type:'canvas', name:'testCanvas', data:{ x:130, y:5, width:30, height:30 }},
                                        //display
                                            {collection:'display', type:'glowbox_rectangle', name:'test_glowbox_rectangle', data:{x:0, y:140}},
                                            {collection:'display', type:'glowbox_circle', name:'test_glowbox_circle', data:{x:15, y:185}},
                                            {collection:'display', type:'glowbox_image', name:'test_glowbox_image', data:{x:0, y:200, glowURL:'/images/testImages/Dore-munchausen-illustration.jpg', dimURL:'/images/testImages/mikeandbrian.jpg'}},
                                            {collection:'display', type:'glowbox_polygon', name:'test_glowbox_polygon', data:{x:0, y:235}},
                                            {collection:'display', type:'glowbox_path', name:'test_glowbox_path', data:{x:0, y:270}},
                                            {collection:'display', type:'sevenSegmentDisplay', name:'test_sevenSegmentDisplay', data:{x:35, y:140}},
                                            {collection:'display', type:'sevenSegmentDisplay', name:'test_sevenSegmentDisplay_canvasBased', data:{x:35, y:175, canvasBased:true}},
                                            {collection:'display', type:'sixteenSegmentDisplay', name:'test_sixteenSegmentDisplay', data:{x:60, y:140}},
                                            {collection:'display', type:'sixteenSegmentDisplay', name:'test_sixteenSegmentDisplay_canvasBased', data:{x:60, y:175, canvasBased:true}},
                                            {collection:'display', type:'readout_sevenSegmentDisplay', name:'test_readout_sevenSegmentDisplay', data:{x:85, y:140}},
                                            {collection:'display', type:'readout_sevenSegmentDisplay', name:'test_readout_sevenSegmentDisplay_canvasBased', data:{x:85, y:175, canvasBased:true}},
                                            {collection:'display', type:'readout_sixteenSegmentDisplay', name:'test_readout_sixteenSegmentDisplay', data:{x:190, y:140}},
                                            {collection:'display', type:'readout_sixteenSegmentDisplay', name:'test_readout_sixteenSegmentDisplay_canvasBased', data:{x:190, y:175, canvasBased:true}},
                                            {collection:'display', type:'level', name:'test_level', data:{x:295, y:140}},
                                            {collection:'display', type:'meter_level', name:'test_meter_level', data:{x:320, y:140}},
                                            {collection:'display', type:'audio_meter_level', name:'test_audio_meter_level', data:{x:345, y:140}},
                                            {collection:'display', type:'gauge', name:'test_gauge', data:{x:370, y:140}},
                                            {collection:'display', type:'gauge_image', name:'test_gauge_image', data:{x:425, y:140, backingURL:'/images/testImages/Dore-munchausen-illustration.jpg'}},
                                            {collection:'display', type:'meter_gauge', name:'test_meter_gauge', data:{x:370, y:175, markings:{ upper:'...........'.split(''), middle:'.........'.split(''), lower:'.......'.split('') }, style:{markingStyle_font:'defaultThin'}}},
                                            {collection:'display', type:'meter_gauge_image', name:'test_meter_gauge_image', data:{x:425, y:175, backingURL:'/images/testImages/mikeandbrian.jpg'}},
                                            {collection:'display', type:'rastorDisplay', name:'test_rastorDisplay', data:{x:480, y:140}},
                                            {collection:'display', type:'grapher', name:'test_grapher', data:{x:550, y:140}},
                                            {collection:'display', type:'grapher', name:'test_grapher_canvasBased', data:{x:550, y:205, canvasBased:true}},
                                            {collection:'display', type:'grapher_periodicWave', name:'test_grapher_periodicWave', data:{x:675, y:140}},
                                            {collection:'display', type:'grapher_periodicWave', name:'test_grapher_periodicWave_canvasBased', data:{x:675, y:205, canvasBased:true}},
                                            {collection:'display', type:'grapher_audioScope', name:'test_grapher_audioScope', data:{x:800, y:140}},
                                            {collection:'display', type:'grapher_audioScope', name:'test_grapher_audioScope_canvasBased', data:{x:800, y:205, canvasBased:true}},
                                        //control
                                            {collection:'control', type:'button_rectangle', name:'test_button_rectangle', data:{
                                                x:0, y:350, text_centre:'rectangle', style:{text__hover__colour:{r:1,g:0,b:0,a:1}}
                                            } },
                                            {collection:'control', type:'button_circle', name:'test_button_circle', data:{
                                                x:15, y:387.5, text_centre:'circle', style:{text__hover__colour:{r:1,g:0,b:0,a:1}}
                                            } },
                                            {collection:'control', type:'button_polygon', name:'test_button_polygon', data:{
                                                x:0,y:405, points:[{x:0,y:5},{x:5,y:0}, {x:25,y:0},{x:30,y:5}, {x:30,y:25},{x:25,y:30}, {x:5,y:30},{x:0,y:25}],style:{text__hover__colour:{r:1,g:0,b:0,a:1}},
                                                text_centre:'polygon'
                                            } },
                                            {collection:'control', type:'button_image', name:'test_button_image', data:{
                                                x:0, y:437.5,
                                                backingURL__off:'/images/testImages/buttonStates/off.png',
                                                backingURL__up:'/images/testImages/buttonStates/up.png',
                                                backingURL__press:'/images/testImages/buttonStates/press.png',
                                                backingURL__select:'/images/testImages/buttonStates/select.png',
                                                backingURL__select_press:'/images/testImages/buttonStates/select_press.png',
                                                backingURL__glow:'/images/testImages/buttonStates/glow.png',
                                                backingURL__glow_press:'/images/testImages/buttonStates/glow_press.png',
                                                backingURL__glow_select:'/images/testImages/buttonStates/glow_select.png',
                                                backingURL__glow_select_press:'/images/testImages/buttonStates/glow_select_press.png',
                                                backingURL__hover:'/images/testImages/buttonStates/hover.png',
                                                backingURL__hover_press:'/images/testImages/buttonStates/hover_press.png',
                                                backingURL__hover_select:'/images/testImages/buttonStates/hover_select.png',
                                                backingURL__hover_select_press:'/images/testImages/buttonStates/hover_select_press.png',
                                                backingURL__hover_glow:'/images/testImages/buttonStates/hover_glow.png',
                                                backingURL__hover_glow_press:'/images/testImages/buttonStates/hover_glow_press.png',
                                                backingURL__hover_glow_select:'/images/testImages/buttonStates/hover_glow_select.png',
                                                backingURL__hover_glow_select_press:'/images/testImages/buttonStates/hover_glow_select_press.png',
                                            } },
                                            {collection:'control', type:'checkbox_rectangle', name:'test_checkbox_rectangle', data:{x:35, y:350} },
                                            {collection:'control', type:'checkbox_circle', name:'test_checkbox_circle', data:{x:45, y:387.5} },
                                            {collection:'control', type:'checkbox_polygon', name:'test_checkbox_polygon', data:{
                                                x:35, y:405,
                                                outterPoints:[{x:0,y:4},{x:4,y:0}, {x:16,y:0},{x:20,y:4}, {x:20,y:16},{x:16,y:20},{x:4,y:20},{x:0,y:16}],
                                                innerPoints:[ {x:2,y:4},{x:4,y:2}, {x:16,y:2},{x:18,y:4}, {x:18,y:16},{x:16,y:18}, {x:4,y:18},{x:2,y:16}],
                                            } },
                                            {collection:'control', type:'checkbox_image', name:'test_checkbox_image', data:{
                                                x:35, y:87.355,
                                                uncheckURL:'/images/testImages/Dore-munchausen-illustration.jpg',
                                                checkURL:'/images/testImages/mikeandbrian.jpg',
                                            } },
                                            {collection:'control', type:'checkboxgrid', name:'test_checkboxgrid', data:{x:60, y:350} },
                                            {collection:'control', type:'dial_1_continuous', name:'test_dial_1_continuous', data:{x:160, y:360} },
                                            {collection:'control', type:'dial_2_continuous', name:'test_dial_2_continuous', data:{x:185, y:360} },
                                            {collection:'control', type:'dial_1_discrete', name:'test_dial_1_discrete', data:{x:160, y:385} },
                                            {collection:'control', type:'dial_2_discrete', name:'test_dial_2_discrete', data:{x:185, y:385} },
                                            {collection:'control', type:'dial_continuous_image', name:'test_dial_continuous_image', data:{
                                                x:210, y:360, 
                                                handleURL:'/images/testImages/expanded-metal-1.jpg',
                                                slotURL:'/images/testImages/dark-background_1048-3848.jpg?size=338&ext=jpg',
                                                needleURL:'/images/testImages/41-satin-stainless-steel.jpg',
                                            } },
                                            {collection:'control', type:'dial_discrete_image', name:'test_dial_discrete_image', data:{
                                                x:210, y:385, 
                                                handleURL:'/images/testImages/expanded-metal-1.jpg',
                                                slotURL:'/images/testImages/dark-background_1048-3848.jpg?size=338&ext=jpg',
                                                needleURL:'/images/testImages/41-satin-stainless-steel.jpg',
                                            } },
                                            {collection:'control', type:'slide_continuous', name:'test_slide_continuous', data:{x:230, y:350} },
                                            {collection:'control', type:'slide_continuous_image', name:'test_slide_continuous_image', data:{
                                                x:245, y:350,
                                                handleURL:'/images/testImages/expanded-metal-1.jpg',
                                                backingURL:'/images/testImages/41-satin-stainless-steel.jpg',
                                            } },
                                            {collection:'control', type:'slide_discrete', name:'test_slide_discrete', data:{x:260, y:350} },
                                            {collection:'control', type:'slide_discrete_image', name:'test_slide_discrete_image', data:{
                                                x:275, y:350,
                                                handleURL:'/images/testImages/expanded-metal-1.jpg',
                                                backingURL:'/images/testImages/41-satin-stainless-steel.jpg',
                                            } },
                                            {collection:'control', type:'slidePanel', name:'test_slidePanel', data:{x:290, y:350} },
                                            {collection:'control', type:'slidePanel_image', name:'test_slidePanel_image', data:{
                                                x:375, y:350,
                                                handleURL:'/images/testImages/expanded-metal-1.jpg',
                                                backingURL:'/images/testImages/41-satin-stainless-steel.jpg',
                                            } },
                                            {collection:'control', type:'rangeslide', name:'test_rangeslide', data:{x:460, y:350} },
                                            {collection:'control', type:'rangeslide_image', name:'test_rangeslide_image', data:{
                                                x:475, y:350,
                                                handleURL:'/images/testImages/expanded-metal-1.jpg',
                                                backingURL:'/images/testImages/41-satin-stainless-steel.jpg',
                                                spanURL:'/images/testImages/dark-background_1048-3848.jpg',
                                            } },
                                            {collection:'control', type:'list', name:'test_list', data:{
                                                x:490, y:350, heightLimit:100, widthLimit:50,
                                                list:[
                                                    { type:'space' },
                                                    { type:'break' },
                                                    { type:'break' },
                                                    { type:'break' },
                                                    { type:'break' },
                                                    { type:'break' },
                                                    { type:'break' },
                                                    { type:'break' },
                                                    { type:'break' },
                                                    { type:'break' },
                                                    { type:'break' },
                                                    { type:'break' },
                                                    { type:'break' },
                                                    { type:'break' },
                                                    { type:'break' },
                                                    { type:'break' },
                            
                                                    { type:'space' },
                            
                                                    { type:'textbreak', text:'break 1'},
                                                    { type:'textbreak', text:'break 2'},
                                                    { type:'textbreak', text:'break 3'},
                                                    { type:'textbreak', text:'break 4'},
                                                    { type:'textbreak', text:'break 5'},
                                                    { type:'textbreak', text:'break 6'},
                                                    { type:'textbreak', text:'break 7'},
                                                    { type:'textbreak', text:'break 8'},
                                                    { type:'textbreak', text:'break 9'},
                                                    { type:'textbreak', text:'break 10'},
                                                    { type:'textbreak', text:'break 11'},
                                                    { type:'textbreak', text:'break 12'},
                                                    { type:'textbreak', text:'break 13'},
                                                    { type:'textbreak', text:'break 14'},
                                                    { type:'textbreak', text:'break 15'},
                            
                                                    { type:'space' },
                            
                                                    { type:'text', text_left:'left', text_centre:'1',  text_right:'right' },
                                                    { type:'text', text_left:'left', text_centre:'2',  text_right:'right' },
                                                    { type:'text', text_left:'left', text_centre:'3',  text_right:'right' },
                                                    { type:'text', text_left:'left', text_centre:'4',  text_right:'right' },
                                                    { type:'text', text_left:'left', text_centre:'5',  text_right:'right' },
                                                    { type:'text', text_left:'left', text_centre:'6',  text_right:'right' },
                                                    { type:'text', text_left:'left', text_centre:'7',  text_right:'right' },
                                                    { type:'text', text_left:'left', text_centre:'8',  text_right:'right' },
                                                    { type:'text', text_left:'left', text_centre:'9',  text_right:'right' },
                                                    { type:'text', text_left:'left', text_centre:'10', text_right:'right' },
                                                    { type:'text', text_left:'left', text_centre:'11', text_right:'right' },
                                                    { type:'text', text_left:'left', text_centre:'12', text_right:'right' },
                                                    { type:'text', text_left:'left', text_centre:'13', text_right:'right' },
                                                    { type:'text', text_left:'left', text_centre:'14', text_right:'right' },
                                                    { type:'text', text_left:'left', text_centre:'15', text_right:'right' },
                            
                                                    { type:'space' },
                            
                                                    { type:'checkbox', text:'checkable 1',  updateFunction:function(){return true;},  onclickFunction:function(val){console.log('checkbox:',val);} },
                                                    { type:'checkbox', text:'checkable 2',  updateFunction:function(){return false;}, onclickFunction:function(val){console.log('checkbox:',val);} },
                                                    { type:'checkbox', text:'checkable 3',  updateFunction:function(){return true;},  onclickFunction:function(val){console.log('checkbox:',val);} },
                                                    { type:'checkbox', text:'checkable 4',  updateFunction:function(){return false;}, onclickFunction:function(val){console.log('checkbox:',val);} },
                                                    { type:'checkbox', text:'checkable 5',  updateFunction:function(){return true;},  onclickFunction:function(val){console.log('checkbox:',val);} },
                                                    { type:'checkbox', text:'checkable 6',  updateFunction:function(){return true;},  onclickFunction:function(val){console.log('checkbox:',val);} },
                                                    { type:'checkbox', text:'checkable 7',  updateFunction:function(){return false;}, onclickFunction:function(val){console.log('checkbox:',val);} },
                                                    { type:'checkbox', text:'checkable 8',  updateFunction:function(){return true;},  onclickFunction:function(val){console.log('checkbox:',val);} },
                                                    { type:'checkbox', text:'checkable 9',  updateFunction:function(){return false;}, onclickFunction:function(val){console.log('checkbox:',val);} },
                                                    { type:'checkbox', text:'checkable 10', updateFunction:function(){return true;},  onclickFunction:function(val){console.log('checkbox:',val);} },
                                                    { type:'checkbox', text:'checkable 11', updateFunction:function(){return false;}, onclickFunction:function(val){console.log('checkbox:',val);} },
                                                    { type:'checkbox', text:'checkable 12', updateFunction:function(){return false;}, onclickFunction:function(val){console.log('checkbox:',val);} },
                                                    { type:'checkbox', text:'checkable 13', updateFunction:function(){return false;}, onclickFunction:function(val){console.log('checkbox:',val);} },
                                                    { type:'checkbox', text:'checkable 14', updateFunction:function(){return true;},  onclickFunction:function(val){console.log('checkbox:',val);} },
                                                    { type:'checkbox', text:'checkable 15', updateFunction:function(){return false;}, onclickFunction:function(val){console.log('checkbox:',val);} },
                            
                                                    { type:'space' },
                            
                                                    { type:'button', text_left:'item1',  text_centre:'', text_right:'', function:function(){console.log('item1 function');}  },
                                                    { type:'button', text_left:'item2',  text_centre:'', text_right:'', function:function(){console.log('item2 function');}  },
                                                    { type:'button', text_left:'item3',  text_centre:'', text_right:'', function:function(){console.log('item3 function');}  },
                                                    { type:'button', text_left:'item4',  text_centre:'', text_right:'', function:function(){console.log('item4 function');}  },
                                                    { type:'button', text_left:'item5',  text_centre:'', text_right:'', function:function(){console.log('item5 function');}  },
                                                    { type:'button', text_left:'item6',  text_centre:'', text_right:'', function:function(){console.log('item6 function');}  },
                                                    { type:'button', text_left:'item7',  text_centre:'', text_right:'', function:function(){console.log('item7 function');}  },
                                                    { type:'button', text_left:'item8',  text_centre:'', text_right:'', function:function(){console.log('item8 function');}  },
                                                    { type:'button', text_left:'item9',  text_centre:'', text_right:'', function:function(){console.log('item9 function');}  },
                                                    { type:'button', text_left:'item10', text_centre:'', text_right:'', function:function(){console.log('item10 function');} },
                                                    { type:'button', text_left:'item11', text_centre:'', text_right:'', function:function(){console.log('item11 function');} },
                                                    { type:'button', text_left:'item12', text_centre:'', text_right:'', function:function(){console.log('item12 function');} },
                                                    { type:'button', text_left:'item13', text_centre:'', text_right:'', function:function(){console.log('item13 function');} },
                                                    { type:'button', text_left:'item14', text_centre:'', text_right:'', function:function(){console.log('item14 function');} },
                                                    { type:'button', text_left:'item15', text_centre:'', text_right:'', function:function(){console.log('item15 function');} },
                            
                                                    { type:'space' },
                            
                                                    { type:'list', text:'sublist 1', list:[
                                                        { type:'space' },
                                                        { type:'break' },
                                                        { type:'break' },
                                                        { type:'break' },
                                                        { type:'break' },
                                                        { type:'break' },
                                                        { type:'break' },
                                                        { type:'break' },
                                                        { type:'break' },
                                                        { type:'break' },
                                                        { type:'break' },
                                                        { type:'break' },
                                                        { type:'break' },
                                                        { type:'break' },
                                                        { type:'break' },
                                                        { type:'break' },
                                                        { type:'space' },
                                                    ] },
                                                    { type:'list', text:'sublist 2', heightLimit:100, list:[
                                                        { type:'space' },
                                                        { type:'textbreak', text:'break 1'},
                                                        { type:'textbreak', text:'break 2'},
                                                        { type:'textbreak', text:'break 3'},
                                                        { type:'textbreak', text:'break 4'},
                                                        { type:'textbreak', text:'break 5'},
                                                        { type:'textbreak', text:'break 6'},
                                                        { type:'textbreak', text:'break 7'},
                                                        { type:'textbreak', text:'break 8'},
                                                        { type:'textbreak', text:'break 9'},
                                                        { type:'textbreak', text:'break 10'},
                                                        { type:'textbreak', text:'break 11'},
                                                        { type:'textbreak', text:'break 12'},
                                                        { type:'textbreak', text:'break 13'},
                                                        { type:'textbreak', text:'break 14'},
                                                        { type:'textbreak', text:'break 15'},
                                                        { type:'space' },
                                                    ] },
                                                    { type:'list', text:'sublist 3', heightLimit:100, list:[
                                                        { type:'space' },
                                                        { type:'text', text_left:'left', text_centre:'1',  text_right:'right' },
                                                        { type:'text', text_left:'left', text_centre:'2',  text_right:'right' },
                                                        { type:'text', text_left:'left', text_centre:'3',  text_right:'right' },
                                                        { type:'text', text_left:'left', text_centre:'4',  text_right:'right' },
                                                        { type:'text', text_left:'left', text_centre:'5',  text_right:'right' },
                                                        { type:'text', text_left:'left', text_centre:'6',  text_right:'right' },
                                                        { type:'text', text_left:'left', text_centre:'7',  text_right:'right' },
                                                        { type:'text', text_left:'left', text_centre:'8',  text_right:'right' },
                                                        { type:'text', text_left:'left', text_centre:'9',  text_right:'right' },
                                                        { type:'text', text_left:'left', text_centre:'10', text_right:'right' },
                                                        { type:'text', text_left:'left', text_centre:'11', text_right:'right' },
                                                        { type:'text', text_left:'left', text_centre:'12', text_right:'right' },
                                                        { type:'text', text_left:'left', text_centre:'13', text_right:'right' },
                                                        { type:'text', text_left:'left', text_centre:'14', text_right:'right' },
                                                        { type:'text', text_left:'left', text_centre:'15', text_right:'right' },
                                                        { type:'space' },
                                                    ] },
                                                    { type:'list', text:'sublist 4', heightLimit:100, list:[
                                                        { type:'space' },
                                                        { type:'checkbox', text:'checkable 1',  updateFunction:function(){return true;},  onclickFunction:function(val){console.log('checkbox:',val);} },
                                                        { type:'checkbox', text:'checkable 2',  updateFunction:function(){return false;}, onclickFunction:function(val){console.log('checkbox:',val);} },
                                                        { type:'checkbox', text:'checkable 3',  updateFunction:function(){return true;},  onclickFunction:function(val){console.log('checkbox:',val);} },
                                                        { type:'checkbox', text:'checkable 4',  updateFunction:function(){return false;}, onclickFunction:function(val){console.log('checkbox:',val);} },
                                                        { type:'checkbox', text:'checkable 5',  updateFunction:function(){return true;},  onclickFunction:function(val){console.log('checkbox:',val);} },
                                                        { type:'checkbox', text:'checkable 6',  updateFunction:function(){return true;},  onclickFunction:function(val){console.log('checkbox:',val);} },
                                                        { type:'checkbox', text:'checkable 7',  updateFunction:function(){return false;}, onclickFunction:function(val){console.log('checkbox:',val);} },
                                                        { type:'checkbox', text:'checkable 8',  updateFunction:function(){return true;},  onclickFunction:function(val){console.log('checkbox:',val);} },
                                                        { type:'checkbox', text:'checkable 9',  updateFunction:function(){return false;}, onclickFunction:function(val){console.log('checkbox:',val);} },
                                                        { type:'checkbox', text:'checkable 10', updateFunction:function(){return true;},  onclickFunction:function(val){console.log('checkbox:',val);} },
                                                        { type:'checkbox', text:'checkable 11', updateFunction:function(){return false;}, onclickFunction:function(val){console.log('checkbox:',val);} },
                                                        { type:'checkbox', text:'checkable 12', updateFunction:function(){return false;}, onclickFunction:function(val){console.log('checkbox:',val);} },
                                                        { type:'checkbox', text:'checkable 13', updateFunction:function(){return false;}, onclickFunction:function(val){console.log('checkbox:',val);} },
                                                        { type:'checkbox', text:'checkable 14', updateFunction:function(){return true;},  onclickFunction:function(val){console.log('checkbox:',val);} },
                                                        { type:'checkbox', text:'checkable 15', updateFunction:function(){return false;}, onclickFunction:function(val){console.log('checkbox:',val);} },
                                                        { type:'space' },
                                                    ] },
                                                    { type:'list', text:'sublist 5', heightLimit:100, list:[
                                                        { type:'space' },
                                                        { type:'button', text_left:'item1',  text_centre:'', text_right:'', function:function(){console.log('item1 function');}  },
                                                        { type:'button', text_left:'item2',  text_centre:'', text_right:'', function:function(){console.log('item2 function');}  },
                                                        { type:'button', text_left:'item3',  text_centre:'', text_right:'', function:function(){console.log('item3 function');}  },
                                                        { type:'button', text_left:'item4',  text_centre:'', text_right:'', function:function(){console.log('item4 function');}  },
                                                        { type:'button', text_left:'item5',  text_centre:'', text_right:'', function:function(){console.log('item5 function');}  },
                                                        { type:'button', text_left:'item6',  text_centre:'', text_right:'', function:function(){console.log('item6 function');}  },
                                                        { type:'button', text_left:'item7',  text_centre:'', text_right:'', function:function(){console.log('item7 function');}  },
                                                        { type:'button', text_left:'item8',  text_centre:'', text_right:'', function:function(){console.log('item8 function');}  },
                                                        { type:'button', text_left:'item9',  text_centre:'', text_right:'', function:function(){console.log('item9 function');}  },
                                                        { type:'button', text_left:'item10', text_centre:'', text_right:'', function:function(){console.log('item10 function');} },
                                                        { type:'button', text_left:'item11', text_centre:'', text_right:'', function:function(){console.log('item11 function');} },
                                                        { type:'button', text_left:'item12', text_centre:'', text_right:'', function:function(){console.log('item12 function');} },
                                                        { type:'button', text_left:'item13', text_centre:'', text_right:'', function:function(){console.log('item13 function');} },
                                                        { type:'button', text_left:'item14', text_centre:'', text_right:'', function:function(){console.log('item14 function');} },
                                                        { type:'button', text_left:'item15', text_centre:'', text_right:'', function:function(){console.log('item15 function');} },
                                                        { type:'button', text_left:'item16', text_centre:'', text_right:'', function:function(){console.log('item16 function');} },
                                                        { type:'space' },
                                                    ] },
                                                    { type:'space' },
                                                ]
                                            } },
                                            {collection:'control', type:'needleOverlay', name:'test_needleOverlay', data:{x:545, y:350} },
                                            {collection:'control', type:'grapher_waveWorkspace', name:'test_grapher_waveWorkspace', data:{x:670,y:350} },
                                            {collection:'control', type:'sequencer', name:'test_sequencer', data:{x:795,y:350,zoomLevel_x:1/2}  },
                                        //dynamic
                                            {collection:'dynamic', type:'connectionNode', name:'test_connectionNode1', data:{ x:25, y:535 }},
                                            {collection:'dynamic', type:'connectionNode', name:'test_connectionNode2', data:{ x:0, y:585 }},
                                            {collection:'dynamic', type:'connectionNode', name:'test_connectionNode3', data:{ x:50, y:585 }},
                                            {collection:'dynamic', type:'connectionNode_signal', name:'test_connectionNode_signal1', data:{ x:125, y:535 }},
                                            {collection:'dynamic', type:'connectionNode_signal', name:'test_connectionNode_signal2', data:{ x:100, y:585 }},
                                            {collection:'dynamic', type:'connectionNode_signal', name:'test_connectionNode_signal3', data:{ x:150, y:585 }},
                                            {collection:'dynamic', type:'connectionNode_voltage', name:'test_connectionNode_voltage1', data:{ x:225, y:535 }},
                                            {collection:'dynamic', type:'connectionNode_voltage', name:'test_connectionNode_voltage2', data:{ x:200, y:585 }},
                                            {collection:'dynamic', type:'connectionNode_voltage', name:'test_connectionNode_voltage3', data:{ x:250, y:585 }},
                                            {collection:'dynamic', type:'connectionNode_data', name:'test_connectionNode_data1', data:{ x:325, y:535 }},
                                            {collection:'dynamic', type:'connectionNode_data', name:'test_connectionNode_data2', data:{ x:300, y:585 }},
                                            {collection:'dynamic', type:'connectionNode_data', name:'test_connectionNode_data3', data:{ x:350, y:585 }},
                                            {collection:'dynamic', type:'connectionNode_audio', name:'test_connectionNode_audio1', data:{ x:425, y:535, isAudioOutput:true}},
                                            {collection:'dynamic', type:'connectionNode_audio', name:'test_connectionNode_audio2', data:{ x:400, y:585 }},
                                            {collection:'dynamic', type:'connectionNode_audio', name:'test_connectionNode_audio3', data:{ x:450, y:585 }},
                                    ],
                                };
                            
                                //main object
                                    const object = interface.unit.builder(design);
                            
                                //playing with the parts
                                    const $ = object.elements.canvas.testCanvas.$;
                                    object.elements.canvas.testCanvas._.fillStyle = _canvas_.library.math.convertColour.obj2rgba({r:0.9,g:0.9,b:0.9,a:1});
                                    object.elements.canvas.testCanvas._.fillRect($(0),$(0),$(30),$(30));
                                    object.elements.canvas.testCanvas._.fillStyle = _canvas_.library.math.convertColour.obj2rgba({r:0.732,g:0.756,b:0.892,a:1});
                                    object.elements.canvas.testCanvas._.fillRect($(0),$(0),$(10),$(10));
                                    object.elements.canvas.testCanvas._.fillStyle = _canvas_.library.math.convertColour.obj2rgba({r:0.107,g:0.722,b:0.945,a:1});
                                    object.elements.canvas.testCanvas._.fillRect($(20),$(0),$(10),$(10));
                                    object.elements.canvas.testCanvas._.fillStyle = _canvas_.library.math.convertColour.obj2rgba({r:0.859,g:0.573,b:0.754,a:1});
                                    object.elements.canvas.testCanvas._.fillRect($(0),$(20),$(10),$(10));
                                    object.elements.canvas.testCanvas._.fillStyle = _canvas_.library.math.convertColour.obj2rgba({r:0.754,g:0.859,b:0.573,a:1});
                                    object.elements.canvas.testCanvas._.fillRect($(20),$(20),$(10),$(10));
                                    object.elements.canvas.testCanvas.requestUpdate();
                            
                                    object.elements.needleOverlay.test_needleOverlay.select(0,0.25);
                                    object.elements.needleOverlay.test_needleOverlay.area(0.5,0.75);
                                    object.elements.grapher_waveWorkspace.test_grapher_waveWorkspace.select(0,0.2);
                                    object.elements.grapher_waveWorkspace.test_grapher_waveWorkspace.area(0.5,0.7);
                                    object.elements.sequencer.test_sequencer.addSignal( 0,0,  10,0.0 );
                                    object.elements.sequencer.test_sequencer.addSignal( 1,1,  10,0.1 );
                                    object.elements.sequencer.test_sequencer.addSignal( 2,2,  10,0.2 );
                                    object.elements.sequencer.test_sequencer.addSignal( 3,3,  10,0.3 );
                                    object.elements.sequencer.test_sequencer.addSignal( 4,4,  10,0.4 );
                                    object.elements.sequencer.test_sequencer.addSignal( 5,5,  10,0.5 );
                                    object.elements.sequencer.test_sequencer.addSignal( 6,6,  10,0.6 );
                                    object.elements.sequencer.test_sequencer.addSignal( 7,7,  10,0.7 );
                                    object.elements.sequencer.test_sequencer.addSignal( 8,8,  10,0.8 );
                                    object.elements.sequencer.test_sequencer.addSignal( 9,9,  10,0.9 );
                                    object.elements.sequencer.test_sequencer.addSignal( 10,10,10,1.0 );
                            
                            
                            
                            
                            
                                //     object.elements.readout_sixteenSegmentDisplay.test_readout_sixteenSegmentDisplay.text('hello');
                                //     object.elements.readout_sixteenSegmentDisplay.test_readout_sixteenSegmentDisplay.print();
                            
                                //     object.elements.grapher.test_grapher1.draw([0,-2,1,-1,2],[0,0.25,0.5,0.75,1]);
                                //     object.elements.grapher.test_grapher1.draw([0,0.25,1],undefined,1);
                                    
                                //     object.elements.grapher_periodicWave.test_grapher_periodicWave1.updateBackground();
                                //     object.elements.grapher_periodicWave.test_grapher_periodicWave1.wave( {sin:[0,1/1,0,1/3,0,1/5,0,1/7,0,1/9,0,1/11,0,1/13,0,1/15],cos:[0,0]} );
                                //     object.elements.grapher_periodicWave.test_grapher_periodicWave1.draw();
                            
                                //     object.elements.needleOverlay.test_needleOverlay1.select(0.25);
                                //     object.elements.needleOverlay.test_needleOverlay1.area(0.5,0.75);
                            
                                //     object.elements.grapher_waveWorkspace.test_grapher_waveWorkspace1.select(0.25);
                                //     object.elements.grapher_waveWorkspace.test_grapher_waveWorkspace1.area(0.5,0.75);
                                    
                                //     object.elements.sequencer.test_sequencer1.addSignal( 0,0,  10,0.0 );
                                //     object.elements.sequencer.test_sequencer1.addSignal( 1,1,  10,0.1 );
                                //     object.elements.sequencer.test_sequencer1.addSignal( 2,2,  10,0.2 );
                                //     object.elements.sequencer.test_sequencer1.addSignal( 3,3,  10,0.3 );
                                //     object.elements.sequencer.test_sequencer1.addSignal( 4,4,  10,0.4 );
                                //     object.elements.sequencer.test_sequencer1.addSignal( 5,5,  10,0.5 );
                                //     object.elements.sequencer.test_sequencer1.addSignal( 6,6,  10,0.6 );
                                //     object.elements.sequencer.test_sequencer1.addSignal( 7,7,  10,0.7 );
                                //     object.elements.sequencer.test_sequencer1.addSignal( 8,8,  10,0.8 );
                                //     object.elements.sequencer.test_sequencer1.addSignal( 9,9,  10,0.9 );
                                //     object.elements.sequencer.test_sequencer1.addSignal( 10,10,10,1.0 );
                                
                                return object;
                            };
                            
                            
                            
                            
                            
                            
                            
                            
                            this.testUnit_1.devUnit = true;
                            this.testUnit_1.metadata = {
                                name:'Test Unit 1',
                                helpURL:'https://curve.metasophiea.com/help/units/test/testUnit_1/'
                            };
                            this.testUnit_2 = function(name,x,y,angle){
                                const design = {
                                    name: name,
                                    model: 'testUnit_2',
                                    collection: 'test',
                                    x:x, y:y, angle:angle,
                                    space: [
                                        {x:0,y:0}, 
                                        {x:100,y:0}, 
                                        {x:100,y:100}, 
                                        {x:0,y:100}, 
                                    ],
                                    // spaceOutline: true,
                                    elements:[
                                        {collection:'basic', type:'rectangle', name:'testRectangle1', data:{ x:0, y:0, width:100, height:100, colour:{r:200/255,g:200/255,b:200/255,a:1} }},
                                        {collection:'basic', type:'rectangle', name:'testRectangle2', data:{ x:10, y:10, width:80, height:80, colour:{r:200/255,g:100/255,b:200/255,a:1} }},
                                    ],
                                };
                            
                                //main object
                                    const object = interface.unit.builder(design);
                                
                                return object;
                            };
                            
                            
                            
                            
                            
                            
                            
                            
                            this.testUnit_2.devUnit = true;
                            this.testUnit_2.metadata = {
                                name:'Test Unit 2',
                                helpURL:'https://curve.metasophiea.com/help/units/test/testUnit_2/'
                            };
                            this.testUnit_3 = function(name,x,y,angle){
                                const design = {
                                    name: name,
                                    model: 'testUnit_3',
                                    collection: 'test',
                                    x:x, y:y, angle:angle,
                                    space: [
                                        {x:0,y:0}, 
                                        {x:100,y:0}, 
                                        {x:100,y:100}, 
                                        {x:0,y:100}, 
                                    ],
                                    spaceOutline: true,
                                    elements:[
                                        {collection:'basic', type:'rectangle', name:'testRectangle1', data:{ x:0, y:0, width:100, height:100, colour:{r:200/255,g:200/255,b:200/255,a:1} }},
                                        {collection:'basic', type:'rectangle', name:'testRectangle2', data:{ x:10, y:10, width:80, height:80, colour:{r:200/255,g:100/255,b:200/255,a:1} }},
                                        {collection:'dynamic', type:'connectionNode', name:'test_connectionNode1', data:{ cableVersion:2, x:60, y:100, height:20, width:10, angle:Math.PI/2 }},
                                    ],
                                };
                            
                                //main object
                                    const object = interface.unit.builder(design);
                                
                                return object;
                            };
                            
                            
                            
                            
                            
                            
                            
                            
                            this.testUnit_3.devUnit = true;
                            this.testUnit_3.metadata = {
                                name:'Test Unit 3',
                                helpURL:'https://curve.metasophiea.com/help/units/test/testUnit_3/'
                            };
                            this.testUnit_4 = function(name,x,y,angle){
                                const shape = [
                                    {x:0,y:0},
                                    {x:400,y:200},
                                    {x:400,y:400},
                                    {x:0,y:400}
                                ];
                                const design = {
                                    name: name,
                                    model: 'testUnit_4',
                                    collection: 'test',
                                    x:x, y:y, angle:angle,
                                    space:shape,
                                    spaceOutline: true,
                                    elements:[
                                        {collection:'basic', type:'polygon', name:'backing', data:{pointsAsXYArray:shape, colour:{r:200/255,g:200/255,b:200/255,a:0.1} } },
                                    ],
                                };
                            
                                //main object
                                    const object = interface.unit.builder(design);
                                
                                return object;
                            };
                            
                            
                            
                            
                            
                            
                            
                            
                            this.testUnit_4.devUnit = true;
                            this.testUnit_4.metadata = {
                                name:'Test Unit 4',
                                helpURL:'https://curve.metasophiea.com/help/units/test/testUnit_4/'
                            };
                            this.testUnit_5 = function(name,x,y,angle){
                                const design = {
                                    name: name,
                                    model: 'testUnit_5',
                                    collection: 'test',
                                    x:x, y:y, angle:angle,
                                    space: [
                                        {x:0,y:0}, 
                                        {x:100,y:0}, 
                                        {x:100,y:100}, 
                                        {x:0,y:100}, 
                                    ],
                                    // spaceOutline: true,
                                    elements:[
                                        {collection:'dynamic', type:'connectionNode', name:'test_connectionNode1', data:{ cableVersion:2, x:110, y:60, height:50, width:50, angle:Math.PI/2 }},
                                        {collection:'basic', type:'rectangle', name:'testRectangle1', data:{ x:0, y:0, width:100, height:100, colour:{r:100/255,g:100/255,b:100/255,a:1} }},
                                        {collection:'basic', type:'rectangle', name:'testRectangle2', data:{ x:10, y:10, width:90, height:90, colour:{r:130/255,g:130/255,b:130/255,a:1} }},
                                        {collection:'basic', type:'rectangle', name:'testRectangle3', data:{ x:20, y:20, width:80, height:80, colour:{r:160/255,g:160/255,b:160/255,a:1} }},
                                        {collection:'basic', type:'rectangle', name:'testRectangle4', data:{ x:30, y:30, width:70, height:70, colour:{r:190/255,g:190/255,b:190/255,a:1} }},
                                        {collection:'basic', type:'rectangle', name:'testRectangle5', data:{ x:0, y:0, width:50, height:50, colour:{r:220/255,g:220/255,b:220/255,a:1} }},
                                    ],
                                };
                            
                                //main object
                                    const object = interface.unit.builder(design);
                                
                                // mouse interaction
                                    object.elements.rectangle.testRectangle5.attachCallback('onmousedown', () => {console.log('onmousedown');});
                            
                                return object;
                            };
                            
                            
                            
                            
                            
                            
                            
                            
                            this.testUnit_5.devUnit = true;
                            this.testUnit_5.metadata = {
                                name:'Test Unit 5',
                                helpURL:'https://curve.metasophiea.com/help/units/test/testUnit_5/'
                            };

                        };
                    };
                    /*
                        a design
                        {
                            name: 'name of unit (unique to collection)',
                            collection: 'name of the collection to which this unit belongs',
                            x: 0, y: 0, angle: 0,
                            space: [{x:0,y:0}, ...], //a collection of points, used to determine the unit's selection/collision area
                            spaceOutline: true/false, //a helper graphic, which when set to true will draw an outline of the space
                            elements:[ //a list of all the parts
                                {
                                    type:'part type name',
                                    name:'a unique name',
                                    data:{}, //data relevant to this part type
                                }
                            ] 
                        }
                    */
                    this.builder = function(design){
                        //input check
                            if(design.x == undefined){ design.x = 0; }
                            if(design.y == undefined){ design.y = 0; }
                            if(design.angle == undefined){ design.angle = 0; }
                    
                        //main group
                            const unit = _canvas_.interface.part.builder('basic','group',design.name,{x:design.x, y:design.y, angle:design.angle});
                            unit.model = design.model;
                            unit.collisionActive = design.collisionActive == undefined ? true : design.collisionActive;
                    
                        //generate parts and append to main group
                            unit.elements = {};
                            for(let a = 0; a < design.elements.length; a++){
                                //check for arguments
                                if(design.elements[a].collection == undefined){console.warn('Interface Unit Builder :: collection name missing'); break;}
                                if(design.elements[a].type == undefined){console.warn('Interface Unit Builder :: type name missing'); break;}
                                if(design.elements[a].name == undefined){console.warn('Interface Unit Builder :: name name missing'); break;}
                    
                    
                                //check for name collision
                                    if( unit.getChildByName(design.elements[a].name) != undefined ){
                                        console.warn('Interface Unit Builder :: error: part with the name "'+design.elements[a].name+'" already exists. Part:',design.elements[a],'will not be added');
                                        continue;
                                    }    
                    
                                //produce and append part
                                    const newPart = _canvas_.interface.part.builder( design.elements[a].collection, design.elements[a].type, design.elements[a].name, design.elements[a].data );
                                    unit.append(newPart);
                    
                                //add part to element tree
                                    if( unit.elements[design.elements[a].type] == undefined ){ unit.elements[design.elements[a].type] = {}; }
                                    unit.elements[design.elements[a].type][design.elements[a].name] = newPart;
                            }
                    
                        //gather together io ports
                            unit.io = {};
                            [
                                {key:'_', name:'connectionNode'},
                                {key:'signal', name:'connectionNode_signal'},
                                {key:'voltage', name:'connectionNode_voltage'},
                                {key:'data', name:'connectionNode_data'},
                                {key:'audio', name:'connectionNode_audio'},
                                {key:'audio2', name:'connectionNode_audio_2'},
                            ].forEach(function(type){
                                if(!unit.elements[type.name]){return;}
                                const keys = Object.keys(unit.elements[type.name]);
                                for(let a = 0; a < keys.length; a++){
                                    const part = unit.elements[type.name][keys[a]];
                                    if( unit.io[type.key] == undefined ){ unit.io[type.key] = {}; }
                                    unit.io[type.key][part.getName()] = part;
                                }
                            });
                    
                            unit.disconnectEverything = function(){
                                for(connectionType in unit.io){
                                    for(connectionName in unit.io[connectionType]){
                                        unit.io[connectionType][connectionName].disconnect();
                                    }
                                }
                            };
                            unit.allowIOConnections = function(bool){
                                if(bool == undefined){return;}
                                for(connectionType in unit.io){
                                    for(connectionName in unit.io[connectionType]){
                                        unit.io[connectionType][connectionName].allowConnections(bool);
                                    }
                                }
                            };
                            unit.allowIODisconnections = function(bool){
                                if(bool == undefined){return;}
                                for(connectionType in unit.io){
                                    for(connectionName in unit.io[connectionType]){
                                        unit.io[connectionType][connectionName].allowDisconnections(bool);
                                    }
                                }
                            };
                    
                        //generate unit's personal space
                            unit.space = {};
                            unit.space.originalPoints = design.space;
                            function generatePersonalSpace(){
                                unit.space.points = design.space.map(a => {
                                    const tmp = _canvas_.library.math.cartesianAngleAdjust(a.x,a.y,unit.angle())
                                    tmp.x += design.x;
                                    tmp.y += design.y;
                                    return tmp;
                                } );
                                unit.space.boundingBox = _canvas_.library.math.boundingBoxFromPoints(unit.space.points);
                    
                                //create invisible space shape
                                if( unit.space.shape != undefined ){
                                    unit.space.shape.pointsAsXYArray(unit.space.originalPoints);
                                }else{
                                    unit.space.shape = _canvas_.interface.part.builder( 'basic', 'polygon', 'personalSpace', { pointsAsXYArray:unit.space.originalPoints, colour:{r:0,g:1,b:0,a:0} } );
                                    unit.space.shape.unit = unit;
                                    unit.prepend( unit.space.shape );
                                }
                            }
                            generatePersonalSpace();
                    
                            //if requested, add an outline shape
                                if( design.spaceOutline ){
                                    unit.append( _canvas_.interface.part.builder( 'basic', 'polygonWithOutline', 'unit.space.shape'+'_Outline', {pointsAsXYArray:design.space, colour:{r:1,g:1,b:1,a:0.25}, lineColour:{r:0,g:0,b:0,a:1} } ) );
                                }
                    
                        //setup unit movement snapping
                            const snapping = {active:false,x:10,y:10,angle:Math.PI/8};
                            unit.snappingActive = function(bool){ if(bool == undefined){return snapping.active;} snapping.active = bool; };
                            unit.snappingX = function(newX){ if(newX == undefined){return snapping.x;} snapping.x = newX; };
                            unit.snappingY = function(newY){ if(newY == undefined){return snapping.y;} snapping.y = newY; };
                            unit.snappingAngle = function(newAngle){ if(newAngle == undefined){return snapping.angle;} snapping.angle = newAngle; };
                    
                        //augment unit x, y and angle adjustment methods
                            unit._x = unit.x;
                            unit._y = unit.y;
                            unit._angle = unit.angle;
                            unit.x = function(newX){
                                if(newX == undefined){ return design.x; }
                    
                                design.x = snapping.active ? Math.round(newX/snapping.x)*snapping.x: newX;
                                unit._x(design.x);
                    
                                generatePersonalSpace();
                            };
                            unit.y = function(newY){
                                if(newY == undefined){ return design.y; }
                    
                                design.y = snapping.active ? Math.round(newY/snapping.y)*snapping.y: newY;
                                unit._y(design.y);
                    
                                generatePersonalSpace();
                            };
                            unit.angle = function(newAngle){
                                if(newAngle == undefined){ return design.angle; }
                    
                                design.angle = snapping.active ? Math.round(newAngle/snapping.angle)*snapping.angle: newAngle;
                                unit._angle(design.angle);
                    
                                generatePersonalSpace();
                            };
                            unit.ioRedraw = function(){
                                if( unit.io ){
                                    const connectionTypes = Object.keys( unit.io );
                                    for(let connectionType = 0; connectionType < connectionTypes.length; connectionType++){
                                        const connectionNodes = unit.io[connectionTypes[connectionType]];
                                        const nodeNames = Object.keys( connectionNodes );
                                        for(let b = 0; b < nodeNames.length; b++){
                                            connectionNodes[nodeNames[b]].draw();
                                        }
                                    }
                                }
                            };
                    
                        //disable all control parts method
                            unit.interactable = function(bool){
                                if(bool == undefined){return;}
                                for(partType in unit.elements){
                                    for(partName in unit.elements[partType]){
                                        if( unit.elements[partType][partName].interactable ){
                                            unit.elements[partType][partName].interactable(bool);
                                        }
                                    }
                                }
                            };
                    
                        //_oncreate/_ondelete
                            unit._oncreate = function(){
                                Object.entries(unit.elements).forEach(([type,parts]) => {
                                    Object.entries(parts).forEach(([name,part]) => {
                                        if(part.oncreate){part.oncreate();}
                                    });
                                });
                            };
                            unit._ondelete = function(){
                                Object.entries(unit.elements).forEach(([type,parts]) => {
                                    Object.entries(parts).forEach(([name,part]) => {
                                        if(part.ondelete){part.ondelete();}
                                    });
                                });
                            };
                    
                        return unit;
                    };
                    //this is a little bit nonsencey
                    this.validator = function(unit,describe=false){
                        const normalFontColour = '#987aa1';
                        const badFontColour = '#db6060';
                    
                        if(!describe){
                            // return {
                            //     tree:unit.getTree(),
                            //     devMode:unit.devMode,
                            //     dotFrame:unit.dotFrame,
                            //     space:Object.assign({},unit.space),
                            //     importData:unit.importData!=undefined,
                            //     exportData:unit.exportData!=undefined,
                            //     interface:Object.keys(unit.io).map(type => { return {type:type,list:Object.keys(unit.io[type])} })
                            // };
                    
                            if(unit.importData==undefined){ console.log('\t%cimportData missing','color:'+badFontColour); }
                            if(unit.exportData==undefined){ console.log('\t%cexportData missing','color:'+badFontColour); }
                            return;
                        }
                    
                    
                    
                        console.log('%cinterface.unit.validator', 'font-size:12px; font-weight:bold;');
                        console.log('\tmodel: %c'+unit.model,'color:'+normalFontColour);
                        console.log('\tname: %c'+unit.name,'color:'+normalFontColour);
                        console.log('\taddress: %c'+unit.getAddress(),'color:'+normalFontColour);
                        console.log('');
                    
                    
                        //check for sub elements
                            console.log('\tcheck for sub elements');
                                Object.keys(unit.elements).forEach(type => {
                                    console.log( '\t\t- '+type );
                                    Object.keys(unit.elements[type]).forEach(item => {
                                        console.log( '\t\t\t- '+item );
                                    });
                                });
                            console.log('');
                        //check if devMode is on
                            console.log('\tdevMode: %c'+(unit.devMode ? 'active' : 'not active'), 'color:'+normalFontColour);
                            console.log('');
                        //check if dotFrame is on
                            console.log('\tdotFrame: %c'+(unit.dotFrame ? 'active' : 'not active'), 'color:'+normalFontColour);
                            console.log('');
                        //check for space
                            console.log('\tUnit Space');
                            console.log('\t\tboundingBox:');
                            console.log('\t\t\ttopLeft',unit.space.boundingBox.topLeft );
                            console.log('\t\t\tbottomRight',unit.space.boundingBox.bottomRight );
                            console.log('\t\toriginalPoints');
                            unit.space.originalPoints.forEach(item => console.log('\t\t\t',item));
                            console.log('\t\tpoints');
                            unit.space.points.forEach(item => console.log('\t\t\t',item));
                            console.log('');
                        //check for import/export
                            console.log('\timport/export');
                            console.log('\t\timportData %c' + (unit.importData == undefined ? 'missing' : 'present'), 'color:'+(unit.importData == undefined ? badFontColour : normalFontColour));
                            console.log('\t\texportData %c' + (unit.exportData == undefined ? 'missing' : 'present'), 'color:'+(unit.exportData == undefined ? badFontColour : normalFontColour));
                            console.log('');
                        //list interface
                            console.log('\tinterface');
                            if(unit.i == undefined){
                                console.log('\t\t- missing -');
                            }else{
                                Object.keys(unit.i).forEach(item => {
                                    console.log( '\t\t- '+item );
                                });
                            }
                            console.log('');
                        //list io
                            console.log('\tio');
                            Object.keys(unit.io).forEach(type => {
                                console.log( '\t\t- '+type );
                                Object.keys(unit.io[type]).forEach(item => {
                                    console.log( '\t\t\t- '+item );
                                });
                            });
                            console.log('');
                    };

                };
            };
            
            _canvas_.system.go.add( function(){
                _canvas_.layers.registerLayerLoaded('interface',_canvas_.interface);
                _canvas_.interface.go.__activate();
            } );
                
            _canvas_.control = new function(){
                this.versionInformation = { tick:0, lastDateModified:{y:2020,m:1,d:14} };
                const control = this;
            
                const dev = {
                    prefix:'control',
                
                    active:{
                        interaction: false,
                        viewport: false, 
                        scene: false, 
                        selection: false, 
                        actionRegistry: false,
                        queryString: false,
                        grapple: false,
                        mouse: false, 
                        keyboard: false, 
                    },
                
                    log:{
                        interaction:function(){
                            if(!dev.active.interaction){return;}
                            console.log( dev.prefix+'.interaction'+arguments[0], ...(new Array(...arguments).slice(1)) );
                        },
                        viewport:function(){
                            if(!dev.active.viewport){return;}
                            console.log( dev.prefix+'.viewport'+arguments[0], ...(new Array(...arguments).slice(1)) );
                        },
                        scene:function(){
                            if(!dev.active.scene){return;}
                            console.log( dev.prefix+'.scene'+arguments[0], ...(new Array(...arguments).slice(1)) );
                        },
                        selection:function(){
                            if(!dev.active.selection){return;}
                            console.log( dev.prefix+'.selection'+arguments[0], ...(new Array(...arguments).slice(1)) );
                        },
                        actionRegistry:function(){
                            if(!dev.active.actionRegistry){return;}
                            console.log( dev.prefix+'.actionRegistry'+arguments[0], ...(new Array(...arguments).slice(1)) );
                        },
                        queryString:function(){
                            if(!dev.active.queryString){return;}
                            console.log( dev.prefix+'.queryString'+arguments[0], ...(new Array(...arguments).slice(1)) );
                        },
                        grapple:function(){
                            if(!dev.active.grapple){return;}
                            console.log( dev.prefix+'.grapple'+arguments[0], ...(new Array(...arguments).slice(1)) );
                        },
                        mouse:function(){
                            if(!dev.active.mouse){return;}
                            console.log( dev.prefix+'.mouse.functionList'+arguments[0], ...(new Array(...arguments).slice(1)) );
                        },
                        keyboard:function(){
                            if(!dev.active.keyboard){return;}
                            console.log( dev.prefix+'.keyboard.functionList'+arguments[0], ...(new Array(...arguments).slice(1)) );
                        },
                    },
                };
            
                this.go = new function(){
                    const functionList = [];
            
                    this.add = function(newFunction){ functionList.push(newFunction); };
                    this.__activate = function(){ functionList.forEach(f => f()); };
                };
            
                const interactionState = {};
                this.interaction = new function(){
                    interactionState.development = false;
                
                    interactionState.menubar = true;
                    interactionState.snapping = true;
                    interactionState.unitAdditionRemoval = true;
                    interactionState.unitTransfer = true;
                    interactionState.unitCollision = true;
                    interactionState.newScene = true;
                    interactionState.sceneSave = true;
                    interactionState.sceneLoad = true;
                    interactionState.unitSelection = true;
                    interactionState.unitGrappleRotation = true;
                    interactionState.unitGrapplePosition = true;
                    interactionState.mouseGroupSelect = true;
                    interactionState.mouseGripPanning = true;
                    interactionState.mouseWheelZoom = true;
                    interactionState.unloadWarning = true;
                
                    Object.keys(interactionState).forEach(key => {
                        this[key] = function(bool){
                            if(bool==undefined){return interactionState[key];}
                            interactionState[key] = bool;
                        };
                    });
                };
                
                window.onbeforeunload = function(){ 
                    if(!interactionState.unloadWarning){ return; }
                    return "Unsaved work will be lost";
                };
            
                this.gui = new function(){
                    let menubar = undefined;
            
                    this.refresh = function(){
                        if(menubar != undefined){
                            menubar.refresh();
                        }
                    };
                    this.heavyRefresh = function(){
                        if(menubar != undefined){
                            menubar.heavyRefresh();
                        }
                    };
                    this.checkboxRefresh = function(){
                        if(menubar != undefined){
                            menubar.checkboxRefresh();
                        }
                    };
            
                    this.showMenubar = function(){
                        //control switch
                            if(!interactionState.menubar){
                                this.hideMenubar();
                                return;
                            }
            
                        if(menubar != undefined){return;}
                        menubar = control.gui.elements.menubar(0,0);
                        _canvas_.system.pane.f.append( menubar );
                    };
                    this.hideMenubar = function(){
                        if(menubar == undefined){return;}
                        _canvas_.system.pane.f.remove( menubar );
                        menubar = undefined;
                    };
                    this.closeAllDropdowns = function(){
                        if(menubar != undefined){
                            menubar.closeAllDropdowns();
                        }
                    };
            
                    this.elements = new function(){
                        this.menubar = function(x,y){
                            const self = this;
                            const vars = {
                                width: _canvas_.control.viewport.width(),
                                height: 20,
                                selected: undefined,
                                activedropdown: undefined,
                                item_horizontalPadding:10,
                                item_spacingHeight:0,
                        
                                subList_arrowMux:0.5,
                                space_height:10/16,
                                break_height:10/8,
                                break_lineMux:1/5,
                                textBreak_height:10/8,
                                textBreak_textToLineSpacing:1,
                                textBreak_textHeightMux:1.1,
                                textBreak_lineMux:1/5,
                            };
                            let style = {
                                backgroundColour:{r:240/255,g:240/255,b:240/255,a:1},
                                
                                text__font:'Helvetica',
                                text__fontSize:14,
                                text__spacing:0.3,
                                text__interCharacterSpacing:0.04,
                        
                                text_colour__off:                                  {r:0.2,g:0.2,b:0.2,a:1},
                                text_colour__up:                                   {r:0.2,g:0.2,b:0.2,a:1},
                                text_colour__press:                                {r:0.2,g:0.2,b:0.2,a:1},
                                text_colour__select:                               {r:0.2,g:0.2,b:0.2,a:1},
                                text_colour__select_press:                         {r:0.2,g:0.2,b:0.2,a:1},
                                text_colour__glow:                                 {r:0.2,g:0.2,b:0.2,a:1},
                                text_colour__glow_press:                           {r:0.2,g:0.2,b:0.2,a:1},
                                text_colour__glow_select:                          {r:0.2,g:0.2,b:0.2,a:1},
                                text_colour__glow_select_press:                    {r:0.2,g:0.2,b:0.2,a:1},
                                text_colour__hover:                                {r:0.2,g:0.2,b:0.2,a:1},
                                text_colour__hover_press:                          {r:0.2,g:0.2,b:0.2,a:1},
                                text_colour__hover_select:                         {r:0.2,g:0.2,b:0.2,a:1},
                                text_colour__hover_select_press:                   {r:0.2,g:0.2,b:0.2,a:1},
                                text_colour__hover_glow:                           {r:0.2,g:0.2,b:0.2,a:1},
                                text_colour__hover_glow_press:                     {r:0.2,g:0.2,b:0.2,a:1},
                                text_colour__hover_glow_select:                    {r:0.2,g:0.2,b:0.2,a:1},
                                text_colour__hover_glow_select_press:              {r:0.2,g:0.2,b:0.2,a:1},
                                    
                                item_backing__off__colour:                              {r:180/255,g:180/255,b:180/255,a:1},
                                item_backing__off__lineColour:                          {r:0/255,g:0/255,b:0/255,a:0},
                                item_backing__off__lineThickness:                       0,
                                item_backing__up__colour:                               {r:240/255,g:240/255,b:240/255,a:1},
                                item_backing__up__lineColour:                           {r:0/255,g:0/255,b:0/255,a:0},
                                item_backing__up__lineThickness:                        0,
                                item_backing__press__colour:                            {r:240/255,g:240/255,b:240/255,a:1},
                                item_backing__press__lineColour:                        {r:0/255,g:0/255,b:0/255,a:0},
                                item_backing__press__lineThickness:                     0,
                                item_backing__select__colour:                           {r:220/255,g:220/255,b:220/255,a:1},
                                item_backing__select__lineColour:                       {r:0/255,g:0/255,b:0/255,a:0},
                                item_backing__select__lineThickness:                    0,
                                item_backing__select_press__colour:                     {r:229/255,g:167/255,b:255/255,a:1},
                                item_backing__select_press__lineColour:                 {r:0,g:0,b:0,a:0},
                                item_backing__select_press__lineThickness:              0,
                                item_backing__glow__colour:                             {r:220/255,g:220/255,b:220/255,a:1},
                                item_backing__glow__lineColour:                         {r:0/255,g:0/255,b:0/255,a:0},
                                item_backing__glow__lineThickness:                      0,
                                item_backing__glow_press__colour:                       {r:250/255,g:250/255,b:250/255,a:1},
                                item_backing__glow_press__lineColour:                   {r:0/255,g:0/255,b:0/255,a:0},
                                item_backing__glow_press__lineThickness:                0,
                                item_backing__glow_select__colour:                      {r:220/255,g:220/255,b:220/255,a:1},
                                item_backing__glow_select__lineColour:                  {r:120/255,g:120/255,b:120/255,a:1},
                                item_backing__glow_select__lineThickness:               0,
                                item_backing__glow_select_press__colour:                {r:250/255,g:250/255,b:250/255,a:1},
                                item_backing__glow_select_press__lineColour:            {r:120/255,g:120/255,b:120/255,a:1},
                                item_backing__glow_select_press__lineThickness:         0,
                                item_backing__hover__colour:                            {r:229/255,g:167/255,b:255/255,a:1},
                                item_backing__hover__lineColour:                        {r:0/255,g:0/255,b:0/255,a:0},
                                item_backing__hover__lineThickness:                     0,
                                item_backing__hover_press__colour:                      {r:240/255,g:240/255,b:240/255,a:1},
                                item_backing__hover_press__lineColour:                  {r:0/255,g:0/255,b:0/255,a:0},
                                item_backing__hover_press__lineThickness:               0,
                                item_backing__hover_select__colour:                     {r:239/255,g:209/255,b:255/255,a:1},
                                item_backing__hover_select__lineColour:                 {r:120/255,g:120/255,b:120/255,a:1},
                                item_backing__hover_select__lineThickness:              0,
                                item_backing__hover_select_press__colour:               {r:240/255,g:240/255,b:240/255,a:1},
                                item_backing__hover_select_press__lineColour:           {r:120/255,g:120/255,b:120/255,a:1},
                                item_backing__hover_select_press__lineThickness:        0,
                                item_backing__hover_glow__colour:                       {r:239/255,g:209/255,b:255/255,a:1},
                                item_backing__hover_glow__lineColour:                   {r:0/255,g:0/255,b:0/255,a:0},
                                item_backing__hover_glow__lineThickness:                0,
                                item_backing__hover_glow_press__colour:                 {r:250/255,g:250/255,b:250/255,a:1},
                                item_backing__hover_glow_press__lineColour:             {r:0/255,g:0/255,b:0/255,a:0},
                                item_backing__hover_glow_press__lineThickness:          0,
                                item_backing__hover_glow_select__colour:                {r:240/255,g:240/255,b:240/255,a:1},
                                item_backing__hover_glow_select__lineColour:            {r:120/255,g:120/255,b:120/255,a:1},
                                item_backing__hover_glow_select__lineThickness:         0,
                                item_backing__hover_glow_select_press__colour:          {r:250/255,g:250/255,b:250/255,a:1},
                                item_backing__hover_glow_select_press__lineColour:      {r:120/255,g:120/255,b:120/255,a:1},
                                item_backing__hover_glow_select_press__lineThickness:   0,
                            
                                checkbox_checkColour:{r:0.7,g:0.7,b:0.7,a:1}, 
                            };
                        
                            //elements
                                //main
                                    const object = _canvas_.interface.part.builder( 'basic', 'group', 'menubar', {});
                                    let bar;
                        
                                //items
                                    function createDropdown(a,x){
                                        let dropdown = undefined;
                        
                                        //produce dropdown
                                            dropdown = _canvas_.interface.part.builder( 'control', 'list', 'dropdown', {
                                                x:x, y:vars.height,
                        
                                                list:self.menubar.dropdowns[a].itemList,
                            
                                                backgroundColour:style.backgroundColour,
                                                backgroundMarkingColour:undefined,
                                            
                                                default_item_height:self.menubar.dropdowns[a].listItemHeight,
                                                default_item_width:self.menubar.dropdowns[a].listWidth,
                                                default_item_spacingHeight:0,
                                                default_item_horizontalPadding:vars.item_horizontalPadding,
                                            
                                                default_text__text:undefined,
                                                default_text__font:style.text__font,
                                                default_text__fontSize:style.text__fontSize,
                                                default_text__printingMode:undefined,
                                                default_text__spacing:style.text__spacing,
                                                default_text__interCharacterSpacing:style.text__interCharacterSpacing,
                        
                                                default_text_colour__off:style.text_colour__off,
                                                default_text_colour__up:style.text_colour__up,
                                                default_text_colour__press:style.text_colour__press,
                                                default_text_colour__select:style.text_colour__select,
                                                default_text_colour__select_press:style.text_colour__select_press,
                                                default_text_colour__glow:style.text_colour__glow,
                                                default_text_colour__glow_press:style.text_colour__glow_press,
                                                default_text_colour__glow_select:style.text_colour__glow_select,
                                                default_text_colour__glow_select_press:style.text_colour__glow_select_press,
                                                default_text_colour__hover:style.text_colour__hover,
                                                default_text_colour__hover_press:style.text_colour__hover_press,
                                                default_text_colour__hover_select:style.text_colour__hover_select,
                                                default_text_colour__hover_select_press:style.text_colour__hover_select_press,
                                                default_text_colour__hover_glow:style.text_colour__hover_glow,
                                                default_text_colour__hover_glow_press:style.text_colour__hover_glow_press,
                                                default_text_colour__hover_glow_select:style.text_colour__hover_glow_select,
                                                default_text_colour__hover_glow_select_press:style.text_colour__hover_glow_select_press,
                                            
                                                default_item__off__colour:style.item_backing__off__colour,
                                                default_item__off__lineColour:style.item_backing__off__lineColour,
                                                default_item__off__lineThickness:style.item_backing__off__lineThickness,
                                                default_item__up__colour:style.item_backing__up__colour,
                                                default_item__up__lineColour:style.item_backing__up__lineColour,
                                                default_item__up__lineThickness:style.item_backing__up__lineThickness,
                                                default_item__press__colour:style.item_backing__press__colour,
                                                default_item__press__lineColour:style.item_backing__press__lineColour,
                                                default_item__press__lineThickness:style.item_backing__press__lineThickness,
                                                default_item__select__colour:style.item_backing__select__colour,
                                                default_item__select__lineColour:style.item_backing__select__lineColour,
                                                default_item__select__lineThickness:style.item_backing__select__lineThickness,
                                                default_item__select_press__colour:style.item_backing__select_press__colour,
                                                default_item__select_press__lineColour:style.item_backing__select_press__lineColour,
                                                default_item__select_press__lineThickness:style.item_backing__select_press__lineThickness,
                                                default_item__glow__colour:style.item_backing__glow__colour,
                                                default_item__glow__lineColour:style.item_backing__glow__lineColour,
                                                default_item__glow__lineThickness:style.item_backing__glow__lineThickness,
                                                default_item__glow_press__colour:style.item_backing__glow_press__colour,
                                                default_item__glow_press__lineColour:style.item_backing__glow_press__lineColour,
                                                default_item__glow_press__lineThickness:style.item_backing__glow_press__lineThickness,
                                                default_item__glow_select__colour:style.item_backing__glow_select__colour,
                                                default_item__glow_select__lineColour:style.item_backing__glow_select__lineColour,
                                                default_item__glow_select__lineThickness:style.item_backing__glow_select__lineThickness,
                                                default_item__glow_select_press__colour:style.item_backing__glow_select_press__colour,
                                                default_item__glow_select_press__lineColour:style.item_backing__glow_select_press__lineColour,
                                                default_item__glow_select_press__lineThickness:style.item_backing__glow_select_press__lineThickness,
                                                default_item__hover__colour:style.item_backing__hover__colour,
                                                default_item__hover__lineColour:style.item_backing__hover__lineColour,
                                                default_item__hover__lineThickness:style.item_backing__hover__lineThickness,
                                                default_item__hover_press__colour:style.item_backing__hover_press__colour,
                                                default_item__hover_press__lineColour:style.item_backing__hover_press__lineColour,
                                                default_item__hover_press__lineThickness:style.item_backing__hover_press__lineThickness,
                                                default_item__hover_select__colour:style.item_backing__hover_select__colour,
                                                default_item__hover_select__lineColour:style.item_backing__hover_select__lineColour,
                                                default_item__hover_select__lineThickness:style.item_backing__hover_select__lineThickness,
                                                default_item__hover_select_press__colour:style.item_backing__hover_select_press__colour,
                                                default_item__hover_select_press__lineColour:style.item_backing__hover_select_press__lineColour,
                                                default_item__hover_select_press__lineThickness:style.item_backing__hover_select_press__lineThickness,
                                                default_item__hover_glow__colour:style.item_backing__hover_glow__colour,
                                                default_item__hover_glow__lineColour:style.item_backing__hover_glow__lineColour,
                                                default_item__hover_glow__lineThickness:style.item_backing__hover_glow__lineThickness,
                                                default_item__hover_glow_press__colour:style.item_backing__hover_glow_press__colour,
                                                default_item__hover_glow_press__lineColour:style.item_backing__hover_glow_press__lineColour,
                                                default_item__hover_glow_press__lineThickness:style.item_backing__hover_glow_press__lineThickness,
                                                default_item__hover_glow_select__colour:style.item_backing__hover_glow_select__colour,
                                                default_item__hover_glow_select__lineColour:style.item_backing__hover_glow_select__lineColour,
                                                default_item__hover_glow_select__lineThickness:style.item_backing__hover_glow_select__lineThickness,
                                                default_item__hover_glow_select_press__colour:style.item_backing__hover_glow_select_press__colour,
                                                default_item__hover_glow_select_press__lineColour:style.item_backing__hover_glow_select_press__lineColour,
                                                default_item__hover_glow_select_press__lineThickness:style.item_backing__hover_glow_select_press__lineThickness,
                                            
                                                subList_arrowMux:vars.subList_arrowMux,
                                                space_height:vars.space_height,
                                                break_height:vars.break_height,
                                                break_lineMux:vars.break_lineMux,
                                                textBreak_height:vars.textBreak_height,
                                                textBreak_textToLineSpacing:vars.textBreak_textToLineSpacing,
                                                textBreak_textHeightMux:vars.textBreak_textHeightMux,
                                                textBreak_lineMux:vars.textBreak_lineMux,
                                                checkbox_checkColour:style.checkbox_checkColour,
                                            });
                        
                                        //add height limitation if the dropdown height exceeds the window height
                                            if( control.viewport.height() < dropdown.getCalculatedListHeight()){
                                                dropdown.heightLimit(control.viewport.height()-vars.height);
                                            }
                        
                                        //upon selection of an item in a dropdown; close the dropdown and have nothing selected
                                            dropdown.onrelease = function(){
                                                object.getChildByName('dropdownButton_'+a).select(false); 
                                                vars.selected = undefined;
                                            };
                        
                                        return dropdown;
                                    }
                                    function produceBar(){ 
                                        object.clear();
                        
                                        bar = _canvas_.interface.part.builder( 'basic', 'rectangle', 'barBacking', {
                                            x:0, y:0, width:_canvas_.control.viewport.width(), height:vars.height, colour:style.backgroundColour
                                        } );
                                        object.append(bar);
                        
                                        let accWidth = 0;
                                        for(let a = 0; a < self.menubar.dropdowns.length; a++){
                                            const item = _canvas_.interface.part.builder( 'control', 'button_rectangle', 'dropdownButton_'+a, {
                                                x:accWidth, y:0, 
                                                width:self.menubar.dropdowns[a].width,
                                                height:vars.height, 
                                                hoverable:false, selectable:true,
                                                text_centre:self.menubar.dropdowns[a].text,
                                                style:{
                                                    text_font:style.text__font, 
                                                    text_size:style.text__fontSize, 
                                                    text_spacing:style.text__spacing, 
                                                    text_interCharacterSpacing:style.text__interCharacterSpacing,
                                                
                                                    text__off__colour:style.text_colour__off,
                                                    text__up__colour:style.text_colour__up,
                                                    text__press__colour:style.text_colour__press,
                                                    text__select__colour:style.text_colour__select,
                                                    text__select_press__colour:style.text_colour__select_press,
                                                    text__glow__colour:style.text_colour__glow,
                                                    text__glow_press__colour:style.text_colour__glow_press,
                                                    text__glow_select__colour:style.text_colour__glow_select,
                                                    text__glow_select_press__colour:style.text_colour__glow_select_press,
                                                    text__hover__colour:style.text_colour__hover,
                                                    text__hover_press__colour:style.text_colour__hover_press,
                                                    text__hover_select__colour:style.text_colour__hover_select,
                                                    text__hover_select_press__colour:style.text_colour__hover_select_press,
                                                    text__hover_glow__colour:style.text_colour__hover_glow,
                                                    text__hover_glow_press__colour:style.text_colour__hover_glow_press,
                                                    text__hover_glow_select__colour:style.text_colour__hover_glow_select,
                                                    text__hover_glow_select_press__colour:style.text_colour__hover_glow_select_press,
                                                
                                                    background__off__colour:style.item_backing__off__colour,
                                                    background__off__lineColour:style.item_backing__off__lineColour,
                                                    background__off__lineThickness:style.item_backing__off__lineThickness,
                                                    background__up__colour:style.item_backing__up__colour,
                                                    background__up__lineColour:style.item_backing__up__lineColour,
                                                    background__up__lineThickness:style.item_backing__up__lineThickness,
                                                    background__press__colour:style.item_backing__press__colour,
                                                    background__press__lineColour:style.item_backing__press__lineColour,
                                                    background__press__lineThickness:style.item_backing__press__lineThickness,
                                                    background__select__colour:style.item_backing__select__colour,
                                                    background__select__lineColour:style.item_backing__select__lineColour,
                                                    background__select__lineThickness:style.item_backing__select__lineThickness,
                                                    background__select_press__colour:style.item_backing__select_press__colour,
                                                    background__select_press__lineColour:style.item_backing__select_press__lineColour,
                                                    background__select_press__lineThickness:style.item_backing__select_press__lineThickness,
                                                    background__glow__colour:style.item_backing__glow__colour,
                                                    background__glow__lineColour:style.item_backing__glow__lineColour,
                                                    background__glow__lineThickness:style.item_backing__glow__lineThickness,
                                                    background__glow_press__colour:style.item_backing__glow_press__colour,
                                                    background__glow_press__lineColour:style.item_backing__glow_press__lineColour,
                                                    background__glow_press__lineThickness:style.item_backing__glow_press__lineThickness,
                                                    background__glow_select__colour:style.item_backing__glow_select__colour,
                                                    background__glow_select__lineColour:style.item_backing__glow_select__lineColour,
                                                    background__glow_select__lineThickness:style.item_backing__glow_select__lineThickness,
                                                    background__glow_select_press__colour:style.item_backing__glow_select_press__colour,
                                                    background__glow_select_press__lineColour:style.item_backing__glow_select_press__lineColour,
                                                    background__glow_select_press__lineThickness:style.item_backing__glow_select_press__lineThickness,
                                                    background__hover__colour:style.item_backing__hover__colour,
                                                    background__hover__lineColour:style.item_backing__hover__lineColour,
                                                    background__hover__lineThickness:style.item_backing__hover__lineThickness,
                                                    background__hover_press__colour:style.item_backing__hover_press__colour,
                                                    background__hover_press__lineColour:style.item_backing__hover_press__lineColour,
                                                    background__hover_press__lineThickness:style.item_backing__hover_press__lineThickness,
                                                    background__hover_select__colour:style.item_backing__hover_select__colour,
                                                    background__hover_select__lineColour:style.item_backing__hover_select__lineColour,
                                                    background__hover_select__lineThickness:style.item_backing__hover_select__lineThickness,
                                                    background__hover_select_press__colour:style.item_backing__hover_select_press__colour,
                                                    background__hover_select_press__lineColour:style.item_backing__hover_select_press__lineColour,
                                                    background__hover_select_press__lineThickness:style.item_backing__hover_select_press__lineThickness,
                                                    background__hover_glow__colour:style.item_backing__hover_glow__colour,
                                                    background__hover_glow__lineColour:style.item_backing__hover_glow__lineColour,
                                                    background__hover_glow__lineThickness:style.item_backing__hover_glow__lineThickness,
                                                    background__hover_glow_press__colour:style.item_backing__hover_glow_press__colour,
                                                    background__hover_glow_press__lineColour:style.item_backing__hover_glow_press__lineColour,
                                                    background__hover_glow_press__lineThickness:style.item_backing__hover_glow_press__lineThickness,
                                                    background__hover_glow_select__colour:style.item_backing__hover_glow_select__colour,
                                                    background__hover_glow_select__lineColour:style.item_backing__hover_glow_select__lineColour,
                                                    background__hover_glow_select__lineThickness:style.item_backing__hover_glow_select__lineThickness,
                                                    background__hover_glow_select_press__colour:style.item_backing__hover_glow_select_press__colour,
                                                    background__hover_glow_select_press__lineColour:style.item_backing__hover_glow_select_press__lineColour,
                                                    background__hover_glow_select_press__lineThickness:style.item_backing__hover_glow_select_press__lineThickness,
                                                },
                                            } );
                                            object.append(item);
                            
                                            item.onpress = function(a){ return function(){
                                                // if this item has already been selected (and will be deselected after this callback)
                                                // sent the menubar's 'vars.selected' value to undefined. Otherwise, set it to
                                                // this item's number
                            
                                                vars.selected = object.getChildByName('dropdownButton_'+a).select() ? undefined : a;
                                            }; }(a);
                                            item.onenter = function(a){ return function(event){
                                                //assuming an item has been selected, and it isn't the item that's currently being 
                                                //entered; deselect that one and tell the menubar that this item is selected now.
                                                //if no mouse button is pressed (no button rolling is happening) select it manually
                                                if( vars.selected != undefined && vars.selected != a){
                                                    object.getChildByName('dropdownButton_'+vars.selected).select(false);
                                                    vars.selected = a;
                                                    object.getChildByName('dropdownButton_'+vars.selected).select(true);
                                                }
                                            }; }(a);
                                            item.onselect = function(a,x){ return function(){
                                                vars.activedropdown = createDropdown(a,x)
                                                object.append(vars.activedropdown);
                                            } }(a,accWidth);
                                            item.ondeselect = function(){ 
                                                object.remove(vars.activedropdown); 
                                                vars.activedropdown = undefined;
                                            };
                            
                                            self.menubar.dropdowns[a].x = accWidth;
                                            accWidth += self.menubar.dropdowns[a].width;
                                        }
                                    }
                                    produceBar();
                        
                            //control
                                object.closeAllDropdowns = function(){
                                    if(vars.activedropdown != undefined){
                                        vars.activedropdown.onrelease();
                                    }
                                };
                                object.style = function(newStyle){
                                    if(newStyle==undefined){return style;}
                                    style = newStyle;
                                    produceBar();
                                };
                        
                            //refresh
                                object.refresh = function(){
                                    bar.width( _canvas_.control.viewport.width() );
                                    if(vars.activedropdown != undefined){ object.closeAllDropdowns(); }
                                };
                                object.refresh();
                                object.heavyRefresh = function(){ produceBar(); };
                                object.checkboxRefresh = function(){
                                    console.log(object.getTree());
                                };
                        
                            return object;
                        };
                        
                        this.menubar.dropdowns = [];
                    };
                    this.style = new function(){
                        this.set = function(newStyle){
                            if(menubar == undefined){return;}
                            return menubar.style(newStyle);
                        };
                        
                        this.currentStyleMode = 'light';
                        this.lightMode = function(){
                            this.currentStyleMode = 'light';
                        
                            _canvas_.control.scene.backgroundColour({r:1,g:1,b:1,a:1});
                        
                            _canvas_.control.gui.style.set(
                                {
                                    backgroundColour:{r:240/255,g:240/255,b:240/255,a:1},
                            
                                    text__font:'Helvetica',
                                    text__fontSize:14,
                                    text__spacing:0.3,
                                    text__interCharacterSpacing:0.04,
                            
                                    text_colour__off:                                       {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__up:                                        {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__press:                                     {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__select:                                    {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__select_press:                              {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__glow:                                      {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__glow_press:                                {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__glow_select:                               {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__glow_select_press:                         {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__hover:                                     {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__hover_press:                               {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__hover_select:                              {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__hover_select_press:                        {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__hover_glow:                                {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__hover_glow_press:                          {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__hover_glow_select:                         {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__hover_glow_select_press:                   {r:0.2,g:0.2,b:0.2,a:1},
                                        
                                    item_backing__off__colour:                              {r:180/255,g:180/255,b:180/255,a:1},
                                    item_backing__off__lineColour:                          {r:0/255,g:0/255,b:0/255,a:0},
                                    item_backing__off__lineThickness:                       0,
                                    item_backing__up__colour:                               {r:240/255,g:240/255,b:240/255,a:1},
                                    item_backing__up__lineColour:                           {r:0/255,g:0/255,b:0/255,a:0},
                                    item_backing__up__lineThickness:                        0,
                                    item_backing__press__colour:                            {r:240/255,g:240/255,b:240/255,a:1},
                                    item_backing__press__lineColour:                        {r:0/255,g:0/255,b:0/255,a:0},
                                    item_backing__press__lineThickness:                     0,
                                    item_backing__select__colour:                           {r:220/255,g:220/255,b:220/255,a:1},
                                    item_backing__select__lineColour:                       {r:0/255,g:0/255,b:0/255,a:0},
                                    item_backing__select__lineThickness:                    0,
                                    item_backing__select_press__colour:                     {r:229/255,g:167/255,b:255/255,a:1},
                                    item_backing__select_press__lineColour:                 {r:0,g:0,b:0,a:0},
                                    item_backing__select_press__lineThickness:              0,
                                    item_backing__glow__colour:                             {r:220/255,g:220/255,b:220/255,a:1},
                                    item_backing__glow__lineColour:                         {r:0/255,g:0/255,b:0/255,a:0},
                                    item_backing__glow__lineThickness:                      0,
                                    item_backing__glow_press__colour:                       {r:250/255,g:250/255,b:250/255,a:1},
                                    item_backing__glow_press__lineColour:                   {r:0/255,g:0/255,b:0/255,a:0},
                                    item_backing__glow_press__lineThickness:                0,
                                    item_backing__glow_select__colour:                      {r:220/255,g:220/255,b:220/255,a:1},
                                    item_backing__glow_select__lineColour:                  {r:120/255,g:120/255,b:120/255,a:1},
                                    item_backing__glow_select__lineThickness:               0,
                                    item_backing__glow_select_press__colour:                {r:250/255,g:250/255,b:250/255,a:1},
                                    item_backing__glow_select_press__lineColour:            {r:120/255,g:120/255,b:120/255,a:1},
                                    item_backing__glow_select_press__lineThickness:         0,
                                    item_backing__hover__colour:                            {r:229/255,g:167/255,b:255/255,a:1},
                                    item_backing__hover__lineColour:                        {r:0/255,g:0/255,b:0/255,a:0},
                                    item_backing__hover__lineThickness:                     0,
                                    item_backing__hover_press__colour:                      {r:240/255,g:240/255,b:240/255,a:1},
                                    item_backing__hover_press__lineColour:                  {r:0/255,g:0/255,b:0/255,a:0},
                                    item_backing__hover_press__lineThickness:               0,
                                    item_backing__hover_select__colour:                     {r:239/255,g:209/255,b:255/255,a:1},
                                    item_backing__hover_select__lineColour:                 {r:120/255,g:120/255,b:120/255,a:1},
                                    item_backing__hover_select__lineThickness:              0,
                                    item_backing__hover_select_press__colour:               {r:240/255,g:240/255,b:240/255,a:1},
                                    item_backing__hover_select_press__lineColour:           {r:120/255,g:120/255,b:120/255,a:1},
                                    item_backing__hover_select_press__lineThickness:        0,
                                    item_backing__hover_glow__colour:                       {r:239/255,g:209/255,b:255/255,a:1},
                                    item_backing__hover_glow__lineColour:                   {r:0/255,g:0/255,b:0/255,a:0},
                                    item_backing__hover_glow__lineThickness:                0,
                                    item_backing__hover_glow_press__colour:                 {r:250/255,g:250/255,b:250/255,a:1},
                                    item_backing__hover_glow_press__lineColour:             {r:0/255,g:0/255,b:0/255,a:0},
                                    item_backing__hover_glow_press__lineThickness:          0,
                                    item_backing__hover_glow_select__colour:                {r:240/255,g:240/255,b:240/255,a:1},
                                    item_backing__hover_glow_select__lineColour:            {r:120/255,g:120/255,b:120/255,a:1},
                                    item_backing__hover_glow_select__lineThickness:         0,
                                    item_backing__hover_glow_select_press__colour:          {r:250/255,g:250/255,b:250/255,a:1},
                                    item_backing__hover_glow_select_press__lineColour:      {r:120/255,g:120/255,b:120/255,a:1},
                                    item_backing__hover_glow_select_press__lineThickness:   0,
                                }
                            );
                        };
                        this.darkMode = function(){
                            this.currentStyleMode = 'dark';
                        
                            _canvas_.control.scene.backgroundColour({r:0,g:0,b:0,a:1});
                        
                            const mux = 0.2;
                            _canvas_.control.gui.style.set(
                                {
                                    backgroundColour:{r:240/255*mux,g:240/255*mux,b:240/255*mux,a:1},
                            
                                    text__font:'Helvetica',
                                    text__fontSize:14,
                                    text__spacing:0.3,
                                    text__interCharacterSpacing:0.04,
                            
                                    text_colour__off:                                       {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__up:                                        {r:1.0,g:1.0,b:1.0,a:1},
                                    text_colour__press:                                     {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__select:                                    {r:0.0,g:0.0,b:0.0,a:1},
                                    text_colour__select_press:                              {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__glow:                                      {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__glow_press:                                {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__glow_select:                               {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__glow_select_press:                         {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__hover:                                     {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__hover_press:                               {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__hover_select:                              {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__hover_select_press:                        {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__hover_glow:                                {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__hover_glow_press:                          {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__hover_glow_select:                         {r:0.2,g:0.2,b:0.2,a:1},
                                    text_colour__hover_glow_select_press:                   {r:0.2,g:0.2,b:0.2,a:1},
                                        
                                    item_backing__off__colour:                              {r:180/255,g:180/255,b:180/255,a:1},
                                    item_backing__off__lineColour:                          {r:0/255,g:0/255,b:0/255,a:0},
                                    item_backing__off__lineThickness:                       0,
                                    item_backing__up__colour:                               {r:240/255*mux,g:240/255*mux,b:240/255*mux,a:1},
                                    item_backing__up__lineColour:                           {r:0/255,g:0/255,b:0/255,a:0},
                                    item_backing__up__lineThickness:                        0,
                                    item_backing__press__colour:                            {r:240/255,g:240/255,b:240/255,a:1},
                                    item_backing__press__lineColour:                        {r:0/255,g:0/255,b:0/255,a:0},
                                    item_backing__press__lineThickness:                     0,
                                    item_backing__select__colour:                           {r:1,g:1,b:1,a:1},
                                    item_backing__select__lineColour:                       {r:0/255,g:0/255,b:0/255,a:0},
                                    item_backing__select__lineThickness:                    0,
                                    item_backing__select_press__colour:                     {r:0.85,g:0.85,b:0.85,a:1},
                                    item_backing__select_press__lineColour:                 {r:0,g:0,b:0,a:0},
                                    item_backing__select_press__lineThickness:              0,
                                    item_backing__glow__colour:                             {r:220/255,g:220/255,b:220/255,a:1},
                                    item_backing__glow__lineColour:                         {r:0/255,g:0/255,b:0/255,a:0},
                                    item_backing__glow__lineThickness:                      0,
                                    item_backing__glow_press__colour:                       {r:250/255,g:250/255,b:250/255,a:1},
                                    item_backing__glow_press__lineColour:                   {r:0/255,g:0/255,b:0/255,a:0},
                                    item_backing__glow_press__lineThickness:                0,
                                    item_backing__glow_select__colour:                      {r:220/255,g:220/255,b:220/255,a:1},
                                    item_backing__glow_select__lineColour:                  {r:120/255,g:120/255,b:120/255,a:1},
                                    item_backing__glow_select__lineThickness:               0,
                                    item_backing__glow_select_press__colour:                {r:250/255,g:250/255,b:250/255,a:1},
                                    item_backing__glow_select_press__lineColour:            {r:120/255,g:120/255,b:120/255,a:1},
                                    item_backing__glow_select_press__lineThickness:         0,
                                    item_backing__hover__colour:                            {r:1,g:1,b:1,a:1},
                                    item_backing__hover__lineColour:                        {r:0/255,g:0/255,b:0/255,a:0},
                                    item_backing__hover__lineThickness:                     0,
                                    item_backing__hover_press__colour:                      {r:0.85,g:0.85,b:0.85,a:1},
                                    item_backing__hover_press__lineColour:                  {r:0/255,g:0/255,b:0/255,a:0},
                                    item_backing__hover_press__lineThickness:               0,
                                    item_backing__hover_select__colour:                     {r:0.9,g:0.9,b:0.9,a:1},
                                    item_backing__hover_select__lineColour:                 {r:120/255,g:120/255,b:120/255,a:1},
                                    item_backing__hover_select__lineThickness:              0,
                                    item_backing__hover_select_press__colour:               {r:0.85,g:0.85,b:0.85,a:1},
                                    item_backing__hover_select_press__lineColour:           {r:120/255,g:120/255,b:120/255,a:1},
                                    item_backing__hover_select_press__lineThickness:        0,
                                    item_backing__hover_glow__colour:                       {r:239/255,g:209/255,b:255/255,a:1},
                                    item_backing__hover_glow__lineColour:                   {r:0/255,g:0/255,b:0/255,a:0},
                                    item_backing__hover_glow__lineThickness:                0,
                                    item_backing__hover_glow_press__colour:                 {r:250/255,g:250/255,b:250/255,a:1},
                                    item_backing__hover_glow_press__lineColour:             {r:0/255,g:0/255,b:0/255,a:0},
                                    item_backing__hover_glow_press__lineThickness:          0,
                                    item_backing__hover_glow_select__colour:                {r:240/255,g:240/255,b:240/255,a:1},
                                    item_backing__hover_glow_select__lineColour:            {r:120/255,g:120/255,b:120/255,a:1},
                                    item_backing__hover_glow_select__lineThickness:         0,
                                    item_backing__hover_glow_select_press__colour:          {r:250/255,g:250/255,b:250/255,a:1},
                                    item_backing__hover_glow_select_press__lineColour:      {r:120/255,g:120/255,b:120/255,a:1},
                                    item_backing__hover_glow_select_press__lineThickness:   0,
                                }
                            );
                        };
                    };
                };
            
                this.viewport = new function(){
                    this.width = function(){ 
                        return _canvas_.width;///window.devicePixelRatio; 
                    };
                    this.height = function(){ 
                        return _canvas_.height;///window.devicePixelRatio; 
                    };
                    
                    this.position = function(x,y){
                        return _canvas_.core.viewport.position(x,y); 
                    };
                    this.scale = function(a){
                        return _canvas_.core.viewport.scale(a); 
                    };
                    this.angle = function(a){
                        return _canvas_.core.viewport.angle(a); 
                    };
                    this.refresh = function(){ 
                        _canvas_.core.meta.refresh();
                        control.gui.refresh();
                    };
                    this.stopMouseScroll = function(bool){ 
                        return _canvas_.core.viewport.stopMouseScroll(bool); 
                    };
                    this.activeRender = function(bool){ 
                        return _canvas_.core.render.active(bool); 
                    };
                };
                
                this.scene = new function(){
                    let IDcounter = 0;
                    
                    this.listLayers = function(printToConsole=false){
                    
                        if(!printToConsole){
                            function print(unit){
                                return { model:unit.model, name:unit.name, x:unit.x(), y:unit.y(), a:unit.angle() };
                            }
                            return {
                                foreground:_canvas_.system.pane.mf.getChildren().filter( a => !a._isCable ).map(print),
                                middleground:_canvas_.system.pane.mm.getChildren().filter( a => !a._isCable ).map(print),
                                background:_canvas_.system.pane.mb.getChildren().filter( a => !a._isCable ).map(print),
                            };
                        }
                    
                        function print(unit){
                            console.log( '\t', 'model:'+unit.model, 'name:'+unit.name, '-', '{x:'+unit.x()+',y:'+unit.y()+',a:'+unit.angle()+'}' );
                        }
                    
                        console.log('foreground'); _canvas_.system.pane.mf.children().filter( a => !a._isCable ).forEach(print);
                        console.log('middleground'); _canvas_.system.pane.mm.children().filter( a => !a._isCable ).forEach(print);
                        console.log('background'); _canvas_.system.pane.mb.children().filter( a => !a._isCable ).forEach(print);
                    };
                    this.backgroundColour = function(colour){
                        return _canvas_.core.render.clearColour(colour);
                    };
                    this.getAllUnits = function(pane=_canvas_.system.pane.mm){
                        return pane.getChildren().filter( a => !a._isCable );
                    };
                    this.getUnitByName = function(name,pane=_canvas_.system.pane.mm){
                        return pane.getChildByName(name);
                    };
                    this.getUnitsByModel = function(model){
                        return this.getAllUnits().filter( a => a.model == model );
                    };
                    this.getUnitUnderPoint = function(x,y,pane=_canvas_.system.pane.mm){
                        for(let a = 0; a < pane.getChildren().length; a++){
                            if( _canvas_.library.math.detectIntersect.pointWithinPoly({x:x,y:y}, pane.getChildren()[a].space) != 'outside' ){
                                return pane.getChildren()[a];
                            }
                        }
                    };
                    this.getUnitsWithinPoly = function(points,pane=_canvas_.system.pane.mm){
                        return pane.getChildren().filter(function(a){ 
                            return !a._isCable && _canvas_.library.math.detectIntersect.polyOnPoly(
                                {points:points,boundingBox:_canvas_.library.math.boundingBoxFromPoints(points)}, 
                                a.space
                            ).intersect;
                        });
                    };
                    const snapping = {active:false,x:10,y:10,angle:Math.PI/8};
                    this.activeSnapping = function(bool,pane=_canvas_.system.pane.mm){
                        
                        //control switch
                            if(!interactionState.snapping){return snapping.active;}
                    
                        if(bool == undefined){return snapping.active;}
                    
                        snapping.active = bool;
                        this.getAllUnits(pane).forEach(unit => unit.snappingActive(bool));
                    };
                    
                    const unitsInteractable = { active:true, store:{} };
                    this.unitsInteractable = function(bool,pane=_canvas_.system.pane.mm){
                    
                        if(bool == undefined){return unitsInteractable.active;}
                    
                        unitsInteractable.active = bool;
                    
                        this.getAllUnits(pane).forEach(unit => {
                            if(bool){
                                if(unitsInteractable.store[unit.getId()] != undefined){
                                    unit.interactable( unitsInteractable.store[unit.getId()] );
                                }
                            }else{
                                unitsInteractable.store[unit.getId()] = unit.interactable();
                                unit.interactable(bool);
                            }
                        });
                    };
                    
                    const cableDisconnectionConnection = { active:true, store:{} };
                    this.cableDisconnectionConnection = function(bool,pane=_canvas_.system.pane.mm){
                    
                        if(bool == undefined){return cableDisconnectionConnection.active;}
                    
                        cableDisconnectionConnection.active = bool;
                        
                        this.getAllUnits(pane).forEach(unit => {
                            if(bool){
                                if(cableDisconnectionConnection.store[unit.getId()] != undefined){
                                    unit.allowIOConnections(unitsInteractable.store[unit.getId()].allowIOConnections);
                                    unit.allowIODisconnections(unitsInteractable.store[unit.getId()].allowIODisconnections);
                                }
                            }else{
                                cableDisconnectionConnection.store[unit.getId()] = {
                                    allowIOConnections: unit.allowIOConnections(),
                                    allowIODisconnections: unit.allowIODisconnections(),
                                };
                                unit.allowIOConnections(bool);
                                unit.allowIODisconnections(bool);
                            }
                        });
                    };
                    this.generateUnitName = function(){
                        return String(IDcounter++);
                    };
                    this.addUnit = function(x,y,a,model,collection,forceName,rectify=true,pane=_canvas_.system.pane.mm){
                    
                        //control switch
                            if(!interactionState.unitAdditionRemoval){return;}
                    
                        //input checking
                            if(model == undefined){
                                console.warn('error::control.scene.addUnit: no model defined'); 
                                return;
                            }
                            if(collection == undefined){
                                console.warn('error::control.scene.addUnit: no collection defined'); 
                                return;
                            }
                    
                        //generate new name for unit
                            const name = forceName==undefined ? this.generateUnitName() : forceName;
                    
                        //produce unit, assign its name and add grapple code
                            if( _canvas_.interface.unit.collection[collection] == undefined ){
                                console.warn('unknown unit collection "'+collection+'" (_canvas_.interface.unit.collection['+collection+'])'); 
                                return;
                            }
                            if( _canvas_.interface.unit.collection[collection][model] == undefined ){
                                console.warn('unknown unit model "'+model+'" (_canvas_.interface.unit.collection['+collection+']['+model+'])'); 
                                return;
                            }
                    
                            let tmp = _canvas_.interface.unit.collection[collection][model](name,x,y,a);
                            tmp.collection = collection;
                            tmp = _canvas_.control.grapple.declare(tmp);
                    
                        //if snapping is active in the scene, don't forget to activate it for this new unit too
                            if(interactionState.snapping){ tmp.snappingActive(snapping.active); }
                    
                        //if requested to do so; check if this new position is possible, and if not find the closest one that is and adjust the unit's position accordingly
                            if(rectify){ this.rectifyUnitPosition(tmp); }
                    
                        //add it to the pane
                            pane.append( tmp );
                    
                        //run the unit's onCreate method
                            tmp._oncreate();
                            if(tmp.oncreate){tmp.oncreate();}
                    
                        //register action
                            control.actionRegistry.registerAction(
                                {
                                    functionName:'control.scene.addUnit',
                                    arguments:[x,y,a,model,collection,forceName,rectify,pane.getAddress()],
                                    name:tmp.getName(),
                                }
                            );
                    
                        return tmp;    
                    };
                    this.removeUnit = function(unit){
                    
                        //control switch
                            if(!interactionState.unitAdditionRemoval){return;}
                    
                        //safety
                            if(unit == undefined){return;}
                    
                        //only proceed if unit is actually in the scene
                            if(_canvas_.system.pane.getMiddlegroundPane(unit) == undefined){ return; }
                    
                        //register action
                            control.actionRegistry.registerAction(
                                {
                                    functionName:'control.scene.removeUnit',
                                    name:unit.getName(),
                                    pane:_canvas_.system.pane.getMiddlegroundPane(unit),
                                    data:this.documentUnits([unit])[0],
                                }
                            );
                    
                        //run the unit's onDelete method
                            unit._ondelete();
                            if(unit.ondelete){unit.ondelete();}
                        //run disconnect on every connection node of this unit
                            unit.disconnectEverything();
                        //remove the object from the pane
                            _canvas_.system.pane.getMiddlegroundPane(unit).remove(unit);
                    };
                    this.transferUnits = function(units,destinationPane){
                    
                        //control switch
                            if(!interactionState.unitTransfer){return;}
                        
                        //register action
                            control.actionRegistry.registerAction(
                                {
                                    functionName:'control.scene.transferUnit',
                                    arguments:[units.map(unit=>unit.getName()),destinationPane],
                                    originalPanes:units.map(unit=>_canvas_.system.pane.getMiddlegroundPane(unit)),
                                }
                            );
                    
                        //collect all the information for these units
                            const data = this.documentUnits(units);
                        //remove the original units
                            units.forEach(unit => this.removeUnit(unit));
                        //print the units to the destination pane
                            return this.printUnits(data,true,destinationPane);
                    };
                    this.rectifyUnitPosition = function(unit,pane=_canvas_.system.pane.mm){
                        
                        //control switch
                            if(!interactionState.unitCollision){return;}
                    
                        //if this unit is to ignore any collision, just bail
                            if(!unit.collisionActive){return false;}
                    
                        //discover if there's an overlap; if not skip all this
                            const allOtherUnits = control.scene.getAllUnits(pane).filter(a => a != unit && a.collisionActive).map(a => { return a.space; });
                    
                            let anyCollision = false;
                            for(let a = 0; a < allOtherUnits.length; a++){
                                anyCollision = anyCollision || _canvas_.library.math.detectIntersect.polyOnPoly( unit.space, allOtherUnits[a] ).intersect;
                            }
                            if(!anyCollision){return false;}
                    
                        //get the offset which will allow this unit to fit
                            const offset = _canvas_.library.math.fitPolyIn( unit.space, allOtherUnits, snapping );
                    
                        //apply offset
                            unit.x(unit.x() + offset.x);
                            unit.y(unit.y() + offset.y);
                        
                        return true; //false: no change was made - true: a change was made
                    };
                    this.documentUnits = function(units,selfContained=false){
                    
                        // position             -   the X, Y and angle of the original object
                        // details              -   data on the unit's type
                        //      collection
                        //      model
                        // data                 -   the exported data from the original object
                        // connections          -   an array of where to connect what
                        //      typeAndNameOfSourcePort
                        //      indexOfDestinationUnit
                        //      typeAndNameOfDestinationPort
                    
                        const outputData = [];
                    
                        //cycle through this array, and create the scene data
                            for(let a = 0; a < units.length; a++){
                                const unit = units[a];
                                const entry = {};
                    
                                //get the units position
                                    entry.position = { x:unit.x(), y:unit.y(), angle:unit.angle() };
                    
                                //unitDetails
                                    entry.details = { collection:unit.collection, model:unit.model };
                    
                                //export the unit's state
                                    entry.data = unit.exportData ? unit.exportData() : {};
                    
                                //log all connections
                                    entry.connections = [];
                                        for(let connectionType in unit.io){
                                            for(let connection in unit.io[connectionType]){
                                                const foreignNode = unit.io[connectionType][connection].getForeignNode();
                                                if(foreignNode == undefined){continue;} //this node isn't connected to anything, so just bail
                                        
                                                const newConnectionEntry = {};
                    
                                                //typeAndNameOfSourcePort
                                                    newConnectionEntry.typeAndNameOfSourcePort = { type:connectionType, name:connection };
                    
                                                //nameOfDestinationUnit
                                                        newConnectionEntry.nameOfDestinationUnit = selfContained ? undefined : foreignNode.parent.getName();
                                                //indexOfDestinationUnit
                                                    newConnectionEntry.indexOfDestinationUnit = units.indexOf(foreignNode.parent);
                    
                                                //typeAndNameOfDestinationPort
                                                    newConnectionEntry.typeAndNameOfDestinationPort = { type:connectionType, name:foreignNode.getName() };
                    
                                                entry.connections.push(newConnectionEntry);
                                            }
                                        }
                    
                                //add this entry to the save data list
                                    outputData.push(entry);
                            }
                    
                        return outputData;  
                    };
                    this.printUnits = function(units, rectify=true, pane=_canvas_.system.pane.mm, autoselect=true){
                    
                        const printedUnits = [];
                    
                        for(let a = 0; a < units.length; a++){
                            const item = units[a];
                    
                            //create the object with its new position adding it to the pane
                                const unit = control.scene.addUnit(
                                    item.position.x, item.position.y, item.position.angle,
                                    item.details.model, item.details.collection, 
                                    item.details.name, 
                                    rectify, pane
                                );
                                printedUnits.push(unit);
                    
                            //import data and select unit
                                if(unit.importData){ try{ unit.importData(item.data); }catch(error){console.warn('control.scene.printUnits:: unable to import data into unit correctly'); console.warn(error);} }
                                if(autoselect){control.selection.selectUnit(unit);}
                    
                            //go through its connections, and attempt to connect them to everything they should be connected to
                            // (don't worry if a object isn't available yet, just skip that one. Things will work out in the end)
                                for(let b = 0; b < item.connections.length; b++){
                                    const connection = item.connections[b];
                    
                                    const destinationUnit = connection.indexOfDestinationUnit != -1 ? control.selection.selectedUnits[connection.indexOfDestinationUnit] : control.scene.getUnitByName(connection.nameOfDestinationUnit);
                                    if(destinationUnit == undefined){continue;}
                    
                                    const sourceNode = unit.io[connection.typeAndNameOfSourcePort.type][connection.typeAndNameOfSourcePort.name];
                                    const destinationNode = destinationUnit.io[connection.typeAndNameOfDestinationPort.type][connection.typeAndNameOfDestinationPort.name];
                                    
                                    sourceNode.connectTo(destinationNode);
                                }
                        }
                    
                        return printedUnits;
                    };
                    this.new = function(askForConfirmation=true){
                    
                        //control switch
                            if(!interactionState.newScene){return;}
                    
                        if(interactionState.unloadWarning && askForConfirmation){
                            if( !confirm("This will clear the current scene! Are you sure?") ){ return; }
                        }
                    
                        this.getAllUnits().forEach(unit => this.removeUnit(unit));
                    
                        IDcounter = 0;
                        control.viewport.position(0,0);
                        control.viewport.scale(1);
                        control.viewport.angle(0);
                    
                        control.actionRegistry.clearRegistry();
                    };
                    this.load = function(url,callback,askForConfirmation=true){
                    
                        //control switch
                            if(!interactionState.sceneLoad){return;}
                    
                        if(interactionState.unloadWarning && askForConfirmation){
                            if( !confirm("This will clear the current scene! Are you sure?") ){ return; }
                        }
                    
                        //procedure for loading in a .crv file
                            function procedure(data,callback){
                                //stopping audio
                                    _canvas_.library.audio.destination.masterGain(0);
                    
                                //unpack data
                                    data = _canvas_.library.misc.unpackData(data);
                    
                                //clear scene
                                    control.scene.new(false);
                    
                                //print to scene
                                    control.scene.printUnits( data.units );
                                
                                //reposition viewport
                                    control.viewport.position( data.viewportLocation.xy.x, data.viewportLocation.xy.y );
                                    control.viewport.scale( data.viewportLocation.scale );
                    
                                //restarting audio
                                    _canvas_.library.audio.destination.masterGain(1);
                    
                                //select everything again to shift every unit in front of the cables, then deselect all units
                                    control.selection.selectEverything(true);
                                    control.selection.deselectEverything();
                    
                                //clear the actionRegister
                                    control.actionRegistry.clearRegistry();
                    
                                //callback
                                    if(callback){callback(metadata);}
                            }
                    
                        //depending on whether a url has been provided or not, perform the appropriate load
                            if(url == undefined){ //load from file
                                _canvas_.library.misc.openFile(function(data){procedure(data,callback);});
                            }else{ //load from url
                                _canvas_.library.misc.loadFileFromURL(url,function(text){ procedure(text.response,callback); },undefined,'text');
                            }
                    };
                    this.save = function(filename='project.crv',compress=false){
                    
                        //control switch
                            if(!interactionState.sceneSave){return;}
                        
                        //stopping audio
                            _canvas_.library.audio.destination.masterGain(0);
                    
                        //gather some initial data
                            const outputData = {
                                filename: filename,
                                viewportLocation: {
                                    xy: _canvas_.control.viewport.position(),
                                    scale: _canvas_.control.viewport.scale(),
                                },
                            };
                    
                        //gather the scene data
                            outputData.units = this.documentUnits( this.getAllUnits().filter(a => !a._isCable) );
                    
                        //pack up data
                            const packedOutputData = _canvas_.library.misc.packData(outputData,compress);
                    
                        //print to file
                            _canvas_.library.misc.printFile(filename,packedOutputData);
                    
                        //restarting audio
                            _canvas_.library.audio.destination.masterGain(1);
                    };

                };
                this.selection = new function(){
                    this.selectedUnits = [];
                    this.lastSelectedUnit = null;
                    this.clipboard = [];
                    
                    this.selectUnit = function(unit,shiftToFront=true){ 
                    
                        //control switch
                            if(!interactionState.unitSelection){return;}
                    
                        //check if object is already selected
                            if( this.selectedUnits.indexOf(unit) != -1 ){return;}
                    
                        //shift object to front of view, (within it's particular pane)
                            if(shiftToFront){
                                const pane = _canvas_.system.pane.getMiddlegroundPane(unit);
                                pane.remove(unit);
                                pane.append(unit);
                            }
                    
                        //colourize space
                            const tmp = _canvas_.interface.part.builder( 
                                'basic', 'polygonWithOutline', 'control.selection::shape::selectionGlow', 
                                {
                                    pointsAsXYArray:unit.space.originalPoints, 
                                    colour:{r:244/255,g:226/255,b:66/255,a:0.25}, lineColour:{r:244/255,g:226/255,b:66/255,a:1}
                                } 
                            );
                            unit.append(tmp);
                    
                        //perform selection
                            if(unit.onselect){object.onselect();}
                            this.selectedUnits.push(unit);
                            this.lastSelectedUnit = unit;
                    };
                    this.selectUnits = function(unitList){
                        for(let a = 0; a < unitList.length; a++){
                            this.selectUnit(unitList[a]);
                        }
                    };
                    this.deselectUnit = function(unit){
                    
                        //decolourize space
                            unit.remove( unit.getChildByName('control.selection::shape::selectionGlow') );
                        
                        //remove unit from selectedUnits list, and activate it's "ondeselect" function
                            this.selectedUnits.splice(this.selectedUnits.indexOf(unit),1);
                            if(unit.ondeselect){unit.ondeselect();}
                    };
                    this.selectEverything = function(shiftToFront=false){
                        this.deselectEverything();
                        _canvas_.system.pane.mm.getChildren().filter(item => !item._isCable).forEach(unit => { this.selectUnit(unit,shiftToFront); });
                    };
                    this.deselectEverything = function(){
                        while(this.selectedUnits.length > 0){
                            this.deselectUnit( this.selectedUnits[0] );
                        }
                    };
                    
                    this.cut = function(){
                    
                        //control switch
                            if(!interactionState.unitAdditionRemoval){return;}
                    
                        this.copy();
                        this.delete();
                    };
                    this.copy = function(){
                    
                        //control switch
                            if(!interactionState.unitAdditionRemoval){return;}
                    
                        this.clipboard = _canvas_.control.scene.documentUnits(this.selectedUnits,true);
                    };
                    this.paste = function(position,rectify=true){
                    
                        //control switch
                            if(!interactionState.unitAdditionRemoval){return;}
                    
                        //if clipboard is empty, don't bother
                            if(this.clipboard.length == 0){return;}
                    
                        //deselect everything
                            this.deselectEverything();
                    
                        //position manipulation
                        //if position is not set to 'duplicate'; calculate new positions for the objects
                            if(position != 'duplicate'){
                                //collect all positions
                                    const points = [];
                                    this.clipboard.forEach( element => points.push(element.position) );
                    
                                //get the bounding box of this selection, and then the top left point of that
                                    const topLeft = _canvas_.library.math.boundingBoxFromPoints(points).topLeft;
                    
                                //if no position has been provided at all; calculate a new one from the mouse position
                                    if(position == undefined){
                                        position = _canvas_.core.viewport.getMousePosition();
                                        position = _canvas_.core.viewport.adapter.windowPoint2workspacePoint(position.x,position.y);
                                        if(position.x == undefined || position.y == undefined){
                                            position = _canvas_.core.viewport.adapter.windowPoint2workspacePoint(0, 0);
                                        }
                                    }
                    
                                //combine this topLeft point with the provided (or calculated) position, 
                                //then add this to the mouses' position
                                    this.clipboard.forEach( function(element){
                                        element.position.x += position.x - topLeft.x;
                                        element.position.y += position.y - topLeft.y;
                                    } );
                            }
                    
                        //unit printing
                            _canvas_.control.scene.printUnits( this.clipboard, rectify );
                    };
                    this.duplicate = function(rectify=true){
                    
                        //control switch
                            if(!interactionState.unitAdditionRemoval){return;}
                    
                        //form register action
                            const action = {
                                functionName:'control.selection.duplicate',
                                unitsToDuplicate:control.selection.selectedUnits.map(unit => unit.getName()),
                            };
                            
                        control.actionRegistry.actionRegistrationActive(false);
                        this.copy();
                        this.paste('duplicate',rectify);
                        this.clipboard = [];
                        control.actionRegistry.actionRegistrationActive(true);
                    
                        //push action
                            action.finalPositions = control.selection.selectedUnits.map(unit => ({x:unit.x(),y:unit.y(),a:unit.angle()}));
                            action.producedUnitNames = control.selection.selectedUnits.map(unit => unit.getName());
                            control.actionRegistry.registerAction(action);
                    };
                    this.delete = function(){
                    
                        //control switch
                            if(!interactionState.unitAdditionRemoval){return;}
                    
                        //if there's nothing to delete, then don't bother trying
                        if(this.selectedUnits.length == 0){return;}
                    
                        //register bookend action
                            control.actionRegistry.registerAction(
                                {
                                    functionName:'control.selection.delete',
                                    count:this.selectedUnits.length,
                                    bookendPosition:'start',
                                }
                            );
                    
                        const selectedUnitCount = this.selectedUnits.length;
                        while(this.selectedUnits.length > 0){
                            control.scene.removeUnit(this.selectedUnits[0]);
                            this.deselectUnit(this.selectedUnits[0]);
                        }
                        this.lastSelectedUnit = null;
                    
                        //register bookend action
                            control.actionRegistry.registerAction(
                                {
                                    functionName:'control.selection.delete',
                                    count:selectedUnitCount,
                                    bookendPosition:'end',
                                }
                            );
                    };
                    
                    this.clearClipboard = function(){
                        this.clipboard = []
                    };
                };
            
                this.actionRegistry = new function(){
                    let _devMode = false;
                    let actionRegistrationActive = true;
                    let actionRegistry = [];
                    let actionPointer = -1;
                    
                    this.actionRegistrationActive = function(a){
                        if(a==undefined){return actionRegistrationActive;}
                        actionRegistrationActive = a;
                    };
                    
                    this.undoFunctionLibrary = {};
                    this.redoFunctionLibrary = {};
                    
                    this.printRegistry = function(printToConsole=false){ 
                        if(printToConsole){ 
                            actionRegistry.forEach((item,index) => console.log(actionPointer==index?'->':'  ',item));
                        }else{
                            return {
                                actionPointer: actionPointer,
                                actionRegistry: actionRegistry,
                                actionRegistrationActive: actionRegistrationActive
                            }; 
                        }
                    };
                    this.clearRegistry = function(){
                        actionRegistry = [];
                        actionPointer = -1;
                    };
                    this.registerAction = function(action){
                    
                        //only register actions if allowed to do so
                            if(!actionRegistrationActive){return;}
                    
                        //if an action is being added but the pointer is not at the end of the actionRegistry; delete everything after the pointer
                            if(actionPointer != actionRegistry.length-1){
                                actionRegistry.splice(actionPointer+1);
                            }
                    
                        //add action and increment pointer
                            actionRegistry.push(action);
                            actionPointer++;
                    
                    };
                    
                    this.undo = function(){
                    
                        //if the 'current action' is a place beyond the list, this means that there's nothing left to undo, so just bail
                            if(actionPointer <= -1){return;}
                    
                        //gather the action
                            const mostRecentAction = actionRegistry[actionPointer];
                    
                        //if this action has an entry in the undo function library, decrement the pointer and execute that function
                            if(mostRecentAction.functionName in this.undoFunctionLibrary){
                                actionPointer--;
                                this.undoFunctionLibrary[mostRecentAction.functionName](mostRecentAction);
                            }
                    
                    };
                    this.redo = function(){
                    
                        //if the 'next action' is a place beyond the list, this means that there's nothing left to redo, so just bail
                            if(actionRegistry.length <= actionPointer+1){return;}
                    
                        //gather the next action
                            const nextAction = actionRegistry[actionPointer+1];
                    
                        //if this action has an entry in the redo function library, increment the pointer and execute that function
                            if(nextAction.functionName in this.redoFunctionLibrary){
                                actionPointer++;
                                this.redoFunctionLibrary[nextAction.functionName](nextAction);
                            }
                    
                    };
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    //control.scene.addUnit
                        this.undoFunctionLibrary['control.scene.addUnit'] = function(action){
                            actionRegistrationActive = false;
                            control.scene.removeUnit( control.scene.getUnitByName(action.name) );
                            actionRegistrationActive = true;
                        };
                        this.redoFunctionLibrary['control.scene.addUnit'] = function(action){
                            const args = action.arguments;
                            actionRegistrationActive = false;
                            control.scene.addUnit(args[0],args[1],args[2],args[3],args[4],action.name,args[6],_canvas_.core.arrangement.getElementByAddress(args[7]));
                            actionRegistrationActive = true;
                        };
                    
                    //control.scene.removeUnit
                        this.undoFunctionLibrary['control.scene.removeUnit'] = function(action){
                            actionRegistrationActive = false;
                            action.data.details.name = action.name;
                            control.scene.printUnits( [action.data], true, action.pane, false );
                            actionRegistrationActive = true;
                        };
                        this.redoFunctionLibrary['control.scene.removeUnit'] = function(action){
                            actionRegistrationActive = false;
                            control.scene.removeUnit( control.scene.getUnitByName(action.name) );
                            actionRegistrationActive = true;
                        };
                    
                    //control.selection.delete
                        this.undoFunctionLibrary['control.selection.delete'] = function(action){
                            for(let a = 0; a < action.count; a++){ control.actionRegistry.undo(); }
                            actionPointer--;
                        };
                        this.redoFunctionLibrary['control.selection.delete'] = function(action){
                            for(let a = 0; a < action.count; a++){ control.actionRegistry.redo(); }
                            actionPointer+=1;
                        };
                    
                    //control.selection.duplicate
                        this.undoFunctionLibrary['control.selection.duplicate'] = function(action){
                            actionRegistrationActive = false;
                            action.producedUnitNames.forEach(name => { control.scene.removeUnit( control.scene.getUnitByName(name) ); });
                            actionRegistrationActive = true;
                        };
                        this.redoFunctionLibrary['control.selection.duplicate'] = function(action){
                    
                            _canvas_.control.selection.deselectEverything();
                    
                            action.unitsToDuplicate.forEach( name => _canvas_.control.selection.selectUnit(_canvas_.control.scene.getUnitByName(name)) );
                    
                            actionRegistrationActive = false;
                            control.selection.duplicate();
                            control.selection.selectedUnits.forEach((unit,index) => {
                                unit.x(action.finalPositions[index].x);
                                unit.y(action.finalPositions[index].y);
                                unit.angle(action.finalPositions[index].a);
                                unit.name = action.producedUnitNames[index];
                            });
                            actionRegistrationActive = true;
                        };
                };
                this.queryString = new function(){
                    let modsBeingLoaded = 0;
                    
                    this.modParameterKey = 'mod';
                    this.controlModListPostfix = 'cml';
                    this.demoParameterKey = 'demo';
                    this.defaultDemoUrlPrefix =  'localhost:8000/demos/';
                    
                    this.modsBeingLoaded = function(){return modsBeingLoaded;};
                    this.modLoader = function(loadingCompleteCallback){
                        function loadMod(modURL){
                            modsBeingLoaded++;
                    
                            _canvas_.library.misc.loadFileFromURL(modURL,function(responseText){
                                var modListFileExtension = '.'+_canvas_.control.queryString.controlModListPostfix;
                                if( modURL.slice(-modListFileExtension.length) == modListFileExtension ){
                                    responseText.response.split('\n').forEach(url => loadMod(url));
                                }else{
                                    var newScript = document.createElement('script');
                                    newScript.innerHTML = responseText.response;
                                    newScript.id = modURL;
                                    document.body.append(newScript);
                                }
                                modsBeingLoaded--;
                    
                                if(modsBeingLoaded == 0 && loadingCompleteCallback){loadingCompleteCallback();}
                            },undefined,'text');
                        }
                        
                        var tmp = (new URL(window.location.href)).searchParams.get(_canvas_.control.queryString.modParameterKey);
                        if(tmp != undefined){ loadMod(tmp); }
                    
                        var counter = 1;
                        do{
                            tmp = (new URL(window.location.href)).searchParams.get(_canvas_.control.queryString.modParameterKey+counter++);
                            if(tmp != undefined){ loadMod(tmp); }
                        }while(tmp != undefined)
                    };
                    this.demoLoader = function(loadingCompleteCallback,beDumbAboutIt=false){
                    
                        function loadDemo(){
                            const demoURL = (new URL(window.location.href)).searchParams.get(_canvas_.control.queryString.demoParameterKey);
                        
                            if(demoURL == undefined){
                                return;
                            }else if( !isNaN(parseInt(demoURL)) ){
                                _canvas_.control.scene.load(_canvas_.control.queryString.defaultDemoUrlPrefix+parseInt(demoURL)+'.crv',loadingCompleteCallback,false);
                            }else{ 
                                _canvas_.control.scene.load(demoURL,loadingCompleteCallback,false);
                            }
                        }
                        function waiter(){
                            if(modsBeingLoaded > 0){ setTimeout(waiter,1000); return; }
                            loadDemo();
                        }
                    
                        beDumbAboutIt ? loadDemo() : waiter();
                    };
                };
            
                this.grapple = new function(){
                    this.tmpdata = {};
                    this.tmpunit = undefined;
                    this.functionList = { onmousedown:[], onmouseup:[], };
                    
                    this.declare = function(unit){
                    
                        function grappleFunctionRunner(list){
                            return function(x,y,event){
                                //save unit
                                    _canvas_.control.grapple.tmpunit = unit;
                                
                                //run through function list, and activate functions where necessary
                                    _canvas_.library.structure.functionListRunner(list,_canvas_.system.keyboard.pressedKeys)(event);
                            };
                        }
                    
                        unit.space.shape.attachCallback('onmousedown', grappleFunctionRunner( this.functionList.onmousedown ) );
                        unit.space.shape.attachCallback('onmouseup', grappleFunctionRunner( this.functionList.onmouseup ) );
                        return unit;
                    };
                    
                    
                    
                    //selection of current unit and deselection of previous unit (if shift is not pressed)
                    this.functionList.onmousedown.push(
                        {
                            requiredKeys:[],
                            function:function(event){
                    
                                // if mousedown occurs over an unit that isn't selected
                                //  and if the shift key is not pressed
                                //   deselect everything
                                //  now, select the unit we're working on if not selected
                                    if( !control.selection.selectedUnits.includes(control.grapple.tmpunit) ){
                                        if(!event.shiftKey){ control.selection.deselectEverything(); }
                                        control.selection.selectUnit(control.grapple.tmpunit);
                                    }
                            },
                        }
                    );
                    //unit rotation
                    this.functionList.onmousedown.push(
                        {
                            requiredKeys:[['shift','alt']],
                            function:function(event){
                    
                                //control switch
                                    if(!interactionState.unitGrappleRotation){return;}
                                
                                //collect together information on the click position and the selected unit's positions and section area
                                    control.grapple.tmpdata.oldClickPosition = _canvas_.core.viewport.adapter.windowPoint2workspacePoint(event.X,event.Y);
                                    control.grapple.tmpdata.oldUnitsPositions = [];
                                    control.grapple.tmpdata.oldUnitsSelectionArea = [];
                                    control.grapple.tmpdata.focalPoint = {x:-1,y:-1};
                                    for(let a = 0; a < control.selection.selectedUnits.length; a++){
                                        control.grapple.tmpdata.oldUnitsPositions.push( {x:control.selection.selectedUnits[a].x(), y:control.selection.selectedUnits[a].y(), angle:control.selection.selectedUnits[a].angle()} );
                                        control.grapple.tmpdata.oldUnitsSelectionArea.push( Object.assign({},control.selection.selectedUnits[a].selectionArea) );
                                        if(control.grapple.tmpdata.focalPoint.x == -1 || control.grapple.tmpdata.focalPoint.x > control.selection.selectedUnits[a].x()){ control.grapple.tmpdata.focalPoint.x = control.selection.selectedUnits[a].x(); }
                                        if(control.grapple.tmpdata.focalPoint.y == -1 || control.grapple.tmpdata.focalPoint.y > control.selection.selectedUnits[a].y()){ control.grapple.tmpdata.focalPoint.y = control.selection.selectedUnits[a].y(); }
                                    }
                    
                                //perform the rotation for all selected units
                                    _canvas_.system.mouse.mouseInteractionHandler(
                                        function(x,y,event){
                                            for(let a = 0; a < control.selection.selectedUnits.length; a++){
                                                const unit = control.selection.selectedUnits[a];
                    
                                                //calculate new angle
                                                    const rotationalMux = 1/100;
                                                    const oldClickPosition = control.grapple.tmpdata.oldClickPosition;
                                                    const newClickPosition = _canvas_.core.viewport.adapter.windowPoint2workspacePoint(event.X,event.Y);
                                                    const oldUnitPosition = control.grapple.tmpdata.oldUnitsPositions[a];
                    
                                                    const producedAngle = (newClickPosition.y - oldClickPosition.y) * rotationalMux;
                    
                                                //rotate unit
                                                    unit.angle(oldUnitPosition.angle + producedAngle);
                    
                                                //calculate xy offset around the focal point of the angle adjust
                                                    const offset = _canvas_.library.math.cartesianAngleAdjust(
                                                        oldUnitPosition.x - control.grapple.tmpdata.focalPoint.x,
                                                        oldUnitPosition.y - control.grapple.tmpdata.focalPoint.y,
                                                        producedAngle
                                                    );
                    
                                                //maintain position
                                                    unit.x(offset.x + control.grapple.tmpdata.focalPoint.x);
                                                    unit.y(offset.y + control.grapple.tmpdata.focalPoint.y);
                    
                                                //check if this new position is possible, and if not find the closest one that is and adjust the unit's position accordingly
                                                    _canvas_.control.scene.rectifyUnitPosition(unit);
                    
                                                //perform all redraws and updates for unit
                                                    if( unit.onrotate ){unit.onrotate();}
                                                    unit.ioRedraw();
                                            }
                                        },
                                        function(x,y,event){},
                                    );
                    
                                return true;
                            }
                        }
                    );
                    this.functionList.onmousedown.push(
                        {
                            requiredKeys:[['alt']],
                            function:function(){
                                _canvas_.control.selection.duplicate(false);
                            },
                        }
                    );
                    this.functionList.onmouseup.push(
                        {
                            requiredKeys:[],
                            function:function(){
                    
                                _canvas_.control.selection.selectedUnits.forEach(unit => {
                                    _canvas_.control.scene.rectifyUnitPosition(unit);
                                    unit.ioRedraw();
                                });
                            },
                        }
                    );
                    //unit movement
                    this.functionList.onmousedown.push(
                        {
                            requiredKeys:[],
                            function:function(event){
                    
                                //control switch
                                    if(!interactionState.unitGrapplePosition){return;}
                    
                                //collect together information on the click position and the selected unit's positions and section area
                                    control.grapple.tmpdata.oldClickPosition = _canvas_.core.viewport.adapter.windowPoint2workspacePoint(event.X,event.Y);
                                    control.grapple.tmpdata.oldUnitsPositions = [];
                                    control.grapple.tmpdata.oldUnitsSelectionArea = [];
                                    for(let a = 0; a < control.selection.selectedUnits.length; a++){
                                        control.grapple.tmpdata.oldUnitsPositions.push( {x:control.selection.selectedUnits[a].x(),y:control.selection.selectedUnits[a].y()} );
                                        control.grapple.tmpdata.oldUnitsSelectionArea.push( Object.assign({},control.selection.selectedUnits[a].selectionArea) );
                                    }
                    
                                //perform the move for all selected units
                                    _canvas_.system.mouse.mouseInteractionHandler(
                                        function(x,y,event){
                                            for(let a = 0; a < control.selection.selectedUnits.length; a++){
                                                const unit = control.selection.selectedUnits[a];
                    
                                                //calculate new position
                                                    const oldClickPosition = control.grapple.tmpdata.oldClickPosition;
                                                    const newClickPosition = _canvas_.core.viewport.adapter.windowPoint2workspacePoint(event.X,event.Y);
                                                    const oldUnitPosition = control.grapple.tmpdata.oldUnitsPositions[a];
                                                    const newUnitPosition = {
                                                        x: oldUnitPosition.x + (newClickPosition.x - oldClickPosition.x),
                                                        y: oldUnitPosition.y + (newClickPosition.y - oldClickPosition.y),
                                                    };
                    
                                                //move unit
                                                    unit.x(newUnitPosition.x);
                                                    unit.y(newUnitPosition.y);
                    
                                                //check if this new position is possible, and if not find the closest one that is and adjust the unit's position accordingly
                                                    _canvas_.control.scene.rectifyUnitPosition(unit);
                    
                                                //perform all redraws and updates for unit
                                                    if( unit.onmove ){unit.onmove();}
                                                    unit.ioRedraw();
                                            }
                                        },
                                        function(x,y,event){}
                                    );
                    
                                return true;
                            }
                        }
                    );
                    
                    //deselection of unit (with shift pressed)
                    this.functionList.onmouseup.push(
                        {
                            requiredKeys:[['shift']],
                            function:function(event){
                    
                                //if mouse-up occurs over an unit that is selected
                                // and if the shift key is pressed
                                // and if the unit we're working on is not the most recently selected
                                //  deselect the unit we're working on
                                // now set the most recently selected reference to null
                                    if( control.selection.selectedUnits.indexOf(control.grapple.tmpunit) != -1 ){
                                        if( control.selection.lastSelectedUnit != control.grapple.tmpunit ){
                                            control.selection.deselectUnit(control.grapple.tmpunit);
                                        }
                                        control.selection.lastSelectedUnit = null;
                                    }
                    
                                return true;
                            }
                        }
                    );
                };
            
                //close dropdowns on click
                _canvas_.system.mouse.functionList.onmousedown.push(
                    {
                        requiredKeys:[],
                        function:function(){
                            //close any open menubar dropdowns
                                _canvas_.control.gui.closeAllDropdowns();
                        }
                    }
                );
                //group select (shift)
                _canvas_.system.mouse.functionList.onmousedown.push(
                    {
                        requiredKeys:[['shift']],
                        function:function(data){
                
                            //control switch
                                if(!interactionState.mouseGroupSelect){return;}
                
                            //create selection graphic and add it to the foreground
                                const mouseDownPoint = _canvas_.core.viewport.adapter.windowPoint2workspacePoint(data.x,data.y);
                                _canvas_.system.mouse.tmp.selectionRectangle = _canvas_.interface.part.builder( 
                                    'basic', 'rectangle', 'selectionRectangle', 
                                    { x:mouseDownPoint.x, y:mouseDownPoint.y, width:0, height:0, colour:{r:224/255, g:184/255, b:252/255, a:0.25} } 
                                );
                                _canvas_.system.pane.mf.append( _canvas_.system.mouse.tmp.selectionRectangle );
                
                            //follow mouse, adjusting selection rectangle as it moves. On mouse up, remove the rectangle and select all
                            //units that touch the area
                                _canvas_.system.mouse.tmp.start = {x:mouseDownPoint.x, y:mouseDownPoint.y};
                                _canvas_.system.mouse.mouseInteractionHandler(
                                    function(x,y,event){
                                        const start = _canvas_.system.mouse.tmp.start;
                                        const end = _canvas_.core.viewport.adapter.windowPoint2workspacePoint(event.X,event.Y);
                
                                        _canvas_.system.mouse.tmp.selectionRectangle.width( end.x - start.x );
                                        _canvas_.system.mouse.tmp.selectionRectangle.height( end.y - start.y );
                                    },
                                    function(x,y,event){
                                        _canvas_.system.pane.mf.remove( _canvas_.system.mouse.tmp.selectionRectangle );
                
                                        const start = _canvas_.system.mouse.tmp.start;
                                        const end = _canvas_.core.viewport.adapter.windowPoint2workspacePoint(event.X,event.Y);
                
                                        _canvas_.control.selection.selectUnits(
                                            _canvas_.control.scene.getUnitsWithinPoly([ {x:start.x,y:start.y}, {x:end.x,y:start.y}, {x:end.x,y:end.y}, {x:start.x,y:end.y} ]) 
                                        );
                                    },
                                );
                
                            return true;
                        }
                    }
                );
                //panning
                _canvas_.system.mouse.functionList.onmousedown.push(
                    {
                        requiredKeys:[],
                        function:function(data){
                
                            _canvas_.control.selection.deselectEverything();
                            
                            //control switch
                                if(!interactionState.mouseGripPanning){return;}
                
                            //save the viewport position and click position
                                _canvas_.system.mouse.tmp.oldPosition = _canvas_.control.viewport.position();
                                _canvas_.system.mouse.tmp.clickPosition = {x:data.x, y:data.y};
                
                            //perform viewport movement
                                _canvas_.system.mouse.mouseInteractionHandler(
                                    function(x,y,event){
                                        //update the viewport position
                                            _canvas_.control.viewport.position(
                                                _canvas_.system.mouse.tmp.oldPosition.x - ((_canvas_.system.mouse.tmp.clickPosition.x-event.X)),
                                                _canvas_.system.mouse.tmp.oldPosition.y - ((_canvas_.system.mouse.tmp.clickPosition.y-event.Y)),
                                            );
                                    },
                                    function(event){},
                                );
                
                            //request that the function list stop here
                                return true;
                        }
                    }
                );
                
                //zoom
                this.mouseWheelMode = 'magic'; // magic / clickyWheel
                _canvas_.system.mouse.functionList.onwheel.push(
                    {
                        requiredKeys:[],
                        function:function(data){
                
                            //control switch
                                if(!interactionState.mouseWheelZoom){return;}
                
                            const scaleLimits = {'max':20, 'min':0.1};
                            
                            let delta = data.event.wheelDeltaY;
                            switch(control.mouseWheelMode){
                                case 'magic':
                                    //already pefect
                                break;
                                case 'clickyWheel':
                                    delta = 25*Math.sign(delta);
                                break;
                            }
                
                            //perform scale and associated pan
                                //discover point under mouse
                                    const originalPoint = _canvas_.core.viewport.adapter.windowPoint2workspacePoint(data.x,data.y);
                                //perform actual scaling
                                    let scale = _canvas_.control.viewport.scale();
                                    scale += scale*(delta/100);
                                    if( scale > scaleLimits.max ){ scale = scaleLimits.max; }
                                    else if( scale < scaleLimits.min ){ scale = scaleLimits.min; }
                                    _canvas_.control.viewport.scale(scale);
                                //discover new point under mouse
                                    const newPoint = _canvas_.core.viewport.adapter.windowPoint2workspacePoint(data.x,data.y);
                                //pan so we're back at the old point (accounting for angle)
                                    const pan = _canvas_.library.math.cartesianAngleAdjust(
                                        (newPoint.x - originalPoint.x),
                                        (newPoint.y - originalPoint.y),
                                        _canvas_.control.viewport.angle()
                                    );
                                    const temp = _canvas_.control.viewport.position();
                                    _canvas_.control.viewport.position(temp.x+pan.x*scale,temp.y+pan.y*scale)
                
                            //request that the function list stop here
                                return true;
                        }
                    }
                );
                _canvas_.system.keyboard.functionList.onkeydown.push(
                    {
                        requiredKeys:[['control','F2'],['command','F2']],
                        function:function(data){ 
                            _canvas_.control.scene.load(undefined,undefined,true);
                            _canvas_.system.keyboard.releaseAll();
                            return true; 
                        }
                    }
                );
                _canvas_.system.keyboard.functionList.onkeydown.push(
                    {
                        requiredKeys:[['control','F3'],['command','F3']],
                        function:function(data){ 
                            _canvas_.control.scene.save();
                            _canvas_.system.keyboard.releaseAll();
                            return true; 
                        }
                    }
                );
                _canvas_.system.keyboard.functionList.onkeydown.push(
                    {
                        requiredKeys:[['shift','control','KeyZ'],['shift','command','KeyZ']],
                        function:function(data){ 
                            _canvas_.control.actionRegistry.redo(); 
                            return true; 
                        }
                    }
                );
                _canvas_.system.keyboard.functionList.onkeydown.push(
                    {
                        requiredKeys:[['control','KeyZ'],['command','KeyZ']],
                        function:function(data){ 
                            _canvas_.control.actionRegistry.undo(); 
                            return true; 
                        }
                    }
                );
                _canvas_.system.keyboard.functionList.onkeydown.push(
                    {
                        requiredKeys:[['control','KeyX'],['command','KeyX']],
                        function:function(data){ 
                            _canvas_.system.keyboard.releaseAll(); 
                            _canvas_.control.selection.cut(); 
                            return true; 
                        }
                    }
                );
                _canvas_.system.keyboard.functionList.onkeydown.push(
                    {
                        requiredKeys:[['control','KeyC'],['command','KeyC']],
                        function:function(data){
                            _canvas_.system.keyboard.releaseAll(); 
                            _canvas_.control.selection.copy();
                            return true;
                        }
                    }
                );
                _canvas_.system.keyboard.functionList.onkeydown.push(
                    {
                        requiredKeys:[['control','KeyV'],['command','KeyV']],
                        function:function(data){
                            _canvas_.system.keyboard.releaseAll(); 
                            _canvas_.control.selection.paste();
                            return true; 
                        }
                    }
                );
                _canvas_.system.keyboard.functionList.onkeydown.push(
                    {
                        requiredKeys:[['control','KeyB'],['command','KeyB']],
                        function:function(data){ 
                            _canvas_.control.selection.duplicate(); 
                            return true; 
                        }
                    }
                );
                _canvas_.system.keyboard.functionList.onkeydown.push(
                    {
                        requiredKeys:[['Delete'],['Backspace']],
                        function:function(data){ 
                            _canvas_.control.selection.delete(); 
                            return true; 
                        }
                    }
                );
                _canvas_.system.keyboard.functionList.onkeydown.push(
                    {
                        requiredKeys:[['control','shift','KeyA'],['command','shift','KeyA']],
                        function:function(data){ 
                            _canvas_.control.selection.deselectEverything(); 
                            return true; 
                        }
                    }
                );
                _canvas_.system.keyboard.functionList.onkeydown.push(
                    {
                        requiredKeys:[['control','KeyA'],['command','KeyA']],
                        function:function(data){ 
                            _canvas_.control.selection.selectEverything();
                            return true; 
                        }
                    }
                );
            };
            
            if( new URL(window.location.href).searchParams.get("dev") != null ){
                _canvas_.control.interaction.unloadWarning(false);
                _canvas_.control.interaction.development(true);
            }
            
            window.onresize = _canvas_.control.viewport.refresh; 
            
            _canvas_.interface.go.add( function(){
                _canvas_.layers.registerLayerLoaded('control',_canvas_.control);
                _canvas_.control.go.__activate();
            } );

            _canvas_.curve = new function(){
                this.versionInformation = { tick:0, lastDateModified:{y:2020,m:3,d:8 } };
                this.go = new function(){
                    const functionList = [];
            
                    this.add = function(newFunction){ functionList.push(newFunction); };
                    this.__activate = function(){ functionList.forEach(f => f()); };
                };
            
            };
            
            _canvas_.control.go.add( function(){
                _canvas_.control.gui.showMenubar();
                _canvas_.control.viewport.stopMouseScroll(true);
                _canvas_.control.viewport.activeRender(true);
                _canvas_.core.render.activeLimitToFrameRate(true);
                _canvas_.core.render.frameRateLimit(30);
            
                _canvas_.layers.registerLayerLoaded('curve',_canvas_.curve);
                _canvas_.curve.go.__activate();
            } );
            
            _canvas_.curve.go.add(function(){
                _canvas_.control.queryString.modLoader();
                _canvas_.control.queryString.defaultDemoUrlPrefix = 'https://curve.metasophiea.com/demos/';
                _canvas_.control.queryString.demoLoader();
                if( (new URL(window.location.href)).searchParams.get("darkmode") != null ){ _canvas_.control.gui.style.darkMode(); }
            });
            
            
            _canvas_.interface.unit.collection = new function(){
                this.development = new function(){
                    this['test_c'] = function(name,x,y,angle){
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'test_c',
                                x:x, y:y, angle:angle,
                                space:[
                                    {x:0, y:0},
                                    {x:100, y:0},
                                    {x:100, y:100},
                                    {x:0, y:100},
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_audio', name:'input_1', data:{ 
                                        x:100, y:40, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'input_2', data:{ 
                                        x:100, y:60, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'input_3', data:{ 
                                        x:100, y:80, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'output', data:{ 
                                        x:0, y:55, width:5, height:15, angle:Math.PI, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    
                                    {collection:'basic', type:'rectangle', name:'backing', data:{ x:0, y:0, width:100, height:100, colour:{r:200/255,g:200/255,b:200/255,a:1} }},
                    
                                    {collection:'control', type:'dial_discrete', name:'mode', data:{
                                        x:20, y:20, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, optionCount:2,
                                    }},
                                    {collection:'control', type:'dial_continuous', name:'mix', data:{
                                        x:40, y:20, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2,
                                    }},
                                    // {collection:'control', type:'dial_continuous', name:'floor', data:{
                                    //     x:60, y:20, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2,
                                    // }},
                                    // {collection:'control', type:'dial_continuous', name:'detune', data:{
                                    //     x:80, y:20, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, arcDistance:1.2,
                                    // }},
                                    // {collection:'control', type:'dial_continuous', name:'dutyCycle', data:{
                                    //     x:100, y:20, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, arcDistance:1.2,
                                    // }},
                                    // {collection:'control', type:'dial_discrete', name:'gainMode', data:{
                                    //     x:20, y:40, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, optionCount:2,
                                    // }},
                                    // {collection:'control', type:'dial_discrete', name:'detuneMode', data:{
                                    //     x:40, y:40, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, optionCount:2,
                                    // }},
                                    // {collection:'control', type:'dial_discrete', name:'dutyCycleMode', data:{
                                    //     x:60, y:40, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, optionCount:2,
                                    // }},
                                ]
                            });
                    
                        //circuitry
                            SA = new _canvas_.interface.circuit.streamAdder(_canvas_.library.audio.context);
                    
                        //wiring
                            //hid
                                object.elements.dial_discrete.mode.onchange = function(value){
                                    SA.mode(value == 1);
                                };
                                object.elements.dial_continuous.mix.onchange = function(value){ 
                                    SA.mix(value);
                                };
                                // object.elements.dial_continuous.floor.onchange = function(value){
                                //     _canvas_.library.audio.changeAudioParam(_canvas_.library.audio.context, WNG.floor, value, 0.01, 'instant', true);
                                // };
                                // object.elements.dial_continuous.detune.onchange = function(value){
                                //     OSC.detune( value*2 - 1 );
                                // };
                                // object.elements.dial_continuous.dutyCycle.onchange = function(value){
                                //     OSC.dutyCycle( value );
                                // };
                                // object.elements.dial_discrete.gainMode.onchange = function(value){
                                //     OSC.gainMode(value);
                                // };
                                // object.elements.dial_discrete.detuneMode.onchange = function(value){
                                //     OSC.detuneMode(value);
                                // };
                                // object.elements.dial_discrete.dutyCycleMode.onchange = function(value){
                                //     OSC.dutyCycleMode(value);
                                // };
                    
                            //keycapture
                            //io
                                object.io.audio.input_1.audioNode = SA.in_1();
                                object.io.audio.input_2.audioNode = SA.in_2();
                                object.io.audio.input_3.audioNode = SA.mixControl();
                                object.io.audio.output.audioNode = SA.out();
                    
                        //interface
                            object.i = {
                            };
                    
                        //import/export
                            object.exportData = function(){
                            };
                            object.importData = function(data){
                            };
                    
                        //setup/tearDown
                            object.oncreate = function(){
                            };
                            object.ondelete = function(){
                            };
                    
                        return object;
                    };
                    this['test_c'].metadata = {
                        name:'test c',
                        category:'',
                        helpURL:''
                    };
                    const imageStoreURL = '/images/units/0 - development/';
                    const style = {
                        background:{r:70/255,g:70/255,b:70/255,a:1},
                        bumper:{r:0.125,g:0.125,b:0.125,a:1},
                        textColour:{r:0.7,g:0.7,b:0.7,a:1},
                    
                        primaryEight:[
                            {r:1,g:0.01,b:0.02,a:1},
                            {r:1,g:0.55,b:0,a:1},
                            {r:1,g:0.93,b:0,a:1},
                            {r:0,g:1,b:0,a:1},
                            {r:0,g:1,b:0.81,a:1},
                            {r:0,g:0.62,b:1,a:1},
                            {r:0.08,g:0,b:1,a:1},
                            {r:0.68,g:0,b:1,a:1}, 
                        ],
                    
                        marking:{
                            default:{r:0.7,g:0.7,b:0.7,a:1},
                            signal:{r:235/255,g:98/255,b:61/255,a:1},
                            voltage:{r:170/255,g:251/255,b:89/255,a:1},
                            data:{r:114/255,g:176/255,b:248/255,a:1},
                            audio:{r:243/255,g:173/255,b:61/255,a:1},
                        },
                        connectionNode:{
                            signal:{
                                dim:{r:235/255,g:98/255,b:61/255,a:1},
                                glow:{r:237/255,g:154/255,b:132/255,a:1},
                                cable_dim:{r:235/255,g:98/255,b:61/255,a:1},
                                cable_glow:{r:237/255,g:154/255,b:132/255,a:1},
                            },
                            voltage:{
                                dim:{r:170/255,g:251/255,b:89/255,a:1},
                                glow:{r:210/255,g:255/255,b:165/255,a:1},
                                cable_dim:{r:170/255,g:251/255,b:89/255,a:1},
                                cable_glow:{r:210/255,g:255/255,b:165/255,a:1},
                            },
                            data:{
                                dim:{r:114/255,g:176/255,b:248/255,a:1},
                                glow:{r:168/255,g:208/255,b:255/255,a:1},
                                cable_dim:{r:114/255,g:176/255,b:248/255,a:1},
                                cable_glow:{r:168/255,g:208/255,b:255/255,a:1},
                            },
                            audio:{
                                dim:{r:243/255,g:173/255,b:61/255,a:1},
                                glow:{r:247/255,g:203/255,b:133/255,a:1},
                                cable_dim:{r:243/255,g:173/255,b:61/255,a:1},
                                cable_glow:{r:247/255,g:203/255,b:133/255,a:1},
                            },
                        },
                        connectionCable:{
                            signal:{
                                dim:{r:235/255,g:98/255,b:61/255,a:1},
                                glow:{r:237/255,g:154/255,b:132/255,a:1},
                            },
                            voltage:{
                                dim:{r:170/255,g:251/255,b:89/255,a:1},
                                glow:{r:210/255,g:255/255,b:165/255,a:1},
                            },
                            data:{
                                dim:{r:114/255,g:176/255,b:248/255,a:1},
                                glow:{r:168/255,g:208/255,b:255/255,a:1},
                            },
                            audio:{
                                dim:{r:243/255,g:173/255,b:61/255,a:1},
                                glow:{r:247/255,g:203/255,b:133/255,a:1},
                            },
                        },
                    };
                    this['test_b'] = function(name,x,y,angle){
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'test_b',
                                x:x, y:y, angle:angle,
                                space:[
                                    {x:0, y:0},
                                    {x:100, y:0},
                                    {x:100, y:100},
                                    {x:0, y:100},
                                ],
                                elements:[
                                    // {collection:'dynamic', type:'connectionNode_audio', name:'input_1', data:{ 
                                    //     x:100, y:40, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    // }},
                                    // {collection:'dynamic', type:'connectionNode_audio', name:'input_2', data:{ 
                                    //     x:100, y:60, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    // }},
                                    // {collection:'dynamic', type:'connectionNode_audio', name:'input_3', data:{ 
                                    //     x:100, y:80, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    // }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'output', data:{ 
                                        x:0, y:55, width:5, height:15, angle:Math.PI, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    
                                    {collection:'basic', type:'rectangle', name:'backing', data:{ x:0, y:0, width:100, height:100, colour:{r:200/255,g:200/255,b:200/255,a:1} }},
                    
                                    {collection:'control', type:'dial_continuous', name:'frequency', data:{
                                        x:20, y:20, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, arcDistance:1.2, optionCount:3,
                                    }},
                                    {collection:'control', type:'dial_continuous', name:'harmonic_mux_1', data:{
                                        x:20+20, y:20, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:1/4, arcDistance:1.2, optionCount:3,
                                    }},
                                    {collection:'control', type:'dial_continuous', name:'harmonic_mux_2', data:{
                                        x:40+20, y:20, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:1/4, arcDistance:1.2,
                                    }},
                                    {collection:'control', type:'dial_continuous', name:'harmonic_power_1', data:{
                                        x:20+20, y:40, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:1/4, arcDistance:1.2,
                                    }},
                                    {collection:'control', type:'dial_continuous', name:'harmonic_power_2', data:{
                                        x:40+20, y:40, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:1/4, arcDistance:1.2,
                                    }},
                                ]
                            });
                    
                        //circuitry
                            OSC = new _canvas_.library.audio.audioWorklet.osc_2(_canvas_.library.audio.context);
                    
                        //wiring
                            //hid
                                object.elements.dial_continuous.frequency.onchange = function(value){
                                    _canvas_.library.audio.changeAudioParam(_canvas_.library.audio.context, OSC.frequency, value*880, 0.01, 'instant', true);
                                };
                                object.elements.dial_continuous.harmonic_mux_1.onchange = function(value){
                                    _canvas_.library.audio.changeAudioParam(_canvas_.library.audio.context, OSC.harmonic_mux_1, value*4, 0.01, 'instant', true);
                                };
                                object.elements.dial_continuous.harmonic_mux_2.onchange = function(value){
                                    _canvas_.library.audio.changeAudioParam(_canvas_.library.audio.context, OSC.harmonic_mux_2, value*4, 0.01, 'instant', true);
                                };
                                object.elements.dial_continuous.harmonic_power_1.onchange = function(value){
                                    _canvas_.library.audio.changeAudioParam(_canvas_.library.audio.context, OSC.harmonic_power_1, value*4, 0.01, 'instant', true);
                                };
                                object.elements.dial_continuous.harmonic_power_2.onchange = function(value){
                                    _canvas_.library.audio.changeAudioParam(_canvas_.library.audio.context, OSC.harmonic_power_2, value*4, 0.01, 'instant', true);
                                };
                    
                            //keycapture
                            //io
                                // object.io.audio.input_1.audioNode = OSC.gainControl();
                                // object.io.audio.input_2.audioNode = OSC.detuneControl();
                                // object.io.audio.input_3.audioNode = OSC.dutyCycleControl();
                                object.io.audio.output.audioNode = OSC;
                    
                        //interface
                            object.i = {
                            };
                    
                        //import/export
                            object.exportData = function(){
                            };
                            object.importData = function(data){
                            };
                    
                        //setup/tearDown
                            object.oncreate = function(){
                            };
                            object.ondelete = function(){
                            };
                    
                        return object;
                    };
                    this['test_b'].metadata = {
                        name:'test b',
                        category:'',
                        helpURL:''
                    };
                    this['test_a'] = function(name,x,y,angle){
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'test_a',
                                x:x, y:y, angle:angle,
                                space:[
                                    {x:0, y:0},
                                    {x:100, y:0},
                                    {x:100, y:100},
                                    {x:0, y:100},
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_audio', name:'input_1', data:{ 
                                        x:100, y:40, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'input_2', data:{ 
                                        x:100, y:60, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'input_3', data:{ 
                                        x:100, y:80, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'output', data:{ 
                                        x:0, y:55, width:5, height:15, angle:Math.PI, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    
                                    {collection:'basic', type:'rectangle', name:'backing', data:{ x:0, y:0, width:100, height:100, colour:{r:200/255,g:200/255,b:200/255,a:1} }},
                    
                                    {collection:'control', type:'dial_discrete', name:'waveform', data:{
                                        x:20, y:20, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, optionCount:3,
                                    }},
                                    {collection:'control', type:'dial_continuous', name:'frequency', data:{
                                        x:40, y:20, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, arcDistance:1.2,
                                    }},
                                    {collection:'control', type:'dial_continuous', name:'gain', data:{
                                        x:60, y:20, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:1, arcDistance:1.2,
                                    }},
                                    {collection:'control', type:'dial_continuous', name:'detune', data:{
                                        x:80, y:20, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, arcDistance:1.2,
                                    }},
                                    {collection:'control', type:'dial_continuous', name:'dutyCycle', data:{
                                        x:100, y:20, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, arcDistance:1.2,
                                    }},
                                    {collection:'control', type:'dial_discrete', name:'gainMode', data:{
                                        x:20, y:40, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, optionCount:2,
                                    }},
                                    {collection:'control', type:'dial_discrete', name:'detuneMode', data:{
                                        x:40, y:40, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, optionCount:2,
                                    }},
                                    {collection:'control', type:'dial_discrete', name:'dutyCycleMode', data:{
                                        x:60, y:40, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, optionCount:2,
                                    }},
                                ]
                            });
                    
                        //circuitry
                            const OSC = new _canvas_.interface.circuit.oscillator(_canvas_.library.audio.context);
                    
                        //wiring
                            //hid
                                object.elements.dial_discrete.waveform.onchange = function(value){
                                    OSC.waveform(value);
                                };
                                object.elements.dial_continuous.frequency.onchange = function(value){
                                    OSC.frequency( value*880 );
                                };
                                object.elements.dial_continuous.gain.onchange = function(value){
                                    OSC.gain( value*2 - 1 );
                                };
                                object.elements.dial_continuous.detune.onchange = function(value){
                                    OSC.detune( value*2 - 1 );
                                };
                                object.elements.dial_continuous.dutyCycle.onchange = function(value){
                                    OSC.dutyCycle( value );
                                };
                                object.elements.dial_discrete.gainMode.onchange = function(value){
                                    OSC.gainMode(value);
                                };
                                object.elements.dial_discrete.detuneMode.onchange = function(value){
                                    OSC.detuneMode(value);
                                };
                                object.elements.dial_discrete.dutyCycleMode.onchange = function(value){
                                    OSC.dutyCycleMode(value);
                                };
                    
                            //keycapture
                            //io
                                object.io.audio.input_1.audioNode = OSC.gainControl();
                                object.io.audio.input_2.audioNode = OSC.detuneControl();
                                object.io.audio.input_3.audioNode = OSC.dutyCycleControl();
                                object.io.audio.output.audioNode = OSC.out();
                    
                        //interface
                            object.i = {
                            };
                    
                        //import/export
                            object.exportData = function(){
                            };
                            object.importData = function(data){
                            };
                    
                        //setup/tearDown
                            object.oncreate = function(){
                            };
                            object.ondelete = function(){
                            };
                    
                        return object;
                    };
                    this['test_a'].metadata = {
                        name:'test a',
                        category:'',
                        helpURL:''
                    };
                    this['test_d'] = function(name,x,y,angle){
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'test_d',
                                x:x, y:y, angle:angle,
                                space:[
                                    {x:0, y:0},
                                    {x:100, y:0},
                                    {x:100, y:100},
                                    {x:0, y:100},
                                ],
                                elements:[
                                    // {collection:'dynamic', type:'connectionNode_audio', name:'input_1', data:{ 
                                    //     x:100, y:40, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    // }},
                                    // {collection:'dynamic', type:'connectionNode_audio', name:'input_2', data:{ 
                                    //     x:100, y:60, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    // }},
                                    // {collection:'dynamic', type:'connectionNode_audio', name:'input_3', data:{ 
                                    //     x:100, y:80, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    // }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'output', data:{ 
                                        x:0, y:55, width:5, height:15, angle:Math.PI, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    
                                    {collection:'basic', type:'rectangle', name:'backing', data:{ x:0, y:0, width:100, height:100, colour:{r:200/255,g:200/255,b:200/255,a:1} }},
                    
                                    {collection:'control', type:'dial_continuous', name:'frequency', data:{
                                        x:20, y:20, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, arcDistance:1.2,
                                    }},
                                    {collection:'control', type:'dial_discrete', name:'harmonic_mux_1', data:{
                                        x:20+20, y:20, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:1, arcDistance:1.2, optionCount:32,
                                    }},
                                    {collection:'control', type:'dial_discrete', name:'harmonic_power_1', data:{
                                        x:20+20, y:40, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:1, arcDistance:1.2, optionCount:32,
                                    }},
                                    {collection:'control', type:'dial_discrete', name:'harmonic_mux_2', data:{
                                        x:40+20, y:20, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:1, arcDistance:1.2, optionCount:32,
                                    }},
                                    {collection:'control', type:'dial_discrete', name:'harmonic_power_2', data:{
                                        x:40+20, y:40, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:1, arcDistance:1.2, optionCount:32,
                                    }},
                                ]
                            });
                    
                        //circuitry
                            OSC = new _canvas_.library.audio.audioWorklet.osc_3(_canvas_.library.audio.context);
                    
                        //wiring
                            //hid
                                object.elements.dial_continuous.frequency.onchange = function(value){
                                    _canvas_.library.audio.changeAudioParam(_canvas_.library.audio.context, OSC.frequency, value*880, 0.01, 'instant', true);
                                };
                                object.elements.dial_discrete.harmonic_mux_1.onchange = function(value){
                                    const temp = OSC.modulationSettings();
                                    temp[0].mux = value;
                                    OSC.modulationSettings(temp);
                                };
                                object.elements.dial_discrete.harmonic_mux_2.onchange = function(value){
                                    const temp = OSC.modulationSettings();
                                    temp[1].mux = value;
                                    OSC.modulationSettings(temp);
                                };
                                object.elements.dial_discrete.harmonic_power_1.onchange = function(value){
                                    const temp = OSC.modulationSettings();
                                    temp[0].power = value;
                                    OSC.modulationSettings(temp);
                                };
                                object.elements.dial_discrete.harmonic_power_2.onchange = function(value){
                                    const temp = OSC.modulationSettings();
                                    temp[1].power = value;
                                    OSC.modulationSettings(temp);
                                };
                    
                            //keycapture
                            //io
                                // object.io.audio.input_1.audioNode = OSC.gainControl();
                                // object.io.audio.input_2.audioNode = OSC.detuneControl();
                                // object.io.audio.input_3.audioNode = OSC.dutyCycleControl();
                                object.io.audio.output.audioNode = OSC;
                    
                        //interface
                            object.i = {
                            };
                    
                        //import/export
                            object.exportData = function(){
                            };
                            object.importData = function(data){
                            };
                    
                        //setup/tearDown
                            object.oncreate = function(){
                            };
                            object.ondelete = function(){
                            };
                    
                        return object;
                    };
                    this['test_d'].metadata = {
                        name:'test d',
                        category:'',
                        helpURL:''
                    };
                    
                    this._collectionData = {
                        name:'development',
                    };
                    this._categoryData = {
                    };
                };
                this.alpha = new function(){
                    this.voltage_combiner = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'voltage_combiner/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:260, height:260 },
                                        design: { width:4, height:4 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'voltage_combiner',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                                              y:(unitStyle.drawingValue.height -unitStyle.offset)/2 },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:0                                                   },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:unitStyle.drawingValue.height -unitStyle.offset     },
                                    { x:0,                                              y:unitStyle.drawingValue.height -unitStyle.offset     },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'output',   data:{ 
                                        x:0, y:unitStyle.drawingValue.height-14.5 + 5, width:5, height:10, angle:Math.PI, cableVersion:2, style:style.connectionNode.voltage 
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'input_1',  data:{ 
                                        x:unitStyle.drawingValue.width-3-1/3, y:10, width:5, height:10, cableVersion:2, style:style.connectionNode.voltage 
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'input_2',  data:{ 
                                        x:unitStyle.drawingValue.width-3-1/3, y:unitStyle.drawingValue.height-18-1/3, width:5, height:10, cableVersion:2, style:style.connectionNode.voltage 
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'port_mix', data:{ 
                                        x:unitStyle.drawingValue.width*0.78, y:unitStyle.drawingValue.height-3-1/3, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.voltage 
                                    }},
                    
                                    {collection:'basic', type:'image', name:'backing', data:{ 
                                        x:-unitStyle.offset/2, y:-unitStyle.offset/2, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png'
                                    } },
                    
                                    {collection:'control', type:'slide_continuous_image',name:'slide_mix',data:{
                                        x:32.5, y:10, width:5, height:25, handleHeight:0.18, value:0.5, resetValue:0.5,
                                        handleURL:unitStyle.imageStoreURL_localPrefix+'handle.png'
                                    }},
                                ]
                            });
                    
                            //circuitry
                                let mix = 0.5;
                                const inputValue = [0,0];
                                function calculateOutput(){ object.io.voltage.output.set( inputValue[1]*mix + inputValue[0]*(1-mix) ); }
                    
                            //wiring
                                //hid
                                    object.elements.slide_continuous_image.slide_mix.onchange = function(value){ mix = value; calculateOutput(); };
                                //io (updates hid)
                                    object.io.voltage.input_1.onchange = function(value){ inputValue[0] = value; calculateOutput(); };
                                    object.io.voltage.input_2.onchange = function(value){ inputValue[1] = value; calculateOutput(); };
                                    object.io.voltage.port_mix.onchange = function(value){ object.elements.slide_continuous_image.slide_mix.set(value); };
                    
                            //interface
                                object.i = {
                                    mix:function(value){ object.elements.slide_continuous_image.slide_mix.set(value); },
                                };
                    
                            //import/export
                                object.exportData = function(){ return mix; };
                                object.importData = function(data){
                                    if(data == undefined){return;}
                    
                                    object.elements.slide_continuous_image.slide_mix.set(data); 
                                };
                    
                            return object;
                        };
                    this.voltage_combiner.metadata = {
                        name:'Voltage Combiner',
                        category:'misc',
                        helpURL:'/help/units/alpha/voltage_combiner/'
                    };

                    this.audio_duplicator = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'audio_duplicator/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:320, height:320 },
                                        design: { width:5, height:5 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const reverseOffset = (unitStyle.drawingValue.width)*(0.875/10);
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'audio_duplicator',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:reverseOffset,                                                              y:0                                                       },
                                    { x:reverseOffset + (unitStyle.drawingValue.width -unitStyle.offset)*(1.7/10),  y:0                                                       },
                                    { x:reverseOffset + (unitStyle.drawingValue.width -unitStyle.offset)*(9/10),    y:(unitStyle.drawingValue.height -unitStyle.offset)*(1/5) },
                                    { x:reverseOffset + (unitStyle.drawingValue.width -unitStyle.offset)*(9/10),    y:(unitStyle.drawingValue.height -unitStyle.offset)*(4/5) },
                                    { x:reverseOffset + (unitStyle.drawingValue.width -unitStyle.offset)*(1.7/10),  y:unitStyle.drawingValue.height -unitStyle.offset         },
                                    { x:reverseOffset,                                                              y:unitStyle.drawingValue.height -unitStyle.offset         },
                                    { x:reverseOffset - (unitStyle.drawingValue.width -unitStyle.offset)*(0.9/10),  y:(unitStyle.drawingValue.height -unitStyle.offset)*(4/5) },
                                    { x:reverseOffset - (unitStyle.drawingValue.width -unitStyle.offset)*(1.25/10), y:(unitStyle.drawingValue.height -unitStyle.offset)*(1/2) },
                                    { x:reverseOffset - (unitStyle.drawingValue.width -unitStyle.offset)*(0.9/10),  y:(unitStyle.drawingValue.height -unitStyle.offset)*(1/5) },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_audio', name:'input', data:{ 
                                        x:unitStyle.drawingValue.width-10/3, y:(unitStyle.drawingValue.height-unitStyle.offset)*0.5 - 15/2, 
                                        width:5, height:15, cableVersion:2, style:style.connectionNode.audio,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'output_1', data:{ 
                                        x:0, y:(unitStyle.drawingValue.height-unitStyle.offset)/2 - 2.5, width:5, height:15, angle:0.15+Math.PI, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'output_2', data:{ 
                                        x:2.25, y:(unitStyle.drawingValue.height-unitStyle.offset)/2 - 2.5 + 20, width:5, height:15, angle:-0.15+Math.PI, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio,
                                    }},
                                    
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ 
                                            x:-unitStyle.offset/2, y:-unitStyle.offset/2,
                                            width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, 
                                            url:unitStyle.imageStoreURL_localPrefix+'backing.png'
                                        }
                                    },
                                ]
                            });
                    
                        //circuitry
                            const node = _canvas_.library.audio.context.createAnalyser();
                    
                        //wiring
                            //io
                                object.io.audio.input.audioNode = node;
                                object.io.audio.output_1.audioNode = node;
                                object.io.audio.output_2.audioNode = node;
                    
                        return object;
                    };
                    this.audio_duplicator.metadata = {
                        name:'Audio Duplicator',
                        category:'misc',
                        helpURL:'/help/units/alpha/audio_duplicator/'
                    };
                    this.data_combiner = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'data_combiner/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:320, height:320 },
                                        design: { width:5, height:5 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'data_combiner',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                                                      y:(unitStyle.drawingValue.height -unitStyle.offset)*(1/5) },
                                    { x:(unitStyle.drawingValue.width -unitStyle.offset)*(2/5), y:0                                                       },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset,         y:0                                                       },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset,         y:unitStyle.drawingValue.height -unitStyle.offset         },
                                    { x:(unitStyle.drawingValue.width -unitStyle.offset)*(2/5), y:unitStyle.drawingValue.height -unitStyle.offset         },
                                    { x:0,                                                      y:(unitStyle.drawingValue.height -unitStyle.offset)*(4/5) },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_data', name:'output', data:{ 
                                        x:0, y:(unitStyle.drawingValue.height-unitStyle.offset)/2 + 15/2, width:5, height:15, angle:Math.PI, cableVersion:2, style:style.connectionNode.data
                                    }},
                                    {collection:'dynamic', type:'connectionNode_data', name:'input_1', data:{ 
                                        x:unitStyle.drawingValue.width -3 -1/3, y:7.5, width:5, height:15, cableVersion:2, style:style.connectionNode.data
                                    }},
                                    {collection:'dynamic', type:'connectionNode_data', name:'input_2', data:{ 
                                        x:unitStyle.drawingValue.width -3 -1/3, y:27.5, width:5, height:15, cableVersion:2, style:style.connectionNode.data
                                    }},
                                    {collection:'basic', type:'image', name:'backing', data:{ 
                                        x:-unitStyle.offset/2, y:-unitStyle.offset/2, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png'
                                    }},
                                ]
                            });
                    
                        //wiring
                            //io
                                object.io.data.input_1.onreceive = function(address,data){ object.io.data.output.send(address,data); };
                                object.io.data.input_2.onreceive = function(address,data){ object.io.data.output.send(address,data); };
                        
                        return object;
                    };
                    this.data_combiner.metadata = {
                        name:'Data Combiner',
                        category:'misc',
                        helpURL:'/help/units/alpha/data_combiner/'
                    };
                    this.signal_combiner= function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'signal_combiner/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:260, height:260 },
                                        design: { width:4, height:4 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'signal_combiner',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                                              y:(unitStyle.drawingValue.height -unitStyle.offset)*0.25 },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:0 },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:unitStyle.drawingValue.height -unitStyle.offset        },
                                    { x:0,                                              y:(unitStyle.drawingValue.height -unitStyle.offset)*0.75 },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'output', data:{ 
                                        x:0, y:(unitStyle.drawingValue.height-unitStyle.offset)/2 + 5, width:5, height:10, angle:Math.PI, cableVersion:2, style:style.connectionNode.signal 
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'input_1', data:{ 
                                        x:unitStyle.drawingValue.width-3-1/3, y:7.5, width:5, height:10, cableVersion:2, style:style.connectionNode.signal 
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'input_2', data:{ 
                                        x:unitStyle.drawingValue.width-3-1/3, y:unitStyle.drawingValue.height-20.5-1/3, width:5, height:10, cableVersion:2, style:style.connectionNode.signal 
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ 
                                            x:-unitStyle.offset/2, y:-unitStyle.offset/2, 
                                            width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, 
                                            url:unitStyle.imageStoreURL_localPrefix+'backing.png'
                                        }
                                    },
                                ]
                            });
                    
                        //wiring
                            //io
                                object.io.signal.input_1.onchange = function(value){ object.io.signal.output.set(value || object.io.signal.input_2.read()); };
                                object.io.signal.input_2.onchange = function(value){ object.io.signal.output.set(value || object.io.signal.input_1.read()); };
                    
                        return object;
                    };
                    this.signal_combiner.metadata = {
                        name:'Signal Combiner',
                        category:'misc',
                        helpURL:'/help/units/alpha/signal_combiner/'
                    };
                    this.signal_duplicator = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'signal_duplicator/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:260, height:260 },
                                        design: { width:4, height:4 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'signal_duplicator',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                                              y:0                                                      },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:(unitStyle.drawingValue.height -unitStyle.offset)*0.25 },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:(unitStyle.drawingValue.height -unitStyle.offset)*0.75 },
                                    { x:0,                                              y:unitStyle.drawingValue.height -unitStyle.offset        },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'input', data:{ 
                                        x:unitStyle.drawingValue.width-10/3, y:(unitStyle.drawingValue.height-unitStyle.offset)/2 - 5, width:5, height:10, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'output_1', data:{ 
                                        x:0, y:(unitStyle.drawingValue.height-unitStyle.offset)/2 - 2.5, width:5, height:10, angle:Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'output_2', data:{
                                        x:0, y:(unitStyle.drawingValue.height-unitStyle.offset)/2 - 2.5 + 15, width:5, height:10, angle:Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ 
                                            x:-unitStyle.offset/2, y:-unitStyle.offset/2, 
                                            width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, 
                                            url:unitStyle.imageStoreURL_localPrefix+'backing.png'
                                        }
                                    },
                                ]
                            });
                    
                            //wiring
                                //io
                                    object.io.signal.input.onchange = function(value){ object.io.signal.output_1.set(value); object.io.signal.output_2.set(value); };
                    
                        return object;
                    };
                    this.signal_duplicator.metadata = {
                        name:'Signal Duplicator',
                        category:'misc',
                        helpURL:'/help/units/alpha/signal_duplicator/'
                    };
                    this.voltage_duplicator = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'voltage_duplicator/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:260, height:260 },
                                        design: { width:4, height:4 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'voltage_duplicator',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                                              y:0                                                   },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:(unitStyle.drawingValue.height -unitStyle.offset)/2 },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:unitStyle.drawingValue.height -unitStyle.offset     },
                                    { x:0,                                              y:unitStyle.drawingValue.height -unitStyle.offset     },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'input', data:{ 
                                        x:unitStyle.drawingValue.width-10/3, y:(unitStyle.drawingValue.height-unitStyle.offset)*0.75 - 5, width:5, height:10, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'output_1', data:{ 
                                        x:0, y:(unitStyle.drawingValue.height-unitStyle.offset)/2, width:5, height:10, angle:Math.PI, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'output_2', data:{
                                        x:0, y:(unitStyle.drawingValue.height-unitStyle.offset)/2 + 15, width:5, height:10, angle:Math.PI, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                    
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ 
                                            x:-unitStyle.offset/2, y:-unitStyle.offset/2, 
                                            width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, 
                                            url:unitStyle.imageStoreURL_localPrefix+'backing.png'
                                        }
                                    },
                                ]
                            });
                    
                        //wiring
                            //io
                                object.io.voltage.input.onchange = function(value){ object.io.voltage.output_1.set(value); object.io.voltage.output_2.set(value); };
                    
                        return object;
                    };
                    this.voltage_duplicator.metadata = {
                        name:'Voltage Duplicator',
                        category:'misc',
                        helpURL:'/help/units/alpha/voltage_duplicator/'
                    };
                    this.data_duplicator = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'data_duplicator/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:320, height:320 },
                                        design: { width:5, height:5 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'data_duplicator',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                                                      y:0                                                       },
                                    { x:(unitStyle.drawingValue.width -unitStyle.offset)*(3/5), y:0                                                       },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset,         y:(unitStyle.drawingValue.height -unitStyle.offset)*(1/5) },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset,         y:(unitStyle.drawingValue.height -unitStyle.offset)*(4/5) },
                                    { x:(unitStyle.drawingValue.width -unitStyle.offset)*(3/5), y:unitStyle.drawingValue.height -unitStyle.offset         },
                                    { x:0,                                                      y:unitStyle.drawingValue.height -unitStyle.offset         },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_data', name:'input', data:{ 
                                        x:unitStyle.drawingValue.width-10/3, y:(unitStyle.drawingValue.height-unitStyle.offset)/2 - 15/2, width:5, height:15, cableVersion:2, style:style.connectionNode.data,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_data', name:'output_1', data:{ 
                                        x:0, y:(unitStyle.drawingValue.height-unitStyle.offset)/2 - 2.5, width:5, height:15, angle:Math.PI, cableVersion:2, style:style.connectionNode.data,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_data', name:'output_2', data:{ 
                                        x:0, y:(unitStyle.drawingValue.height-unitStyle.offset)/2 - 2.5 + 20, width:5, height:15, angle:Math.PI, cableVersion:2, style:style.connectionNode.data,
                                    }},
                                    
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ 
                                            x:-unitStyle.offset/2, y:-unitStyle.offset/2,
                                            width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, 
                                            url:unitStyle.imageStoreURL_localPrefix+'backing.png'
                                        }
                                    },
                                ]
                            });
                    
                        //wiring
                            //io
                                object.io.data.input.onreceive = function(address,data){
                                    object.io.data.output_1.send(address,data);
                                    object.io.data.output_2.send(address,data);
                                };
                    
                        return object;
                    };
                    this.data_duplicator.metadata = {
                        name:'Data Duplicator',
                        category:'misc',
                        helpURL:'/help/units/alpha/data_duplicator/'
                    };
                    this.eightTrackMixer = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'eightTrackMixer/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:1550, height:830 },
                                        design: { width:25.5, height:13.5 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                                    this.dial = style.primaryEight.map(item => { return { handle:item, slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} }; });
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'eightTrackMixer',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                                              y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:unitStyle.drawingValue.height -unitStyle.offset },
                                    { x:0,                                              y:unitStyle.drawingValue.height -unitStyle.offset },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_audio', name:'output_L', data:{ 
                                        x:105, y:0, width:5, height:15, angle:-Math.PI/2, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'output_R', data:{ 
                                        x:130, y:0, width:5, height:15, angle:-Math.PI/2, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:-unitStyle.offset/2, y:-unitStyle.offset/2, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png' }
                                    },
                                ].concat(
                                    (function(){
                                        const newElements = [];
                                        for(let a = 0; a < 8; a++){
                                            newElements.push(
                                                {collection:'control', type:'dial_2_continuous',name:'dial_panner_'+a,data:{
                                                    x:20 +30*a, y:32.75, radius:(165/6)/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, arcDistance:1.2, value:0.5, resetValue:0.5, style:unitStyle.dial[a],
                                                }},
                                            );
                                            newElements.push(
                                                {collection:'control', type:'slide_continuous_image',name:'slide_volume_'+a,data:{
                                                    x:12.5 +30*a, y:52.5, width:15, height:75, handleHeight:0.125, value:1, resetValue:0.5,
                                                    handleURL:unitStyle.imageStoreURL_localPrefix+'volumeSlideHandles_'+a+'.png'
                                                }}
                                            );
                                            newElements.unshift(
                                                {collection:'dynamic', type:'connectionNode_audio', name:'input_'+a, data:{ 
                                                    x:27.5 +30*a, y:135, width:5, height:15, angle:Math.PI/2, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio,
                                                }},
                                            );
                                            newElements.unshift(
                                                {collection:'dynamic', type:'connectionNode_voltage', name:'voltageConnection_panner_'+a, data:{ 
                                                    x:0, y:20 +12.5*a, width:5, height:10, angle:Math.PI, cableVersion:2, style:style.connectionNode.voltage
                                                }},
                                            );
                                            newElements.unshift(
                                                {collection:'dynamic', type:'connectionNode_voltage', name:'voltageConnection_volume_'+a, data:{ 
                                                    x:255, y:30 +12.5*a, width:5, height:10, angle:0, cableVersion:2, style:style.connectionNode.voltage
                                                }},
                                            );
                                        }
                                        return newElements;
                                    })()
                                )
                            });
                    
                        //circuitry
                            const outLeft = _canvas_.library.audio.context.createAnalyser();
                            const outRight = _canvas_.library.audio.context.createAnalyser();
                            const audioLanes = []
                            for(let a = 0; a < 8; a++){
                                audioLanes.push( new _canvas_.interface.circuit.channelMultiplier(_canvas_.library.audio.context,2) );
                            }
                    
                        //wiring
                            //hid
                                for(let a = 0; a < 8; a++){
                                    object.elements.slide_continuous_image['slide_volume_'+a].onchange = function(a){
                                        return function(value){
                                            audioLanes[a].inGain(2*(1-value));
                                        }
                                    }(a);
                                    object.elements.dial_2_continuous['dial_panner_'+a].onchange = function(a){
                                        return function(value){
                                            audioLanes[a].outGain(0,1-value);
                                            audioLanes[a].outGain(1,value);
                                        }
                                    }(a);
                    
                                    object.elements.connectionNode_voltage['voltageConnection_panner_'+a].onchange = function(a){
                                        return function(value){
                                            object.elements.dial_2_continuous['dial_panner_'+a].set(value);
                                        }
                                    }(a);
                                    object.elements.connectionNode_voltage['voltageConnection_volume_'+a].onchange = function(a){
                                        return function(value){
                                            object.elements.slide_continuous_image['slide_volume_'+a].set(1-value);
                                        }
                                    }(a);
                                }
                            //io
                                object.io.audio.output_L.audioNode = outLeft;
                                object.io.audio.output_R.audioNode = outRight;
                    
                                for(let a = 0; a < 8; a++){
                                    object.io.audio['input_'+a].audioNode = audioLanes[a].in();
                                    audioLanes[a].out(0).connect( outLeft );
                                    audioLanes[a].out(1).connect( outRight );
                                }
                    
                        //interface
                            object.i = {
                                gain:function(track,value){
                                    if(value == undefined){
                                        return 1-object.elements.slide_continuous_image['slide_volume_'+track].get();
                                    }else{
                                        object.elements.slide_continuous_image['slide_volume_'+track].set(1-value);
                                    }
                                },
                                pan:function(track,value){
                                    if(value == undefined){
                                        return object.elements.dial_2_continuous['dial_panner_'+track].get();
                                    }else{
                                        object.elements.dial_2_continuous['dial_panner_'+track].set(value);
                                    }
                                },
                            };
                    
                        //import/export
                            object.exportData = function(){
                                return {
                                    gains:[...Array(8).keys()].map(item => object.i.gain(item)),
                                    pans:[...Array(8).keys()].map(item => object.i.pan(item)),
                                };
                            };
                            object.importData = function(data){
                                data.gains.forEach((value,index) => object.i.gain(index,value));
                                data.pans.forEach((value,index) => object.i.pan(index,value));
                            };
                    
                        //setup/tearDown
                            object.oncreate = function(){
                                for(let a = 0; a < 8; a++){
                                    object.i.gain(a,0.5);
                                    object.i.pan(a,0.5);
                                }
                            };
                    
                        return object;
                    };
                    this.eightTrackMixer.metadata = {
                        name:'Eight Track Mixer',
                        category:'misc',
                        helpURL:'/help/units/alpha/eightTrackMixer/'
                    };
                    this.signal_readout = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'signal_readout/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:320, height:290 },
                                        design: { width:5, height:4.5 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'signal_readout',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                                              y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:unitStyle.drawingValue.height -unitStyle.offset },
                                    { x:0,                                              y:unitStyle.drawingValue.height -unitStyle.offset },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in', data:{ 
                                        x:unitStyle.drawingValue.width-3.5, y:unitStyle.drawingValue.height-15, width:5, height:10, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:-unitStyle.offset/2, y:-unitStyle.offset/2, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png' }
                                    },
                                    {collection:'display', type:'glowbox_image', name:'lamp', 
                                        data:{ 
                                            x:5, y:5, width:35, height:35,
                                            dimURL:unitStyle.imageStoreURL_localPrefix+'light_off.png',
                                            glowURL:unitStyle.imageStoreURL_localPrefix+'light_on.png',
                                        },
                                    }
                                ]
                            });
                    
                        //wiring
                            //io
                                object.io.signal.in.onchange = function(value){
                                    if(value){ object.elements.glowbox_image.lamp.on(); }
                                    else{ object.elements.glowbox_image.lamp.off(); }
                                };
                    
                        return object;
                    };
                    this.signal_readout.metadata = {
                        name:'Signal Readout',
                        category:'monitors',
                        helpURL:'/help/units/alpha/signal_readout/'
                    };
                    this.amplifier = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'amplifier/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:935, height:860 },
                                        design: { width:15.5, height:14.25 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'amplifier',
                                x:x, y:y, angle:angle,
                                space:[
                                    {x:0,                                              y:0},
                                    {x:unitStyle.drawingValue.width -unitStyle.offset, y:0},
                                    {x:unitStyle.drawingValue.width -unitStyle.offset, y:unitStyle.drawingValue.height -unitStyle.offset},
                                    {x:0,                                              y:unitStyle.drawingValue.height -unitStyle.offset},
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_audio', name:'input_L', data:{
                                        x:unitStyle.drawingValue.width-unitStyle.offset,
                                        y:unitStyle.drawingValue.height-unitStyle.offset-20,
                                        width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'input_R', data:{ 
                                        x:unitStyle.drawingValue.width-unitStyle.offset,
                                        y:unitStyle.drawingValue.height-unitStyle.offset-40,
                                        width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio,
                                    }},
                    
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:-unitStyle.offset/2, y:-unitStyle.offset/2, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png' }
                                    },
                                ]
                            });
                    
                        //circuitry
                            const flow = {
                                destination:null,
                                stereoCombiner: null,
                                input_L: _canvas_.library.audio.context.createAnalyser(), input_R: _canvas_.library.audio.context.createAnalyser(), 
                            };
                            // const node = _canvas_.library.audio.context.createAnalyser();
                    
                            //destination
                                flow._destination = _canvas_.library.audio.destination;
                    
                            //stereo channel combiner
                                flow.stereoCombiner = new ChannelMergerNode(_canvas_.library.audio.context, {numberOfInputs:2});
                    
                            //audio connections
                                //populate input nodes
                                    object.io.audio.input_L.audioNode = flow.input_L;
                                    object.io.audio.input_R.audioNode = flow.input_R;
                                //inputs to stereo combiner
                                    flow.input_L.connect(flow.stereoCombiner, 0, 0);
                                    flow.input_R.connect(flow.stereoCombiner, 0, 1);
                                //stereo combiner to main output
                                    flow.stereoCombiner.connect(flow._destination);
                    
                        return object;
                    };
                    this.amplifier.metadata = {
                        name:'Amplifier',
                        category:'monitors',
                        helpURL:'/help/units/alpha/amplifier/'
                    };
                    this.voltage_readout = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'voltage_readout/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:440, height:290 },
                                        design: { width:7, height:4.5 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                                    this.gauge = {needles:[{r:0,g:0,b:0,a:1}]};
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'voltage_readout',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                                              y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:unitStyle.drawingValue.height -unitStyle.offset },
                                    { x:0,                                              y:unitStyle.drawingValue.height -unitStyle.offset },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'in', data:{ 
                                        x:unitStyle.drawingValue.width-3.5, y:unitStyle.drawingValue.height-15, width:5, height:10, angle:0, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', data:{ 
                                        x:-unitStyle.offset/2, y:-unitStyle.offset/2, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png'
                                    } },
                                    {collection:'display', type:'gauge_image', name:'gauge', data:{ 
                                        x:5, y:5, width:55, height:35,
                                        backingURL:unitStyle.imageStoreURL_localPrefix+'gauge_backing.png',
                                        style:unitStyle.gauge,
                                    }, },
                                ]
                            });
                    
                        //wiring
                            //io
                                object.io.voltage.in.onchange = function(value){
                                    object.elements.gauge_image.gauge.needle( Math.abs(value) );
                                };
                    
                        return object;
                    };
                    this.voltage_readout.metadata = {
                        name:'Voltage Readout',
                        category:'monitors',
                        helpURL:'/help/units/alpha/voltage_readout/'
                    };
                    this.audio_scope = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'audio_scope/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:1220, height:680 },
                                        design: { width:20, height:11 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                                    this.dial = { handle:{r:0.93,g:0,b:0.55,a:1}, slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                                    this.waveport = { backgroundText_size:10, backing:{r:0.15,g:0.15,b:0.15,a:1} };
                            };
                    
                        //main object creation
                        const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'audio_scope',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                                                          y:0                                                                 },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset,             y:0                                                                 },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset,             y:(unitStyle.drawingValue.height -unitStyle.offset)*(11.25/20) - 2  },
                                    { x:(unitStyle.drawingValue.width -unitStyle.offset)*(17.5/20), y:(unitStyle.drawingValue.height -unitStyle.offset)*(11.25/20) - 2  },
                                    { x:(unitStyle.drawingValue.width -unitStyle.offset)*(16/20),   y:(unitStyle.drawingValue.height -unitStyle.offset)*(14/20) - 2     },
                                    { x:(unitStyle.drawingValue.width -unitStyle.offset)*(16/20),   y:unitStyle.drawingValue.height -unitStyle.offset                   },
                                    { x:0,                                                          y:unitStyle.drawingValue.height -unitStyle.offset                   },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_audio', name:'input', data:{ 
                                        x:160, y:80, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', data:{ 
                                        x:-unitStyle.offset/2, y:-unitStyle.offset/2, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png'
                                    }},
                                    {collection:'control', type:'dial_2_continuous',name:'dial_framerate',data:{
                                        x:173.5, y:42.5, radius:75/6, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, resetValue:0.5, style:unitStyle.dial,
                                    }},
                                    {collection:'control', type:'button_image', name:'hold', data:{
                                        x:158.5, y:5, width:30, height:15, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_down.png',
                                    }},
                                    {collection:'display', type:'grapher_audioScope', name:'waveport', data:{
                                        x:5, y:5, width:150, height:100, canvasBased:true, style:unitStyle.waveport,
                                    }},
                                ]
                            });
                    
                        //circuitry
                            const attributes = {
                                framerateLimits: {min:1, max:30},
                                framerate:1,
                            };
                    
                        //wiring
                            //hid
                                object.elements.button_image.hold.onpress = function(){object.elements.grapher_audioScope.waveport.stop();};
                                object.elements.button_image.hold.onrelease = function(){object.elements.grapher_audioScope.waveport.start();};
                                object.elements.dial_2_continuous.dial_framerate.onchange = function(a){
                                    attributes.framerate = attributes.framerateLimits.min + Math.floor((attributes.framerateLimits.max - attributes.framerateLimits.min)*a);
                                    object.elements.grapher_audioScope.waveport.refreshRate(attributes.framerate);
                                };
                            //io 
                                object.io.audio.input.audioNode = object.elements.grapher_audioScope.waveport.getNode();
                    
                        //interface
                            object.i = {
                                framerate:function(a){
                                    if(a==undefined){return attributes.framerate;}
                                    object.elements.dial_2_continuous.dial_framerate.set(a/attributes.framerateLimits.max);
                                },
                                sampleWidth:function(a){
                                    return object.elements.grapher_audioScope.waveport.resolution(a);
                                },
                            };
                    
                        //import/export
                            object.exportData = function(){
                                return {
                                    framerate:object.i.framerate(),
                                    sampleWidth:object.i.sampleWidth(),
                                };
                            };
                            object.importData = function(data){
                                object.i.framerate(data.framerate);
                                object.i.sampleWidth(data.sampleWidth);
                            };
                            
                        //setup/tearDown
                            object.oncreate = function(){
                                object.elements.grapher_audioScope.waveport.start();
                                object.elements.dial_2_continuous.dial_framerate.set(0);
                            };
                    
                        return object;
                    };
                    this.audio_scope.metadata = {
                        name:'Audio Scope',
                        category:'monitors',
                        helpURL:'/help/units/alpha/audio_scope/'
                    };

                    this.data_readout = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'data_readout/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:1220, height:920 },
                                        design: { width:20, height:15 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'data_readout',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                                              y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:unitStyle.drawingValue.height -unitStyle.offset },
                                    { x:0,                                              y:unitStyle.drawingValue.height -unitStyle.offset },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_data', name:'in', data:{ 
                                        x:unitStyle.drawingValue.width-3.5, y:unitStyle.drawingValue.height-30, width:5, height:15, angle:0, cableVersion:2, style:style.connectionNode.data,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:-unitStyle.offset/2, y:-unitStyle.offset/2, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png' }
                                    },
                                ]
                            });
                    
                        //circuitry
                            let lineCount = 0;
                            let maxLineCount = 25;
                            const lines = [];
                            let lineElements = [];
                            const textStyle = {
                                colour:{r:1,g:1,b:1,a:1}, 
                                size:4, 
                                font:'defaultThin', 
                                printingMode:{widthCalculation:'absolute',horizontal:'left',vertical:'top'}
                            };
                            const maxPrintingWidth = 175;
                    
                            function printLine(line){
                                //add the new text to the list, and if the list becomes too long, remove the oldest item
                                    lines.unshift( { prefix:(lineCount++)+':/> ', line:line } );
                    
                                //empty screen of text
                                    for(let a = 0; a < lineElements.length; a++){ lineElements[a].parent.remove(lineElements[a]); }
                                    lineElements = [];
                    
                                //write all lines to screen
                                    for(let a = 0; a < lines.length; a++){
                                        lineElements[a] = _canvas_.interface.part.builder('basic','text','screenText_'+a,{ 
                                            x:12.5, y:12.5 + a*5, 
                                            width:textStyle.size,
                                            height:textStyle.size, 
                                            text:lines[a].prefix + lines[a].line, 
                                            colour:textStyle.colour, 
                                            font:textStyle.font, 
                                            printingMode:textStyle.printingMode
                                        });
                    
                                        //check the width of the created line, trim characters off until its within the defined width (storing the characters)
                                        let leftOvers = '';
                                        while( lineElements[a].resultingWidth() > maxPrintingWidth ){
                                            leftOvers = lineElements[a].string().substring(lineElements[a].string().length-1) + leftOvers;
                                            lineElements[a].string( lineElements[a].string().slice(0,-1) );
                                        }
                    
                                        //if there are characters that were trimmed, add them in their own line
                                        //also correct the original line
                                        if(leftOvers.length > 0){
                                            lines.splice(a+1,0,{prefix:lines[a].prefix,line:leftOvers});
                                            lines[a].line = lineElements[a].string().slice(lines[a].prefix.length);
                                        }
                    
                                        object.append( lineElements[a] );
                    
                                    //if there are too many lines, cut off the oldest
                                        while(lines.length > maxLineCount){ lines.pop(); }
                                }
                            }
                    
                        //wiring
                            //io
                                object.io.data.in.onreceive = function(address,data){ printLine( JSON.stringify({address:address, data:data}) ); };
                    
                        return object;
                    };
                    this.data_readout.metadata = {
                        name:'Data Readout',
                        category:'monitors',
                        helpURL:'/help/units/alpha/data_readout/'
                    };

                    this.audio_recorder = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'audio_recorder/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:590, height:260 },
                                        design: { width:9.5, height:4 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'audio_recorder',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                                              y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:unitStyle.drawingValue.height -unitStyle.offset },
                                    { x:0,                                              y:unitStyle.drawingValue.height -unitStyle.offset },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_audio', name:'io_input_R', data:{ 
                                        x:unitStyle.drawingValue.width-10/3, y:5, width:5, height:15, cableVersion:2, style:style.connectionNode.audio,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'io_input_L', data:{ 
                                        x:unitStyle.drawingValue.width-10/3, y:22.5, width:5, height:15, cableVersion:2, style:style.connectionNode.audio,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', data:{ 
                                        x:-unitStyle.offset/2, y:-unitStyle.offset/2, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png'
                                    }},
                                    {collection:'display', type:'glowbox_image', name:'light_empty', data:{
                                        x:5, y:4.15, height:10, width:19.5,
                                        glowURL:unitStyle.imageStoreURL_localPrefix+'light_empty_active.png',
                                        dimURL:unitStyle.imageStoreURL_localPrefix+'light_empty.png',
                                    }},
                                    {collection:'display', type:'glowbox_image', name:'light_recording', data:{
                                        x:5+(19.5+2/3)*1, y:4.15, height:10, width:19.5,
                                        glowURL:unitStyle.imageStoreURL_localPrefix+'light_recording_active.png',
                                        dimURL:unitStyle.imageStoreURL_localPrefix+'light_recording.png',
                                    }},
                                    {collection:'display', type:'glowbox_image', name:'light_paused', data:{
                                        x:5+(19.5+2/3)*2, y:4.15, height:10, width:19.5,
                                        glowURL:unitStyle.imageStoreURL_localPrefix+'light_paused_active.png',
                                        dimURL:unitStyle.imageStoreURL_localPrefix+'light_paused.png',
                                    }},
                                    {collection:'display', type:'glowbox_image', name:'light_stopped', data:{
                                        x:5+(19.5+2/3)*3, y:4.15, height:10, width:19.5,
                                        glowURL:unitStyle.imageStoreURL_localPrefix+'light_stopped_active.png',
                                        dimURL:unitStyle.imageStoreURL_localPrefix+'light_stopped.png',
                                    }},
                                    {collection:'display', type:'readout_sixteenSegmentDisplay', name:'time', data:{
                                        x:5+2/3, y:15+2/3, width:78.75, height:8.75, canvasBased:true, count:14, decimalPlaces:true, resolution:5,
                                    }},
                                    {collection:'control', type:'button_image', name:'button_record', data:{
                                        x:5, y:25+4/5, width:15+1/3, height:10, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_record.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_record_active.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'button_pause', data:{
                                        x:5+(16+1/6)*1, y:25+4/5, width:15+1/3, height:10, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_pause.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_pause_active.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'button_stop', data:{
                                        x:5+(16+1/6)*2, y:25+4/5, width:15+1/3, height:10, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_stop.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_stop_active.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'button_save', data:{
                                        x:5+(16+1/6)*3, y:25+4/5, width:15+1/3, height:10, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_save.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_save_active.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'button_delete', data:{
                                        x:5+(16+1/6)*4, y:25+4/5, width:15+1/3, height:10, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_delete.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_delete_active.png',
                                    }},
                                ]
                            });
                    
                        //circuitry
                            const recorderCircuit = new _canvas_.interface.circuit.recorder(_canvas_.library.audio.context);
                    
                            //time readout
                                const interval = setInterval(function(){
                                    const time = _canvas_.library.math.seconds2time( recorderCircuit.recordingTime() );
                                    object.elements.readout_sixteenSegmentDisplay.time.text(
                                        _canvas_.library.misc.padString(
                                            _canvas_.library.misc.padString(time.h,2,'0')+':'+
                                            _canvas_.library.misc.padString(time.m,2,'0')+':'+
                                            _canvas_.library.misc.padString(time.s,2,'0')+'.'+
                                            _canvas_.library.misc.padString(time.ms,2,'0'),
                                            13
                                        )
                                    );
                                    object.elements.readout_sixteenSegmentDisplay.time.print();
                                },100);
                    
                            //lights
                                let state = 'empty'; //empty - recording - paused - full
                                function updateLights(action){
                                    if( state == 'empty' && (action == 'save' || action == 'stop') ){return;}
                                    if( action == 'stop' || action == 'save' ){ state = 'full'; }
                                    if( state == 'empty' && action == 'rec' ){ state = 'recording'; }
                                    if( action == 'clear' ){ state = 'empty'; }
                                    if( state == 'recording' && action == 'pause/resume' ){ state = 'paused'; }
                                    else if( state == 'paused' && (action == 'pause/resume' || action == 'rec') ){ state = 'recording'; }
                    
                                    if(state == 'empty'){object.elements.glowbox_image.light_empty.on();}else{object.elements.glowbox_image.light_empty.off();}
                                    if(state == 'recording'){object.elements.glowbox_image.light_recording.on();}else{object.elements.glowbox_image.light_recording.off();}
                                    if(state == 'paused'){object.elements.glowbox_image.light_paused.on();}else{object.elements.glowbox_image.light_paused.off();}
                                    if(state == 'full'){object.elements.glowbox_image.light_stopped.on();}else{object.elements.glowbox_image.light_stopped.off();}
                                }
                                updateLights('clear');
                                object.elements.glowbox_image.light_empty.on();
                    
                        //wiring
                            //hid
                                object.elements.button_image.button_record.onpress = function(){
                                    if(state == 'paused'){recorderCircuit.resume();}
                                    else{recorderCircuit.start();}
                                    updateLights('rec');
                                };
                                object.elements.button_image.button_pause.onpress = function(){
                                    if(state == 'paused'){recorderCircuit.resume();}
                                    else{recorderCircuit.pause();}
                                    updateLights('pause/resume');
                                };
                                object.elements.button_image.button_stop.onpress = function(){
                                    updateLights('stop');
                                    recorderCircuit.stop();
                                }
                                object.elements.button_image.button_save.onpress = function(){
                                    updateLights('save');
                                    if(state != 'empty'){ recorderCircuit.save(); }
                                };
                                object.elements.button_image.button_delete.onpress = function(){
                                    updateLights('clear');
                                    recorderCircuit.clear();
                                };
                            //io
                                object.io.audio.io_input_R.audioNode = recorderCircuit.in_right();
                                object.io.audio.io_input_L.audioNode = recorderCircuit.in_left();
                    
                        //interface
                            object.i = {
                                record:function(){ object.elements.button_image.button_record.onpress(); },
                                pause:function(){ object.elements.button_image.button_pause.onpress(); },
                                stop:function(){ object.elements.button_image.button_stop.onpress(); },
                                save:function(){ object.elements.button_image.button_save.onpress(); },
                                clear:function(){ object.elements.button_image.button_delete.onpress(); },
                            };
                    
                        //setup/tearDown
                            object.ondelete = function(){
                                clearInterval(interval);
                            };
                    
                        return object;
                    };
                    this.audio_recorder.metadata = {
                        name:'Audio Recorder',
                        category:'monitors',
                        helpURL:'/help/units/alpha/audio_recorder/'
                    };
                    this.ruler = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //calculation of measurements
                                    this.drawingValue = { 
                                        width: 50, 
                                        height: 1000,
                                    };
                    
                                //styling values
                                    this.background = {r:200/255,g:200/255,b:200/255,a:1};
                                    this.markings = {r:150/255,g:150/255,b:150/255,a:1};
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'ruler',
                                x:x, y:y, angle:angle,
                                collisionActive:false,
                                space:[
                                    { x:0,                            y:0                             },
                                    { x:unitStyle.drawingValue.width, y:0                             },
                                    { x:unitStyle.drawingValue.width, y:unitStyle.drawingValue.height },
                                    { x:0,                            y:unitStyle.drawingValue.height },
                                ],
                                elements:
                                    [
                                        {collection:'basic', type:'polygon', name:'backing', data:{ 
                                            pointsAsXYArray:[
                                                { x:0,                            y:0                             },
                                                { x:unitStyle.drawingValue.width, y:0                             },
                                                { x:unitStyle.drawingValue.width, y:unitStyle.drawingValue.height },
                                                { x:0,                            y:unitStyle.drawingValue.height },
                                            ], 
                                            colour:unitStyle.background
                                        }},
                                    ].concat(
                                        (new Array(100).fill(0)).flatMap((value,index) => {
                                            if(index == 0){return [];}
                                            const newMarkings = []
                    
                                            //centimetres
                                                newMarkings.push(
                                                    {collection:'basic', type:'rectangle', name:'centimetre_line_L_'+index, data:{
                                                        x:0, y:index*10 - 0.5, width:5, height:1, 
                                                        colour:unitStyle.markings,
                                                    }}
                                                );
                                                newMarkings.push(
                                                    {collection:'basic', type:'rectangle', name:'centimetre_line_R_'+index, data:{
                                                        x:45, y:index*10 - 0.5, width:5, height:1, 
                                                        colour:unitStyle.markings,
                                                    }}
                                                );
                                                if( index%5 != 0 && index%10 != 0 ){
                                                    newMarkings.push(
                                                        {collection:'basic', type:'text', name:'centimetre_line_text_'+index, data:{
                                                            x:25, y:index*10, text:index,
                                                            width:2.5,height:2.5,
                                                            printingMode:{widthCalculation:'absolute', horizontal:'middle', vertical:'middle'},
                                                            colour:unitStyle.markings, font:'defaultThin',
                                                        }}
                                                    );
                                                }
                    
                                            //pentimetres
                                                if( index%5 == 0 ){
                                                    newMarkings.push(
                                                        {collection:'basic', type:'rectangle', name:'pentimetre_line_L_'+index, data:{
                                                            x:0, y:index*10 - 0.5, width:10, height:1, 
                                                            colour:unitStyle.markings,
                                                        }}
                                                    );
                                                    newMarkings.push(
                                                        {collection:'basic', type:'rectangle', name:'pentimetre_line_R_'+index, data:{
                                                            x:40, y:index*10 - 0.5, width:10, height:1, 
                                                            colour:unitStyle.markings,
                                                        }}
                                                    );
                                                    if( index%10 != 0 ){
                                                        newMarkings.push(
                                                            {collection:'basic', type:'text', name:'pentimetre_line_text_'+index, data:{
                                                                x:25, y:index*10, text:index,
                                                                width:5,height:5,
                                                                printingMode:{widthCalculation:'absolute', horizontal:'middle', vertical:'middle'},
                                                                colour:unitStyle.markings, font:'defaultThin',
                                                            }}
                                                        );
                                                    }
                                                }
                    
                                            //decimetres
                                                if( index%10 == 0 ){
                                                    newMarkings.push(
                                                        {collection:'basic', type:'rectangle', name:'decimetre_line_L_'+index, data:{
                                                            x:0, y:index*10 - 0.5, width:15, height:1, 
                                                            colour:unitStyle.markings,
                                                        }}
                                                    );
                                                    newMarkings.push(
                                                        {collection:'basic', type:'rectangle', name:'decimetre_line_R_'+index, data:{
                                                            x:35, y:index*10 - 0.5, width:15, height:1, 
                                                            colour:unitStyle.markings,
                                                        }}
                                                    );
                                                    newMarkings.push(
                                                        {collection:'basic', type:'text', name:'decimetre_line_text_'+index, data:{
                                                            x:25, y:index*10, text:index,
                                                            printingMode:{widthCalculation:'absolute', horizontal:'middle', vertical:'middle'},
                                                            colour:unitStyle.markings, font:'defaultThin',
                                                        }}
                                                    );
                                                }
                    
                                            return newMarkings;
                                        })
                                    )
                            });
                    
                        return object;
                    };
                    this.ruler.metadata = {
                        name:'Ruler',
                        category:'tools',
                        helpURL:'/help/units/alpha/ruler/'
                    };
                    this.voltage_dial = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'voltage_dial/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file:{ width:275, height:260 },
                                        design:{ width:4.25, height:4 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                                    this.dial = { handle:{r:0.75,g:0.75,b:0.75,a:1}, slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                            };
                    
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'voltage_dial',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                                              y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:unitStyle.drawingValue.height -unitStyle.offset },
                                    { x:0,                                              y:unitStyle.drawingValue.height -unitStyle.offset },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'out', data:{ 
                                        x:unitStyle.drawingValue.width/2.2 - 10/2, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:-unitStyle.offset/2, y:-unitStyle.offset/2, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png' }
                                    },
                                    {collection:'control', type:'dial_2_continuous',name:'theDial',data:{
                                        x:20, y:20, radius:30/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, resetValue:0.5, style:unitStyle.dial,
                                    }},
                                ]
                            });
                    
                        
                        //wiring
                            //hid
                                object.elements.dial_2_continuous.theDial.onchange = function(value){ object.elements.connectionNode_voltage.out.set( value ); };
                    
                            //import/export
                                object.exportData = function(){
                                    return {
                                        state:object.elements.dial_2_continuous.theDial.get()
                                    };
                                };
                                object.importData = function(data){
                                    object.elements.dial_2_continuous.theDial.set(data.state);
                                };
                            
                        return object;
                    };
                    
                    
                    
                    this.voltage_dial.metadata = {
                        name:'Voltage Dial',
                        category:'humanInterfaceDevices',
                        helpURL:'/help/units/alpha/voltage_dial/'
                    };
                    this.musicalKeyboard = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'musicalKeyboard/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:3800, height:800 },
                                        design: { width:63.5, height:13 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                                    this.velocityDial = { handle:style.primaryEight[5], slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                                    this.whiteKey = {
                                        background__up__colour:{r:0.97,g:0.97,b:0.97,a:1},
                                        background__hover__colour:{r:1,g:1,b:1,a:1},
                                        background__press__colour:{r:0.87,g:0.87,b:0.87,a:1},
                                        background__hover_press__colour:{r:0.87,g:0.87,b:0.87,a:1},
                                    };
                                    this.blackKey = { 
                                        background__up__colour:{r:0.18,g:0.18,b:0.18,a:1}, 
                                        background__hover__colour:{r:0.28,g:0.28,b:0.28,a:1}, 
                                        background__press__colour:{r:0.08,g:0.08,b:0.08,a:1},
                                        background__hover_press__colour:{r:0.08,g:0.08,b:0.08,a:1},
                                    };
                                    this.LEDs = {
                                        glow:{r:232/255, g:160/255, b:111/255, a:1}, 
                                        dim:{r:164/255, g:80/255, b:61/255, a:1},
                                    };
                                    this.keyCount = 49;
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'musicalKeyboard',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                                              y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:unitStyle.drawingValue.height -unitStyle.offset },
                                    { x:0,                                              y:unitStyle.drawingValue.height -unitStyle.offset },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_data', name:'midiIn', data:{ 
                                        x:unitStyle.drawingValue.width-3.5, y:10, width:5, height:15, angle:0, cableVersion:2, style:style.connectionNode.data,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_data', name:'midiOut', data:{ 
                                        x:0, y:117.5, width:5, height:15, angle:Math.PI, cableVersion:2, style:style.connectionNode.data
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'velocityIn', data:{ 
                                        x:25, y:unitStyle.drawingValue.height-3.5, width:5, height:10, angle:Math.PI*0.5, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:-unitStyle.offset/2, y:-unitStyle.offset/2, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png' }
                                    },
                                    {collection:'control', type:'dial_2_continuous',name:'velocity',data:{
                                        x:20, y:110, radius:25/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, resetValue:0.5, style:unitStyle.velocityDial,
                                    }},
                                ].concat(
                                    (function(){
                                        const newKeys = [];
                    
                                        const keyPattern = 'wbwbwwbwbwbw'.split('');
                    
                                        //white keys
                                            let whiteOffset = 0;
                                            for(let a = 0; a < unitStyle.keyCount; a++){
                                                const keyType = keyPattern[a%keyPattern.length];
                    
                                                if(keyType == 'w'){
                                                    newKeys.unshift(
                                                        {collection:'dynamic', type:'connectionNode_signal', name:'signalOut_'+a, data:{ 
                                                            x:55 +whiteOffset -0.5 -10, y:0, width:5, height:9, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                                        }},
                                                    );
                                                    newKeys.unshift(
                                                        {collection:'dynamic', type:'connectionNode_signal', name:'activateKey_'+a, data:{ 
                                                            x:55 +whiteOffset -0.5, y:unitStyle.drawingValue.height -unitStyle.offset, width:5, height:9, angle:Math.PI*0.5, cableVersion:2, style:style.connectionNode.signal,
                                                        }},
                                                    );
                                                    newKeys.push(
                                                        {collection:'display', type:'glowbox_rectangle',name:'LED'+a,data:{ x:41.25 +whiteOffset, y:6, width:17.5, height:1, style:unitStyle.LEDs }},
                                                        {collection:'control', type:'button_rectangle', name:'key_'+a, data:{ x:40.5 +whiteOffset, y:10, width:19, height:120, style:unitStyle.whiteKey }},
                                                    );
                                                    whiteOffset += 20;
                                                }
                                            }
                    
                                        //black keys
                                            let blackOffset = 0;
                                            for(let a = 0; a < unitStyle.keyCount; a++){
                                                const keyType = keyPattern[a%keyPattern.length];
                    
                                                if(keyType == 'b'){
                                                    newKeys.unshift(
                                                        {collection:'dynamic', type:'connectionNode_signal', name:'signalOut_'+a, data:{ 
                                                            x:55 +blackOffset -0.5, y:0, width:5, height:9, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                                        }},
                                                    );
                                                    newKeys.unshift(
                                                        {collection:'dynamic', type:'connectionNode_signal', name:'activateKey_'+a, data:{ 
                                                            x:65 +blackOffset -0.5, y:unitStyle.drawingValue.height -unitStyle.offset, width:5, height:9, angle:Math.PI*0.5, cableVersion:2, style:style.connectionNode.signal,
                                                        }},
                                                    );
                                                    newKeys.push(
                                                        {collection:'display', type:'glowbox_rectangle',name:'LED'+a,data:{ x:51.25 +blackOffset, y:2.75, width:17.5, height:1, style:unitStyle.LEDs }},
                                                        {collection:'control', type:'button_rectangle', name:'key_'+a, data:{ x:55 +blackOffset, y:10, width:10, height:70, style:unitStyle.blackKey }},
                                                    );
                                                    blackOffset += 20;
                                                }
                                                if(keyType == keyPattern[(a-1)%keyPattern.length]){ blackOffset += 20; }
                    
                                            }
                    
                                        return newKeys;
                                    })()
                                )
                            });
                    
                        //circuitry
                            const state = {
                                midiNumberOffset:60,
                                velocity:0,
                            };
                    
                            function sendMidiData(keyNumber,mode){
                                if(keyNumber < 0){return;}
                    
                                if(mode == 'press'){
                                    object.elements.glowbox_rectangle['LED'+keyNumber].on();
                                    object.io.signal['signalOut_'+keyNumber].set(true);
                                }else{
                                    object.elements.glowbox_rectangle['LED'+keyNumber].off();
                                    object.io.signal['signalOut_'+keyNumber].set(false);
                                }
                    
                                object.io.data.midiOut.send('midinumber', { 
                                    num:keyNumber+state.midiNumberOffset,
                                    velocity: mode == 'press' ? object.elements.dial_2_continuous.velocity.get() : 0,
                                } );
                            }
                    
                        //wiring
                            //hid
                                object.elements.dial_2_continuous.velocity.onchange = function(value){ state.velocity = value; };
                                for(let a = 0; a < unitStyle.keyCount; a++){
                                    object.elements.button_rectangle['key_'+a].onpress = (function(keyNumber){ return function(){sendMidiData(keyNumber,'press');} })(a);
                                    object.elements.button_rectangle['key_'+a].onrelease = (function(keyNumber){ return function(){sendMidiData(keyNumber,'release');} })(a);
                                }
                    
                            //keycapture
                                const keyCodes = [ 90, 83, 88, 68, 67, 86, 71, 66, 72, 78, 74, 77, 81, 50, 87, 51, 69, 82, 53, 84, 54, 89, 55, 85, 73 ];
                                object.elements.image.backing.attachCallback('onkeydown', function(x,y,event){
                                    if( keyCodes.includes(event.keyCode) ){
                                        object.elements.button_rectangle['key_'+keyCodes.indexOf(event.keyCode)].press();
                                    }
                                });
                                object.elements.image.backing.attachCallback('onkeyup', function(x,y,event){
                                    if( keyCodes.includes(event.keyCode) ){
                                        object.elements.button_rectangle['key_'+keyCodes.indexOf(event.keyCode)].release();
                                    }
                                });
                    
                            //io
                                object.io.data.midiIn.onreceive = function(address, data){ if(address != 'midinumber'){return;} sendMidiData(data.num-state.midiNumberOffset,data.velocity>0?'press':'release'); };
                                object.io.voltage.velocityIn.onchange = function(value){ object.elements.dial_2_continuous.velocity.set(value); };
                                for(let a = 0; a < unitStyle.keyCount; a++){
                                    object.io.signal['activateKey_'+a].onchange = (function(keyNumber){ return function(value){ sendMidiData(keyNumber,value?'press':'release'); } })(a);
                                }
                    
                        //interface
                            object.i = {
                                velocity:function(value){ 
                                    if(value==undefined){return state.velocity; }
                                    object.elements.dial_2_continuous.velocity.set(value);
                                },
                                pushKey:function(key){ object.elements.button_rectangle['key_'+key].press(); },
                                releaseKey:function(key){ object.elements.button_rectangle['key_'+key].release();},
                                releaseAllKeys:function(){ for(let a = 0; a < keyCount; a++){ object.elements.button_rectangle['key_'+a].release(); } },
                            };
                    
                        //import/export
                            object.exportData = function(){ return {velocity:state.velocity}; };
                            object.importData = function(data){ object.elements.dial_2_continuous.velocity.set(data.velocity); };
                    
                        //setup/tearDown
                            object.oncreate = function(){
                                object.elements.dial_2_continuous.velocity.set(0.5);
                            };
                    
                        return object;
                    };
                    this.musicalKeyboard.metadata = {
                        name:'Musical Keyboard',
                        category:'humanInterfaceDevices',
                        helpURL:'/help/units/alpha/musicalKeyboard/'
                    };

                    this.audio_in = function(name,x,y,angle,setupConnect=true){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'audio_in/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:905, height:320 },
                                        design: { width:14.75, height:5 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                                    this.outputGain = { handle:{r:0.99,g:0.46,b:0.33,a:1}, slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'audio_in',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                                              y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:unitStyle.drawingValue.height -unitStyle.offset },
                                    { x:0,                                              y:unitStyle.drawingValue.height -unitStyle.offset },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_audio', name:'io_output', data:{ 
                                        x:0, y:25 + 15/2, width:5, height:15, angle:Math.PI, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'io_previous', data:{ 
                                        x:117.9 - 10/2, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'io_next', data:{ 
                                        x:132.05 - 10/2, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', data:{ 
                                        x:-unitStyle.offset/2, y:-unitStyle.offset/2, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png'
                                    }},
                                    {collection:'control', type:'dial_2_continuous', name:'outputGain',data:{
                                        x:20, y:25, radius:75/6, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, arcDistance:1.2, resetValue:0.5, style:unitStyle.outputGain,
                                    }},
                                    {collection:'control', type:'button_image', name:'button_previous', data:{
                                        x:112.5, y:12.5, width:10.85, height:10.85, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_down.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'button_next', data:{
                                        x:137.5, y:23.35, width:10.85, height:10.85, hoverable:false, angle:Math.PI,
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_down.png',
                                    }},
                                    {collection:'display', type:'audio_meter_level', name:'audioIn',data:{ 
                                        x:37.5+10/16, y:5+10/16, width:11.65-10/8, height:40-10/8
                                    }},
                                    {collection:'display', type:'readout_sixteenSegmentDisplay', name:'index', data:{
                                        x:52.5+10/16, y:12.5+10/16, width:56.65-10/8, height:10.85-10/8, canvasBased:true, count:11, resolution:5,
                                    }},
                                    {collection:'display', type:'readout_sixteenSegmentDisplay', name:'text', data:{
                                        x:52.5+10/16, y:26.7+10/16, width:85-10/8, height:10.85-10/8, canvasBased:true, count:18, resolution:5,
                                    }},
                                ]
                            });
                    
                        //circuitry
                            const state = {
                                deviceList:[],
                                currentSelection: 0
                            };
                            const audioInCircuit = new _canvas_.interface.circuit.audioIn(_canvas_.library.audio.context,setupConnect);
                    
                            audioInCircuit.out().connect( object.elements.audio_meter_level.audioIn.audioIn() );
                    
                            function selectDevice(a){
                                if(state.deviceList.length == 0){
                                    object.elements.readout_sixteenSegmentDisplay.index.text('');
                                    object.elements.readout_sixteenSegmentDisplay.index.print();
                                    object.elements.readout_sixteenSegmentDisplay.text.text(' -- no devices --');
                                    object.elements.readout_sixteenSegmentDisplay.text.print('smart');
                                    return;
                                }
                                if( a < 0 || a >= state.deviceList.length ){return;}
                                state.currentSelection = a;
                    
                                selectionNum=''+(a+1);while(selectionNum.length < 2){ selectionNum = '0'+selectionNum;}
                                totalNum=''+state.deviceList.length; while(totalNum.length < 2){ totalNum = '0'+totalNum; }
                                let index_text = selectionNum+'/'+totalNum; while(index_text.length < 8){ index_text = ' '+index_text; }
                                object.elements.readout_sixteenSegmentDisplay.index.text(index_text);
                                object.elements.readout_sixteenSegmentDisplay.index.print();
                    
                                let text_text = state.deviceList[a].deviceId;
                                if(state.deviceList[a].label.length > 0){text_text = state.deviceList[a].label +' - '+ text_text;}
                                object.elements.readout_sixteenSegmentDisplay.text.text(text_text);
                                object.elements.readout_sixteenSegmentDisplay.text.print('smart');
                    
                                audioInCircuit.selectDevice( state.deviceList[a].deviceId );
                            }
                            function incSelection(){ selectDevice(state.currentSelection+1); }
                            function decSelection(){ selectDevice(state.currentSelection-1); }
                    
                        //wiring
                            //hid
                                object.elements.dial_2_continuous.outputGain.onchange = function(value){audioInCircuit.gain(value*2);}
                                object.elements.button_image.button_previous.onpress = function(){ decSelection(); };
                                object.elements.button_image.button_next.onpress = function(){ incSelection(); };
                            //io
                                object.io.audio.io_output.audioNode = audioInCircuit.out();
                                object.io.signal.io_previous.onchange = function(value){ if(value){ object.elements.button_image.button_previous.press(); }else{ object.elements.button_image.button_previous.release(); } };
                                object.io.signal.io_next.onchange = function(value){ if(value){ object.elements.button_image.button_next.press(); }else{ object.elements.button_image.button_next.release(); } };
                    
                        //interface
                            object.i = {
                                gain:function(value){
                                    if(value == undefined){return object.elements.dial_2_continuous.outputGain.get();}
                                    object.elements.dial_2_continuous.outputGain.set(value);
                                },
                            };
                    
                        //import/export
                            object.exportData = function(){
                                return { gain: object.elements.dial_2_continuous.outputGain.get() };
                            };
                            object.importData = function(data){
                                object.elements.dial_2_continuous.outputGain.get( data.gain );
                            };
                        
                        //setup/tearDown
                            object.oncreate = function(){
                                audioInCircuit.listDevices(function(a){state.deviceList=a;});
                                if(setupConnect){setTimeout(function(){selectDevice(0);},500);}
                                object.elements.dial_2_continuous.outputGain.set(0.5);
                                object.elements.audio_meter_level.audioIn.start();
                            };
                    
                        return object;
                    };
                    this.audio_in.metadata = {
                        name:'Audio In',
                        category:'humanInterfaceDevices',
                        helpURL:'/help/units/alpha/audio_in/'
                    };
                    this.signal_switch = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'signal_switch/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:149, height:260 },
                                        design: { width:2.125, height:4 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'signal_switch',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                                              y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:unitStyle.drawingValue.height -unitStyle.offset },
                                    { x:0,                                              y:unitStyle.drawingValue.height -unitStyle.offset },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out', data:{ 
                                        x:unitStyle.drawingValue.width/2.3 - 10/2, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:-unitStyle.offset/2, y:-unitStyle.offset/2, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png' }
                                    },
                                    {collection:'control', type:'slide_discrete_image',name:'theSwitch',data:{
                                        x:5.25, y:5.25, width:9.5, height:29.5, handleHeight:1/2, resetValue:0, optionCount:2, value:1,
                                        handleURL:unitStyle.imageStoreURL_localPrefix+'handle.png',
                                    }},
                                ]
                            });
                        
                        //wiring
                            //hid
                                object.elements.slide_discrete_image.theSwitch.onchange = function(value){ object.elements.connectionNode_signal.out.set( 1-value == 0 ? false : true ); };
                    
                        //import/export
                            object.exportData = function(){
                                return { state: object.elements.slide_discrete_image.theSwitch.get() };
                            };
                            object.importData = function(data){
                                object.elements.slide_discrete_image.theSwitch.set(data.state);
                            };
                    
                        return object;
                    };
                    this.signal_switch.metadata = {
                        name:'Signal Switch',
                        category:'humanInterfaceDevices',
                        helpURL:'/help/units/alpha/signal_switch/'
                    };
                    const imageStoreURL = '/images/units/1 - alpha/';
                    const style = {
                        background:{r:70/255,g:70/255,b:70/255,a:1},
                        bumper:{r:0.125,g:0.125,b:0.125,a:1},
                        textColour:{r:0.7,g:0.7,b:0.7,a:1},
                    
                        primaryEight:[
                            {r:1,g:0.01,b:0.02,a:1},
                            {r:1,g:0.55,b:0,a:1},
                            {r:1,g:0.93,b:0,a:1},
                            {r:0,g:1,b:0,a:1},
                            {r:0,g:1,b:0.81,a:1},
                            {r:0,g:0.62,b:1,a:1},
                            {r:0.08,g:0,b:1,a:1},
                            {r:0.68,g:0,b:1,a:1}, 
                        ],
                    
                        marking:{
                            default:{r:0.7,g:0.7,b:0.7,a:1},
                            signal:{r:235/255,g:98/255,b:61/255,a:1},
                            voltage:{r:170/255,g:251/255,b:89/255,a:1},
                            data:{r:114/255,g:176/255,b:248/255,a:1},
                            audio:{r:243/255,g:173/255,b:61/255,a:1},
                        },
                        connectionNode:{
                            signal:{
                                dim:{r:235/255,g:98/255,b:61/255,a:1},
                                glow:{r:237/255,g:154/255,b:132/255,a:1},
                                cable_dim:{r:235/255,g:98/255,b:61/255,a:1},
                                cable_glow:{r:237/255,g:154/255,b:132/255,a:1},
                            },
                            voltage:{
                                dim:{r:170/255,g:251/255,b:89/255,a:1},
                                glow:{r:210/255,g:255/255,b:165/255,a:1},
                                cable_dim:{r:170/255,g:251/255,b:89/255,a:1},
                                cable_glow:{r:210/255,g:255/255,b:165/255,a:1},
                            },
                            data:{
                                dim:{r:114/255,g:176/255,b:248/255,a:1},
                                glow:{r:168/255,g:208/255,b:255/255,a:1},
                                cable_dim:{r:114/255,g:176/255,b:248/255,a:1},
                                cable_glow:{r:168/255,g:208/255,b:255/255,a:1},
                            },
                            audio:{
                                dim:{r:243/255,g:173/255,b:61/255,a:1},
                                glow:{r:247/255,g:203/255,b:133/255,a:1},
                                cable_dim:{r:243/255,g:173/255,b:61/255,a:1},
                                cable_glow:{r:247/255,g:203/255,b:133/255,a:1},
                            },
                        },
                        connectionCable:{
                            signal:{
                                dim:{r:235/255,g:98/255,b:61/255,a:1},
                                glow:{r:237/255,g:154/255,b:132/255,a:1},
                            },
                            voltage:{
                                dim:{r:170/255,g:251/255,b:89/255,a:1},
                                glow:{r:210/255,g:255/255,b:165/255,a:1},
                            },
                            data:{
                                dim:{r:114/255,g:176/255,b:248/255,a:1},
                                glow:{r:168/255,g:208/255,b:255/255,a:1},
                            },
                            audio:{
                                dim:{r:243/255,g:173/255,b:61/255,a:1},
                                glow:{r:247/255,g:203/255,b:133/255,a:1},
                            },
                        },
                    };
                    this.basic_synthesizer = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'basic_synthesizer/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:1115, height:680 },
                                        design: { width:18.25, height:11 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                                    this.outputGain = { handle:{r:0.93,g:0.45,b:0.31,a:1}, slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                                    this.attack = { handle:{r:0.99,g:0.93,b:0.31,a:1}, slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                                    this.release = { handle:{r:0.44,g:0.95,b:0.79,a:1}, slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                                    this.detune_note = { handle:{r:0.61,g:0.16,b:0.96,a:1}, slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                                    this.detune_octave = { handle:{r:0.92,g:0.2,b:0.47,a:1}, slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                                    this.periodicWaveType = { handle:{r:0.75,g:0.75,b:0.75,a:1}, slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                                    this.gainWobblePeriod = { handle:{r:0.57,g:0.97,b:0.3,a:1}, slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                                    this.gainWobbleDepth = { handle:{r:0.46,g:0.98,b:0.65,a:1}, slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                                    this.detuneWobblePeriod = { handle:{r:0.94,g:0.55,b:0.2,a:1}, slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                                    this.detuneWobbleDepth = { handle:{r:0.96,g:0.75,b:0.26,a:1}, slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                                    this.panicButton = {
                                        background__up__colour:{r:0.75,g:0.75,b:0.75,a:1},
                                        background__hover__colour:{r:0.85,g:0.85,b:0.85,a:1},
                                        background__press__colour:{r:0.5,g:0.5,b:0.5,a:1},
                                        background__hover_press__colour:{r:0.5,g:0.5,b:0.5,a:1},
                                    };
                            };
                    
                            //main object creation
                                const object = _canvas_.interface.unit.builder({
                                    name:name,
                                    model:'basic_synthesizer',
                                    x:x, y:y, angle:angle,
                                    space:[
                                        { x:unitStyle.drawingValue.width*(1/18.5),                        y:0                                                         },
                                        { x:unitStyle.drawingValue.width*(17.5/18.5) -unitStyle.offset,   y:0                                                         },
                                        { x:unitStyle.drawingValue.width -unitStyle.offset,               y:unitStyle.drawingValue.height*(1/11)                      },
                                        { x:unitStyle.drawingValue.width -unitStyle.offset,               y:(unitStyle.drawingValue.height+unitStyle.offset)*(4.5/11) },
                                        { x:(unitStyle.drawingValue.width-unitStyle.offset)*(12.15/18.5), y:unitStyle.drawingValue.height -unitStyle.offset           },
                                        { x:unitStyle.drawingValue.width*(1/18.5),                        y:unitStyle.drawingValue.height -unitStyle.offset           },
                                        { x:0,                                                            y:(unitStyle.drawingValue.height-unitStyle.offset)*(10/11)  },
                                        { x:0,                                                            y:unitStyle.drawingValue.height*(1/11)                      },
                                    ],
                                    elements:[
                                        {collection:'dynamic', type:'connectionNode_audio', name:'io_output', data:{ 
                                            x:0, y:35, width:5, height:15, angle:Math.PI, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio,
                                        }},
                                        {collection:'dynamic', type:'connectionNode_voltage', name:'io_outputGain', data:{ 
                                            x:15, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                        }},
                                        {collection:'dynamic', type:'connectionNode_voltage', name:'io_attack', data:{ 
                                            x:50, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                        }},
                                        {collection:'dynamic', type:'connectionNode_voltage', name:'io_release', data:{ 
                                            x:82.5, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                        }},
                                        {collection:'dynamic', type:'connectionNode_voltage', name:'io_detune_note', data:{ 
                                            x:117.5, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                        }},
                                        {collection:'dynamic', type:'connectionNode_signal', name:'io_detune_octave_down', data:{ 
                                            x:150 - 6, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                        }},
                                        {collection:'dynamic', type:'connectionNode_signal', name:'io_detune_octave_up', data:{ 
                                            x:150 + 6, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                        }},
                                        {collection:'dynamic', type:'connectionNode_data', name:'io_midiNoteInput', data:{ 
                                            x:unitStyle.drawingValue.width - 5/1.5, y:27.5 - 15/2, width:5, height:15, cableVersion:2, style:style.connectionNode.data,
                                        }},
                                        {collection:'dynamic', type:'connectionNode_voltage', name:'io_gainWobblePeriod', data:{ 
                                            x:90/2 - 6, y:unitStyle.drawingValue.height - 5/1.5, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                        }},
                                        {collection:'dynamic', type:'connectionNode_voltage', name:'io_gainWobbleDepth', data:{ 
                                            x:90/2 + 6, y:unitStyle.drawingValue.height - 5/1.5, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                        }},
                                        {collection:'dynamic', type:'connectionNode_voltage', name:'io_detuneWobblePeriod', data:{ 
                                            x:155/2 - 6, y:unitStyle.drawingValue.height - 5/1.5, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                        }},
                                        {collection:'dynamic', type:'connectionNode_voltage', name:'io_detuneWobbleDepth', data:{ 
                                            x:155/2 + 6, y:unitStyle.drawingValue.height - 5/1.5, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                        }},
                                        {collection:'dynamic', type:'connectionNode_data', name:'io_periodicWaveType_dataIn', data:{ 
                                            x:unitStyle.drawingValue.width-35 -2.5, y:unitStyle.drawingValue.height-35 +2.5, width:5, height:15, angle:Math.PI/4, cableVersion:2, style:style.connectionNode.data,
                                        }},
                                        {collection:'dynamic', type:'connectionNode_signal', name:'io_periodicWaveType_down', data:{ 
                                            x:unitStyle.drawingValue.width-35 -14, y:unitStyle.drawingValue.height-35 +14, width:5, height:10, angle:Math.PI/4, cableVersion:2, style:style.connectionNode.signal,
                                        }},
                                        {collection:'dynamic', type:'connectionNode_signal', name:'io_periodicWaveType_up', data:{ 
                                            x:unitStyle.drawingValue.width-35 +5.5, y:unitStyle.drawingValue.height-35 -5.5, width:5, height:10, angle:Math.PI/4, cableVersion:2, style:style.connectionNode.signal,
                                        }},
                                        {collection:'dynamic', type:'connectionNode_signal', name:'io_panic', data:{ 
                                            x:unitStyle.drawingValue.width-35 +22.5, y:unitStyle.drawingValue.height-35 -22.5, width:5, height:10, angle:Math.PI/4, cableVersion:2, style:style.connectionNode.signal,
                                        }},
                                        {collection:'basic', type:'image', name:'backing', 
                                            data:{ x:-unitStyle.offset/2, y:-unitStyle.offset/2, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png' }
                                        },
                                        {collection:'control', type:'dial_2_continuous',name:'outputGain',data:{
                                            x:20, y:27.5, radius:27.5/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, arcDistance:1.2, resetValue:0.5, value:0.5, style:unitStyle.outputGain,
                                        }},
                                        {collection:'control', type:'dial_2_continuous',name:'attack',data:{
                                            x:55, y:27.5, radius:27.5/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, arcDistance:1.2, resetValue:0, style:unitStyle.attack,
                                        }},
                                        {collection:'control', type:'dial_2_continuous',name:'release',data:{
                                            x:87.5, y:27.5, radius:27.5/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, resetValue:0, style:unitStyle.release,
                                        }},
                                        {collection:'control', type:'dial_2_continuous',name:'detune_note',data:{
                                            x:122.5, y:27.5, radius:27.5/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, arcDistance:1.2, resetValue:0.5, style:unitStyle.detune_note,
                                        }},
                                        {collection:'control', type:'dial_2_discrete',name:'detune_octave',data:{
                                            x:155, y:27.5, radius:27.5/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:3, arcDistance:1.2, resetValue:3, optionCount:7, style:unitStyle.detune_octave,
                                        }},
                                        {collection:'control', type:'dial_2_discrete',name:'periodicWaveType',data:{
                                            x:130, y:72.5, radius:32.5/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, resetValue:0, style:unitStyle.periodicWaveType,
                                        }},
                                        {collection:'control', type:'dial_2_continuous',name:'gainWobblePeriod',data:{
                                            x:40, y:62.5, radius:25/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, resetValue:0, style:unitStyle.gainWobblePeriod,
                                        }},
                                        {collection:'control', type:'dial_2_continuous',name:'gainWobbleDepth',data:{
                                            x:40, y:92.5, radius:25/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, resetValue:0, style:unitStyle.gainWobbleDepth,
                                        }},
                                        {collection:'control', type:'dial_2_continuous',name:'detuneWobblePeriod',data:{
                                            x:72.5, y:62.5, radius:25/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, resetValue:0, style:unitStyle.detuneWobblePeriod,
                                        }},
                                        {collection:'control', type:'dial_2_continuous',name:'detuneWobbleDepth',data:{
                                            x:72.5, y:92.5, radius:25/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, resetValue:0, style:unitStyle.detuneWobbleDepth,
                                        }},
                                        {collection:'control', type:'button_circle', name:'panicButton', data:{ 
                                            x:162.5, y:52.5, r:15/2, style:unitStyle.panicButton,
                                        }},
                                    ]
                                });
                    
                        //circuitry
                            const detuneLimits = {min:-100, max:100};
                            const synthesizerCircuit = new _canvas_.interface.circuit.synthesizer(_canvas_.library.audio.context);
                    
                        //wiring
                            //hid
                                object.elements.dial_2_continuous.outputGain.onchange = function(value){ synthesizerCircuit.gain( value ); };
                                object.elements.dial_2_continuous.attack.onchange = function(value){ synthesizerCircuit.attack( value ); };
                                object.elements.dial_2_continuous.release.onchange = function(value){ synthesizerCircuit.release( value ); };
                                object.elements.dial_2_continuous.detune_note.onchange = function(value){ synthesizerCircuit.detune( value*(detuneLimits.max-detuneLimits.min) + detuneLimits.min ); };
                                object.elements.dial_2_discrete.detune_octave.onchange = function(value){ synthesizerCircuit.octave( value-3 ); };
                                object.elements.dial_2_discrete.periodicWaveType.onchange = function(value){ synthesizerCircuit.waveType( ['sine','triangle','square','sawtooth','custom'][value] ); };
                                object.elements.dial_2_continuous.gainWobblePeriod.onchange = function(value){ synthesizerCircuit.gainWobblePeriod( (1-value)<0.01?0.011:(1-value) ); };
                                object.elements.dial_2_continuous.gainWobbleDepth.onchange = function(value){ synthesizerCircuit.gainWobbleDepth(value);};
                                object.elements.dial_2_continuous.detuneWobblePeriod.onchange = function(value){ synthesizerCircuit.detuneWobblePeriod( (1-value)<0.01?0.011:(1-value) ); };
                                object.elements.dial_2_continuous.detuneWobbleDepth.onchange = function(value){ synthesizerCircuit.detuneWobbleDepth( value*100 ); };
                                object.elements.button_circle.panicButton.onpress = function(){ synthesizerCircuit.panic(); };
                            //io
                                object.io.audio.io_output.audioNode = synthesizerCircuit.out();
                    
                                object.io.data.io_midiNoteInput.onreceive = function(address,data){
                                    if(address != 'midinumber'){return;}
                                    synthesizerCircuit.perform(data);
                                };
                                object.io.data.io_periodicWaveType_dataIn.onreceive = function(address,data){
                                    if(address != 'periodicWave'){return;}
                                    synthesizerCircuit.waveType(undefined, data);
                                };
                                object.io.voltage.io_outputGain.onchange = function(value){
                                    object.elements.dial_2_continuous.outputGain.set(value);
                                };
                                object.io.voltage.io_attack.onchange = function(value){
                                    object.elements.dial_2_continuous.attack.set(value);
                                };
                                object.io.voltage.io_release.onchange = function(value){
                                    object.elements.dial_2_continuous.release.set(value);
                                };
                                object.io.voltage.io_detune_note.onchange = function(value){ 
                                    object.elements.dial_2_continuous.detune_note.set(value);
                                };
                                object.io.signal.io_detune_octave_down.onchange = function(value){ if(!value){return;}
                                    object.elements.dial_2_discrete.detune_octave.set( object.elements.dial_2_discrete.detune_octave.get() - 1 );
                                };
                                object.io.signal.io_detune_octave_up.onchange = function(value){ if(!value){return;}
                                    object.elements.dial_2_discrete.detune_octave.set( object.elements.dial_2_discrete.detune_octave.get() + 1 );
                                };
                                object.io.voltage.io_gainWobblePeriod.onchange = function(value){
                                    object.elements.dial_2_continuous.gainWobblePeriod.set(value);
                                };
                                object.io.voltage.io_gainWobbleDepth.onchange = function(value){
                                    object.elements.dial_2_continuous.gainWobbleDepth.set(value);
                                };
                                object.io.voltage.io_detuneWobblePeriod.onchange = function(value){
                                    object.elements.dial_2_continuous.detuneWobblePeriod.set(value);
                                };
                                object.io.voltage.io_detuneWobbleDepth.onchange = function(value){
                                    object.elements.dial_2_continuous.detuneWobbleDepth.set(value);
                                };
                                object.io.signal.io_periodicWaveType_down.onchange = function(value){ if(!value){return;}
                                    object.elements.dial_2_discrete.periodicWaveType.set( object.elements.dial_2_discrete.periodicWaveType.get() - 1 );
                                };
                                object.io.signal.io_periodicWaveType_up.onchange = function(value){ if(!value){return;}
                                    object.elements.dial_2_discrete.periodicWaveType.set( object.elements.dial_2_discrete.periodicWaveType.get() + 1 );
                                };
                                object.io.signal.io_panic.onchange = function(value){ value ? object.elements.button_circle.panicButton.press() : object.elements.button_circle.panicButton.release(); };
                    
                        //interface
                            object.i = {
                                periodicWave:function(data){return synthesizerCircuit.periodicWave(data);},
                                performMidiNote:function(data){synthesizerCircuit.perform(data);},
                            };
                            ['outputGain','attack','release','detune_note','gainWobblePeriod','gainWobbleDepth','detuneWobblePeriod','detuneWobbleDepth'].forEach(dialName => {
                                object.i[dialName] = (function(element){
                                    return function(value){ if(value==undefined){return element.get();}else{element.set(value);} }
                                })(object.elements.dial_2_continuous[dialName]);
                            });
                            ['detune_octave','periodicWaveType'].forEach(dialName => {
                                object.i[dialName] = (function(element){
                                    return function(value){ if(value==undefined){return element.get();}else{element.set(value);} }
                                })(object.elements.dial_2_discrete[dialName]);
                            });
                    
                        //import/export
                            object.exportData = function(){
                                return {
                                    gain: object.elements.dial_2_continuous.outputGain.get(),
                                    attack: object.elements.dial_2_continuous.attack.get()*10,
                                    release: object.elements.dial_2_continuous.release.get()*10,
                                    detune: 100*((object.elements.dial_2_continuous.detune_note.get()*2)-1),
                                    octave: object.elements.dial_2_discrete.detune_octave.get()-3,
                                    waveType: ['sine','triangle','square','sawtooth','custom'][object.elements.dial_2_discrete.periodicWaveType.get()],
                                    gainWobble:{
                                        rate: object.elements.dial_2_continuous.gainWobblePeriod.get()*100,
                                        depth: object.elements.dial_2_continuous.gainWobbleDepth.get()
                                    },
                                    detuneWobble:{
                                        rate: object.elements.dial_2_continuous.detuneWobblePeriod.get()*100,
                                        depth: object.elements.dial_2_continuous.detuneWobbleDepth.get()
                                    },
                                };
                            };
                            object.importData = function(data){
                                if(data == undefined){return;}
                    
                                object.elements.dial_2_continuous.outputGain.set( data.gain );
                                object.elements.dial_2_continuous.attack.set( data.attack/10 );
                                object.elements.dial_2_continuous.release.set( data.release/10 );
                                object.elements.dial_2_continuous.detune_note.set( (1+(data.detune/100))/2 );
                                object.elements.dial_2_discrete.detune_octave.set( data.octave+3 );
                                object.elements.dial_2_discrete.periodicWaveType.set( ['sine','triangle','square','sawtooth','custom'].indexOf(data.waveType) );
                                object.elements.dial_2_continuous.gainWobblePeriod.set( data.gainWobble.rate/100 );
                                object.elements.dial_2_continuous.gainWobbleDepth.set( data.gainWobble.depth );
                                object.elements.dial_2_continuous.detuneWobblePeriod.set( data.detuneWobble.rate/100 );
                                object.elements.dial_2_continuous.detuneWobbleDepth.set( data.detuneWobble.depth );
                            };
                    
                        //setup/tearDown
                            object.oncreate = function(){
                                synthesizerCircuit.gain( 0.5 );
                            };
                            object.ondelete = function(){
                            };
                            
                        return object;
                    };
                    this.basic_synthesizer.metadata = {
                        name:'Basic Synthesizer',
                        category:'synthesizers',
                        helpURL:'/help/units/alpha/basic_synthesizer/'
                    };
                    this.audio_file_player = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'audio_file_player/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:1025, height:305 },
                                        design: { width:16.75, height:4.75 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                                    this.dial_playbackSpeed = { handle:{r:0.46,g:0.98,b:0.82,a:1}, slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                                    this.grapher_waveWorkspace = { background_lineThickness:0.1, backing:{r:0,g:0,b:0,a:1} };
                                    this.fireLight = { glow:{r:0.99,g:0.94,b:0.72,a:1}, dim:{r:0.62,g:0.57,b:0.36,a:1} };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'audio_file_player',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                                              y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:unitStyle.drawingValue.height -unitStyle.offset },
                                    { x:0,                                              y:unitStyle.drawingValue.height -unitStyle.offset },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_audio', name:'io_output_R', data:{ 
                                        x:0, y:15 + 15/2, width:5, height:15, angle:Math.PI, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'io_output_L', data:{ 
                                        x:0, y:32.5 + 15/2, width:5, height:15, angle:Math.PI, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'io_play', data:{ 
                                        x:12.5, y:unitStyle.drawingValue.height-3-1/3, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'io_stop', data:{ 
                                        x:25, y:unitStyle.drawingValue.height-3-1/3, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'io_singleOrInfini', data:{ 
                                        x:unitStyle.drawingValue.width-3-1/3, y:34, width:5, height:10, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'io_loop', data:{ 
                                        x:unitStyle.drawingValue.width-3-1/3, y:19, width:5, height:10, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'io_playbackSpeed', data:{ 
                                        x:120, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'io_waveworkspace_startPosition', data:{ 
                                        x:10, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'io_waveworkspace_endPosition', data:{ 
                                        x:25, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                    
                                    {collection:'basic', type:'image', name:'backing', data:{ 
                                        x:-unitStyle.offset/2, y:-unitStyle.offset/2, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png'
                                    }},
                    
                                    {collection:'control', type:'dial_2_continuous', name:'dial_playbackSpeed',data:{
                                        x:125, y:20, radius:67.5/6, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, arcDistance:1.2, resetValue:0.5, style:unitStyle.dial_playbackSpeed,
                                    }},
                                    {collection:'display', type:'readout_sixteenSegmentDisplay', name:'time', data:{
                                        x:27.5+10/16, y:35+10/16, width:42.5 -10/8, height:10-10/8, canvasBased:true, count:8, resolution:5,
                                    }},
                                    {collection:'display', type:'readout_sixteenSegmentDisplay', name:'trackNameReadout', data:{
                                        x:82.5 -10 +10/16, y:35+10/16, width:60*14/12 -10/8, height:10-10/8, canvasBased:true, count:14, resolution:5,
                                    }},
                                    {collection:'control', type:'button_image', name:'button_play', data:{
                                        x:2.5, y:35, width:10, height:10, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_play_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_play_down.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'button_stop', data:{
                                        x:15, y:35, width:10, height:10, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_stop_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_stop_down.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'button_open', data:{
                                        x:145, y:2.5, width:12.5, height:12.5, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_file_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_file_down.png',
                                    }},
                                    {collection:'control', type:'checkbox_image', name:'checkbox_loop', data:{
                                        x:145, y:17.5, width:12.5, height:12.5,
                                        uncheckURL:unitStyle.imageStoreURL_localPrefix+'loop_off.png', 
                                        checkURL:unitStyle.imageStoreURL_localPrefix+'loop_on.png',
                                    }},
                                    {collection:'control', type:'checkbox_image', name:'checkbox_singleOrInfini', data:{
                                        x:145, y:32.5, width:12.5, height:12.5,
                                        uncheckURL:unitStyle.imageStoreURL_localPrefix+'single.png', 
                                        checkURL:unitStyle.imageStoreURL_localPrefix+'infini.png',
                                    }},
                                    {collection:'control', type:'grapher_waveWorkspace', name:'grapher_waveWorkspace', data:{
                                        x:5+10/16, y:2.5+10/16, width:102.5-10/6, height:30-10/8, style:unitStyle.grapher_waveWorkspace,
                                    }},
                                    {collection:'display', type:'glowbox_rectangle',name:'fireLight',data:{ 
                                        x:2.5, y:2.5, width:2.5, height:30, style:unitStyle.fireLight,
                                    }},
                                ]
                            });
                        
                        //circuitry
                            const playerCircuit = new _canvas_.interface.circuit.player(_canvas_.library.audio.context);
                            
                            function loadProcess(data){
                                object.elements.grapher_waveWorkspace.grapher_waveWorkspace.draw( playerCircuit.waveformSegment() );
                            
                                object.elements.readout_sixteenSegmentDisplay.trackNameReadout.text(data.name);
                                object.elements.readout_sixteenSegmentDisplay.trackNameReadout.print('smart');
                            }
                            function refresh(){
                                //check if there's a track at all
                                    if( !playerCircuit.isLoaded() ){return;}
                    
                                //time readout
                                    if(playerCircuit.concurrentPlayCountLimit() == 1){
                                        let tmp = playerCircuit.currentTime(0);
                                        if(tmp == -1){tmp = 0;}
                                        const time = _canvas_.library.math.seconds2time( Math.round(tmp));
                    
                                        object.elements.readout_sixteenSegmentDisplay.time.text(
                                            _canvas_.library.misc.padString(time.h,2,'0')+':'+
                                            _canvas_.library.misc.padString(time.m,2,'0')+':'+
                                            _canvas_.library.misc.padString(time.s,2,'0')
                                        );
                                        object.elements.readout_sixteenSegmentDisplay.time.print();
                                    }else{
                                        console.log( playerCircuit.currentTime() );
                                        object.elements.readout_sixteenSegmentDisplay.time.text(
                                            _canvas_.library.misc.padString(playerCircuit.currentTime().length,8,' ')
                                        );
                                        object.elements.readout_sixteenSegmentDisplay.time.print();
                                    }
                                
                                //waveport
                                    const progressList = playerCircuit.progress();
                                    let needleList = object.elements.grapher_waveWorkspace.grapher_waveWorkspace.list();
                    
                                    //adjust needles to match player
                                        progressList.forEach((needlePosition,index) => {
                                            object.elements.grapher_waveWorkspace.grapher_waveWorkspace.select(index,needlePosition,false);
                                        });
                    
                                    //remove unneeded needles
                                        while(Object.keys(needleList).length > progressList.length){
                                            object.elements.grapher_waveWorkspace.grapher_waveWorkspace.select((Object.keys(needleList).length-1),-1,false);
                                            needleList = object.elements.grapher_waveWorkspace.grapher_waveWorkspace.list();
                                        }
                            }
                            const refreshInterval = setInterval(refresh,1000/30);
                    
                        //wiring
                            //hid
                                object.elements.button_image.button_open.onpress = function(){
                                    playerCircuit.load('file',loadProcess);
                                };
                                object.elements.button_image.button_play.onpress = function(){
                                    if(object.i.concurrentPlayCountLimit() == 1 && playerCircuit.currentTime().length > 0){ playerCircuit.resume(); }
                                    else{ playerCircuit.start(); }
                    
                                    //flash light
                                        object.elements.glowbox_rectangle.fireLight.on();
                                        setTimeout(object.elements.glowbox_rectangle.fireLight.off, 100);
                                };
                                object.elements.button_image.button_stop.onpress = function(){ playerCircuit.stop(); };
                                object.elements.dial_2_continuous.dial_playbackSpeed.onchange = function(data){ playerCircuit.rate( 2*data ); };
                                object.elements.checkbox_image.checkbox_loop.onchange = function(bool){ return playerCircuit.loop(bool); };
                                object.elements.checkbox_image.checkbox_singleOrInfini.onchange = function(value){ return playerCircuit.concurrentPlayCountLimit(value ? -1 : 1); };
                                object.elements.grapher_waveWorkspace.grapher_waveWorkspace.onchange = function(needle,value){
                                    if( !isNaN(parseInt(needle)) ){
                                        if( playerCircuit.progress(needle) == -1 ){
                                            playerCircuit.createPlayhead(value);
                                        }else{
                                            playerCircuit.jumpTo(needle,value);
                                        }
                                    }
                    
                                    const area = object.elements.grapher_waveWorkspace.grapher_waveWorkspace.area();
                                    if(needle == 'selection_A'){ area.A = value; }
                                    if(needle == 'selection_B'){ area.B = value; }
                    
                                    object.elements.grapher_waveWorkspace.grapher_waveWorkspace.area(area.A,area.B,false);
                                    if(!object.elements.grapher_waveWorkspace.grapher_waveWorkspace.areaIsActive()){ area.A = 0; area.B = 1; }
                                    if(area.A > area.B){ const tmp = area.A; area.A = area.B; area.B = tmp; } //keepin' things straight
                                    return playerCircuit.area(area.A,area.B);
                                };
                            //io
                                object.io.audio.io_output_R.audioNode = playerCircuit.out_right()
                                object.io.audio.io_output_L.audioNode = playerCircuit.out_left()
                    
                                object.io.signal.io_play.onchange = function(value){
                                    const part = object.elements.button_image.button_play;
                                    value ? part.press() : part.release();
                                };
                                object.io.signal.io_stop.onchange = function(value){
                                    const part = object.elements.button_image.button_stop;
                                    value ? part.press() : part.release();
                                };
                                object.io.signal.io_singleOrInfini.onchange = function(value){
                                    if(!value){return;}
                                    const part = object.elements.checkbox_image.checkbox_singleOrInfini;
                                    part.set(!part.get());
                                };
                                object.io.signal.io_loop.onchange = function(value){
                                    if(!value){return;}
                                    const part = object.elements.checkbox_image.checkbox_loop;
                                    part.set(!part.get());
                                };
                                object.io.voltage.io_playbackSpeed.onchange = function(value){
                                    object.elements.dial_2_continuous.dial_playbackSpeed.set(value);
                                };
                                object.io.voltage.io_waveworkspace_startPosition.onchange = function(value){
                                    vconstcurrent = object.elements.grapher_waveWorkspace.grapher_waveWorkspace.area().B;
                                    if(current == undefined){current = 1;}
                                    object.elements.grapher_waveWorkspace.grapher_waveWorkspace.area(value,current);
                                };
                                object.io.voltage.io_waveworkspace_endPosition.onchange = function(value){
                                    let current = object.elements.grapher_waveWorkspace.grapher_waveWorkspace.area().A;
                                    if(current == undefined){current = 0;}
                                    object.elements.grapher_waveWorkspace.grapher_waveWorkspace.area(current,value);
                                };
                    
                        //interface
                            object.i = {
                                loadRaw:function(data){ playerCircuit.loadRaw(data,loadProcess); },
                                loadByFile:function(){ playerCircuit.load('file',loadProcess); },
                                loadByURL:function(url){ playerCircuit.load('url',loadProcess,url); },
                                fire:function(){
                                    if(playerCircuit.concurrentPlayCountLimit() == 1 && playerCircuit.currentTime().length > 0){ playerCircuit.resume(); }
                                    else{ playerCircuit.start(); }
                    
                                    //flash light
                                        object.elements.glowbox_rectangle.fireLight.on();
                                        setTimeout(object.elements.glowbox_rectangle.fireLight.off, 100);
                                },
                                pause:function(){ playerCircuit.pause(); },
                                resume:function(){ playerCircuit.resume(); },
                                stop:function(){ playerCircuit.stop(); },
                                area:function(start,end){ return object.elements.grapher_waveWorkspace.grapher_waveWorkspace.area(start,end); },
                                looping:function(bool){
                                    if(bool == undefined){ return object.elements.checkbox_image.checkbox_loop.get(); }
                                    object.elements.checkbox_image.checkbox_loop.set(bool);
                                },
                                rate:function(value){
                                    if(value == undefined){ return object.elements.dial_2_continuous.dial_playbackSpeed.get(); }
                                    object.elements.dial_2_continuous.dial_playbackSpeed.set(value);
                                },
                                jumpTo:function(needle,position){ playerCircuit.jumpTo(position,needle); },
                                concurrentPlayCountLimit:function(value){ return playerCircuit.concurrentPlayCountLimit(value); },
                            };
                    
                        //import/export
                            object.exportData = function(){
                                return{
                                    track: playerCircuit.unloadRaw(),
                                    rate: object.elements.dial_2_continuous.dial_playbackSpeed.get(),
                                    loopActive: object.elements.checkbox_image.checkbox_loop.get(), 
                                    selectedArea: object.elements.grapher_waveWorkspace.grapher_waveWorkspace.area(),
                                    singleOrInfini: object.elements.checkbox_image.checkbox_singleOrInfini.get(),
                                };
                            };
                            object.importData = function(data){
                                object.i.loadRaw(data.track);
                                object.elements.dial_2_continuous.dial_playbackSpeed.set(data.rate);
                                object.elements.checkbox_image.checkbox_loop.set(data.loopActive);
                                object.elements.grapher_waveWorkspace.grapher_waveWorkspace.area(data.selectedArea.A,data.selectedArea.B);
                                object.elements.checkbox_image.checkbox_singleOrInfini.set(data.singleOrInfini);
                            };
                    
                        //setup/tearDown
                            object.ondelete = function(){
                                clearInterval(refreshInterval);
                            };
                    
                        return object;
                    };
                    this.audio_file_player.metadata = {
                        name:'Audio File Player',
                        category:'synthesizers',
                        helpURL:'/help/units/alpha/audio_file_player/'
                    };

                    this.distortion = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'distortion/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:725, height:395 },
                                        design: { width:11.75, height:6.25 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                                    this.inGain = { handle:style.primaryEight[1], slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                                    this.resolution = { handle:style.primaryEight[7], slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                                    this.distortion = { handle:style.primaryEight[4], slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                                    this.outGain = { handle:style.primaryEight[0], slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'distortion',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                                              y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:unitStyle.drawingValue.height -unitStyle.offset },
                                    { x:0,                                              y:unitStyle.drawingValue.height -unitStyle.offset },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_audio', name:'input', data:{ 
                                        x:unitStyle.drawingValue.width-2.9, y:40, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'output', data:{ 
                                        x:0, y:55, width:5, height:15, angle:Math.PI, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'inGain_connection', data:{ 
                                        x:97, y:unitStyle.drawingValue.height-3.5, width:5, height:10, angle:Math.PI*0.5, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'resolution_connection', data:{ 
                                        x:67, y:0, width:5, height:10, angle:-Math.PI*0.5, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'distortion_connection', data:{ 
                                        x:32, y:0, width:5, height:10, angle:-Math.PI*0.5, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'outGain_connection', data:{ 
                                        x:22, y:unitStyle.drawingValue.height-3.5, width:5, height:10, angle:Math.PI*0.5, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'oversample_left', data:{ 
                                        x:50, y:unitStyle.drawingValue.height-3.5, width:5, height:10, angle:Math.PI*0.5, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'oversample_right', data:{ 
                                        x:68, y:unitStyle.drawingValue.height-3.5, width:5, height:10, angle:Math.PI*0.5, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:-unitStyle.offset/2, y:-unitStyle.offset/2, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png' }
                                    },
                                    {collection:'control', type:'dial_2_continuous',name:'inGain',data:{
                                        x:92, y:47, radius:22.5/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, resetValue:0.5, style:unitStyle.inGain,
                                    }},
                                    {collection:'control', type:'dial_2_continuous',name:'resolution',data:{
                                        x:72, y:19.5, radius:27.5/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, resetValue:0.5, style:unitStyle.resolution,
                                    }},
                                    {collection:'control', type:'dial_2_continuous',name:'distortion',data:{
                                        x:37, y:19.5, radius:27.5/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, resetValue:0.5, style:unitStyle.distortion,
                                    }},
                                    {collection:'control', type:'dial_2_continuous',name:'outGain',data:{
                                        x:17, y:47, radius:22.5/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, resetValue:0.5, style:unitStyle.outGain,
                                    }},
                                    {collection:'control', type:'slide_discrete_image',name:'oversample',data:{
                                        x:41.5, y:57.5, width:10, height:27, handleHeight:1/3, resetValue:0.5, angle:-Math.PI/2, optionCount:3, value:0,
                                        handleURL:unitStyle.imageStoreURL_localPrefix+'handle.png',
                                    }},
                                ]
                            });
                    
                        //circuitry
                            const distortionCircuit = new _canvas_.interface.circuit.distortionUnit(_canvas_.library.audio.context);
                    
                        //wiring
                            //hid
                                object.elements.dial_2_continuous.inGain.onchange = function(value){distortionCircuit.inGain(2*value);};
                                object.elements.dial_2_continuous.resolution.onchange = function(value){distortionCircuit.resolution(Math.round(value*1000));};
                                object.elements.dial_2_continuous.distortion.onchange = function(value){distortionCircuit.distortionAmount(value*100);};
                                object.elements.dial_2_continuous.outGain.onchange = function(value){distortionCircuit.outGain(value);};
                                object.elements.slide_discrete_image.oversample.onchange = function(value){distortionCircuit.oversample(['none','2x','4x'][value]);};
                            //io
                                object.io.audio.input.audioNode = distortionCircuit.in();
                                object.io.audio.output.audioNode = distortionCircuit.out();
                                object.elements.connectionNode_signal.oversample_left.onchange = function(value){ if(!value){return;} object.elements.slide_discrete_image.oversample.set( object.elements.slide_discrete_image.oversample.get() - 1 ); };
                                object.elements.connectionNode_signal.oversample_right.onchange = function(value){ if(!value){return;} object.elements.slide_discrete_image.oversample.set( object.elements.slide_discrete_image.oversample.get() + 1 ); };
                                object.elements.connectionNode_voltage.inGain_connection.onchange = function(value){ object.elements.dial_2_continuous.inGain.set(value); };
                                object.elements.connectionNode_voltage.resolution_connection.onchange = function(value){ object.elements.dial_2_continuous.resolution.set(value); };
                                object.elements.connectionNode_voltage.distortion_connection.onchange = function(value){ object.elements.dial_2_continuous.distortion.set(value); };
                                object.elements.connectionNode_voltage.outGain_connection.onchange = function(value){ object.elements.dial_2_continuous.outGain.set(value); };
                    
                        //interface
                            object.i = {
                                outGain:function(value){
                                    if(value==undefined){ return object.elements.dial_2_continuous.outGain.get(); }
                                    object.elements.dial_2_continuous.outGain.set(value);
                                },
                                distortionAmount:function(value){
                                    if(value==undefined){ return object.elements.dial_2_continuous.distortion.get(); }
                                    object.elements.dial_2_continuous.distortion.set(value);
                                },
                                resolution:function(value){
                                    if(value==undefined){ return object.elements.dial_2_continuous.resolution.get(); }
                                    object.elements.dial_2_continuous.resolution.set(value);
                                },
                                overSample:function(value){
                                    if(value==undefined){ return object.elements.slide_discrete_image.oversample.get(); }
                                    object.elements.slide_discrete_image.oversample.set(value);
                                },
                                inGain:function(value){
                                    if(value==undefined){ return object.elements.dial_2_continuous.inGain.get(); }
                                    object.elements.dial_2_continuous.inGain.set(value);
                                },
                            };
                    
                        //import/export
                            object.importData = function(data){
                                object.elements.dial_2_continuous.outGain.set(data.outGain);
                                object.elements.dial_2_continuous.distortion.set(data.distortionAmount);
                                object.elements.dial_2_continuous.resolution.set(data.resolution);
                                object.elements.slide_discrete_image.oversample.set(data.overSample);
                                object.elements.dial_2_continuous.inGain.set(data.inGain);
                            };
                            object.exportData = function(){
                                return {
                                    outGain:          object.elements.dial_2_continuous.outGain.get(), 
                                    distortionAmount: object.elements.dial_2_continuous.distortion.get(), 
                                    resolution:       object.elements.dial_2_continuous.resolution.get(), 
                                    overSample:       object.elements.slide_discrete_image.oversample.get(), 
                                    inGain:           object.elements.dial_2_continuous.inGain.get()
                                };
                            };
                    
                        //setup/tearDown
                            object.oncreate = function(){
                                object.elements.dial_2_continuous.resolution.set(0.5);
                                object.elements.dial_2_continuous.inGain.set(0.5);
                                object.elements.dial_2_continuous.outGain.set(1);
                            };
                    
                        return object;
                    };
                    this.distortion.metadata = {
                        name:'Distortion',
                        category:'effects',
                        helpURL:'/help/units/alpha/distortion/'
                    };
                    

                    this.reverb = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'reverb/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:885, height:320 },
                                        design: { width:14.5, height:5 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                                    this.LCD = {
                                        background:{r:0.1,g:0.1,b:0.1,a:1},
                                        glow:{r:0.3,g:0.64,b:0.22,a:1},
                                        dim:{r:0.1,g:0.24,b:0.12,a:1}
                                    };
                                    this.dial_wet = { handle:style.primaryEight[5], slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                                    this.dial_dry = { handle:style.primaryEight[2], slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'reverb',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                                              y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:unitStyle.drawingValue.height -unitStyle.offset },
                                    { x:0,                                              y:unitStyle.drawingValue.height -unitStyle.offset },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_audio', name:'input', data:{ 
                                        x:unitStyle.drawingValue.width-3.5, y:30, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'output', data:{ 
                                        x:0, y:45, width:5, height:15, angle:Math.PI, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'wet_connection', data:{ 
                                        x:92.5, y:unitStyle.drawingValue.height-3.5, width:5, height:10, angle:Math.PI*0.5, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'dry_connection', data:{ 
                                        x:125, y:unitStyle.drawingValue.height-3.5, width:5, height:10, angle:Math.PI*0.5, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'rocker_down_connection', data:{ 
                                        x:69, y:unitStyle.drawingValue.height-3.5, width:5, height:10, angle:Math.PI*0.5, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'rocker_up_connection', data:{ 
                                        x:59, y:0, width:5, height:10, angle:-Math.PI*0.5, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:-unitStyle.offset/2, y:-unitStyle.offset/2, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'guide.png' }
                                    },
                                    {collection:'control', type:'dial_2_continuous',name:'wet',data:{
                                        x:87.5, y:22.5, radius:27.5/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, resetValue:0.5, style:unitStyle.dial_wet,
                                    }},
                                    {collection:'control', type:'dial_2_continuous',name:'dry',data:{
                                        x:120, y:22.5, radius:27.5/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, resetValue:0.5, style:unitStyle.dial_dry,
                                    }},
                                    {collection:'control', type:'button_image', name:'rocker_up', data:{
                                        x:58.7, y:10, width:10, height:15, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'rocker_up_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'rocker_up_down.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'rocker_down', data:{
                                        x:58.7, y:25, width:10, height:15, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'rocker_down_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'rocker_down_down.png',
                                    }},
                                    {collection:'display', type:'sevenSegmentDisplay', name:'LCD_10', data:{ x:5, y:5, width:25, height:40, canvasBased:true, style:unitStyle.LCD }},
                                    {collection:'display', type:'sevenSegmentDisplay', name:'LCD_1', data:{ x:30, y:5, width:25, height:40, canvasBased:true, style:unitStyle.LCD }},
                                ]
                            });
                    
                        //circuitry        
                            const state = {
                                reverbTypeSelected:0,
                                availableTypes:[],
                                wet:0.5,
                                dry:0.5,
                            };
                            const reverbCircuit = new _canvas_.interface.circuit.reverbUnit(_canvas_.library.audio.context);
                                
                            //internal functions
                                let loadingScreenIntervalID;
                                const journeyHistory = [];
                                const journey = [
                                    //big loop
                                        // ['LCD_1',0],
                                        // ['LCD_1',2],
                                        // ['LCD_1',5],
                                        // ['LCD_1',6],
                                        // ['LCD_10',6],
                                        // ['LCD_10',4],
                                        // ['LCD_10',1],
                                        // ['LCD_10',0],
                    
                                    //four loops
                                        ['LCD_10',3],
                                        ['LCD_10',1],
                                        ['LCD_10',0],
                                        ['LCD_10',2],
                                        ['LCD_10',5],
                                        ['LCD_10',6],
                                        ['LCD_10',4],
                                        ['LCD_10',3],
                                        ['LCD_1',3],
                                        ['LCD_1',5],
                                        ['LCD_1',6],
                                        ['LCD_1',4],
                                        ['LCD_1',1],
                                        ['LCD_1',0],
                                        ['LCD_1',2],
                                        ['LCD_1',3],
                                ];
                                let step = 0;
                                function startReadoutLoadingScreen(){
                                    object.elements.sevenSegmentDisplay.LCD_10.enterCharacter();
                                    object.elements.sevenSegmentDisplay.LCD_1.enterCharacter();
                                    
                                    if(loadingScreenIntervalID != undefined){return;}
                                    loadingScreenIntervalID = setInterval(function(){
                                        const data = journey[step++]
                                        if(step >= journey.length){step = 0;}
                    
                                        if(journeyHistory.length == 3){
                                            const last = journeyHistory.shift();
                                            if(last != undefined){ object.elements.sevenSegmentDisplay[last[0]].set(last[1],false); }
                                        }
                    
                                        object.elements.sevenSegmentDisplay[data[0]].set(data[1],true);
                    
                                        journeyHistory.push(data);
                                    },1000/20);
                                }
                                function stopReadoutLoadingScreen(){
                                    clearInterval(loadingScreenIntervalID);
                                    loadingScreenIntervalID = undefined;
                                    object.elements.sevenSegmentDisplay.LCD_10.enterCharacter();
                                    object.elements.sevenSegmentDisplay.LCD_1.enterCharacter();
                                };
                                function setReadout(num){
                                    num = ("0" + num).slice(-2);
                    
                                    object.elements.sevenSegmentDisplay.LCD_10.enterCharacter(num[0]);
                                    object.elements.sevenSegmentDisplay.LCD_1.enterCharacter(num[1]);
                                }
                                function setReverbType(a){
                                    if( state.availableTypes.length == 0 ){ console.log('broken or not yet ready'); return; }
                    
                                    if( a >= state.availableTypes.length ){a = state.availableTypes.length-1;}
                                    else if( a < 0 ){a = 0;}
                        
                                    state.reverbTypeSelected = a;
                                    startReadoutLoadingScreen();
                                    reverbCircuit.type( state.availableTypes[a], function(){stopReadoutLoadingScreen(); setReadout(state.reverbTypeSelected);} );    
                                }
                                function incReverbType(){ setReverbType(state.reverbTypeSelected+1); }
                                function decReverbType(){ setReverbType(state.reverbTypeSelected-1); }
                                function updateWetDry(){ reverbCircuit.wetdry('manualControl',state.wet,state.dry); }
                    
                        //wiring
                            //hid
                                object.elements.dial_2_continuous.wet.onchange = function(value){ state.wet = value; updateWetDry(); };
                                object.elements.dial_2_continuous.dry.onchange = function(value){ state.dry = value; updateWetDry(); };
                                object.elements.button_image.rocker_up.onpress = function(){ incReverbType(); };
                                object.elements.button_image.rocker_down.onpress = function(){ decReverbType(); };
                            //io
                                object.io.audio.input.audioNode = reverbCircuit.in();
                                object.io.audio.output.audioNode = reverbCircuit.out();
                                object.io.voltage.wet_connection.onchange = function(value){ object.elements.dial_2_continuous.wet.set(value); };
                                object.io.voltage.dry_connection.onchange = function(value){ object.elements.dial_2_continuous.dry.set(value); };
                                object.io.signal.rocker_down_connection.onchange = function(value){
                                    value ? object.elements.button_image.rocker_down.press() : object.elements.button_image.rocker_down.release();
                                };
                                object.io.signal.rocker_up_connection.onchange = function(value){
                                    value ? object.elements.button_image.rocker_up.press() : object.elements.button_image.rocker_up.release();
                                };
                    
                        //interface
                            object.i = {
                                wet: function(value){
                                    if(value == undefined){
                                        return object.elements.dial_2_continuous.wet.get();
                                    }else{
                                        object.elements.dial_2_continuous.wet.set(value);
                                    }
                                },
                                dry: function(value){
                                    if(value == undefined){
                                        return object.elements.dial_2_continuous.dry.get();
                                    }else{
                                        object.elements.dial_2_continuous.dry.set(value);
                                    }
                                },
                                reverbNumber: function(number){ if(value == undefined){ return state.reverbTypeSelected; }else{ setReverbType(number); } }
                            };
                    
                        //import/export
                            object.exportData = function(){
                                return {
                                    wet: object.elements.dial_2_continuous.wet.get(),
                                    dry: object.elements.dial_2_continuous.dry.get(),
                                    reverbNumber: state.reverbTypeSelected,
                                };
                            };
                            object.importData = function(data){
                                object.elements.dial_2_continuous.wet.set(data.wet);
                                object.elements.dial_2_continuous.dry.set(data.dry);
                                state.reverbTypeSelected = data.reverbNumber;
                            };
                    
                        //setup/tearDown
                            object.oncreate = function(){
                                reverbCircuit.getTypes( a => { state.availableTypes = a; setReverbType(state.reverbTypeSelected); } );
                            };
                    
                        return object;
                    };
                    this.reverb.metadata = {
                        name:'Reverb',
                        category:'effects',
                        helpURL:'/help/units/alpha/reverb/'
                    };
                    this.filter = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'filter/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:620, height:260 },
                                        design: { width:10, height:4 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                                    this.dial_lowBand = { handle:style.primaryEight[0], slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                                    this.dial_midBand = { handle:style.primaryEight[3], slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                                    this.dial_highBand = { handle:style.primaryEight[5], slot:{r:0,g:0,b:0,a:0}, needle:{r:1,g:1,b:1,a:1} };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'filter',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                                              y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:unitStyle.drawingValue.height -unitStyle.offset },
                                    { x:0,                                              y:unitStyle.drawingValue.height -unitStyle.offset },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_audio', name:'input', data:{ 
                                        x:unitStyle.drawingValue.width - 10/3, y:unitStyle.drawingValue.height/2 - 9, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'output', data:{ 
                                        x:0, y:unitStyle.drawingValue.height/2 + 6, width:5, height:15, angle:Math.PI, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', data:{ 
                                        x:-unitStyle.offset/2, y:-unitStyle.offset/2, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png'
                                    }},
                                    {collection:'control', type:'dial_2_continuous',name:'dial_lowBand',data:{
                                        x:17.5, y:22.5, radius:12.5, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, arcDistance:1.2, resetValue:0.5, style:unitStyle.dial_lowBand,
                                    }},
                                    {collection:'control', type:'dial_2_continuous',name:'dial_midBand',data:{
                                        x:47.5, y:22.5, radius:12.5, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, arcDistance:1.2, resetValue:0.5, style:unitStyle.dial_midBand,
                                    }},
                                    {collection:'control', type:'dial_2_continuous',name:'dial_highBand',data:{
                                        x:77.5, y:22.5, radius:12.5, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, arcDistance:1.2, resetValue:0.5, style:unitStyle.dial_highBand,
                                    }},
                                ]
                            });
                    
                        //circuitry
                            const curvePointExponentialSharpness = 10.586609649448984;
                            const state = {
                                currentValues:{
                                    gain: [1,1,1],
                                    frequency: [250,700,2500],
                                    Q: [0,1/2,0],
                                },
                                defaultValues:{
                                    gain: [1,1,1],
                                    frequency: [250,700,2500],
                                    Q: [0,0.35,0],
                                }
                            };
                            const filterCircuit = new _canvas_.interface.circuit.multibandFilter(_canvas_.library.audio.context, 3, true);
                    
                            function setGain(band,value){ 
                                if(band == undefined){return state.currentValues.gain;}
                                if(value == undefined){return state.currentValues.gain[band];}
                    
                                state.currentValues.gain[band] = value;
                                filterCircuit.gain(band,state.currentValues.gain[band]);
                            }
                    
                        //wiring
                            //hid
                                object.elements.dial_2_continuous.dial_lowBand.onchange = function(value){ setGain(0,value*2); };
                                object.elements.dial_2_continuous.dial_midBand.onchange = function(value){ setGain(1,value*2); };
                                object.elements.dial_2_continuous.dial_highBand.onchange = function(value){ setGain(2,value*2); };
                            //io
                                object.io.audio.input.audioNode = filterCircuit.in();
                                object.io.audio.output.audioNode = filterCircuit.out();
                    
                        //interface
                            object.i = {
                                gain:function(band,value){
                                    const element = object.elements.dial_2_continuous[ ['dial_lowBand','dial_midBand','dial_highBand'][band] ];
                                    if(value == undefined){ return element.get(); }
                                    element.set(value/2);
                                },
                                Q:function(band,value){ 
                                    if(band == undefined){return state.currentValues.Q;}
                                    if(value == undefined){return state.currentValues.Q[band];}
                    
                                    state.currentValues.Q[band] = value;
                                    filterCircuit.Q(band, _canvas_.library.math.curvePoint.exponential(state.currentValues.Q[band],0,20000,curvePointExponentialSharpness));
                                },
                                frequency:function(band,value){
                                    if(band == undefined){return state.currentValues.frequency;}
                                    if(value == undefined){return state.currentValues.frequency[band];}
                    
                                    state.currentValues.frequency[band] = value;
                                    filterCircuit.frequency(band, state.currentValues.frequency[band]);
                                },
                                reset:function(channel){
                                    if(channel == undefined){
                                        //if no channel if specified, reset all of them
                                        for(let a = 0; a < 3; a++){ object.i.reset(a); }
                                        return;
                                    }
                                    for(let a = 0; a < 3; a++){
                                        object.i.gain(a,state.defaultValues.gain[a]);
                                        object.i.Q(a,state.defaultValues.Q[a]);
                                        object.i.frequency(a,state.defaultValues.frequency[a]);
                                    }
                                },
                            };
                    
                        //import/export
                            object.exportData = function(){
                                return {
                                    low: object.elements.dial_2_continuous.dial_lowBand.get(),
                                    mid: object.elements.dial_2_continuous.dial_midBand.get(),
                                    high: object.elements.dial_2_continuous.dial_highBand.get(),
                                };
                            };
                            object.importData = function(data){
                                object.elements.dial_2_continuous.dial_lowBand.set( data.low );
                                object.elements.dial_2_continuous.dial_midBand.set( data.mid );
                                object.elements.dial_2_continuous.dial_highBand.set( data.high );
                            };
                    
                        //setup/tearDown
                            object.oncreate = function(){
                                object.i.reset();
                            };
                    
                        return object;
                    };
                    this.filter.metadata = {
                        name:'Filter (unfinished)',
                        category:'effects',
                        helpURL:'/help/units/alpha/filter/'
                    };

                    this.pulse_generator = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'pulse_generator/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:590, height:260 },
                                        design: { width:9.5, height:4 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                                    this.LCD = {
                                        background:{r:0.1,g:0.1,b:0.1,a:1},
                                        glow: {r:0.3,g:0.64,b:0.22,a:1},
                                        dim: {r:0.1,g:0.24,b:0.12,a:1}
                                    }
                                    this.ledSyncFlash = {
                                        dim: {r:0.64,g:0.31,b:0.24,a:1}, 
                                        glow: {r:0.94,g:0.31,b:0.34,a:1}
                                    };
                                    this.syncButton = {
                                        background__up__colour: {r:0.69,g:0.69,b:0.69,a:1},
                                        background__press__colour: {r:0.8,g:0.8,b:0.8,a:1},
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'pulse_generator',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                                                    y:0                                                      },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset,       y:0                                                      },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset,       y:unitStyle.drawingValue.height -unitStyle.offset        },
                                    { x:(unitStyle.drawingValue.width -unitStyle.offset)/9.5, y:unitStyle.drawingValue.height -unitStyle.offset        },
                                    { x:0,                                                    y:(unitStyle.drawingValue.height -unitStyle.offset)*0.75 },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'output', data:{
                                        x:0, y:21.5, width:5, height:10, angle:Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'port_sync', data:{
                                        x:7.5, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'port_100_up',     data:{ x:21.65 + 10.85*0, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'port_10_up',      data:{ x:21.65 + 10.85*1, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'port_1_up',       data:{ x:21.65 + 10.85*2, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'port_0.1_up',     data:{ x:21.65 + 10.85*3, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'port_0.01_up',    data:{ x:21.65 + 10.85*4, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'port_0.001_up',   data:{ x:21.65 + 10.85*5, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'port_100_down',   data:{ x:10 + 21.65 + 10.85*0, y:unitStyle.drawingValue.height-3-1/3, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'port_10_down',    data:{ x:10 + 21.65 + 10.85*1, y:unitStyle.drawingValue.height-3-1/3, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'port_1_down',     data:{ x:10 + 21.65 + 10.85*2, y:unitStyle.drawingValue.height-3-1/3, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'port_0.1_down',   data:{ x:10 + 21.65 + 10.85*3, y:unitStyle.drawingValue.height-3-1/3, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'port_0.01_down',  data:{ x:10 + 21.65 + 10.85*4, y:unitStyle.drawingValue.height-3-1/3, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'port_0.001_down', data:{ x:10 + 21.65 + 10.85*5, y:unitStyle.drawingValue.height-3-1/3, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal }},
                    
                                    {collection:'basic', type:'image', name:'backing', data:{ 
                                        x:-unitStyle.offset/2, y:-unitStyle.offset/2, 
                                        width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, 
                                        url:unitStyle.imageStoreURL_localPrefix+'backing.png'
                                    } },
                    
                                    {collection:'display', type:'glowbox_path', name:'ledSyncFlash', data:{ 
                                        x:0, y:0, points:[ {x:5-3/4,y:5-3/4}, {x:20+3/4,y:5-3/4}, {x:20+3/4,y:35+3/4}, {x:12.5-2/5,y:35+3/4}, {x:5-3/4,y:27.5+2/5} ],
                                        looping:true, jointType:'round', style:unitStyle.ledSyncFlash,
                                    } },
                                    {collection:'control', type:'button_polygon', name:'sync', data:{
                                        x:5, y:5, hoverable:false, points:[ {x:0,y:0}, {x:15,y:0}, {x:15,y:30}, {x:7.5,y:30}, {x:0,y:22.5} ], style:unitStyle.syncButton,
                                    }},
                                    {collection:'basic', type:'image', name:'time_symbol', data:{ 
                                        x:6.25, y:12.5, width:12 + 1/3, height:12 + 1/3, url:unitStyle.imageStoreURL_localPrefix+'time_symbol.png'
                                    } },
                    
                                    {collection:'display', type:'readout_sevenSegmentDisplay', name:'LCD', data:{ 
                                        x:21.75, y:10.75, width:64, height:18.5, canvasBased:true, count:6, decimalPlaces:true, style:unitStyle.LCD, resolution:5,
                                    }},
                    
                                    {collection:'control', type:'button_image', name:'100_up',     data:{ x:21.65 + 10.85*0, y:5,  width:10, height:5, hoverable:false, backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_up.png', backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_down.png' }},
                                    {collection:'control', type:'button_image', name:'10_up',      data:{ x:21.65 + 10.85*1, y:5,  width:10, height:5, hoverable:false, backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_up.png', backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_down.png' }},
                                    {collection:'control', type:'button_image', name:'1_up',       data:{ x:21.65 + 10.85*2, y:5,  width:10, height:5, hoverable:false, backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_up.png', backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_down.png' }},
                                    {collection:'control', type:'button_image', name:'0.1_up',     data:{ x:21.65 + 10.85*3, y:5,  width:10, height:5, hoverable:false, backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_up.png', backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_down.png' }},
                                    {collection:'control', type:'button_image', name:'0.01_up',    data:{ x:21.65 + 10.85*4, y:5,  width:10, height:5, hoverable:false, backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_up.png', backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_down.png' }},
                                    {collection:'control', type:'button_image', name:'0.001_up',   data:{ x:21.65 + 10.85*5, y:5,  width:10, height:5, hoverable:false, backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_up.png', backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_down.png' }},
                                    {collection:'control', type:'button_image', name:'100_down',   data:{ x:21.65 + 10.85*0, y:30, width:10, height:5, hoverable:false, backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_up.png', backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_down.png' }},
                                    {collection:'control', type:'button_image', name:'10_down',    data:{ x:21.65 + 10.85*1, y:30, width:10, height:5, hoverable:false, backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_up.png', backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_down.png' }},
                                    {collection:'control', type:'button_image', name:'1_down',     data:{ x:21.65 + 10.85*2, y:30, width:10, height:5, hoverable:false, backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_up.png', backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_down.png' }},
                                    {collection:'control', type:'button_image', name:'0.1_down',   data:{ x:21.65 + 10.85*3, y:30, width:10, height:5, hoverable:false, backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_up.png', backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_down.png' }},
                                    {collection:'control', type:'button_image', name:'0.01_down',  data:{ x:21.65 + 10.85*4, y:30, width:10, height:5, hoverable:false, backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_up.png', backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_down.png' }},
                                    {collection:'control', type:'button_image', name:'0.001_down', data:{ x:21.65 + 10.85*5, y:30, width:10, height:5, hoverable:false, backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_up.png', backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_down.png' }},
                                ],
                            });
                    
                        //circuitry
                            const state = {
                                storedValue: [1,2,0,0,0,0],
                                interval: null,
                                tempo: 120,
                            };
                            function updateTempo(newTempo){
                                //safety
                                    if(newTempo > 999){newTempo = 999;}
                                    if(newTempo < 0.001){newTempo = 0.001;}
                    
                                //update readout
                                    const readout_tmp = (''+newTempo).split('.');
                                    let string = readout_tmp[0];
                                    if(newTempo < 100){string = '0' + string;}
                                    if(newTempo < 10){string = '0' + string;}
                                    if(readout_tmp[1] == undefined){ string += '.000';}
                                    else if(readout_tmp[1].length == 1){ string += '.' + readout_tmp[1] + '00';}
                                    else if(readout_tmp[1].length == 2){ string += '.' + readout_tmp[1] + '0';}
                                    else if(readout_tmp[1].length >= 3){ string += '.' + readout_tmp[1];}
                                    if(string.length > 7){ string = string.slice(0,7); }
                                    tempoString = string;
                                    newTempo = parseFloat(string);
                    
                                    object.elements.readout_sevenSegmentDisplay.LCD.text(string);
                                    object.elements.readout_sevenSegmentDisplay.LCD.print();
                    
                                //update interval
                                    if(state.interval){ clearInterval(state.interval); }
                                    if(newTempo > 0){
                                        state.interval = setInterval(function(){
                                            object.io.signal.output.set(true);
                                            object.elements.glowbox_path.ledSyncFlash.on();
                                            setTimeout(function(){
                                                object.io.signal.output.set(false);
                                                object.elements.glowbox_path.ledSyncFlash.off();
                                            },50)
                                        },1000*(60/newTempo));
                                    }
                    
                                object.io.signal.output.set(true);
                                object.elements.glowbox_path.ledSyncFlash.on();
                                setTimeout(function(){
                                    object.io.signal.output.set(false);
                                    object.elements.glowbox_path.ledSyncFlash.off();
                                },50)
                    
                                //update state
                                    state.tempo = newTempo;
                    
                                    state.storedValue = [0,0,0,0,0,0];
                                    let tmp = String(state.tempo).split('');
                                    
                                    if(tmp.indexOf('.') == -1){
                                        tmp.reverse().forEach((value,index) => { state.storedValue[2-index] = value; });
                                    }else{
                                        tmp.slice(0,(tmp.indexOf('.'))).reverse().forEach((value,index) => { state.storedValue[2-index] = value; });
                                        tmp.slice((tmp.indexOf('.'))+1).forEach((value,index) => { state.storedValue[3+index] = value; });
                                    }
                    
                                    state.storedValue = state.storedValue.map(item => parseInt(item));
                            }
                            function updateUsingStoredValue(){
                                updateTempo( parseFloat(state.storedValue.slice(0,3).join('') +'.'+ state.storedValue.slice(3,6).join('')) );
                            }
                    
                        //wiring
                            //hid
                                object.elements.button_polygon.sync.onpress = function(){ updateTempo(state.tempo); };
                                ['100_up', '10_up', '1_up', '0.1_up', '0.01_up', '0.001_up'].forEach((buttonName,index) => {
                                    object.elements.button_image[buttonName].onpress = function(){ state.storedValue[index] = state.storedValue[index] == 9 ? 0 : state.storedValue[index]+1; updateUsingStoredValue(); };
                                });
                                ['100_down', '10_down', '1_down', '0.1_down', '0.01_down', '0.001_down'].forEach((buttonName,index) => {
                                    object.elements.button_image[buttonName].onpress = function(){ state.storedValue[index] = state.storedValue[index] == 0 ? 9 : state.storedValue[index]-1; updateUsingStoredValue(); };
                                });
                                
                            //io
                                [
                                    'sync',
                                    '100_up', '10_up', '1_up', '0.1_up', '0.01_up', '0.001_up',
                                    '100_down', '10_down', '1_down', '0.1_down', '0.01_down', '0.001_down'
                                ].forEach(portName => {
                                    object.io.signal['port_'+portName].onchange = function(value){
                                        if(value){ object.elements.button_image[portName].press();   }
                                        else{      object.elements.button_image[portName].release(); }
                                    };
                                });
                    
                        //interface
                            object.i = {
                                tempo:function(value){
                                    if(value == undefined){return state.tempo;}
                                    updateTempo(value);
                                },
                            };
                    
                        //import/export
                            object.exportData = function(){
                                return { tempo:state.tempo };
                            };
                            object.importData = function(data){
                                object.i.tempo(data.tempo);
                            };
                    
                        //oncreate/ondelete
                            object.oncreate = function(){
                                updateUsingStoredValue();
                            };
                            object.ondelete = function(){
                                clearInterval(state.interval);
                            };
                    
                        return object;
                    };
                    this.pulse_generator.metadata = {
                        name:'Pulse Generator',
                        category:'sequencers',
                        helpURL:'/help/units/alpha/pulse_generator/'
                    };
                    this.eightStepSequencer = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'eightStepSequencer/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:1670, height:590 },
                                        design: { width:27.5, height:9.5 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                                    this.LED = {
                                        glow:{r:232/255, g:160/255, b:111/255, a:1},
                                        dim:{r:164/255, g:80/255, b:61/255, a:1},
                                    };
                                    this.dial = {
                                        slot:{r:0,g:0,b:0,a:0},
                                        needle:{r:1,g:1,b:1,a:1},
                                    };
                                    this.button = {
                                        background__up__colour:{r:175/255,g:175/255,b:175/255,a:1},
                                        background__hover__colour:{r:200/255,g:200/255,b:200/255,a:1},
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'eightStepSequencer',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                                                           y:0                                                           },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset,              y:0                                                           },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset,              y:(unitStyle.drawingValue.height -unitStyle.offset)*(5.5/9.5) },
                                    { x:(unitStyle.drawingValue.width-unitStyle.offset)*(26/27.5),   y:(unitStyle.drawingValue.height -unitStyle.offset)*(5.5/9.5) },
                                    { x:(unitStyle.drawingValue.width-unitStyle.offset)*(24.5/27.5), y:(unitStyle.drawingValue.height -unitStyle.offset)*(7/9.5)   },
                                    { x:(unitStyle.drawingValue.width-unitStyle.offset)*(24.5/27.5), y:unitStyle.drawingValue.height -unitStyle.offset             },
                                    { x:0,                                                           y:unitStyle.drawingValue.height -unitStyle.offset             },
                                ],
                                elements:
                                    (new Array(8).fill(0)).flatMap((value,index) => { 
                                        return [
                                            {collection:'dynamic', type:'connectionNode_signal', name:'noteOctaveChange_back_'+index, data:{ 
                                                x:7 +30*index, y:0, width:5, height:10, angle:Math.PI*1.5, cableVersion:2, style:style.connectionNode.signal,
                                            }},
                                            {collection:'dynamic', type:'connectionNode_signal', name:'noteOctaveChange_fore_'+index, data:{ 
                                                x:18 +30*index, y:0, width:5, height:10, angle:Math.PI*1.5, cableVersion:2, style:style.connectionNode.signal,
                                            }},
                                            {collection:'dynamic', type:'connectionNode_signal', name:'activate_'+index, data:{ 
                                                x:17 +30*index, y:unitStyle.drawingValue.height -unitStyle.offset, width:5, height:10, angle:Math.PI*0.5, cableVersion:2, style:style.connectionNode.signal,
                                            }},
                                            {collection:'dynamic', type:'connectionNode_voltage', name:'velocity_'+index, data:{ 
                                                x:28 +30*index, y:unitStyle.drawingValue.height -unitStyle.offset, width:5, height:10, angle:Math.PI*0.5, cableVersion:2, style:style.connectionNode.voltage,
                                            }}
                                        ]; 
                                    }).concat(
                                    [
                                        {collection:'dynamic', type:'connectionNode_data', name:'output', data:{ 
                                            x:0, y:30, width:5, height:15, angle:Math.PI, cableVersion:2, style:style.connectionNode.data,
                                        }},
                                        {collection:'dynamic', type:'connectionNode_signal', name:'directionChange_step', data:{ 
                                            x:unitStyle.drawingValue.width-0.5 -unitStyle.offset, y:10, width:5, height:10, cableVersion:2, style:style.connectionNode.signal,
                                        }},
                                        {collection:'dynamic', type:'connectionNode_signal', name:'directionChange_forwards', data:{ 
                                            x:unitStyle.drawingValue.width-0.5 -unitStyle.offset, y:22, width:5, height:10, cableVersion:2, style:style.connectionNode.signal,
                                        }},
                                        {collection:'dynamic', type:'connectionNode_signal', name:'directionChange_backwards', data:{ 
                                            x:unitStyle.drawingValue.width-0.5 -unitStyle.offset, y:33, width:5, height:10, cableVersion:2, style:style.connectionNode.signal,
                                        }},
                    
                                        {collection:'basic', type:'image', name:'backing', 
                                            data:{ x:-unitStyle.offset/2, y:-unitStyle.offset/2, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png' }
                                        },
                    
                                        {collection:'control', type:'button_image', name:'button_step', data:{
                                            x:243.25, y:4.5, width:21, height:21, hoverable:false, 
                                            backingURL__up:unitStyle.imageStoreURL_localPrefix+'stepButton_up.png',
                                            backingURL__press:unitStyle.imageStoreURL_localPrefix+'stepButton_down.png',
                                        }},
                                        {collection:'control', type:'slide_discrete_image',name:'slide_direction',data:{
                                            x:244, y:37.125, width:9.25, height:19.4, handleHeight:1/2, resetValue:0.5, angle:-Math.PI/2, optionCount:2, value:1,
                                            handleURL:unitStyle.imageStoreURL_localPrefix+'directionSlideHandle.png',
                                        }},
                                    ]).concat(
                                        (new Array(8).fill(0)).flatMap((value,index) => { 
                                            return [
                                                {collection:'display', type:'glowbox_rectangle',name:'LED'+index,data:{
                                                    x:12.5 +30*index, y:2.5, width:10, height:2.5, style:unitStyle.LED
                                                }},
                                                {collection:'control', type:'dial_2_discrete',name:'dial_noteSelect_'+index,data:{
                                                    x:17.5 +30*index, y:22.5, radius:(150/6)/2, startAngle:(2.9*Math.PI)/4, maxAngle:1.55*Math.PI, optionCount:12, arcDistance:1.2, resetValue:0.5,
                                                    style:{ handle:style.primaryEight[index], slot:unitStyle.dial.slot, needle:unitStyle.dial.needle },
                                                }},
                                                {collection:'control', type:'slide_discrete_image',name:'slide_octave_'+index,data:{
                                                    x:5.6 +30*index, y:47.25, width:9.5, height:23.75, handleHeight:1/2.5, resetValue:0.5, angle:-Math.PI/2, optionCount:3, value:1,
                                                    handleURL:unitStyle.imageStoreURL_localPrefix+'octaveSlideHandle_'+index+'.png',
                                                }},
                                                {collection:'control', type:'dial_2_continuous',name:'dial_velocity_'+index,data:{
                                                    x:17.5 +30*index, y:57.5, radius:(75/6)/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, resetValue:0.5,
                                                    style:{ handle:style.primaryEight[index], slot:unitStyle.dial.slot, needle:unitStyle.dial.needle },
                                                }},
                                                {collection:'control', type:'button_rectangle', name:'button_activate_'+index, data:{
                                                    x:17.5 +30*index, y:68.5, width:16, height:16, angle:Math.PI/4, style:unitStyle.button,
                                                }},
                                            ]; 
                                        })
                                    )
                            });
                    
                        //circuitry
                            const state = {
                                stepCount:8,
                                direction:1,
                                previousPosition:-1,
                                position:-1,
                                requestedNextPosition:-1,
                                stages:new Array(8).fill(undefined).map(() => ({note:0, octave:0, velocity:0})),
                                previousMidiNumber:-1,
                            };
                            function stageToMidiNoteNumber(stage){
                                const octaveOffset = 4;
                                const note = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'][stage.note];
                                const octave = stage.octave+octaveOffset;
                                return _canvas_.library.audio.name2num(octave+note);
                            }
                            function step(){
                                //figure out what stage to step to next
                                    state.previousPosition = state.position;
                                    state.position = state.requestedNextPosition != -1 ? state.requestedNextPosition : state.position+state.direction;
                                    state.requestedNextPosition = -1;
                                    if(state.position > state.stepCount-1){state.position = 0;}else if(state.position < 0){state.position = state.stepCount-1;}
                    
                                //stop previous note (unless there wasn't one) and send the new one
                                    const midiNumber = stageToMidiNoteNumber(state.stages[state.position]);
                                    if(state.previousMidiNumber != -1){object.elements.connectionNode_data.output.send('midinumber',{num:state.previousMidiNumber, velocity:0});}
                                    object.elements.connectionNode_data.output.send('midinumber',{num:midiNumber, velocity:state.stages[state.position].velocity});
                                    state.previousMidiNumber = midiNumber;
                    
                                //light up the appropriate LED
                                    if(state.previousPosition != -1){ object.elements.glowbox_rectangle['LED'+state.previousPosition].off(); }
                                    object.elements.glowbox_rectangle['LED'+state.position].on(); 
                            }
                    
                        //wiring
                            //hid
                                object.elements.button_image.button_step.onpress = step;
                                object.elements.slide_discrete_image.slide_direction.onchange = function(value){ state.direction = value*2 - 1; };
                                for(let index = 0; index < 8; index++){
                                    object.elements.dial_2_discrete['dial_noteSelect_'+index].onchange = function(index){return function(value){state.stages[index].note=value}}(index);
                                    object.elements.slide_discrete_image['slide_octave_'+index].onchange = function(index){return function(value){state.stages[index].octave=value-1}}(index);
                                    object.elements.dial_2_continuous['dial_velocity_'+index].onchange = function(index){return function(value){state.stages[index].velocity=value}}(index);
                                    object.elements.button_rectangle['button_activate_'+index].onpress = function(index){return function(){state.requestedNextPosition=index;step();}}(index);
                                }
                            //io
                                object.io.signal.directionChange_step.onchange = function(value){ if(!value){return} object.elements.button_image.button_step.press(); object.elements.button_image.button_step.release(); } 
                                object.io.signal.directionChange_forwards.onchange = function(value){ if(!value){return} object.elements.slide_discrete_image.slide_direction.set(1); } 
                                object.io.signal.directionChange_backwards.onchange = function(value){ if(!value){return} object.elements.slide_discrete_image.slide_direction.set(0); } 
                                for(let index = 0; index < 8; index++){
                                    object.io.signal['noteOctaveChange_back_'+index].onchange = function(index){return function(value){
                                        if(!value){return} 
                    
                                        let newNote = state.stages[index].note - 1;
                                        let newOctave = state.stages[index].octave;
                                        if(newNote < 0){ newNote = 11; newOctave--; }
                                        if(newOctave < -1){ return; }
                    
                                        object.elements.dial_2_discrete['dial_noteSelect_'+index].set(newNote);
                                        object.elements.slide_discrete_image['slide_octave_'+index].set(newOctave+1);
                                    } }(index);
                                    object.io.signal['noteOctaveChange_fore_'+index].onchange = function(index){return function(value){
                                        if(!value){return}
                    
                                        let newNote = state.stages[index].note + 1;
                                        let newOctave = state.stages[index].octave;
                                        if(newNote > 11){ newNote = 0; newOctave++; }
                                        if(newOctave > 1){ return; }
                    
                                        object.elements.dial_2_discrete['dial_noteSelect_'+index].set(newNote);
                                        object.elements.slide_discrete_image['slide_octave_'+index].set(newOctave+1);
                                    } }(index);
                                    object.io.signal['activate_'+index].onchange = function(index){ return function(value){ 
                                        if(!value){return} 
                                        object.elements.button_rectangle['button_activate_'+index].press(); 
                                        object.elements.button_rectangle['button_activate_'+index].release(); 
                                    } }(index);
                                    object.io.voltage['velocity_'+index].onchange = function(index){ return function(value){ 
                                        object.elements.dial_2_continuous['dial_velocity_'+index].set(value);
                                    }}(index);
                                }
                    
                        //interface
                            object.i = {
                                step:function(){ object.elements.button_image.button_step.press(); },
                                direction:function(value){ 
                                    if(value == undefined){ return object.elements.slide_discrete_image.slide_direction.get(); }
                                    object.elements.slide_discrete_image.slide_direction.set(value);
                                },
                                noteDial:function(number,value){ 
                                    if(number == undefined){return null;}
                                    if(value == undefined){ object.elements.dial_2_discrete['dial_noteSelect_'+number].get(); }
                                    object.elements.dial_2_discrete['dial_noteSelect_'+number].set(value);
                                },
                                octaveSlider:function(number,value){ 
                                    if(number == undefined){return null;}
                                    if(value == undefined){ object.elements.slide_discrete_image['slide_octave_'+number].get(); }
                                    object.elements.slide_discrete_image['slide_octave_'+number].set(value);
                                },
                                velocityDial:function(number,value){ 
                                    if(number == undefined){return null;}
                                    if(value == undefined){ object.elements.dial_2_continuous['dial_velocity_'+number].get(); }
                                    object.elements.dial_2_continuous['dial_velocity_'+number].set(value);
                                },
                                activateStep:function(number){ object.elements.button_rectangle['button_activate_'+number].press(); },
                                getStages:function(){return state.stages;},
                            };
                    
                        //import/export
                            object.exportData = function(){
                                return {
                                    stages:Object.assign([],state.stages),
                                    direction: object.elements.slide_discrete_image.slide_direction.get(),
                                    currentStage: state.position,
                                };
                            };
                            object.importData = function(data){
                                object.elements.slide_discrete_image.slide_direction.set(data.direction);
                    
                                data.stages.forEach( (stage,index) => {
                                    object.elements.dial_2_discrete['dial_noteSelect_'+index].set(stage.note);
                                    object.elements.slide_discrete_image['slide_octave_'+index].set(stage.octave+1);
                                    object.elements.dial_2_continuous['dial_velocity_'+index].set(stage.velocity);
                                });
                    
                                state.position = data.currentStage;
                            };
                    
                        return object;
                    };
                    this.eightStepSequencer.metadata = {
                        name:'Eight Step Sequencer',
                        category:'sequencers',
                        helpURL:'/help/units/alpha/eightStepSequencer/'
                    };
                    this.launchpad = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'launchpad/';
                    
                                //calculation of measurements
                                    const div = 6;
                                    const measurement = { 
                                        file: { width:1370, height:1200 },
                                        design: { width:22.5, height:19.5 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                                    this.checkbox = {
                                        check: {r:0.56,g:0.42,b:0.61,a:1},
                                        backing: {r:0.74,g:0.53,b:0.8,a:1},
                                        checkGlow: {r:0.71,g:0.57,b:0.76,a:1},
                                        backingGlow: {r:0.84,g:0.63,b:0.95,a:1},
                                    };
                                    this.glowbox_circle = {
                                        glow: {r:0.97,g:0.89,b:0.99,a:1},
                                        dim: {r:0.1,g:0.1,b:0.1,a:1},
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'launchpad',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                                              y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:0                                               },
                                    { x:unitStyle.drawingValue.width -unitStyle.offset, y:unitStyle.drawingValue.height -unitStyle.offset },
                                    { x:0,                                              y:unitStyle.drawingValue.height -unitStyle.offset },
                                ],
                                elements:(new Array(8).fill(0)).map( (item,y) => {
                                    return {collection:'dynamic', type:'connectionNode_signal', name:'output_'+y, data:{
                                        x:0, y:85/4 + (70/3)*y, width:5, height:10, angle:Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }};
                                }).concat([
                                    {collection:'dynamic', type:'connectionNode_signal', name:'activate_step', data:{ x:unitStyle.drawingValue.width-10/3, y:11.25, width:5, height:10, cableVersion:2, style:style.connectionNode.signal }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'activate_upPage', data:{ x:unitStyle.drawingValue.width-10/3, y:151.25, width:5, height:10, cableVersion:2, style:style.connectionNode.signal }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'activate_downPage', data:{ x:unitStyle.drawingValue.width-10/3, y:175, width:5, height:10, cableVersion:2, style:style.connectionNode.signal }},
                        
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ 
                                            x:-unitStyle.offset/2, y:-unitStyle.offset/2, 
                                            width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, 
                                            url:unitStyle.imageStoreURL_localPrefix+'backing.png'
                                        }
                                    },
                        
                                    {collection:'control', type:'button_image', name:'step', data:{
                                        x:(190+10/3), y:6.66, width:20, height:20, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'step_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'step_down.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'upPage', data:{
                                        x:(190+10/3), y:146.66, width:20, height:20, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'upPage_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'upPage_down.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'downPage', data:{
                                        x:(190+10/3), y:170, width:20, height:20, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'downPage_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'downPage_down.png',
                                    }},
                                ]).concat(
                                    (new Array(8).fill(0)).map( (item,y) => {
                                        return {collection:'display', type:'glowbox_circle', name:'LED_'+y, data:{
                                            x:(200+10/3), y:40 + (10+10/3)*y, radius:2, style:unitStyle.glowbox_circle,
                                        }}
                                    })
                                ).concat(
                                    (new Array(8).fill(0)).flatMap( (item,y) => {
                                        return (new Array(8).fill(0)).map( (item,x) => {
                                            return {collection:'control', type:'checkbox_rectangle', name:y+'_'+x, data:{
                                                x:(20 + 70*x)/3, y:(20 + 70*y)/3, width:20, height:20, style:unitStyle.checkbox,
                                            }};
                                        })
                                    })
                                )
                            });
                    
                        //circuitry
                            const state = {
                                currentColumn:-1,
                                currentPage:0,
                                pages:(new Array(8).fill(undefined)).map(() => {
                                    return (new Array(8).fill(undefined)).map(() => {
                                        return (new Array(8).fill(false))
                                    })
                                }),
                            };
                            function refresh(){
                                for(let y = 0; y < 8; y++){
                                    object.elements.glowbox_circle['LED_'+y].off();
                                    for(let x = 0; x < 8; x++){
                                        object.elements.checkbox_rectangle[y+'_'+x].set( state.pages[state.currentPage][y][x] );
                                    }
                                }
                                object.elements.glowbox_circle['LED_'+state.currentPage].on();
                            }
                            function changeToPage(pageNumber){
                                state.currentPage = pageNumber;
                                refresh();
                            }
                            function changeToColumn(column){
                                if(state.currentColumn != -1){ for(let y = 0; y < 8; y++){ object.elements.checkbox_rectangle[y+'_'+state.currentColumn].light(false); } }
                    
                                state.currentColumn = column;
                    
                                for(let y = 0; y < 8; y++){
                                    object.elements.checkbox_rectangle[y+'_'+state.currentColumn].light(true);
                                    if( !object.elements.connectionNode_signal['output_'+y].read() && !state.pages[state.currentPage][y][state.currentColumn] ){ continue; }
                    
                                    object.elements.connectionNode_signal['output_'+y].set(false);
                                    if( state.pages[state.currentPage][y][state.currentColumn] ){ object.elements.connectionNode_signal['output_'+y].set(true); }
                                }
                            }
                            function nextPage(){
                                state.currentPage++;
                                if(state.currentPage > 7){state.currentPage = 0}
                                changeToPage(state.currentPage);
                            }
                            function backPage(){
                                state.currentPage--;
                                if(state.currentPage < 0){state.currentPage = 7}
                                changeToPage(state.currentPage);
                            }
                            function step(){
                                let tmp = state.currentColumn+1; 
                                if(tmp > 7){tmp = 0;}
                                changeToColumn(tmp);
                            }
                    
                        //wiring
                            //hid
                                object.elements.button_image.step.onpress = step;
                                object.elements.button_image.upPage.onpress = backPage;
                                object.elements.button_image.downPage.onpress = nextPage;
                                for(let y = 0; y < 8; y++){ for(let x = 0; x < 8; x++){
                                    object.elements.checkbox_rectangle[y+'_'+x].onchange = (function(x,y){return function(value){ 
                                        state.pages[state.currentPage][y][x] = value; 
                                    }})(x,y);
                                } }
                            //io
                                object.io.signal.activate_step.onchange = function(value){if(value){step();}};
                                object.io.signal.activate_upPage.onchange = function(value){if(value){backPage();}};
                                object.io.signal.activate_downPage.onchange = function(value){if(value){nextPage();}};
                    
                        //interface
                            object.i = {
                                getPages:function(){return state.pages;},
                                currentPage:function(value){
                                    if(value==undefined){return state.currentPage;}
                                    changeToPage(value);
                                },
                                columnPosition:function(value){
                                    if(value==undefined){return state.currentColumn;}
                                    changeToColumn(value);
                                },
                                step:step,
                                data:function(page,x,y,value){
                                    if(page == undefined || x == undefined || y == undefined){return;}
                                    if(value == undefined){ return state.pages[page][y][x]; }
                                    state.pages[page][y][x] = value;
                                    refresh();
                                }
                            };
                    
                        //import/export
                            object.exportData = function(){ return {
                                currentPage:state.currentPage,
                                currentColumn:state.currentColumn,
                                pages:JSON.stringify(state.pages),
                            }; };
                            object.importData = function(data){
                                state.currentColumn = data.currentColumn;
                                state.currentPage = data.currentPage;
                                state.pages = JSON.parse(data.pages);
                                refresh();
                            };
                    
                        //setup/tearDown
                            object.oncreate = function(){
                                changeToPage(0);
                            };
                    
                        return object;
                    };
                    this.launchpad.metadata = {
                        name:'Launchpad',
                        category:'sequencers',
                        helpURL:'/help/units/alpha/launchpad/'
                    };
                    
                    this._collectionData = {
                        name:'Alpha',
                        itemWidth:210,
                        categoryOrder:[
                            'monitors',
                            'humanInterfaceDevices',
                            'sequencers',
                            'synthesizers',
                            'effects',
                            'tools',
                            'misc',
                        ],   
                    };
                    this._categoryData = {
                        tools:{ printingName:'Tools',itemWidth:150},
                        misc:{ printingName:'Miscellaneous',itemWidth:150},
                        monitors:{ printingName:'Monitors',itemWidth:150},
                        effects:{ printingName:'Audio Effect Units',itemWidth:150},
                        sequencers:{ printingName:'Sequencers',itemWidth:175},
                        synthesizers:{ printingName:'Synthesizers',itemWidth:150},
                        humanInterfaceDevices:{ printingName:'Human Interface Devices',itemWidth:150},
                    };
                };
                this.curvetech = new function(){
                    this.light_panel_8 = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'light_panel/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = { 
                                        file: { width:1070, height:130 },
                                        design: { width:10.7, height:1.3 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'light_panel_8',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_0', data:{ 
                                        x:1.8 + (12.4/2) + 10/2, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_1', data:{ 
                                        x:1.8 + 13 + (12.4/2) + 10/2, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_2', data:{ 
                                        x:1.8 + 13*2 + (12.4/2) + 10/2, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_3', data:{ 
                                        x:1.8 + 13*3 + (12.4/2) + 10/2, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_4', data:{ 
                                        x:1.8 + 13*4 + (12.4/2) + 10/2, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_5', data:{ 
                                        x:1.8 + 13*5 + (12.4/2) + 10/2, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_6', data:{ 
                                        x:1.8 + 13*6 + (12.4/2) + 10/2, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_7', data:{ 
                                        x:1.8 + 13*7 + (12.4/2) + 10/2, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'8_backing.png' }
                                    },
                                    {collection:'display', type:'glowbox_image', name:'lamp_0', 
                                        data:{ 
                                            x:1.8, y:4.8, width:12.4, height:6.4,
                                            dimURL:unitStyle.imageStoreURL_localPrefix+'light_off.png',
                                            glowURL:unitStyle.imageStoreURL_localPrefix+'light_on.png',
                                        },
                                    },
                                    {collection:'display', type:'glowbox_image', name:'lamp_1', 
                                        data:{ 
                                            x:1.8 + 13, y:4.8, width:12.4, height:6.4,
                                            dimURL:unitStyle.imageStoreURL_localPrefix+'light_off.png',
                                            glowURL:unitStyle.imageStoreURL_localPrefix+'light_on.png',
                                        },
                                    },
                                    {collection:'display', type:'glowbox_image', name:'lamp_2', 
                                        data:{ 
                                            x:1.8 + 13*2, y:4.8, width:12.4, height:6.4,
                                            dimURL:unitStyle.imageStoreURL_localPrefix+'light_off.png',
                                            glowURL:unitStyle.imageStoreURL_localPrefix+'light_on.png',
                                        },
                                    },
                                    {collection:'display', type:'glowbox_image', name:'lamp_3', 
                                        data:{ 
                                            x:1.8 + 13*3, y:4.8, width:12.4, height:6.4,
                                            dimURL:unitStyle.imageStoreURL_localPrefix+'light_off.png',
                                            glowURL:unitStyle.imageStoreURL_localPrefix+'light_on.png',
                                        },
                                    },
                                    {collection:'display', type:'glowbox_image', name:'lamp_4', 
                                        data:{ 
                                            x:1.8 + 13*4, y:4.8, width:12.4, height:6.4,
                                            dimURL:unitStyle.imageStoreURL_localPrefix+'light_off.png',
                                            glowURL:unitStyle.imageStoreURL_localPrefix+'light_on.png',
                                        },
                                    },
                                    {collection:'display', type:'glowbox_image', name:'lamp_5', 
                                        data:{ 
                                            x:1.8 + 13*5, y:4.8, width:12.4, height:6.4,
                                            dimURL:unitStyle.imageStoreURL_localPrefix+'light_off.png',
                                            glowURL:unitStyle.imageStoreURL_localPrefix+'light_on.png',
                                        },
                                    },
                                    {collection:'display', type:'glowbox_image', name:'lamp_6', 
                                        data:{ 
                                            x:1.8 + 13*6, y:4.8, width:12.4, height:6.4,
                                            dimURL:unitStyle.imageStoreURL_localPrefix+'light_off.png',
                                            glowURL:unitStyle.imageStoreURL_localPrefix+'light_on.png',
                                        },
                                    },
                                    {collection:'display', type:'glowbox_image', name:'lamp_7', 
                                        data:{ 
                                            x:1.8 + 13*7, y:4.8, width:12.4, height:6.4,
                                            dimURL:unitStyle.imageStoreURL_localPrefix+'light_off.png',
                                            glowURL:unitStyle.imageStoreURL_localPrefix+'light_on.png',
                                        },
                                    }
                                ]
                            });
                        
                        //wiring
                            //io
                                for(let a = 0; a <= 7; a++){
                                    object.io.signal['in_'+a].onchange = (function(a){ return function(value){
                                        const lamp = object.elements.glowbox_image['lamp_'+a];
                                        value ? lamp.on() : lamp.off();
                                    }; })(a);
                                }
                    
                        return object;
                    };
                    this.light_panel_8.metadata = {
                        name:'Light Panel - Type C',
                        category:'interface',
                        helpURL:'/help/units/curvetech/light_panel_8/'
                    };
                    this.button_panel_1 = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'button_panel/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = { 
                                        file: { width:200, height:300 },
                                        design: { width:2, height:3 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'button_panel_1',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out', data:{ 
                                        x:unitStyle.drawingValue.width/2-5, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'1_backing.png' }
                                    },
                                    {collection:'control', type:'button_image', name:'button', data:{
                                        x:5, y:10, width:10, height:15, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'key_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'key_down.png',
                                    }},
                                ]
                            });
                    
                        //wiring
                            //hid
                                object.elements.button_image.button.onpress = function(){ object.io.signal.out.set(true); };
                                object.elements.button_image.button.onrelease = function(){ object.io.signal.out.set(false); };
                            //keycapture
                                const keyCodes = [ 49 ];
                                object.elements.image.backing.attachCallback('onkeydown', function(x,y,event){
                                    if( keyCodes.includes(event.keyCode) ){
                                        object.elements.button_image.button.press();
                                    }
                                });
                                object.elements.image.backing.attachCallback('onkeyup', function(x,y,event){
                                    if( keyCodes.includes(event.keyCode) ){
                                        object.elements.button_image.button.release();
                                    }
                                });
                    
                        //interface
                            object.i = {
                                press:function(){ object.elements.button_image.button.press(); },
                                release:function(){ object.elements.button_image.button.release(); },
                            };
                    
                        return object;
                    };
                    this.button_panel_1.metadata = {
                        name:'Button Panel - Type A',
                        category:'interface',
                        helpURL:'/help/units/curvetech/button_panel_1/'
                    };
                    this.multi_option_signal_sender_8 = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'multi_option_signal_sender/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = { 
                                        file: { width:300, height:300 },
                                        design: { width:3, height:3 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'multi_option_signal_sender_8',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_0', data:{ 
                                        x:unitStyle.drawingValue.width*(1/4)+5+1.25, y:unitStyle.drawingValue.height, width:5, height:10, angle:-Math.PI*1.5, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_1', data:{ 
                                        x:0, y:27.5-1.25, width:5, height:10, angle:-Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_2', data:{ 
                                        x:0, y:12.5+1.25, width:5, height:10, angle:-Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_3', data:{ 
                                        x:unitStyle.drawingValue.width*(1/4)-5+1.25, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_4', data:{ 
                                        x:unitStyle.drawingValue.width*(3/4)-5-1.25, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_5', data:{ 
                                        x:unitStyle.drawingValue.width, y:2.5+1.25, width:5, height:10, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_6', data:{ 
                                        x:unitStyle.drawingValue.width, y:17.5-1.25, width:5, height:10, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_7', data:{ 
                                        x:unitStyle.drawingValue.width*(3/4)+5-1.25, y:unitStyle.drawingValue.height, width:5, height:10, angle:-Math.PI*1.5, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'8_backing.png' }
                                    },
                                    {collection:'control', type:'dial_2_discrete',name:'detune_octave',data:{
                                        x:15, y:15, radius:17.5/2, startAngle:-Math.PI*(1+3/8), maxAngle:Math.PI*(1+3/4), arcDistance:1.2, optionCount:8, style:{handle:style.primeColour.lightGrey},
                                    }},
                                ]
                            });
                    
                        //circuitry
                            const state = {position:0};
                        
                        //wiring
                            //hid
                                object.elements.dial_2_discrete.detune_octave.onchange = function(value){
                                    object.io.signal['out_'+state.position].set(false);
                                    state.position = value;
                                    object.io.signal['out_'+state.position].set(true);
                                };
                    
                        //interface
                                object.i = {
                                    position:function(value){
                                        if(value == undefined){return state.position;}
                                        object.elements.dial_2_discrete.detune_octave.set(value);
                                    }
                                };
                    
                        //import/export
                            object.importData = function(data){
                                object.elements.dial_2_discrete.detune_octave.set(data.position);
                            };
                            object.exportData = function(){
                                return { position: state.position };
                            };
                    
                        //setup
                            object.io.signal['out_'+state.position].set(true);
                    
                        return object;
                    };
                    this.multi_option_signal_sender_8.metadata = {
                        name:'Multi Option Signal Sender - Type C',
                        category:'interface',
                        helpURL:'/help/units/curvetech/multi_option_signal_sender_8/'
                    };
                    this.button_panel_4 = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'button_panel/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = { 
                                        file: { width:530, height:300 },
                                        design: { width:5.3, height:3 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'button_panel_4',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_1', data:{ 
                                        x:5, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_2', data:{ 
                                        x:5+11*1, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_3', data:{ 
                                        x:5+11*2, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_4', data:{ 
                                        x:5+11*3, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'4_backing.png' }
                                    },
                                    {collection:'control', type:'button_image', name:'button_1', data:{
                                        x:5, y:10, width:10, height:15, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'key_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'key_down.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'button_2', data:{
                                        x:5+11*1, y:10, width:10, height:15, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'key_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'key_down.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'button_3', data:{
                                        x:5+11*2, y:10, width:10, height:15, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'key_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'key_down.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'button_4', data:{
                                        x:5+11*3, y:10, width:10, height:15, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'key_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'key_down.png',
                                    }},
                                ]
                            });
                    
                        //wiring
                            //hid
                                object.elements.button_image.button_1.onpress = function(){   object.io.signal.out_1.set(true);  };
                                object.elements.button_image.button_1.onrelease = function(){ object.io.signal.out_1.set(false); };
                                object.elements.button_image.button_2.onpress = function(){   object.io.signal.out_2.set(true);  };
                                object.elements.button_image.button_2.onrelease = function(){ object.io.signal.out_2.set(false); };
                                object.elements.button_image.button_3.onpress = function(){   object.io.signal.out_3.set(true);  };
                                object.elements.button_image.button_3.onrelease = function(){ object.io.signal.out_3.set(false); };
                                object.elements.button_image.button_4.onpress = function(){   object.io.signal.out_4.set(true);  };
                                object.elements.button_image.button_4.onrelease = function(){ object.io.signal.out_4.set(false); };
                            //keycapture
                                const keyCodes = [ 49, 50, 51, 52 ];
                                object.elements.image.backing.attachCallback('onkeydown', function(x,y,event){
                                    if( keyCodes.includes(event.keyCode) ){
                                        object.elements.button_image['button_'+(keyCodes.indexOf(event.keyCode)+1)].press();
                                    }
                                });
                                object.elements.image.backing.attachCallback('onkeyup', function(x,y,event){
                                    if( keyCodes.includes(event.keyCode) ){
                                        object.elements.button_image['button_'+(keyCodes.indexOf(event.keyCode)+1)].release();
                                    }
                                });
                    
                        //interface
                            object.i = {
                                press:function(button){ object.elements.button_image['button_'+button].press(); },
                                release:function(button){ object.elements.button_image['button_'+button].release(); },
                            };
                    
                        return object;
                    };
                    this.button_panel_4.metadata = {
                        name:'Button Panel - Type C',
                        category:'interface',
                        helpURL:'/help/units/curvetech/button_panel_4/'
                    };
                    this.light_panel_2 = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'light_panel/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = { 
                                        file: { width:290, height:130 },
                                        design: { width:2.9, height:1.3 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'light_panel_2',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_0', data:{ 
                                        x:1.8 + (12.4/2) + 10/2, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_1', data:{ 
                                        x:1.8 + 13 + (12.4/2) + 10/2, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'2_backing.png' }
                                    },
                                    {collection:'display', type:'glowbox_image', name:'lamp_0', 
                                        data:{ 
                                            x:1.8, y:4.8, width:12.4, height:6.4,
                                            dimURL:unitStyle.imageStoreURL_localPrefix+'light_off.png',
                                            glowURL:unitStyle.imageStoreURL_localPrefix+'light_on.png',
                                        },
                                    },
                                    {collection:'display', type:'glowbox_image', name:'lamp_1', 
                                        data:{ 
                                            x:1.8 + 13, y:4.8, width:12.4, height:6.4,
                                            dimURL:unitStyle.imageStoreURL_localPrefix+'light_off.png',
                                            glowURL:unitStyle.imageStoreURL_localPrefix+'light_on.png',
                                        },
                                    }
                                ]
                            });
                        
                        //wiring
                            //io
                                for(let a = 0; a <= 1; a++){
                                    object.io.signal['in_'+a].onchange = (function(a){ return function(value){
                                        const lamp = object.elements.glowbox_image['lamp_'+a];
                                        value ? lamp.on() : lamp.off();
                                    }; })(a);
                                }
                    
                        return object;
                    };
                    this.light_panel_2.metadata = {
                        name:'Light Panel - Type A',
                        category:'interface',
                        helpURL:'/help/units/curvetech/light_panel_2/'
                    };
                    this.multi_option_signal_sender_2 = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'multi_option_signal_sender/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = { 
                                        file: { width:300, height:300 },
                                        design: { width:3, height:3 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'multi_option_signal_sender_2',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_0', data:{ 
                                        x:unitStyle.drawingValue.width*(1/4)-5+1.25, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_1', data:{ 
                                        x:unitStyle.drawingValue.width*(3/4)-5-1.25, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'2_backing.png' }
                                    },
                                    {collection:'control', type:'dial_2_discrete',name:'detune_octave',data:{
                                        x:15, y:15, radius:17.5/2, startAngle:-Math.PI*(3/4), maxAngle:0.5*Math.PI, arcDistance:1.2, optionCount:2, style:{handle:style.primeColour.lightGrey},
                                    }},
                                ]
                            });
                    
                        //circuitry
                            const state = {position:0};
                        
                        //wiring
                            //hid
                                object.elements.dial_2_discrete.detune_octave.onchange = function(value){
                                    object.io.signal['out_'+state.position].set(false);
                                    state.position = value;
                                    object.io.signal['out_'+state.position].set(true);
                                };
                    
                        //interface
                                object.i = {
                                    position:function(value){
                                        if(value == undefined){return state.position;}
                                        object.elements.dial_2_discrete.detune_octave.set(value);
                                    }
                                };
                    
                        //import/export
                            object.importData = function(data){
                                object.elements.dial_2_discrete.detune_octave.set(data.position);
                            };
                            object.exportData = function(){
                                return { position: state.position };
                            };
                    
                        //setup
                            object.io.signal['out_'+state.position].set(true);
                    
                        return object;
                    };
                    this.multi_option_signal_sender_2.metadata = {
                        name:'Multi Option Signal Sender - Type A',
                        category:'interface',
                        helpURL:'/help/units/curvetech/multi_option_signal_sender_2/'
                    };
                    this.light_panel_4 = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'light_panel/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = { 
                                        file: { width:550, height:130 },
                                        design: { width:5.5, height:1.3 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'light_panel_4',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_0', data:{ 
                                        x:1.8 + (12.4/2) + 10/2, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_1', data:{ 
                                        x:1.8 + 13 + (12.4/2) + 10/2, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_2', data:{ 
                                        x:1.8 + 13*2 + (12.4/2) + 10/2, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_3', data:{ 
                                        x:1.8 + 13*3 + (12.4/2) + 10/2, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'4_backing.png' }
                                    },
                                    {collection:'display', type:'glowbox_image', name:'lamp_0', 
                                        data:{ 
                                            x:1.8, y:4.8, width:12.4, height:6.4,
                                            dimURL:unitStyle.imageStoreURL_localPrefix+'light_off.png',
                                            glowURL:unitStyle.imageStoreURL_localPrefix+'light_on.png',
                                        },
                                    },
                                    {collection:'display', type:'glowbox_image', name:'lamp_1', 
                                        data:{ 
                                            x:1.8 + 13, y:4.8, width:12.4, height:6.4,
                                            dimURL:unitStyle.imageStoreURL_localPrefix+'light_off.png',
                                            glowURL:unitStyle.imageStoreURL_localPrefix+'light_on.png',
                                        },
                                    },
                                    {collection:'display', type:'glowbox_image', name:'lamp_2', 
                                        data:{ 
                                            x:1.8 + 13*2, y:4.8, width:12.4, height:6.4,
                                            dimURL:unitStyle.imageStoreURL_localPrefix+'light_off.png',
                                            glowURL:unitStyle.imageStoreURL_localPrefix+'light_on.png',
                                        },
                                    },
                                    {collection:'display', type:'glowbox_image', name:'lamp_3', 
                                        data:{ 
                                            x:1.8 + 13*3, y:4.8, width:12.4, height:6.4,
                                            dimURL:unitStyle.imageStoreURL_localPrefix+'light_off.png',
                                            glowURL:unitStyle.imageStoreURL_localPrefix+'light_on.png',
                                        },
                                    }
                                ]
                            });
                        
                        //wiring
                            //io
                                for(let a = 0; a <= 3; a++){
                                    object.io.signal['in_'+a].onchange = (function(a){ return function(value){
                                        const lamp = object.elements.glowbox_image['lamp_'+a];
                                        value ? lamp.on() : lamp.off();
                                    }; })(a);
                                }
                    
                        return object;
                    };
                    this.light_panel_4.metadata = {
                        name:'Light Panel - Type B',
                        category:'interface',
                        helpURL:'/help/units/curvetech/light_panel_4/'
                    };
                    this.button_panel_8 = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'button_panel/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = { 
                                        file: { width:970, height:300 },
                                        design: { width:9.7, height:3 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'button_panel_8',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_1', data:{ 
                                        x:5, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_2', data:{ 
                                        x:5+11*1, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_3', data:{ 
                                        x:5+11*2, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_4', data:{ 
                                        x:5+11*3, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_5', data:{ 
                                        x:5+11*4, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_6', data:{ 
                                        x:5+11*5, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_7', data:{ 
                                        x:5+11*6, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_8', data:{ 
                                        x:5+11*7, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'8_backing.png' }
                                    },
                                    {collection:'control', type:'button_image', name:'button_1', data:{
                                        x:5, y:10, width:10, height:15, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'key_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'key_down.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'button_2', data:{
                                        x:5+11*1, y:10, width:10, height:15, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'key_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'key_down.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'button_3', data:{
                                        x:5+11*2, y:10, width:10, height:15, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'key_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'key_down.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'button_4', data:{
                                        x:5+11*3, y:10, width:10, height:15, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'key_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'key_down.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'button_5', data:{
                                        x:5+11*4, y:10, width:10, height:15, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'key_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'key_down.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'button_6', data:{
                                        x:5+11*5, y:10, width:10, height:15, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'key_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'key_down.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'button_7', data:{
                                        x:5+11*6, y:10, width:10, height:15, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'key_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'key_down.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'button_8', data:{
                                        x:5+11*7, y:10, width:10, height:15, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'key_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'key_down.png',
                                    }},
                                ]
                            });
                    
                        //wiring
                            //hid
                                object.elements.button_image.button_1.onpress = function(){   object.io.signal.out_1.set(true);  };
                                object.elements.button_image.button_1.onrelease = function(){ object.io.signal.out_1.set(false); };
                                object.elements.button_image.button_2.onpress = function(){   object.io.signal.out_2.set(true);  };
                                object.elements.button_image.button_2.onrelease = function(){ object.io.signal.out_2.set(false); };
                                object.elements.button_image.button_3.onpress = function(){   object.io.signal.out_3.set(true);  };
                                object.elements.button_image.button_3.onrelease = function(){ object.io.signal.out_3.set(false); };
                                object.elements.button_image.button_4.onpress = function(){   object.io.signal.out_4.set(true);  };
                                object.elements.button_image.button_4.onrelease = function(){ object.io.signal.out_4.set(false); };
                                object.elements.button_image.button_5.onpress = function(){   object.io.signal.out_5.set(true);  };
                                object.elements.button_image.button_5.onrelease = function(){ object.io.signal.out_5.set(false); };
                                object.elements.button_image.button_6.onpress = function(){   object.io.signal.out_6.set(true);  };
                                object.elements.button_image.button_6.onrelease = function(){ object.io.signal.out_6.set(false); };
                                object.elements.button_image.button_7.onpress = function(){   object.io.signal.out_7.set(true);  };
                                object.elements.button_image.button_7.onrelease = function(){ object.io.signal.out_7.set(false); };
                                object.elements.button_image.button_8.onpress = function(){   object.io.signal.out_8.set(true);  };
                                object.elements.button_image.button_8.onrelease = function(){ object.io.signal.out_8.set(false); };
                            //keycapture
                                const keyCodes = [ 49, 50, 51, 52, 53, 54, 55, 56 ];
                                object.elements.image.backing.attachCallback('onkeydown', function(x,y,event){
                                    if( keyCodes.includes(event.keyCode) ){
                                        object.elements.button_image['button_'+(keyCodes.indexOf(event.keyCode)+1)].press();
                                    }
                                });
                                object.elements.image.backing.attachCallback('onkeyup', function(x,y,event){
                                    if( keyCodes.includes(event.keyCode) ){
                                        object.elements.button_image['button_'+(keyCodes.indexOf(event.keyCode)+1)].release();
                                    }
                                });
                    
                        //interface
                            object.i = {
                                press:function(button){ object.elements.button_image['button_'+button].press(); },
                                release:function(button){ object.elements.button_image['button_'+button].release(); },
                            };
                    
                        return object;
                    };
                    this.button_panel_8.metadata = {
                        name:'Button Panel - Type D',
                        category:'interface',
                        helpURL:'/help/units/curvetech/button_panel_8/'
                    };
                    this.multi_option_signal_sender_4 = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'multi_option_signal_sender/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = { 
                                        file: { width:300, height:300 },
                                        design: { width:3, height:3 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'multi_option_signal_sender_4',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_0', data:{ 
                                        x:0, y:12.5+1.25, width:5, height:10, angle:-Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_1', data:{ 
                                        x:unitStyle.drawingValue.width*(1/4)-5+1.25, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_2', data:{ 
                                        x:unitStyle.drawingValue.width*(3/4)-5-1.25, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_3', data:{ 
                                        x:unitStyle.drawingValue.width, y:2.5+1.25, width:5, height:10, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'4_backing.png' }
                                    },
                                    {collection:'control', type:'dial_2_discrete',name:'detune_octave',data:{
                                        x:15, y:15, radius:17.5/2, startAngle:-Math.PI*(7/8), maxAngle:(3/4)*Math.PI, arcDistance:1.2, optionCount:4, style:{handle:style.primeColour.lightGrey},
                                    }},
                                ]
                            });
                    
                        //circuitry
                            const state = {position:0};
                        
                        //wiring
                            //hid
                                object.elements.dial_2_discrete.detune_octave.onchange = function(value){
                                    object.io.signal['out_'+state.position].set(false);
                                    state.position = value;
                                    object.io.signal['out_'+state.position].set(true);
                                };
                    
                        //interface
                                object.i = {
                                    position:function(value){
                                        if(value == undefined){return state.position;}
                                        object.elements.dial_2_discrete.detune_octave.set(value);
                                    }
                                };
                    
                        //import/export
                            object.importData = function(data){
                                object.elements.dial_2_discrete.detune_octave.set(data.position);
                            };
                            object.exportData = function(){
                                return { position: state.position };
                            };
                    
                        //setup
                            object.io.signal['out_'+state.position].set(true);
                    
                        return object;
                    };
                    this.multi_option_signal_sender_4.metadata = {
                        name:'Multi Option Signal Sender - Type B',
                        category:'interface',
                        helpURL:'/help/units/curvetech/multi_option_signal_sender_4/'
                    };
                    this.button_panel_2 = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'button_panel/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = { 
                                        file: { width:310, height:300 },
                                        design: { width:3.1, height:3 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'button_panel_2',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_1', data:{ 
                                        x:5, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_2', data:{ 
                                        x:5 + 11, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'2_backing.png' }
                                    },
                                    {collection:'control', type:'button_image', name:'button_1', data:{
                                        x:5, y:10, width:10, height:15, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'key_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'key_down.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'button_2', data:{
                                        x:5 + 11, y:10, width:10, height:15, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'key_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'key_down.png',
                                    }},
                                ]
                            });
                    
                        //wiring
                            //hid
                                object.elements.button_image.button_1.onpress = function(){   object.io.signal.out_1.set(true);  };
                                object.elements.button_image.button_1.onrelease = function(){ object.io.signal.out_1.set(false); };
                                object.elements.button_image.button_2.onpress = function(){   object.io.signal.out_2.set(true);  };
                                object.elements.button_image.button_2.onrelease = function(){ object.io.signal.out_2.set(false); };
                            //keycapture
                                const keyCodes = [ 49, 50 ];
                                object.elements.image.backing.attachCallback('onkeydown', function(x,y,event){
                                    if( keyCodes.includes(event.keyCode) ){
                                        object.elements.button_image['button_'+(keyCodes.indexOf(event.keyCode)+1)].press();
                                    }
                                });
                                object.elements.image.backing.attachCallback('onkeyup', function(x,y,event){
                                    if( keyCodes.includes(event.keyCode) ){
                                        object.elements.button_image['button_'+(keyCodes.indexOf(event.keyCode)+1)].release();
                                    }
                                });
                    
                        //interface
                            object.i = {
                                press:function(button){ object.elements.button_image['button_'+button].press(); },
                                release:function(button){ object.elements.button_image['button_'+button].release(); },
                            };
                    
                        return object;
                    };
                    this.button_panel_2.metadata = {
                        name:'Button Panel - Type B',
                        category:'interface',
                        helpURL:'/help/units/curvetech/button_panel_2/'
                    };
                    const imageStoreURL = '/images/units/2 - curvetech/';
                    const style = {
                        primeColour:{
                            lightGrey:{r:0.77,g:0.77,b:0.77,a:1},
                        },
                    
                        connectionNode:{
                            signal:{
                                dim:{r:235/255,g:98/255,b:61/255,a:1},
                                glow:{r:237/255,g:154/255,b:132/255,a:1},
                                cable_dim:{r:235/255,g:98/255,b:61/255,a:1},
                                cable_glow:{r:237/255,g:154/255,b:132/255,a:1},
                            },
                            voltage:{
                                dim:{r:170/255,g:251/255,b:89/255,a:1},
                                glow:{r:210/255,g:255/255,b:165/255,a:1},
                                cable_dim:{r:170/255,g:251/255,b:89/255,a:1},
                                cable_glow:{r:210/255,g:255/255,b:165/255,a:1},
                            },
                            data:{
                                dim:{r:114/255,g:176/255,b:248/255,a:1},
                                glow:{r:168/255,g:208/255,b:255/255,a:1},
                                cable_dim:{r:114/255,g:176/255,b:248/255,a:1},
                                cable_glow:{r:168/255,g:208/255,b:255/255,a:1},
                            },
                            audio:{
                                dim:{r:243/255,g:173/255,b:61/255,a:1},
                                glow:{r:247/255,g:203/255,b:133/255,a:1},
                                cable_dim:{r:243/255,g:173/255,b:61/255,a:1},
                                cable_glow:{r:247/255,g:203/255,b:133/255,a:1},
                            },
                        },
                    };
                    this.OR = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'logic_gates/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = {
                                        file: { width:100, height:100 },
                                        design: { width:1, height:1 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'OR',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out', data:{ 
                                        x:unitStyle.drawingValue.width/2-2.5, y:0, width:2.5, height:5, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_1', data:{ 
                                        x:unitStyle.drawingValue.width*(1/4)+2.5, y:unitStyle.drawingValue.height-2.5, width:5, height:5, angle:Math.PI/2+0.1, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_2', data:{ 
                                        x:unitStyle.drawingValue.width*(3/4)+2.5, y:unitStyle.drawingValue.height-2.5-0.5, width:5, height:5, angle:Math.PI/2-0.1, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'OR.png' }
                                    },
                                ]
                            });
                    
                        //circuitry
                            const currentInputValues = [false,false];
                            let delay = 1;
                            function updateOutput(A,B){
                                if(delay > 0){ 
                                    setTimeout(function(){
                                        object.io.signal.out.set(A || B);
                                    },delay);
                                }else{
                                    object.io.signal.out.set(A || B);
                                }
                            }
                    
                        //wiring
                            //io
                                object.io.signal.in_1.onchange = function(value){
                                    if(value == currentInputValues[0]){return;}
                                    currentInputValues[0] = value;
                                    updateOutput(currentInputValues[0],currentInputValues[1]);
                                };
                                object.io.signal.in_2.onchange = function(value){
                                    if(value == currentInputValues[1]){return;}
                                    currentInputValues[1] = value;
                                    updateOutput(currentInputValues[0],currentInputValues[1]);
                                };
                    
                        //setup
                            updateOutput(currentInputValues[0],currentInputValues[1]);
                    
                        return object;
                    };
                    this.OR.metadata = {
                        name:'OR',
                        category:'logic_gates',
                        helpURL:'/help/units/curvetech/OR/'
                    };
                    this.NOR = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'logic_gates/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = {
                                        file: { width:100, height:100 },
                                        design: { width:1, height:1 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'NOR',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out', data:{ 
                                        x:unitStyle.drawingValue.width/2-2.5, y:0, width:2.5, height:5, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_1', data:{ 
                                        x:unitStyle.drawingValue.width*(1/4)+2.5, y:unitStyle.drawingValue.height-2.5, width:5, height:5, angle:Math.PI/2+0.1, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_2', data:{ 
                                        x:unitStyle.drawingValue.width*(3/4)+2.5, y:unitStyle.drawingValue.height-2.5-0.5, width:5, height:5, angle:Math.PI/2-0.1, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'NOR.png' }
                                    },
                                ]
                            });
                    
                        //circuitry
                            const currentInputValues = [false,false];
                            let delay = 1;
                            function updateOutput(A,B){
                                if(delay > 0){ 
                                    setTimeout(function(){
                                        object.io.signal.out.set(!(A || B));
                                    },delay);
                                }else{
                                    object.io.signal.out.set(!(A || B));
                                }
                            }
                    
                        //wiring
                            //io
                                object.io.signal.in_1.onchange = function(value){
                                    if(value == currentInputValues[0]){return;}
                                    currentInputValues[0] = value;
                                    updateOutput(currentInputValues[0],currentInputValues[1]);
                                };
                                object.io.signal.in_2.onchange = function(value){
                                    if(value == currentInputValues[1]){return;}
                                    currentInputValues[1] = value;
                                    updateOutput(currentInputValues[0],currentInputValues[1]);
                                };
                    
                        //setup
                            updateOutput(currentInputValues[0],currentInputValues[1]);
                    
                        return object;
                    };
                    this.NOR.metadata = {
                        name:'NOR',
                        category:'logic_gates',
                        helpURL:'/help/units/curvetech/NOR/'
                    };
                    this.DUP = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'logic_gates/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = {
                                        file: { width:100, height:100 },
                                        design: { width:1, height:1 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'DUP',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_1', data:{ 
                                        x:unitStyle.drawingValue.width*(1/4)-2.5, y:2.5+0.5, width:5, height:5, angle:-Math.PI/2-0.1, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_2', data:{ 
                                        x:unitStyle.drawingValue.width*(1/4)+2.5, y:2.5, width:5, height:5, angle:-Math.PI/2+0.1, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in', data:{ 
                                        x:unitStyle.drawingValue.width/2+2.5, y:unitStyle.drawingValue.height, width:2.5, height:5, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'DUP.png' }
                                    },
                                ]
                            });
                        
                        //circuitry
                            let currentInputValue = false;
                            let delay = 1;
                            function updateOutput(A){
                                if(delay > 0){ 
                                    setTimeout(function(){
                                        object.io.signal.out_1.set(A);
                                        object.io.signal.out_2.set(A);
                                    },delay);
                                }else{
                                    object.io.signal.out_1.set(A);
                                    object.io.signal.out_2.set(A);
                                }
                            }
                    
                        //wiring
                            //io
                                object.io.signal.in.onchange = function(value){
                                    if(value == currentInputValue){return;}
                                    currentInputValue = value;
                                    updateOutput(currentInputValue);
                                };
                    
                        //setup
                            updateOutput(currentInputValue);
                    
                        return object;
                    };
                    this.DUP.metadata = {
                        name:'DUP',
                        category:'logic_gates',
                        helpURL:'/help/units/curvetech/DUP/'
                    };
                    this.AND = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'logic_gates/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = {
                                        file: { width:100, height:100 },
                                        design: { width:1, height:1 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'AND',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out', data:{ 
                                        x:unitStyle.drawingValue.width/2-2.5, y:0, width:2.5, height:5, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_1', data:{ 
                                        x:unitStyle.drawingValue.width*(1/4)+2.5, y:unitStyle.drawingValue.height-2.5, width:5, height:5, angle:Math.PI/2+0.1, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_2', data:{ 
                                        x:unitStyle.drawingValue.width*(3/4)+2.5, y:unitStyle.drawingValue.height-2.5-0.5, width:5, height:5, angle:Math.PI/2-0.1, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'AND.png' }
                                    },
                                ]
                            });
                    
                        //circuitry
                            const currentInputValues = [false,false];
                            let delay = 1;
                            function updateOutput(A,B){
                                if(delay > 0){ 
                                    setTimeout(function(){
                                        object.io.signal.out.set(A && B);
                                    },delay);
                                }else{
                                    object.io.signal.out.set(A && B);
                                }
                            }
                    
                        //wiring
                            //io
                                object.io.signal.in_1.onchange = function(value){
                                    if(value == currentInputValues[0]){return;}
                                    currentInputValues[0] = value;
                                    updateOutput(currentInputValues[0],currentInputValues[1]);
                                };
                                object.io.signal.in_2.onchange = function(value){
                                    if(value == currentInputValues[1]){return;}
                                    currentInputValues[1] = value;
                                    updateOutput(currentInputValues[0],currentInputValues[1]);
                                };
                    
                        //setup
                            updateOutput(currentInputValues[0],currentInputValues[1]); 
                    
                        return object;
                    };
                    this.AND.metadata = {
                        name:'AND',
                        category:'logic_gates',
                        helpURL:'/help/units/curvetech/AND/'
                    };
                    this.REP = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'logic_gates/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = {
                                        file: { width:100, height:100 },
                                        design: { width:1, height:1 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'REP',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out', data:{ 
                                        x:unitStyle.drawingValue.width/2-2.5, y:0, width:2.5, height:5, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in', data:{ 
                                        x:unitStyle.drawingValue.width/2+2.5, y:unitStyle.drawingValue.height, width:2.5, height:5, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'REP.png' }
                                    },
                                ]
                            });
                        
                        //circuitry
                            let currentInputValue = false;
                            let delay = 1;
                            function updateOutput(A){
                                if(delay > 0){ 
                                    setTimeout(function(){
                                        object.io.signal.out.set(A);
                                    },delay);
                                }else{
                                    object.io.signal.out.set(A);
                                }
                            }
                    
                        //wiring
                            //io
                                object.io.signal.in.onchange = function(value){
                                    if(value == currentInputValue){return;}
                                    currentInputValue = value;
                                    updateOutput(currentInputValue);
                                };
                    
                        //setup
                            updateOutput(currentInputValue);
                    
                        return object;
                    };
                    this.REP.metadata = {
                        name:'REP',
                        category:'logic_gates',
                        helpURL:'/help/units/curvetech/REP/'
                    };
                    this.NAND = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'logic_gates/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = {
                                        file: { width:100, height:100 },
                                        design: { width:1, height:1 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'NAND',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out', data:{ 
                                        x:unitStyle.drawingValue.width/2-2.5, y:0, width:2.5, height:5, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_1', data:{ 
                                        x:unitStyle.drawingValue.width*(1/4)+2.5, y:unitStyle.drawingValue.height-2.5, width:5, height:5, angle:Math.PI/2+0.1, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_2', data:{ 
                                        x:unitStyle.drawingValue.width*(3/4)+2.5, y:unitStyle.drawingValue.height-2.5-0.5, width:5, height:5, angle:Math.PI/2-0.1, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'NAND.png' }
                                    },
                                ]
                            });
                    
                        //circuitry
                            const currentInputValues = [false,false];
                            let delay = 1;
                            function updateOutput(A,B){
                                if(delay > 0){ 
                                    setTimeout(function(){
                                        object.io.signal.out.set(!(A && B));
                                    },delay);
                                }else{
                                    object.io.signal.out.set(!(A && B));
                                }
                            }
                    
                        //wiring
                            //io
                                object.io.signal.in_1.onchange = function(value){
                                    if(value == currentInputValues[0]){return;}
                                    currentInputValues[0] = value;
                                    updateOutput(currentInputValues[0],currentInputValues[1]);
                                };
                                object.io.signal.in_2.onchange = function(value){
                                    if(value == currentInputValues[1]){return;}
                                    currentInputValues[1] = value;
                                    updateOutput(currentInputValues[0],currentInputValues[1]);
                                };
                    
                        //setup
                            updateOutput(currentInputValues[0],currentInputValues[1]);
                    
                        return object;
                    };
                    this.NAND.metadata = {
                        name:'NAND',
                        category:'logic_gates',
                        helpURL:'/help/units/curvetech/NAND/'
                    };
                    this.XNOR = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'logic_gates/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = {
                                        file: { width:100, height:100 },
                                        design: { width:1, height:1 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'XNOR',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out', data:{ 
                                        x:unitStyle.drawingValue.width/2-2.5, y:0, width:2.5, height:5, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_1', data:{ 
                                        x:unitStyle.drawingValue.width*(1/4)+2.5, y:unitStyle.drawingValue.height-2.5, width:5, height:5, angle:Math.PI/2+0.1, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_2', data:{ 
                                        x:unitStyle.drawingValue.width*(3/4)+2.5, y:unitStyle.drawingValue.height-2.5-0.5, width:5, height:5, angle:Math.PI/2-0.1, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'XNOR.png' }
                                    },
                                ]
                            });
                    
                        //circuitry
                            const currentInputValues = [false,false];
                            let delay = 1;
                            function updateOutput(A,B){
                                if(delay > 0){ 
                                    setTimeout(function(){
                                        object.io.signal.out.set(A || B);
                                    },delay);
                                }else{
                                    object.io.signal.out.set(A || B);
                                }
                            }
                    
                        //wiring
                            //io
                                object.io.signal.in_1.onchange = function(value){
                                    if(value == currentInputValues[0]){return;}
                                    currentInputValues[0] = value;
                                    updateOutput(currentInputValues[0],currentInputValues[1]);
                                };
                                object.io.signal.in_2.onchange = function(value){
                                    if(value == currentInputValues[1]){return;}
                                    currentInputValues[1] = value;
                                    updateOutput(currentInputValues[0],currentInputValues[1]);
                                };
                    
                        //setup
                            updateOutput(currentInputValues[0],currentInputValues[1]);
                    
                        return object;
                    };
                    this.XNOR.metadata = {
                        name:'XNOR',
                        category:'logic_gates',
                        helpURL:'/help/units/curvetech/XNOR/'
                    };
                    this.NOT = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'logic_gates/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = {
                                        file: { width:100, height:100 },
                                        design: { width:1, height:1 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'NOT',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out', data:{ 
                                        x:unitStyle.drawingValue.width/2-2.5, y:0, width:2.5, height:5, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in', data:{ 
                                        x:unitStyle.drawingValue.width/2+2.5, y:unitStyle.drawingValue.height, width:2.5, height:5, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'NOT.png' }
                                    },
                                ]
                            });
                        
                        //circuitry
                            let currentInputValue = false;
                            // const loopProtection = {
                            //     maxChangesPerSecond:100,
                            //     changeCount:0,
                            //     interval:setInterval(function(){ 
                            //         loopProtection.changeCount = 0;
                            //         object.io.signal.out.set(!object.io.signal.in.read());
                            //     },1000),
                            // };
                            let delay = 1;
                            function updateOutput(A){
                                if(delay > 0){ 
                                    setTimeout(function(){
                                        object.io.signal.out.set(!A);
                                    },delay);
                                }else{
                                    object.io.signal.out.set(!A);
                                }
                            }
                    
                        //wiring
                            //io
                                object.io.signal.in.onchange = function(value){
                                    if(value == currentInputValue){return;}
                                    currentInputValue = value;
                                    updateOutput(currentInputValue);
                    
                                    // if(loopProtection.changeCount > loopProtection.maxChangesPerSecond ){return;}
                                    // loopProtection.changeCount++;
                                    // updateOutput();
                                };
                    
                        //setup
                            updateOutput(currentInputValue);
                    
                        return object;
                    };
                    this.NOT.metadata = {
                        name:'NOT',
                        category:'logic_gates',
                        helpURL:'/help/units/curvetech/NOT/'
                    };
                    this.XOR = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'logic_gates/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = {
                                        file: { width:100, height:100 },
                                        design: { width:1, height:1 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'XOR',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out', data:{ 
                                        x:unitStyle.drawingValue.width/2-2.5, y:0, width:2.5, height:5, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_1', data:{ 
                                        x:unitStyle.drawingValue.width*(1/4)+2.5, y:unitStyle.drawingValue.height-2.5, width:5, height:5, angle:Math.PI/2+0.1, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_2', data:{ 
                                        x:unitStyle.drawingValue.width*(3/4)+2.5, y:unitStyle.drawingValue.height-2.5-0.5, width:5, height:5, angle:Math.PI/2-0.1, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'XOR.png' }
                                    },
                                ]
                            });
                    
                        //circuitry
                            const currentInputValues = [false,false];
                            let delay = 1;
                            function updateOutput(A,B){
                                if(delay > 0){ 
                                    setTimeout(function(){
                                        object.io.signal.out.set(A != B);
                                    },delay);
                                }else{
                                    object.io.signal.out.set(A != B);
                                }
                            }
                    
                        //wiring
                            //io
                                object.io.signal.in_1.onchange = function(value){
                                    if(value == currentInputValues[0]){return;}
                                    currentInputValues[0] = value;
                                    updateOutput(currentInputValues[0],currentInputValues[1]);
                                };
                                object.io.signal.in_2.onchange = function(value){
                                    if(value == currentInputValues[1]){return;}
                                    currentInputValues[1] = value;
                                    updateOutput(currentInputValues[0],currentInputValues[1]);
                                };
                    
                        //setup
                            updateOutput(currentInputValues[0],currentInputValues[1]);
                    
                        return object;
                    };
                    this.XOR.metadata = {
                        name:'XOR',
                        category:'logic_gates',
                        helpURL:'/help/units/curvetech/XOR/'
                    };
                    this.demultiplexer_4 = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'demultiplexer/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = {
                                        file: { width:200, height:400 },
                                        design: { width:2, height:4 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                                    this.LEDs = {
                                        glow:{r:232/255, g:160/255, b:111/255, a:1}, 
                                        dim:{r:164/255, g:80/255, b:61/255, a:1},
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'demultiplexer_4',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'switch', data:{ 
                                        x:unitStyle.drawingValue.width*0.5-2.5, y:0, width:2.5, height:5, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out', data:{ 
                                        x:unitStyle.drawingValue.width, y:unitStyle.drawingValue.height*1/2 - 2.5, width:2.5, height:5, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_0', data:{ 
                                        x:0, y:unitStyle.drawingValue.height*1/5 + 2.5, width:2.5, height:5, angle:-Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_1', data:{ 
                                        x:0, y:unitStyle.drawingValue.height*2/5 + 2.5, width:2.5, height:5, angle:-Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_2', data:{ 
                                        x:0, y:unitStyle.drawingValue.height*3/5 + 2.5, width:2.5, height:5, angle:-Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_3', data:{ 
                                        x:0, y:unitStyle.drawingValue.height*4/5 + 2.5, width:2.5, height:5, angle:-Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'4_backing.png' }
                                    },
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_0',data:{ x:10 - 0.5/2, y:unitStyle.drawingValue.height*1/5 - 2.5, width:0.5, height:5, style:unitStyle.LEDs }},
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_1',data:{ x:10 - 0.5/2, y:unitStyle.drawingValue.height*2/5 - 2.5, width:0.5, height:5, style:unitStyle.LEDs }},
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_2',data:{ x:10 - 0.5/2, y:unitStyle.drawingValue.height*3/5 - 2.5, width:0.5, height:5, style:unitStyle.LEDs }},
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_3',data:{ x:10 - 0.5/2, y:unitStyle.drawingValue.height*4/5 - 2.5, width:0.5, height:5, style:unitStyle.LEDs }},
                                ]
                            });
                    
                        //circuitry
                            const state = {
                                channelCount:4,
                                previousPosition:-1,
                                position:0,
                            };
                            function gotoPosition(value){
                                state.previousPosition = state.position;
                                state.position = value;
                            }
                            function step(){
                                if( state.channelCount <= state.position+1 ){ gotoPosition(0); }else{ gotoPosition(state.position+1); }
                            }
                            function update(){
                                if(state.previousPosition != -1){
                                    object.io.signal.out.set( object.io.signal['in_'+state.position].read() );
                                    object.elements.glowbox_rectangle['LED_'+state.previousPosition].off();
                                }
                                object.elements.glowbox_rectangle['LED_'+state.position].on();
                                object.io.signal.out.set( object.io.signal['in_'+state.position].read() );
                            }
                    
                        //wiring
                            //io
                                for(let a = 0; a < state.channelCount; a++){
                                    object.io.signal['in_'+a].onchange = (function(a){
                                        return function(value){
                                            if(state.position == a){ object.io.signal.out.set(value); }
                                        };
                                    })(a);
                                }
                                object.io.signal.switch.onchange = function(value){
                                    if(!value){return;}
                                    step();
                                    update();
                                };
                    
                        //interface
                            object.i = {
                                step:function(){step();update();},
                                position:function(value){
                                    if(value==undefined){return state.position;}
                                    gotoPosition(value);
                                    update();
                                },
                            };
                    
                        //import/export
                            object.importData = function(data){
                                gotoPosition(data.position);
                                update();
                            };
                            object.exportData = function(){
                                return { position: state.position };
                            };
                    
                        //setup
                            update();
                    
                        return object;
                    };
                    this.demultiplexer_4.metadata = {
                        name:'Demultiplexer - Type B',
                        category:'devices',
                        helpURL:'/help/units/curvetech/demultiplexer_4/'
                    };
                    this.multiplexer_4 = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'multiplexer/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = {
                                        file: { width:200, height:400 },
                                        design: { width:2, height:4 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                                    this.LEDs = {
                                        glow:{r:232/255, g:160/255, b:111/255, a:1}, 
                                        dim:{r:164/255, g:80/255, b:61/255, a:1},
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'multiplexer_4',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'switch', data:{ 
                                        x:unitStyle.drawingValue.width*0.5-2.5, y:0, width:2.5, height:5, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in', data:{ 
                                        x:0, y:unitStyle.drawingValue.height*2/3 - 2.5, width:2.5, height:5, angle:-Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_0', data:{ 
                                        x:unitStyle.drawingValue.width, y:unitStyle.drawingValue.height*1/5 - 2.5, width:2.5, height:5, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_1', data:{ 
                                        x:unitStyle.drawingValue.width, y:unitStyle.drawingValue.height*2/5 - 2.5, width:2.5, height:5, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_2', data:{ 
                                        x:unitStyle.drawingValue.width, y:unitStyle.drawingValue.height*3/5 - 2.5, width:2.5, height:5, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_3', data:{ 
                                        x:unitStyle.drawingValue.width, y:unitStyle.drawingValue.height*4/5 - 2.5, width:2.5, height:5, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'4_backing.png' }
                                    },
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_0',data:{ x:10 - 0.5/2, y:unitStyle.drawingValue.height*1/5 - 2.5, width:0.5, height:5, style:unitStyle.LEDs }},
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_1',data:{ x:10 - 0.5/2, y:unitStyle.drawingValue.height*2/5 - 2.5, width:0.5, height:5, style:unitStyle.LEDs }},
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_2',data:{ x:10 - 0.5/2, y:unitStyle.drawingValue.height*3/5 - 2.5, width:0.5, height:5, style:unitStyle.LEDs }},
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_3',data:{ x:10 - 0.5/2, y:unitStyle.drawingValue.height*4/5 - 2.5, width:0.5, height:5, style:unitStyle.LEDs }},
                                ]
                            });
                    
                        //circuitry
                            const state = {
                                channelCount:4,
                                previousPosition:-1,
                                position:0,
                            };
                            function gotoPosition(value){
                                state.previousPosition = state.position;
                                state.position = value;
                            }
                            function step(){
                                if( state.channelCount <= state.position+1 ){ gotoPosition(0); }else{ gotoPosition(state.position+1); }
                            }
                            function update(){
                                if(state.previousPosition != -1){
                                    object.io.signal['out_'+state.previousPosition].set(false);
                                    object.elements.glowbox_rectangle['LED_'+state.previousPosition].off();
                                }
                                object.elements.glowbox_rectangle['LED_'+state.position].on();
                                object.io.signal['out_'+state.position].set( object.io.signal.in.read() );
                            }
                    
                        //wiring
                            //io
                                object.io.signal.in.onchange = function(value){ object.io.signal['out_'+state.position].set(value); };
                                object.io.signal.switch.onchange = function(value){
                                    if(!value){return;}
                                    step();
                                    update();
                                };
                    
                        //interface
                            object.i = {
                                step:function(){step();update();},
                                position:function(value){
                                    if(value==undefined){return state.position;}
                                    gotoPosition(value);
                                    update();
                                },
                            };
                    
                        //import/export
                            object.importData = function(data){
                                gotoPosition(data.position);
                                update();
                            };
                            object.exportData = function(){
                                return { position: state.position };
                            };
                    
                        //setup
                            update();
                    
                        return object;
                    };
                    this.multiplexer_4.metadata = {
                        name:'Multiplexer - Type B',
                        category:'devices',
                        helpURL:'/help/units/curvetech/multiplexer_4/'
                    };
                    this.adder = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'adder/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = {
                                        file: { width:150, height:200 },
                                        design: { width:1.5, height:2 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'adder',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out', data:{ 
                                        x:unitStyle.drawingValue.width/2-2.5, y:0, width:2.5, height:5, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'carry_in', data:{ 
                                        x:unitStyle.drawingValue.width, y:5, width:2.5, height:5, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'carry_out', data:{ 
                                        x:0, y:10, width:2.5, height:5, angle:-Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_1', data:{ 
                                        x:unitStyle.drawingValue.width*(1/4)+2.5, y:unitStyle.drawingValue.height-2.5, width:5, height:5, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_2', data:{ 
                                        x:unitStyle.drawingValue.width*(3/4)+2.5, y:unitStyle.drawingValue.height-2.5, width:5, height:5, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png' }
                                    },
                                ]
                            });
                    
                        //circuitry
                            const currentInputValues = {in_1:false, in_2:false, carry_in:false};
                            function update(){
                                const v = currentInputValues;
                                object.io.signal.out.set( v.in_1 != v.in_2 != v.carry_in );
                                object.io.signal.carry_out.set( (v.in_1 && v.in_2) || (v.carry_in && v.in_1) || (v.carry_in && v.in_2) );
                            };
                    
                        //wiring
                            //io
                                object.io.signal.in_1.onchange = function(value){
                                    if(value == currentInputValues.in_1){return;}
                                    currentInputValues.in_1 = value;
                                    update();
                                };
                                object.io.signal.in_2.onchange = function(value){
                                    if(value == currentInputValues.in_2){return;}
                                    currentInputValues.in_2 = value;
                                    update();
                                };
                                object.io.signal.carry_in.onchange = function(value){
                                    if(value == currentInputValues.carry_in){return;}
                                    currentInputValues.carry_in = value;
                                    update();
                                };
                    
                        return object;
                    };
                    this.adder.metadata = {
                        name:'Adder',
                        category:'devices',
                        helpURL:'/help/units/curvetech/adder/'
                    };
                    this.demultiplexer_8 = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'demultiplexer/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = {
                                        file: { width:200, height:500 },
                                        design: { width:2, height:5 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                                    this.LEDs = {
                                        glow:{r:232/255, g:160/255, b:111/255, a:1}, 
                                        dim:{r:164/255, g:80/255, b:61/255, a:1},
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'demultiplexer_8',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'switch', data:{ 
                                        x:unitStyle.drawingValue.width*0.5-2.5, y:0, width:2.5, height:5, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out', data:{ 
                                        x:unitStyle.drawingValue.width, y:unitStyle.drawingValue.height*1/2 - 2.5, width:2.5, height:5, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_0', data:{ 
                                        x:0, y:6 + 2.5 + 5.5*0, width:2.5, height:5, angle:-Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_1', data:{ 
                                        x:0, y:6 + 2.5 + 5.5*1, width:2.5, height:5, angle:-Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_2', data:{ 
                                        x:0, y:6 + 2.5 + 5.5*2, width:2.5, height:5, angle:-Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_3', data:{ 
                                        x:0, y:6 + 2.5 + 5.5*3, width:2.5, height:5, angle:-Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_4', data:{ 
                                        x:0, y:6 + 2.5 + 5.5*4, width:2.5, height:5, angle:-Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_5', data:{ 
                                        x:0, y:6 + 2.5 + 5.5*5, width:2.5, height:5, angle:-Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_6', data:{ 
                                        x:0, y:6 + 2.5 + 5.5*6, width:2.5, height:5, angle:-Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_7', data:{ 
                                        x:0, y:6 + 2.5 + 5.5*7, width:2.5, height:5, angle:-Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'8_backing.png' }
                                    },
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_0',data:{ x:10 - 0.5/2, y:8 - 2.5 + 5*0, width:0.5, height:4, style:unitStyle.LEDs }},
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_1',data:{ x:10 - 0.5/2, y:8 - 2.5 + 5*1, width:0.5, height:4, style:unitStyle.LEDs }},
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_2',data:{ x:10 - 0.5/2, y:8 - 2.5 + 5*2, width:0.5, height:4, style:unitStyle.LEDs }},
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_3',data:{ x:10 - 0.5/2, y:8 - 2.5 + 5*3, width:0.5, height:4, style:unitStyle.LEDs }},
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_4',data:{ x:10 - 0.5/2, y:8 - 2.5 + 5*4, width:0.5, height:4, style:unitStyle.LEDs }},
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_5',data:{ x:10 - 0.5/2, y:8 - 2.5 + 5*5, width:0.5, height:4, style:unitStyle.LEDs }},
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_6',data:{ x:10 - 0.5/2, y:8 - 2.5 + 5*6, width:0.5, height:4, style:unitStyle.LEDs }},
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_7',data:{ x:10 - 0.5/2, y:8 - 2.5 + 5*7, width:0.5, height:4, style:unitStyle.LEDs }},
                                ]
                            });
                    
                        //circuitry
                            const state = {
                                channelCount:8,
                                previousPosition:-1,
                                position:0,
                            };
                            function gotoPosition(value){
                                state.previousPosition = state.position;
                                state.position = value;
                            }
                            function step(){
                                if( state.channelCount <= state.position+1 ){ gotoPosition(0); }else{ gotoPosition(state.position+1); }
                            }
                            function update(){
                                if(state.previousPosition != -1){
                                    object.io.signal.out.set( object.io.signal['in_'+state.position].read() );
                                    object.elements.glowbox_rectangle['LED_'+state.previousPosition].off();
                                }
                                object.elements.glowbox_rectangle['LED_'+state.position].on();
                                object.io.signal.out.set( object.io.signal['in_'+state.position].read() );
                            }
                    
                        //wiring
                            //io
                                for(let a = 0; a < state.channelCount; a++){
                                    object.io.signal['in_'+a].onchange = (function(a){
                                        return function(value){
                                            if(state.position == a){ object.io.signal.out.set(value); }
                                        };
                                    })(a);
                                }
                                object.io.signal.switch.onchange = function(value){
                                    if(!value){return;}
                                    step();
                                    update();
                                };
                    
                        //interface
                            object.i = {
                                step:function(){step();update();},
                                position:function(value){
                                    if(value==undefined){return state.position;}
                                    gotoPosition(value);
                                    update();
                                },
                            };
                    
                        //import/export
                            object.importData = function(data){
                                gotoPosition(data.position);
                                update();
                            };
                            object.exportData = function(){
                                return { position: state.position };
                            };
                    
                        //setup
                            update();
                    
                        return object;
                    };
                    this.demultiplexer_8.metadata = {
                        name:'Demultiplexer - Type C',
                        category:'devices',
                        helpURL:'/help/units/curvetech/demultiplexer_8/'
                    };
                    this.multiplexer_2 = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'multiplexer/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = {
                                        file: { width:200, height:300 },
                                        design: { width:2, height:3 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                                    this.LEDs = {
                                        glow:{r:232/255, g:160/255, b:111/255, a:1}, 
                                        dim:{r:164/255, g:80/255, b:61/255, a:1},
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'multiplexer_2',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'switch', data:{ 
                                        x:unitStyle.drawingValue.width*0.5-2.5, y:0, width:2.5, height:5, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in', data:{ 
                                        x:0, y:unitStyle.drawingValue.height*2/3 - 2.5, width:2.5, height:5, angle:-Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_0', data:{ 
                                        x:unitStyle.drawingValue.width, y:unitStyle.drawingValue.height*1/3 - 2.5, width:2.5, height:5, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_1', data:{ 
                                        x:unitStyle.drawingValue.width, y:unitStyle.drawingValue.height*2/3 - 2.5, width:2.5, height:5, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'2_backing.png' }
                                    },
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_0',data:{ x:10 - 0.5/2, y:7.5,    width:0.5, height:5, style:unitStyle.LEDs }},
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_1',data:{ x:10 - 0.5/2, y:7.5+10, width:0.5, height:5, style:unitStyle.LEDs }},
                                ]
                            });
                    
                        //circuitry
                            const state = {
                                channelCount:2,
                                previousPosition:-1,
                                position:0,
                            };
                            function gotoPosition(value){
                                state.previousPosition = state.position;
                                state.position = value;
                            }
                            function step(){
                                if( state.channelCount <= state.position+1 ){ gotoPosition(0); }else{ gotoPosition(state.position+1); }
                            }
                            function update(){
                                if(state.previousPosition != -1){
                                    object.io.signal['out_'+state.previousPosition].set(false);
                                    object.elements.glowbox_rectangle['LED_'+state.previousPosition].off();
                                }
                                object.elements.glowbox_rectangle['LED_'+state.position].on();
                                object.io.signal['out_'+state.position].set( object.io.signal.in.read() );
                            }
                    
                        //wiring
                            //io
                                object.io.signal.in.onchange = function(value){ object.io.signal['out_'+state.position].set(value); };
                                object.io.signal.switch.onchange = function(value){
                                    if(!value){return;}
                                    step();
                                    update();
                                };
                    
                        //interface
                            object.i = {
                                step:function(){step();update();},
                                position:function(value){
                                    if(value==undefined){return state.position;}
                                    gotoPosition(value);
                                    update();
                                },
                            };
                    
                        //import/export
                            object.importData = function(data){
                                gotoPosition(data.position);
                                update();
                            };
                            object.exportData = function(){
                                return { position: state.position };
                            };
                    
                        //setup
                            update();
                    
                        return object;
                    };
                    this.multiplexer_2.metadata = {
                        name:'Multiplexer - Type A',
                        category:'devices',
                        helpURL:'/help/units/curvetech/multiplexer_2/'
                    };
                    this.single_bit_memory = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'single_bit_memory/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = {
                                        file: { width:250, height:250 },
                                        design: { width:2.5, height:2.5 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'single_bit_memory',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out', data:{ 
                                        x:unitStyle.drawingValue.width*0.4-2.5, y:0, width:2.5, height:5, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'read', data:{ 
                                        x:unitStyle.drawingValue.width, y:unitStyle.drawingValue.height*1/3 - 2.5, width:2.5, height:5, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'write', data:{ 
                                        x:unitStyle.drawingValue.width, y:unitStyle.drawingValue.height*2/3 - 2.5, width:2.5, height:5, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in', data:{ 
                                        x:unitStyle.drawingValue.width*0.4+2.5, y:unitStyle.drawingValue.height, width:2.5, height:5, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png' }
                                    },
                                    {collection:'display', type:'glowbox_image', name:'lamp', 
                                        data:{ 
                                            x:4-0.2, y:9-0.2, width:12 + 0.4, height:12 + 0.4,
                                            dimURL:unitStyle.imageStoreURL_localPrefix+'light_off.png',
                                            glowURL:unitStyle.imageStoreURL_localPrefix+'light_on.png',
                                        },
                                    },
                                    {collection:'control', type:'button_image', name:'button_set', data:{
                                        x:11, y:3, width:5, height:5, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_set_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_set_down.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'button_read', data:{
                                        x:17, y:3, width:5, height:5, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_read_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_read_down.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'button_clear', data:{
                                        x:17, y:9, width:5, height:5, hoverable:false, 
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_clear_up.png',
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_clear_down.png',
                                    }},
                                ]
                            });
                            
                            //circuitry
                                const state = {
                                    memory:false,
                                    read:false,
                                    write:false,
                                };
                                function update(){
                                    if(state.write){ state.memory = object.io.signal.in.read(); }
                                    if(state.memory){ object.elements.glowbox_image.lamp.on(); }else{ object.elements.glowbox_image.lamp.off(); }
                                    object.io.signal.out.set(state.read && state.memory);
                                }
                    
                            //wiring
                                //hid
                                    object.elements.button_image.button_set.onpress = function(value){ if(!value){return;} state.memory = true; update(); };
                                    object.elements.button_image.button_read.onpress = function(){ state.read = true; update(); };
                                    object.elements.button_image.button_read.onrelease = function(){ state.read = false; update(); };
                                    object.elements.button_image.button_clear.onpress = function(value){ if(!value){return;} state.memory = false; update(); };
                    
                                //io
                                    object.io.signal.read.onchange = function(value){
                                        if(value){ object.elements.button_image.button_read.press(); }else{ object.elements.button_image.button_read.release(); }
                                    };
                                    object.io.signal.write.onchange = function(value){ state.write = value; update(); };
                                    object.io.signal.in.onchange = function(value){ update(); };
                    
                            //interface
                                    object.i = {
                                        memory:function(value){ if(value==undefined){return state.memory;} state.memory = value; update(); },
                                        read:function(value){ if(value==undefined){return state.read;} state.read = value; update(); },
                                        write:function(value){ if(value==undefined){return state.write;} state.write = value; update(); },
                                        info:function(){ return Object.assign({},state); },
                                    };
                    
                            //import/export
                                object.importData = function(data){
                                    state.memory = data.memory;
                                    update();
                                };
                                object.exportData = function(){
                                    return { memory: state.memory };
                                };
                    
                        return object;
                    };
                    this.single_bit_memory.metadata = {
                        name:'Single Bit Memory',
                        category:'devices',
                        helpURL:'/help/units/curvetech/single_bit_memory/'
                    };
                    this.multiplexer_8 = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'multiplexer/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = {
                                        file: { width:200, height:500 },
                                        design: { width:2, height:5 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                                    this.LEDs = {
                                        glow:{r:232/255, g:160/255, b:111/255, a:1}, 
                                        dim:{r:164/255, g:80/255, b:61/255, a:1},
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'multiplexer_8',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'switch', data:{ 
                                        x:unitStyle.drawingValue.width*0.5-2.5, y:0, width:2.5, height:5, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in', data:{ 
                                        x:0, y:unitStyle.drawingValue.height*0.6 - 2.5, width:2.5, height:5, angle:-Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_0', data:{ 
                                        x:unitStyle.drawingValue.width, y:6 - 2.5 + 5.5*0, width:2.5, height:5, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_1', data:{ 
                                        x:unitStyle.drawingValue.width, y:6 - 2.5 + 5.5*1, width:2.5, height:5, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_2', data:{ 
                                        x:unitStyle.drawingValue.width, y:6 - 2.5 + 5.5*2, width:2.5, height:5, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_3', data:{ 
                                        x:unitStyle.drawingValue.width, y:6 - 2.5 + 5.5*3, width:2.5, height:5, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_4', data:{ 
                                        x:unitStyle.drawingValue.width, y:6 - 2.5 + 5.5*4, width:2.5, height:5, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_5', data:{ 
                                        x:unitStyle.drawingValue.width, y:6 - 2.5 + 5.5*5, width:2.5, height:5, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_6', data:{ 
                                        x:unitStyle.drawingValue.width, y:6 - 2.5 + 5.5*6, width:2.5, height:5, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out_7', data:{ 
                                        x:unitStyle.drawingValue.width, y:6 - 2.5 + 5.5*7, width:2.5, height:5, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'8_backing.png' }
                                    },
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_0',data:{ x:10 - 0.5/2, y:8 - 2.5 + 5*0, width:0.5, height:4, style:unitStyle.LEDs }},
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_1',data:{ x:10 - 0.5/2, y:8 - 2.5 + 5*1, width:0.5, height:4, style:unitStyle.LEDs }},
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_2',data:{ x:10 - 0.5/2, y:8 - 2.5 + 5*2, width:0.5, height:4, style:unitStyle.LEDs }},
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_3',data:{ x:10 - 0.5/2, y:8 - 2.5 + 5*3, width:0.5, height:4, style:unitStyle.LEDs }},
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_4',data:{ x:10 - 0.5/2, y:8 - 2.5 + 5*4, width:0.5, height:4, style:unitStyle.LEDs }},
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_5',data:{ x:10 - 0.5/2, y:8 - 2.5 + 5*5, width:0.5, height:4, style:unitStyle.LEDs }},
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_6',data:{ x:10 - 0.5/2, y:8 - 2.5 + 5*6, width:0.5, height:4, style:unitStyle.LEDs }},
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_7',data:{ x:10 - 0.5/2, y:8 - 2.5 + 5*7, width:0.5, height:4, style:unitStyle.LEDs }},
                                ]
                            });
                    
                        //circuitry
                            const state = {
                                channelCount:8,
                                previousPosition:-1,
                                position:0,
                            };
                            function gotoPosition(value){
                                state.previousPosition = state.position;
                                state.position = value;
                            }
                            function step(){
                                if( state.channelCount <= state.position+1 ){ gotoPosition(0); }else{ gotoPosition(state.position+1); }
                            }
                            function update(){
                                if(state.previousPosition != -1){
                                    object.io.signal['out_'+state.previousPosition].set(false);
                                    object.elements.glowbox_rectangle['LED_'+state.previousPosition].off();
                                }
                                object.elements.glowbox_rectangle['LED_'+state.position].on();
                                object.io.signal['out_'+state.position].set( object.io.signal.in.read() );
                            }
                    
                        //wiring
                            //io
                                object.io.signal.in.onchange = function(value){ object.io.signal['out_'+state.position].set(value); };
                                object.io.signal.switch.onchange = function(value){
                                    if(!value){return;}
                                    step();
                                    update();
                                };
                    
                        //interface
                            object.i = {
                                step:function(){step();update();},
                                position:function(value){
                                    if(value==undefined){return state.position;}
                                    gotoPosition(value);
                                    update();
                                },
                            };
                    
                        //import/export
                            object.importData = function(data){
                                gotoPosition(data.position);
                                update();
                            };
                            object.exportData = function(){
                                return { position: state.position };
                            };
                    
                        //setup
                            update();
                    
                        return object;
                    };
                    this.multiplexer_8.metadata = {
                        name:'Multiplexer - Type C',
                        category:'devices',
                        helpURL:'/help/units/curvetech/multiplexer_8/'
                    };
                    this.demultiplexer_2 = function(name,x,y,angle){
                        //unitStyle
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'demultiplexer/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = {
                                        file: { width:200, height:300 },
                                        design: { width:2, height:3 },
                                    };
                    
                                    this.offset = 20/div;
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                                    this.LEDs = {
                                        glow:{r:232/255, g:160/255, b:111/255, a:1}, 
                                        dim:{r:164/255, g:80/255, b:61/255, a:1},
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'demultiplexer_2',
                                x:x, y:y, angle:angle,
                                space:[
                                    { x:0,                             y:0                             },
                                    { x:unitStyle.drawingValue.width , y:0                             },
                                    { x:unitStyle.drawingValue.width , y:unitStyle.drawingValue.height },
                                    { x:0,                             y:unitStyle.drawingValue.height },
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_signal', name:'switch', data:{ 
                                        x:unitStyle.drawingValue.width*0.5-2.5, y:0, width:2.5, height:5, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'out', data:{ 
                                        x:unitStyle.drawingValue.width, y:unitStyle.drawingValue.height*1/2 - 2.5, width:2.5, height:5, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_0', data:{ 
                                        x:0, y:unitStyle.drawingValue.height*1/3 + 2.5, width:2.5, height:5, angle:-Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'in_1', data:{ 
                                        x:0, y:unitStyle.drawingValue.height*2/3 + 2.5, width:2.5, height:5, angle:-Math.PI, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:0, y:0, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'2_backing.png' }
                                    },
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_0',data:{ x:10 - 0.5/2, y:7.5,    width:0.5, height:5, style:unitStyle.LEDs }},
                                    {collection:'display', type:'glowbox_rectangle',name:'LED_1',data:{ x:10 - 0.5/2, y:7.5+10, width:0.5, height:5, style:unitStyle.LEDs }},
                                ]
                            });
                    
                        //circuitry
                            const state = {
                                channelCount:2,
                                previousPosition:-1,
                                position:0,
                            };
                            function gotoPosition(value){
                                state.previousPosition = state.position;
                                state.position = value;
                            }
                            function step(){
                                if( state.channelCount <= state.position+1 ){ gotoPosition(0); }else{ gotoPosition(state.position+1); }
                            }
                            function update(){
                                if(state.previousPosition != -1){
                                    object.io.signal.out.set( object.io.signal['in_'+state.position].read() );
                                    object.elements.glowbox_rectangle['LED_'+state.previousPosition].off();
                                }
                                object.elements.glowbox_rectangle['LED_'+state.position].on();
                                object.io.signal.out.set( object.io.signal['in_'+state.position].read() );
                            }
                    
                        //wiring
                            //io
                                for(let a = 0; a < state.channelCount; a++){
                                    object.io.signal['in_'+a].onchange = (function(a){
                                        return function(value){
                                            if(state.position == a){ object.io.signal.out.set(value); }
                                        };
                                    })(a);
                                }
                                object.io.signal.switch.onchange = function(value){
                                    if(!value){return;}
                                    step();
                                    update();
                                };
                    
                        //interface
                            object.i = {
                                step:function(){step();update();},
                                position:function(value){
                                    if(value==undefined){return state.position;}
                                    gotoPosition(value);
                                    update();
                                },
                            };
                    
                        //import/export
                            object.importData = function(data){
                                gotoPosition(data.position);
                                update();
                            };
                            object.exportData = function(){
                                return { position: state.position };
                            };
                    
                        //setup
                            update();
                    
                        return object;
                    };
                    this.demultiplexer_2.metadata = {
                        name:'Demultiplexer - Type A',
                        category:'devices',
                        helpURL:'/help/units/curvetech/demultiplexer_2/'
                    };
                    
                    this._collectionData = {
                        name:'curveTech',
                        itemWidth:210,
                        categoryOrder:[
                            'interface',
                            'logic_gates',
                            'devices',
                        ],   
                    };
                    this._categoryData = {
                        interface:{ printingName:'Interface',itemWidth:265},
                        logic_gates:{ printingName:'Logic Gates',itemWidth:100},
                        devices:{ printingName:'Devices',itemWidth:175},
                    };
                };
                this.harbinger = new function(){
                    this['dsds-8^3'] = function(name,x,y,angle){
                        //audio sample URLs
                            const samples = [
                                [
                                    // - bass
                                    '/sounds/78/bass_1.wav',
                                    '/sounds/78/bass_2.wav',
                                    '/sounds/808/bass_1.wav',
                                    '/sounds/808/bass_2.wav',
                                    '/sounds/808/bass_3.wav',
                                    '/sounds/SP12/bass_1.wav',
                                    '/sounds/SP12/bass_2.wav',
                                    '/sounds/SP12/bass_3.wav',
                                ],[
                                    // - snare
                                    '/sounds/78/snare_1.wav',
                                    '/sounds/78/snare_2.wav',
                                    '/sounds/808/snare_1.wav',
                                    '/sounds/808/snare_2.wav',
                                    '/sounds/808/snare_3.wav',
                                    '/sounds/SP12/snare_1.wav',
                                    '/sounds/SP12/snare_2.wav',
                                    '/sounds/SP12/snare_3.wav',
                                ],[
                                    // - hat_closed
                                    '/sounds/78/hat_closed_1.wav',
                                    '/sounds/808/hat_closed_1.wav',
                                    '/sounds/808/hat_closed_2.wav',
                                    '/sounds/SP12/hat_closed_1.wav',
                                    '/sounds/SP12/hat_closed_2.wav',
                                    '/sounds/RetroMachines/hat_closed_1.wav',
                                    '/sounds/RetroMachines/hat_closed_2.wav',
                                    '/sounds/ModernMachines/hat_closed_1.wav',
                                ],[
                                    // - hat_open
                                    '/sounds/78/hat_open_1.wav',
                                    '/sounds/78/hat_open_2.wav',
                                    '/sounds/808/hat_open_1.wav',
                                    '/sounds/808/hat_open_2.wav',
                                    '/sounds/SP12/hat_open_1.wav',
                                    '/sounds/SP12/hat_open_2.wav',
                                    '/sounds/RetroMachines/hat_open_1.wav',
                                    '/sounds/ModernMachines/hat_open_1.wav',
                                ],[
                                    // misc 1 - 8
                                    '/sounds/ElectroBump/ride.wav',
                                    '/sounds/HitMachine/ride.wav',
                                    '/sounds/808/cowbell.wav',
                                    '/sounds/SP12/cowbell.wav',
                                    '/sounds/78/rim.wav',
                                    '/sounds/808/rim.wav',
                                    '/sounds/SP12/rim_1.wav',
                                    '/sounds/SP12/rim_2.wav',
                                ],[
                                    // misc 9 - 16
                                    '/sounds/SP12/tom_low.wav',
                                    '/sounds/SP12/tom_mid.wav',
                                    '/sounds/SP12/tom_high.wav',
                                    '/sounds/78/maraca.wav',
                                    '/sounds/808/maraca.wav',
                                    '/sounds/78/tamb_1.wav',
                                    '/sounds/78/tamb_2.wav',
                                    '/sounds/78/tamb_3.wav',
                                ],[
                                    // misc 17 - 24
                                    '/sounds/78/bongo_low.wav',
                                    '/sounds/78/bongo_mid.wav',
                                    '/sounds/78/bongo_high.wav',
                                    '/sounds/78/gulro_long.wav',
                                    '/sounds/78/gulro_short.wav',
                                    '/sounds/78/gulro_high.wav',
                                    '/sounds/78/clave.wav',
                                    '/sounds/78/metal.wav',
                                ],[
                                    // misc 25 - 32
                                    '/sounds/808/clap.wav',
                                    '/sounds/Grimy909/crash.wav',
                                    '/sounds/808/conga_low.wav',
                                    '/sounds/808/conga_mid.wav',
                                    '/sounds/808/conga_high.wav',
                                    '/sounds/SP12/conga_low.wav',
                                    '/sounds/SP12/conga_mid.wav',
                                    '/sounds/SP12/conga_high.wav',
                                ]
                            ];
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'dsds-8^3/';
                                    this.imageStoreURL_commonPrefix = imageStoreURL+'common/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = {
                                        file: { width:2900, height:1240 },
                                        design: { width:28.5, height:12 },
                                    };
                    
                                    this.offset = {x:5,y:2};
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //colours
                                    this.LED = {
                                        glow:{r:1,g:0,b:0,a:1},
                                        dim:{r:0.48,g:0.21,b:0.19,a:1},
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'dsds-8^3',
                                x:x, y:y, angle:angle,
                                space:[
                                    {x:-unitStyle.offset.x,                               y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                    {x:-unitStyle.offset.x,                               y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                ],
                                elements:
                                    (new Array(8)).fill().flatMap((item,index) => {
                                        return [
                                            {collection:'dynamic', type:'connectionNode_audio', name:'audio_out_'+index, data:{ 
                                                x:(22.5-15/2)  + index*30, y:0, width:5, height:15, angle:-Math.PI/2, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio,
                                            }},
                                            {collection:'dynamic', type:'connectionNode_signal', name:'signal_in_'+index, data:{ 
                                                x:(22.5+10/2)  + index*30, y:unitStyle.drawingValue.height-unitStyle.offset.y*2, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                            }},
                                            {collection:'dynamic', type:'connectionNode_voltage', name:'voltage_in_'+index, data:{ 
                                                x:(22.5+10/2)  + index*30, y:unitStyle.drawingValue.height-unitStyle.offset.y*2, width:0, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                            }},
                                        ];
                                    }).concat(
                                        [
                                            {collection:'dynamic', type:'connectionNode_audio', name:'audio_out_master', data:{ 
                                                x:(22.5-15/2)  + 8*30, y:0, width:5, height:15, angle:-Math.PI/2, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio,
                                            }},
                                            {collection:'basic', type:'image', name:'backing', 
                                                data:{ x:-unitStyle.offset.x, y:-unitStyle.offset.y, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png' }
                                            },
                                            {collection:'control', type:'dial_continuous_image', name:'masterVolume', data:{
                                                x:unitStyle.offset.x*2 + 252, y:27, radius:20/2, startAngle:2.5, maxAngle:4.4, value:0.5, resetValue:0.5,
                                                handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'signal', data:{
                                                x:unitStyle.offset.x*2 + 244-1, y:95.5, width:8, height:20, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_commonPrefix+'signal_off.png',
                                                backingURL__press:unitStyle.imageStoreURL_commonPrefix+'signal_off.png',
                                                backingURL__glow:unitStyle.imageStoreURL_commonPrefix+'signal_on.png',
                                                backingURL__glow_press:unitStyle.imageStoreURL_commonPrefix+'signal_on.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'voltage', data:{
                                                x:unitStyle.offset.x*2 + 253, y:95.5, width:8, height:20, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_commonPrefix+'voltage_off.png',
                                                backingURL__press:unitStyle.imageStoreURL_commonPrefix+'voltage_off.png',
                                                backingURL__glow:unitStyle.imageStoreURL_commonPrefix+'voltage_on.png',
                                                backingURL__glow_press:unitStyle.imageStoreURL_commonPrefix+'voltage_on.png',
                                            }},
                    
                                            {collection:'control', type:'button_image', name:'preset_1', data:{
                                                x:unitStyle.offset.x*2 + 241.5, y:40.5, width:21, height:9, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_localPrefix+'preset_1_off.png',
                                                backingURL__press:unitStyle.imageStoreURL_localPrefix+'preset_1_off.png',
                                                backingURL__glow:unitStyle.imageStoreURL_localPrefix+'preset_1_on.png',
                                                backingURL__glow_press:unitStyle.imageStoreURL_localPrefix+'preset_1_on.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'preset_2', data:{
                                                x:unitStyle.offset.x*2 + 241.5, y:40.5 + 11, width:21, height:9, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_localPrefix+'preset_2_off.png',
                                                backingURL__press:unitStyle.imageStoreURL_localPrefix+'preset_2_off.png',
                                                backingURL__glow:unitStyle.imageStoreURL_localPrefix+'preset_2_on.png',
                                                backingURL__glow_press:unitStyle.imageStoreURL_localPrefix+'preset_2_on.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'preset_3', data:{
                                                x:unitStyle.offset.x*2 + 241.5, y:40.5 + 11*2, width:21, height:9, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_localPrefix+'preset_3_off.png',
                                                backingURL__press:unitStyle.imageStoreURL_localPrefix+'preset_3_off.png',
                                                backingURL__glow:unitStyle.imageStoreURL_localPrefix+'preset_3_on.png',
                                                backingURL__glow_press:unitStyle.imageStoreURL_localPrefix+'preset_3_on.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'preset_4', data:{
                                                x:unitStyle.offset.x*2 + 241.5, y:40.5 + 11*3, width:21, height:9, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_localPrefix+'preset_4_off.png',
                                                backingURL__press:unitStyle.imageStoreURL_localPrefix+'preset_4_off.png',
                                                backingURL__glow:unitStyle.imageStoreURL_localPrefix+'preset_4_on.png',
                                                backingURL__glow_press:unitStyle.imageStoreURL_localPrefix+'preset_4_on.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'preset_5', data:{
                                                x:unitStyle.offset.x*2 + 241.5, y:40.5 + 11*4, width:21, height:9, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_localPrefix+'preset_5_off.png',
                                                backingURL__press:unitStyle.imageStoreURL_localPrefix+'preset_5_off.png',
                                                backingURL__glow:unitStyle.imageStoreURL_localPrefix+'preset_5_on.png',
                                                backingURL__glow_press:unitStyle.imageStoreURL_localPrefix+'preset_5_on.png',
                                            }},
                                        ]
                                    ).concat(
                                        (new Array(8)).fill().flatMap((item,index) => {
                                            return [
                                                {collection:'control', type:'dial_continuous_image', name:'volume_'+index, data:{
                                                    x:16 + index*30, y:24, radius:13/2, startAngle:2.5, maxAngle:4.4, value:0.5, resetValue:0.5,
                                                    handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_small.png',
                                                }},
                                                {collection:'control', type:'dial_continuous_image', name:'rate_'+index, data:{
                                                    x:28 + index*30, y:36, radius:13/2, startAngle:2.5, maxAngle:4.4, value:0.5, resetValue:0.5,
                                                    handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_small.png',
                                                }},
                                                {collection:'control', type:'dial_discrete_image', name:'bank_'+index, data:{
                                                    x:22 + index*30, y:60, radius:20/2, startAngle:2.5, maxAngle:4.4, value:0, optionCount:8, 
                                                    handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                                }},
                                                {collection:'display', type:'glowbox_circle', name:'channelStatusLED_'+index, data:{
                                                    x:32 + index*30, y:74, radius:3/2, capType:'round', style:unitStyle.LED
                                                }},
                                                {collection:'control', type:'dial_discrete_image', name:'sample_'+index, data:{
                                                    x:22 + index*30, y:90, radius:20/2, startAngle:2.5, maxAngle:4.4, value:0, optionCount:8, 
                                                    handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                                }},
                                                {collection:'display', type:'glowbox_path', name:'channelFireLED_'+index, data:{
                                                    x:14 + index*30, y:104, points:[{x:0,y:0},{x:16,y:0}], capType:'round', style:unitStyle.LED
                                                }},
                                                {collection:'control', type:'button_image', name:'fire_'+index, data:{
                                                    x:11.5 + index*30, y:107.5, width:21, height:9, hoverable:false,
                                                    backingURL__up:unitStyle.imageStoreURL_localPrefix+'fire_up.png',
                                                    backingURL__press:unitStyle.imageStoreURL_localPrefix+'fire_down.png',
                                                }},
                                            ];
                                        })
                                    )
                            });
                    
                        //circuitry
                            const state = {
                                presetSettingTimeout:2000,
                                inputMode:'signal',
                                currentPreset:1,
                                presets:[
                                    [
                                        {bank:0,sample:0,rate:0.5,volume:0.5},
                                        {bank:1,sample:0,rate:0.5,volume:0.5},
                                        {bank:2,sample:0,rate:0.5,volume:0.5},
                                        {bank:3,sample:0,rate:0.5,volume:0.5},
                                        {bank:7,sample:5,rate:0.5,volume:0.5},
                                        {bank:7,sample:6,rate:0.5,volume:0.5},
                                        {bank:6,sample:0,rate:0.5,volume:0.5},
                                        {bank:7,sample:0,rate:0.5,volume:0.5},
                                    ],
                                    [
                                        {bank:0,sample:5,rate:0.5,volume:0.5},
                                        {bank:1,sample:5,rate:0.5,volume:0.5},
                                        {bank:2,sample:5,rate:0.5,volume:0.5},
                                        {bank:3,sample:4,rate:0.5,volume:0.5},
                                        {bank:4,sample:5,rate:0.5,volume:0.5},
                                        {bank:5,sample:1,rate:0.5,volume:0.5},
                                        {bank:5,sample:4,rate:0.5,volume:0.5},
                                        {bank:5,sample:6,rate:0.5,volume:0.5},
                                    ],
                                    [
                                        {bank:0,sample:2,rate:0.5,volume:0.5},
                                        {bank:1,sample:2,rate:0.5,volume:0.5},
                                        {bank:2,sample:7,rate:0.5,volume:0.5},
                                        {bank:3,sample:5,rate:0.5,volume:0.5},
                                        {bank:4,sample:3,rate:0.5,volume:0.5},
                                        {bank:5,sample:0,rate:0.5,volume:0.5},
                                        {bank:5,sample:1,rate:0.5,volume:0.5},
                                        {bank:5,sample:2,rate:0.5,volume:0.5},
                                    ],
                                    [
                                        {bank:0,sample:5,rate:0.5,volume:0.5},
                                        {bank:1,sample:7,rate:0.5,volume:0.5},
                                        {bank:2,sample:6,rate:0.5,volume:0.5},
                                        {bank:3,sample:6,rate:0.5,volume:0.5},
                                        {bank:4,sample:1,rate:0.5,volume:0.5},
                                        {bank:4,sample:3,rate:0.5,volume:0.5},
                                        {bank:5,sample:4,rate:0.5,volume:0.5},
                                        {bank:7,sample:1,rate:0.5,volume:0.5},
                                    ],
                                    [
                                        {bank:7,sample:2,rate:0.5,volume:0.5},
                                        {bank:7,sample:3,rate:0.5,volume:0.5},
                                        {bank:7,sample:4,rate:0.5,volume:0.5},
                                        {bank:6,sample:0,rate:0.5,volume:0.5},
                                        {bank:6,sample:1,rate:0.5,volume:0.5},
                                        {bank:6,sample:2,rate:0.5,volume:0.5},
                                        {bank:4,sample:4,rate:0.5,volume:0.5},
                                        {bank:7,sample:1,rate:0.5,volume:0.5},
                                    ],
                                ],
                            };
                            
                            const channelData = (new Array(8)).fill().map((item,index) => {
                                return { bank:0, sample:0, rate:1, volume:1 }
                            });
                    
                            const masterGain = new _canvas_.interface.circuit.gain(_canvas_.library.audio.context);
                            object.io.audio.audio_out_master.audioNode = masterGain.out();
                            const channelGains = (new Array(8)).fill().map((item,index) => {
                                const gain = new _canvas_.interface.circuit.gain(_canvas_.library.audio.context);
                                object.io.audio['audio_out_'+index].audioNode = gain.out();
                                gain.out().connect( masterGain.in() );
                                return gain;
                            });
                            const samplePlayers = (new Array(8)).fill().map((item,index) => {
                                const player = new _canvas_.interface.circuit.player(_canvas_.library.audio.context);
                                player.concurrentPlayCountLimit(-1);
                                player.out_right().connect( channelGains[index].in() );
                                return player;
                            });
                    
                            function fire(channel,mode='signal',value){
                                if(mode == 'signal'){
                                    samplePlayers[channel].start();
                                    object.elements.glowbox_path['channelFireLED_'+channel].on();
                                    setTimeout(object.elements.glowbox_path['channelFireLED_'+channel].off, 100);
                                }else if(mode == 'voltage'){
                                    // samplePlayers[channel].rate(
                                    //     object.elements.dial_continuous_image['rate_'+channel].get()*2 * value 
                                    // );
                                    channelGains[channel].gain(
                                        object.elements.dial_continuous_image['volume_'+channel].get()*2 * value 
                                    );
                                    samplePlayers[channel].start();
                                    object.elements.glowbox_path['channelFireLED_'+channel].on();
                                    setTimeout(object.elements.glowbox_path['channelFireLED_'+channel].off, 100);
                                }
                            }
                            function loadSample(channel,bank,sample){
                                setChannelStatusLED(channel,'loading');
                                samplePlayers[channel].load(
                                    'url',
                                    () => { 
                                        setChannelStatusLED(channel,'ready');
                                        if( bank != channelData[channel].bank || sample != channelData[channel].sample ){
                                            loadSample(channel,channelData[channel].bank,channelData[channel].sample);
                                        }
                                    },
                                    samples[bank][sample],
                                    () => { 
                                        setChannelStatusLED(channel,'error');
                                        if( bank != channelData[channel].bank || sample != channelData[channel].sample ){
                                            loadSample(channel,channelData[channel].bank,channelData[channel].sample);
                                        }
                                    },
                                );
                            }
                            function setInputConnectionNodes(mode){
                                if(mode != 'signal' && mode != 'voltage'){return;}
                                if(state.inputMode == mode){return;}
                                state.inputMode = mode;
                    
                                const duration = 500;
                                const detail = 30;
                                const zero2five = _canvas_.library.math.curveGenerator.s(detail,0,5);
                                const five2zero = _canvas_.library.math.curveGenerator.s(detail,5,0);
                    
                                if(mode == 'signal'){
                                    for(let a = 0; a < 8; a++){
                                        object.elements.connectionNode_voltage['voltage_in_'+a].disconnect();
                                        object.elements.connectionNode_voltage['voltage_in_'+a].set(0);
                                        
                                        for(let b = 0; b < detail; b++){
                                            setTimeout(()=>{
                                                object.elements.connectionNode_signal['signal_in_'+a].getChildren()[0].width(zero2five[b]);
                                                object.elements.connectionNode_voltage['voltage_in_'+a].getChildren()[0].width(five2zero[b]);
                                            },
                                            (duration/detail)*b);
                                        }
                                    }
                                }else if(mode == 'voltage'){
                                    for(let a = 0; a < 8; a++){
                                        object.elements.connectionNode_signal['signal_in_'+a].disconnect();
                                        object.elements.connectionNode_signal['signal_in_'+a].set(false);
                                        for(let b = 0; b < detail; b++){
                                            setTimeout(()=>{
                                                object.elements.connectionNode_signal['signal_in_'+a].getChildren()[0].width(five2zero[b]);
                                                object.elements.connectionNode_voltage['voltage_in_'+a].getChildren()[0].width(zero2five[b]);
                                            },
                                            (duration/detail)*b);
                                        }
                                    }
                                }
                    
                                if(state.inputMode == 'signal'){
                                    object.elements.button_image.signal.glow(true);
                                    object.elements.button_image.voltage.glow(false);
                                }else if(state.inputMode == 'voltage'){
                                    object.elements.button_image.signal.glow(false);
                                    object.elements.button_image.voltage.glow(true);
                                }
                            }
                            const intervals = [];
                            function setChannelStatusLED(channel,status){
                                if( intervals[channel] != undefined && intervals[channel].interval != undefined ){
                                    clearInterval(intervals[channel].interval);
                                }
                                const led = object.elements.glowbox_circle['channelStatusLED_'+channel];
                    
                                switch(status){
                                    case 'ready':
                                        led.on();
                                    break;
                                    case 'loading':
                                        intervals[channel] = {};
                                        intervals[channel].flip = true;
                                        intervals[channel].interval = setInterval(() => {
                                            intervals[channel].flip ? led.on() : led.off();
                                            intervals[channel].flip = !intervals[channel].flip;
                                        },250);
                                    break;
                                    case 'error':
                                        led.off();
                                    break;
                                }
                            }
                            function selectPreset(preset){
                                for(let a = 1; a <= 5; a++){
                                    object.elements.button_image['preset_'+a].glow(false);
                                }
                                object.elements.button_image['preset_'+preset].glow(true);
                    
                                state.currentPreset = preset;
                    
                                state.presets[preset-1].forEach((set,index) => {
                                    object.elements.dial_continuous_image['volume_'+index].set(set.volume);
                                    object.elements.dial_continuous_image['rate_'+index].set(set.rate);
                                    object.elements.dial_discrete_image['bank_'+index].set(set.bank);
                                    object.elements.dial_discrete_image['sample_'+index].set(set.sample);
                                });
                            }
                            function savePreset(block){
                                state.presets[block] = (new Array(8)).fill().map((item,index) => {
                                    return {
                                        bank:object.elements.dial_discrete_image['bank_'+index].get(), 
                                        sample:object.elements.dial_discrete_image['sample_'+index].get(), 
                                        rate:object.elements.dial_continuous_image['rate_'+index].get(), 
                                        volume:object.elements.dial_continuous_image['volume_'+index].get()
                                    };
                                });
                    
                                object.elements.button_image['preset_'+(block+1)].glow(false);
                                setTimeout(() => { object.elements.button_image['preset_'+(block+1)].glow(true); },100);
                                setTimeout(() => { object.elements.button_image['preset_'+(block+1)].glow(false); },200);
                                setTimeout(() => { object.elements.button_image['preset_'+(block+1)].glow(true); },300);
                                setTimeout(() => { object.elements.button_image['preset_'+(block+1)].glow(false); },400);
                                setTimeout(() => { object.elements.button_image['preset_'+(block+1)].glow(true); },500);
                            }
                    
                        //wiring
                            //hid
                                object.elements.button_image.signal.onpress = function(){
                                    setInputConnectionNodes('signal');
                                };
                                object.elements.button_image.voltage.onpress = function(){
                                    setInputConnectionNodes('voltage');
                                };
                                for(let a = 0; a < 8; a++){
                                    object.elements.dial_continuous_image['volume_'+a].onchange = function(value){
                                        channelData[a].volume = value;
                                        channelGains[a].gain(value*2);
                                    };
                                    object.elements.dial_continuous_image['rate_'+a].onchange = function(value){
                                        channelData[a].rate = value;
                                        if(channelData[a].rate <= 0.1){ channelData[a].rate = 0.1; }
                                        samplePlayers[a].rate( 2*channelData[a].rate );
                                    };
                                    object.elements.dial_discrete_image['bank_'+a].onchange = function(value){
                                        channelData[a].bank = value;
                                        loadSample(a,channelData[a].bank,channelData[a].sample);
                                    };
                                    object.elements.dial_discrete_image['sample_'+a].onchange = function(value){
                                        channelData[a].sample = value;
                                        loadSample(a,channelData[a].bank,channelData[a].sample);
                                    };
                                    object.elements.button_image['fire_'+a].onpress = function(){
                                        fire(a);
                                    };
                                }
                    
                                object.elements.dial_continuous_image.masterVolume.onchange = function(value){
                                    masterGain.gain(value*2);
                                };
                    
                                object.elements.button_image.preset_1.onpress = function(){
                                    object.elements.button_image.preset_1.pressedTime = Date.now();
                                    setTimeout(() => { 
                                        const pressedTime = object.elements.button_image.preset_1.pressedTime;
                                        if( pressedTime > 0 && Date.now() - pressedTime > state.presetSettingTimeout ){
                                            savePreset(0);
                                        }
                                    }, state.presetSettingTimeout);
                                };
                                object.elements.button_image.preset_1.onrelease = function(){
                                    object.elements.button_image.preset_1.pressedTime = -1;
                                    selectPreset(1);
                                };
                                object.elements.button_image.preset_2.onpress = function(){ 
                                    object.elements.button_image.preset_2.pressedTime = Date.now();
                                    setTimeout(() => { 
                                        const pressedTime = object.elements.button_image.preset_2.pressedTime;
                                        if( pressedTime > 0 && Date.now() - pressedTime > state.presetSettingTimeout ){
                                            savePreset(1);
                                        }
                                    }, state.presetSettingTimeout);
                                };
                                object.elements.button_image.preset_2.onrelease = function(){ 
                                    object.elements.button_image.preset_2.pressedTime = -1;
                                    selectPreset(2);
                                };
                                object.elements.button_image.preset_3.onpress = function(){ 
                                    object.elements.button_image.preset_3.pressedTime = Date.now();
                                    setTimeout(() => { 
                                        const pressedTime = object.elements.button_image.preset_3.pressedTime;
                                        if( pressedTime > 0 && Date.now() - pressedTime > state.presetSettingTimeout ){
                                            savePreset(3);
                                        }
                                    }, state.presetSettingTimeout);
                                };
                                object.elements.button_image.preset_3.onrelease = function(){ 
                                    object.elements.button_image.preset_3.pressedTime = -1;
                                    selectPreset(3);
                                };
                                object.elements.button_image.preset_4.onpress = function(){ 
                                    object.elements.button_image.preset_4.pressedTime = Date.now();
                                    setTimeout(() => { 
                                        const pressedTime = object.elements.button_image.preset_4.pressedTime;
                                        if( pressedTime > 0 && Date.now() - pressedTime > state.presetSettingTimeout ){
                                            savePreset(4);
                                        }
                                    }, state.presetSettingTimeout);
                                };
                                object.elements.button_image.preset_4.onrelease = function(){ 
                                    object.elements.button_image.preset_4.pressedTime = -1;
                                    selectPreset(4);
                                };
                                object.elements.button_image.preset_5.onpress = function(){ 
                                    object.elements.button_image.preset_5.pressedTime = Date.now();
                                    setTimeout(() => { 
                                        const pressedTime = object.elements.button_image.preset_5.pressedTime;
                                        if( pressedTime > 0 && Date.now() - pressedTime > state.presetSettingTimeout ){
                                            savePreset(5);
                                        }
                                    }, state.presetSettingTimeout);
                                };
                                object.elements.button_image.preset_5.onrelease = function(){ 
                                    object.elements.button_image.preset_5.pressedTime = -1;
                                    selectPreset(5);
                                };
                    
                            //keycapture
                                object.elements.image.backing.attachCallback('onkeydown', function(x,y,event){
                                    switch(event.keyCode){
                                        case 49: object.elements.button_image.preset_1.press(); break;
                                        case 50: object.elements.button_image.preset_2.press(); break;
                                        case 51: object.elements.button_image.preset_3.press(); break;
                                        case 52: object.elements.button_image.preset_4.press(); break;
                                        case 53: object.elements.button_image.preset_5.press(); break;
                    
                                        case 90: object.elements.button_image['fire_'+0].press(); break;
                                        case 88: object.elements.button_image['fire_'+1].press(); break;
                                        case 67: object.elements.button_image['fire_'+2].press(); break;
                                        case 86: object.elements.button_image['fire_'+3].press(); break;
                                        case 66: object.elements.button_image['fire_'+4].press(); break;
                                        case 78: object.elements.button_image['fire_'+5].press(); break;
                                        case 77: object.elements.button_image['fire_'+6].press(); break;
                                        case 188: object.elements.button_image['fire_'+7].press(); break;
                                    }
                                });
                                object.elements.image.backing.attachCallback('onkeyup', function(x,y,event){
                                    switch(event.keyCode){
                                        case 49: object.elements.button_image.preset_1.release(); break;
                                        case 50: object.elements.button_image.preset_2.release(); break;
                                        case 51: object.elements.button_image.preset_3.release(); break;
                                        case 52: object.elements.button_image.preset_4.release(); break;
                                        case 53: object.elements.button_image.preset_5.release(); break;
                    
                                        case 90: object.elements.button_image['fire_'+0].release(); break;
                                        case 88: object.elements.button_image['fire_'+1].release(); break;
                                        case 67: object.elements.button_image['fire_'+2].release(); break;
                                        case 86: object.elements.button_image['fire_'+3].release(); break;
                                        case 66: object.elements.button_image['fire_'+4].release(); break;
                                        case 78: object.elements.button_image['fire_'+5].release(); break;
                                        case 77: object.elements.button_image['fire_'+6].release(); break;
                                        case 188: object.elements.button_image['fire_'+7].release(); break;
                                    }
                                });
                    
                            //io
                                for(let a = 0; a < 8; a++){
                                    object.io.signal['signal_in_'+a].onchange = function(value){
                                        if(!value){return;}
                                        fire(a);
                                    } 
                                    object.io.voltage['voltage_in_'+a].onchange = function(value){
                                        if(value <= 0){return;}
                                        fire(a,'voltage',value);
                                    } 
                                }
                    
                        //interface
                            object.i = {
                            };
                    
                        //import/export
                            object.exportData = function(){
                                return {
                                    currentSettings:(new Array(8)).fill().map((item,index) => {
                                        return {
                                            bank:object.elements.dial_discrete_image['bank_'+index].get(), 
                                            sample:object.elements.dial_discrete_image['sample_'+index].get(), 
                                            rate:object.elements.dial_continuous_image['rate_'+index].get(), 
                                            volume:object.elements.dial_continuous_image['volume_'+index].get()
                                        };
                                    }),
                                    state:JSON.parse(JSON.stringify(state)),
                                };
                            };
                            object.importData = function(data){
                                state.presetSettingTimeout = data.state.presetSettingTimeout;
                                state.presets = data.state.presets;
                                setInputConnectionNodes(data.state.inputMode);
                                selectPreset(data.state.currentPreset);
                                data.currentSettings.forEach((channel,index) => {
                                    object.elements.dial_discrete_image['bank_'+index].set(channel.bank);
                                    object.elements.dial_discrete_image['sample_'+index].set(channel.sample);
                                    object.elements.dial_continuous_image['rate_'+index].set(channel.rate);
                                    object.elements.dial_continuous_image['volume_'+index].set(channel.volume);
                                });
                            };
                    
                        //setup/tearDown
                            object.oncreate = function(){
                                loadSample(0,0,0);
                                for(let a = 1; a < 8; a++){
                                    object.elements.dial_discrete_image['bank_'+a].set(a);
                                }
                                object.elements.button_image.signal.glow(true);
                                selectPreset(1);
                            };
                            object.ondelete = function(){
                                intervals.forEach(interval => {
                                    clearInterval(interval.interval);
                                });
                            };
                    
                        return object;
                    };
                    this['dsds-8^3'].metadata = {
                        name:'Digital Sample Drum Set - 8^3',
                        category:'',
                        helpURL:'/help/units/harbinger/dsds-8^3/'
                    };
                    this['mrd-16'] = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'mrd-16/';
                                    this.imageStoreURL_commonPrefix = imageStoreURL+'common/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = { 
                                        file: { width:3450, height:790 },
                                        design: { width:33.5, height:7.5 },
                                    };
                    
                                    this.offset = {x:5,y:2};
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //colours
                                    this.selectorLEDstyle = {
                                        glow:{r:1,g:0.5,b:0.5,a:1},
                                        dim:{r:1,g:1,b:1,a:1},
                                    };
                                    this.channelLEDstyle = {
                                        glow:{r:1,g:0,b:0,a:1},
                                        dim:{r:0.85,g:0.6,b:0.6,a:1},
                                    };
                                    this.selectorStepLEDstyle = {
                                        glow:{r:1,g:1,b:1,a:1},
                                        dim:{r:0.5,g:0.5,b:0.5,a:1},
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'mrd-16',
                                x:x, y:y, angle:angle,
                                space:[
                                    {x:-unitStyle.offset.x,                               y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                    {x:-unitStyle.offset.x,                               y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                ],
                                elements:
                                    (new Array(8)).fill().flatMap((item,index) => {
                                        return [
                                            {collection:'dynamic', type:'connectionNode_signal', name:'signal_out_'+index, data:{ 
                                                x:18 - (10/2) + index*30, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                            }},
                                            {collection:'dynamic', type:'connectionNode_voltage', name:'voltage_out_'+index, data:{ 
                                                x:18 - (10/2) + index*30, y:0, width:0, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                            }},
                                        ];
                                    }).concat(
                                        [
                                            {collection:'dynamic', type:'connectionNode_signal', name:'pulseIn', data:{ 
                                                x:unitStyle.drawingValue.width - unitStyle.offset.x, y:50, width:5, height:10, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                            }},
                    
                                            {collection:'basic', type:'image', name:'backing', 
                                                data:{ x:-unitStyle.offset.x, y:-unitStyle.offset.y, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png' }
                                            },
                    
                                            {collection:'control', type:'button_image', name:'signal', data:{
                                                x:10, y:13, width:8, height:20, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_commonPrefix+'signal_off.png',
                                                backingURL__press:unitStyle.imageStoreURL_commonPrefix+'signal_off.png',
                                                backingURL__glow:unitStyle.imageStoreURL_commonPrefix+'signal_on.png',
                                                backingURL__glow_press:unitStyle.imageStoreURL_commonPrefix+'signal_on.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'voltage', data:{
                                                x:22, y:13, width:8, height:20, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_commonPrefix+'voltage_off.png',
                                                backingURL__press:unitStyle.imageStoreURL_commonPrefix+'voltage_off.png',
                                                backingURL__glow:unitStyle.imageStoreURL_commonPrefix+'voltage_on.png',
                                                backingURL__glow_press:unitStyle.imageStoreURL_commonPrefix+'voltage_on.png',
                                            }},
                    
                                            {collection:'control', type:'button_image', name:'channel_left', data:{
                                                x:34, y:13, width:8, height:20, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_commonPrefix+'row_up.png',
                                                backingURL__press:unitStyle.imageStoreURL_commonPrefix+'row_down.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'channel_right', data:{
                                                x:46+8, y:13+20, width:8, height:20, angle:Math.PI, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_commonPrefix+'row_up.png',
                                                backingURL__press:unitStyle.imageStoreURL_commonPrefix+'row_down.png',
                                            }},
                                            {collection:'control', type:'checkbox_image', name:'unify', data:{
                                                x:58, y:13, width:8, height:20,
                                                checkURL:unitStyle.imageStoreURL_commonPrefix+'unify_on.png',
                                                uncheckURL:unitStyle.imageStoreURL_commonPrefix+'unify_off.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'page_up', data:{
                                                x:70, y:13, width:20, height:8, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_commonPrefix+'page_up_up.png',
                                                backingURL__press:unitStyle.imageStoreURL_commonPrefix+'page_up_down.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'page_down', data:{
                                                x:70, y:25, width:20, height:8, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_commonPrefix+'page_down_up.png',
                                                backingURL__press:unitStyle.imageStoreURL_commonPrefix+'page_down_down.png',
                                            }},
                                            {collection:'display', type:'sevenSegmentDisplay', name:'page', data:{
                                                x:94.5, y:13.5, width:11, height:19, canvasBased:true, resolution:5,
                                            }},
                                            {collection:'control', type:'button_image', name:'clear', data:{
                                                x:110, y:13, width:8, height:20, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_commonPrefix+'clear_up.png',
                                                backingURL__press:unitStyle.imageStoreURL_commonPrefix+'clear_down.png',
                                            }},
                                            {collection:'control', type:'dial_discrete_image', name:'releaseLength', data:{
                                                x:132, y:23, radius:20/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, optionCount:4, 
                                                handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'step', data:{
                                                x:146, y:13, width:20, height:20, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_commonPrefix+'step_up.png',
                                                backingURL__press:unitStyle.imageStoreURL_commonPrefix+'step_down.png',
                                            }},
                                            {collection:'control', type:'dial_discrete_image', name:'direction', data:{
                                                x:180, y:23, radius:20/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, optionCount:4, 
                                                handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                            }},
                                        ]
                                    ).concat(
                                        (new Array(16)).fill().flatMap((item,index) => {
                                            return [
                                                {collection:'display', type:'glowbox_rectangle', name:'selectorStepLED_'+index, data:{
                                                    x:17.5 - (5/2) + index*20, y:69, width:5*0, height:2.5, style:unitStyle.selectorStepLEDstyle,
                                                }},
                                            ];
                                        })
                                    ).concat(
                                        (new Array(8)).fill().flatMap((item,index) => {
                                            return [
                                                {collection:'display', type:'glowbox_path', name:'channelLED_'+index, data:{
                                                    x:10.5 + index*30, y:6.5, thickness:1.5, points:[{x:0,y:0},{x:15,y:0}], capType:'round', style:unitStyle.channelLEDstyle
                                                }},
                                            ]
                                        })
                                    ).concat(
                                        (new Array(4)).fill().flatMap((item,index) => {
                                            return [
                                                {collection:'control', type:'button_image', name:'selector_'+index, data:{
                                                    x:10 + index*20, y:39, width:15, height:30, hoverable:false, selectable:true,
                                                    backingURL__up:unitStyle.imageStoreURL_commonPrefix+'1_up.png',
                                                    backingURL__press:unitStyle.imageStoreURL_commonPrefix+'1_down.png',
                                                    backingURL__select:unitStyle.imageStoreURL_commonPrefix+'1_up_select.png',
                                                    backingURL__select_press:unitStyle.imageStoreURL_commonPrefix+'1_down_select.png',
                                                    backingURL__glow:unitStyle.imageStoreURL_commonPrefix+'1_up_glow.png',
                                                    backingURL__glow_press:unitStyle.imageStoreURL_commonPrefix+'1_down_glow.png',
                                                    backingURL__glow_select:unitStyle.imageStoreURL_commonPrefix+'1_up_glow_select.png',
                                                    backingURL__glow_select_press:unitStyle.imageStoreURL_commonPrefix+'1_down_glow_select.png',
                                                }},
                                                {collection:'control', type:'button_image', name:'selector_'+(index+4), data:{
                                                    x:10 + (index+4)*20, y:39, width:15, height:30, hoverable:false, selectable:true,
                                                    backingURL__up:unitStyle.imageStoreURL_commonPrefix+'2_up.png',
                                                    backingURL__press:unitStyle.imageStoreURL_commonPrefix+'2_down.png',
                                                    backingURL__select:unitStyle.imageStoreURL_commonPrefix+'2_up_select.png',
                                                    backingURL__select_press:unitStyle.imageStoreURL_commonPrefix+'2_down_select.png',
                                                    backingURL__glow:unitStyle.imageStoreURL_commonPrefix+'2_up_glow.png',
                                                    backingURL__glow_press:unitStyle.imageStoreURL_commonPrefix+'2_down_glow.png',
                                                    backingURL__glow_select:unitStyle.imageStoreURL_commonPrefix+'2_up_glow_select.png',
                                                    backingURL__glow_select_press:unitStyle.imageStoreURL_commonPrefix+'2_down_glow_select.png',
                                                }},
                                                {collection:'control', type:'button_image', name:'selector_'+(index+8), data:{
                                                    x:10 + (index+8)*20, y:39, width:15, height:30, hoverable:false, selectable:true,
                                                    backingURL__up:unitStyle.imageStoreURL_commonPrefix+'3_up.png',
                                                    backingURL__press:unitStyle.imageStoreURL_commonPrefix+'3_down.png',
                                                    backingURL__select:unitStyle.imageStoreURL_commonPrefix+'3_up_select.png',
                                                    backingURL__select_press:unitStyle.imageStoreURL_commonPrefix+'3_down_select.png',
                                                    backingURL__glow:unitStyle.imageStoreURL_commonPrefix+'3_up_glow.png',
                                                    backingURL__glow_press:unitStyle.imageStoreURL_commonPrefix+'3_down_glow.png',
                                                    backingURL__glow_select:unitStyle.imageStoreURL_commonPrefix+'3_up_glow_select.png',
                                                    backingURL__glow_select_press:unitStyle.imageStoreURL_commonPrefix+'3_down_glow_select.png',
                                                }},
                                                {collection:'control', type:'button_image', name:'selector_'+(index+12), data:{
                                                    x:10 + (index+12)*20, y:39, width:15, height:30, hoverable:false, selectable:true,
                                                    backingURL__up:unitStyle.imageStoreURL_commonPrefix+'4_up.png',
                                                    backingURL__press:unitStyle.imageStoreURL_commonPrefix+'4_down.png',
                                                    backingURL__select:unitStyle.imageStoreURL_commonPrefix+'4_up_select.png',
                                                    backingURL__select_press:unitStyle.imageStoreURL_commonPrefix+'4_down_select.png',
                                                    backingURL__glow:unitStyle.imageStoreURL_commonPrefix+'4_up_glow.png',
                                                    backingURL__glow_press:unitStyle.imageStoreURL_commonPrefix+'4_down_glow.png',
                                                    backingURL__glow_select:unitStyle.imageStoreURL_commonPrefix+'4_up_glow_select.png',
                                                    backingURL__glow_select_press:unitStyle.imageStoreURL_commonPrefix+'4_down_glow_select.png',
                                                }},
                                            ];
                                        })
                                    )
                            });
                    
                        //circuitry
                            const channelCount = 8;
                            const selectorCount = 16;
                            const pageCount = 10;
                            const state = {
                                outputMode:'signal', //signal / voltage
                                step:0, 
                                direction:'l2r', //l2r / r2l / bounce / random
                                bounceDirection:1,
                                currentChannel:0,
                                unifyChannels:false,
                                channel:[],
                                currentlySoundingChannels:[0,0,0,0,0,0,0,0],
                                release:1,
                            };
                            for(let a = 0; a < channelCount; a++){
                                state.channel.push(
                                    {
                                        currentPage:0,
                                        pages:(new Array(pageCount)).fill().map(() => (new Array(selectorCount)).fill().map(() => false) )
                                    }
                                );
                            }
                    
                            function refreshLEDs(){
                                //output select
                                    if(state.outputMode == 'signal'){
                                        object.elements.button_image.signal.glow(true);
                                        object.elements.button_image.voltage.glow(false);
                                    }else if(state.outputMode == 'voltage'){
                                        object.elements.button_image.signal.glow(false);
                                        object.elements.button_image.voltage.glow(true);
                                    }
                    
                                //channel
                                    for(let a = 0; a < channelCount; a++){
                                        object.elements.glowbox_path['channelLED_'+a].off();
                                    }
                                    object.elements.glowbox_path['channelLED_'+state.currentChannel].on();
                    
                                //page
                                    const page = state.channel[state.currentChannel].currentPage;
                                    object.elements.sevenSegmentDisplay.page.enterCharacter(page);
                                    
                                //step
                                    for(let a = 0; a < selectorCount; a++){
                                        object.elements.button_image['selector_'+a].glow(false);
                                    }
                                    object.elements.button_image['selector_'+state.step].glow(true);
                            }
                            function refreshSelectors(){
                                const page = state.channel[state.currentChannel].currentPage;
                                for(let a = 0; a < selectorCount; a++){
                                    object.elements.button_image['selector_'+a].select(
                                        state.channel[state.currentChannel].pages[page][a]
                                    );
                                }
                            }
                            function refresh(){
                                refreshLEDs();
                                refreshSelectors();
                            }
                            function setOutputConnectionNodes(mode){
                                if(mode != 'signal' && mode != 'voltage'){return;}
                                if(state.outputMode == mode){return;}
                                state.outputMode = mode;
                    
                                const duration = 500;
                                const detail = 30;
                                const zero2five = _canvas_.library.math.curveGenerator.s(detail,0,5);
                                const five2zero = _canvas_.library.math.curveGenerator.s(detail,5,0);
                    
                                if(mode == 'signal'){
                                    for(let a = 0; a < 8; a++){
                                        object.elements.connectionNode_voltage['voltage_out_'+a].disconnect();
                                        object.elements.connectionNode_voltage['voltage_out_'+a].set(0);
                                        
                                        for(let b = 0; b < detail; b++){
                                            setTimeout(()=>{
                                                object.elements.connectionNode_signal['signal_out_'+a].getChildren()[0].width(zero2five[b]);
                                                object.elements.connectionNode_voltage['voltage_out_'+a].getChildren()[0].width(five2zero[b]);
                                            },
                                            (duration/detail)*b);
                                        }
                                    }
                                }else if(mode == 'voltage'){
                                    for(let a = 0; a < 8; a++){
                                        object.elements.connectionNode_signal['signal_out_'+a].disconnect();
                                        object.elements.connectionNode_signal['signal_out_'+a].set(false);
                                        for(let b = 0; b < detail; b++){
                                            setTimeout(()=>{
                                                object.elements.connectionNode_signal['signal_out_'+a].getChildren()[0].width(five2zero[b]);
                                                object.elements.connectionNode_voltage['voltage_out_'+a].getChildren()[0].width(zero2five[b]);
                                            },
                                            (duration/detail)*b);
                                        }
                                    }
                                }
                                refreshLEDs();
                            }
                            function setChannel(channel){
                                if(channel == undefined){ return state.currentChannel; }
                                state.currentChannel = channel;
                                refreshLEDs();
                            }
                            function step(){
                                switch(state.direction){
                                    case 'l2r':
                                        state.step++;
                                        if(state.step > selectorCount-1){state.step = 0;}
                                    break;
                                    case 'r2l': 
                                        state.step--;
                                        if(state.step < 0){state.step = selectorCount-1;}
                                    break;
                                    case 'bounce':
                                        if(state.step == 0){state.bounceDirection = 1;}
                                        if(state.step == selectorCount-1){state.bounceDirection = -1;}
                                        state.step += state.bounceDirection;
                                    break;
                                    case 'random': 
                                        state.step = Math.floor(Math.random()*selectorCount);
                                    break;
                                }
                    
                                state.currentlySoundingChannels = state.currentlySoundingChannels.map((item,index) => {
                                    if(item == 0){return 0;}
                                    if(item == 1){
                                        if( state.outputMode == 'signal' ){
                                            object.elements.connectionNode_signal['signal_out_'+index].set( false );
                                        }else if( state.outputMode == 'voltage' ){
                                            object.elements.connectionNode_voltage['voltage_out_'+index].set( 0 );
                                        }
                                        return 0;
                                    }
                                    if(item > 1){
                                        return item - 1;
                                    }
                                });
                                for(let a = 0; a < 8; a++){
                                    if( state.channel[a].pages[state.channel[a].currentPage][state.step] && state.currentlySoundingChannels[a] == 0 ){
                                        if( state.outputMode == 'signal' ){
                                            object.elements.connectionNode_signal['signal_out_'+a].set( true );
                                        }else if( state.outputMode == 'voltage' ){
                                            object.elements.connectionNode_voltage['voltage_out_'+a].set( 1 );
                                        }
                                        state.currentlySoundingChannels[a] = state.release;
                                    }
                                }
                                
                                refreshLEDs();
                            }
                    
                        //wiring
                            //hid
                                object.elements.button_image.signal.onpress = function(){
                                    setOutputConnectionNodes('signal');
                                };
                                object.elements.button_image.voltage.onpress = function(){
                                    setOutputConnectionNodes('voltage');
                                };
                                object.elements.button_image.channel_left.onpress = function(){
                                    state.currentChannel--;
                                    if(state.currentChannel < 0){state.currentChannel = channelCount-1;}
                                    refresh();
                                };
                                object.elements.button_image.channel_right.onpress = function(){
                                    state.currentChannel++;
                                    if(state.currentChannel > channelCount-1){state.currentChannel = 0;}
                                    refresh();
                                };
                                object.elements.button_image.page_up.onpress = function(){
                                    state.channel[state.currentChannel].currentPage++;
                                    if(state.channel[state.currentChannel].currentPage > channelCount-1){state.channel[state.currentChannel].currentPage = 0;}
                    
                                    if(state.unifyChannels){
                                        for(let a = 0; a < 8; a++){
                                            state.channel[a].currentPage = state.channel[state.currentChannel].currentPage;
                                        }
                                    }
                    
                                    refresh();
                                };
                                object.elements.button_image.page_down.onpress = function(){
                                    state.channel[state.currentChannel].currentPage--;
                                    if(state.channel[state.currentChannel].currentPage < 0){state.channel[state.currentChannel].currentPage = channelCount-1;}
                    
                                    if(state.unifyChannels){
                                        for(let a = 0; a < 8; a++){
                                            state.channel[a].currentPage = state.channel[state.currentChannel].currentPage;
                                        }
                                    }
                    
                                    refresh();
                                };
                                object.elements.checkbox_image.unify.onchange = function(bool){
                                    state.unifyChannels = bool;
                                };
                                object.elements.button_image.clear.onpress = function(){
                                    const page = state.channel[state.currentChannel].currentPage;
                                    for(let a = 0; a < selectorCount; a++){
                                        state.channel[state.currentChannel].pages[page][a] = false;
                                    }
                                    if(state.unifyChannels){
                                        for(let a = 0; a < channelCount; a++){
                                            for(let b = 0; b < selectorCount; b++){
                                                state.channel[a].pages[page][b] = false;
                                            }
                                        }
                                    }
                                    refresh();
                                };
                                object.elements.dial_discrete_image.releaseLength.onchange = function(value){
                                    state.release = value+1;
                                };
                                object.elements.button_image.step.onpress = function(){
                                    step();
                                };
                                object.elements.dial_discrete_image.direction.onchange = function(value){
                                    state.direction = ['l2r','r2l','bounce','random'][value];
                                };
                                
                                //selectors
                                    for(let a = 0; a < selectorCount; a++){
                                        object.elements.button_image['selector_'+a].onselect = function(){
                                            const page = state.channel[state.currentChannel].currentPage;
                                            state.channel[state.currentChannel].pages[page][a] = true;
                                            refreshLEDs();
                                        };
                                        object.elements.button_image['selector_'+a].ondeselect = function(){
                                            const page = state.channel[state.currentChannel].currentPage;
                                            state.channel[state.currentChannel].pages[page][a] = false;
                                            refreshLEDs();
                                        };
                                    }
                    
                            //keycapture
                                object.elements.image.backing.attachCallback('onkeydown', function(x,y,event){
                                    switch(event.keyCode){
                                        case 49: setChannel(0); break;
                                        case 50: setChannel(1); break;
                                        case 51: setChannel(2); break;
                                        case 52: setChannel(3); break;
                                        case 53: setChannel(4); break;
                                        case 54: setChannel(5); break;
                                        case 55: setChannel(6); break;
                                        case 56: setChannel(7); break;
                    
                                        case 57: object.elements.dial_discrete_image.releaseLength.nudge(-1); break;
                                        case 48: object.elements.dial_discrete_image.releaseLength.nudge(1);  break;
                                        case 189: object.elements.dial_discrete_image.direction.nudge(-1); break;
                                        case 187: object.elements.dial_discrete_image.direction.nudge(1);  break;
                    
                                        case 191: object.elements.checkbox_image.unify.toggle(); break;
                                        case 186: object.elements.button_image.clear.press(); break;
                                        case 13: step(); break;
                    
                                        case 81: 
                                            state.channel[state.currentChannel].currentPage = 0;
                                            if(state.unifyChannels){
                                                state.channel.forEach( a => {a.currentPage = 0;} );
                                            }
                                            refreshLEDs();
                                        break;
                                        case 87: 
                                            state.channel[state.currentChannel].currentPage = 1;
                                            if(state.unifyChannels){ state.channel.forEach( a => {a.currentPage = 1;} ); }
                                            refreshLEDs();
                                        break;
                                        case 69: 
                                            state.channel[state.currentChannel].currentPage = 2;
                                            if(state.unifyChannels){ state.channel.forEach( a => {a.currentPage = 2;} ); }
                                            refreshLEDs();
                                        break;
                                        case 82: 
                                            state.channel[state.currentChannel].currentPage = 3;
                                            if(state.unifyChannels){ state.channel.forEach( a => {a.currentPage = 3;} ); }
                                            refreshLEDs();
                                        break;
                                        case 84: 
                                            state.channel[state.currentChannel].currentPage = 4;
                                            if(state.unifyChannels){ state.channel.forEach( a => {a.currentPage = 4;} ); }
                                            refreshLEDs();
                                        break;
                                        case 89: 
                                            state.channel[state.currentChannel].currentPage = 5;
                                            if(state.unifyChannels){ state.channel.forEach( a => {a.currentPage = 5;} ); }
                                            refreshLEDs();
                                        break;
                                        case 85: 
                                            state.channel[state.currentChannel].currentPage = 6;
                                            if(state.unifyChannels){ state.channel.forEach( a => {a.currentPage = 6;} ); }
                                            refreshLEDs();
                                        break;
                                        case 73: 
                                            state.channel[state.currentChannel].currentPage = 7;
                                            if(state.unifyChannels){ state.channel.forEach( a => {a.currentPage = 7;} ); }
                                            refreshLEDs();
                                        break;
                                        case 79: 
                                            state.channel[state.currentChannel].currentPage = 8;
                                            if(state.unifyChannels){ state.channel.forEach( a => {a.currentPage = 8;} ); }
                                            refreshLEDs();
                                        break;
                                        case 80: 
                                            state.channel[state.currentChannel].currentPage = 9;
                                            if(state.unifyChannels){ state.channel.forEach( a => {a.currentPage = 9;} ); }
                                            refreshLEDs();
                                        break;
                    
                                        case 65: object.elements.button_image['selector_0'].press();  break;
                                        case 83: object.elements.button_image['selector_1'].press();  break;
                                        case 68: object.elements.button_image['selector_2'].press();  break;
                                        case 70: object.elements.button_image['selector_3'].press();  break;
                                        case 71: object.elements.button_image['selector_4'].press();  break;
                                        case 72: object.elements.button_image['selector_5'].press();  break;
                                        case 74: object.elements.button_image['selector_6'].press();  break;
                                        case 75: object.elements.button_image['selector_7'].press();  break;
                                        case 90: object.elements.button_image['selector_8'].press();  break;
                                        case 88: object.elements.button_image['selector_9'].press();  break;
                                        case 67: object.elements.button_image['selector_10'].press(); break;
                                        case 86: object.elements.button_image['selector_11'].press(); break;
                                        case 66: object.elements.button_image['selector_12'].press(); break;
                                        case 78: object.elements.button_image['selector_13'].press(); break;
                                        case 77: object.elements.button_image['selector_14'].press(); break;
                                        case 188: object.elements.button_image['selector_15'].press(); break;
                                    }
                                });
                                object.elements.image.backing.attachCallback('onkeyup', function(x,y,event){
                                    switch(event.keyCode){
                                        case 186: object.elements.button_image.clear.release(); break;
                    
                                        case 65: object.elements.button_image['selector_0'].release();  break;
                                        case 83: object.elements.button_image['selector_1'].release();  break;
                                        case 68: object.elements.button_image['selector_2'].release();  break;
                                        case 70: object.elements.button_image['selector_3'].release();  break;
                                        case 71: object.elements.button_image['selector_4'].release();  break;
                                        case 72: object.elements.button_image['selector_5'].release();  break;
                                        case 74: object.elements.button_image['selector_6'].release();  break;
                                        case 75: object.elements.button_image['selector_7'].release();  break;
                                        case 90: object.elements.button_image['selector_8'].release();  break;
                                        case 88: object.elements.button_image['selector_9'].release();  break;
                                        case 67: object.elements.button_image['selector_10'].release(); break;
                                        case 86: object.elements.button_image['selector_11'].release(); break;
                                        case 66: object.elements.button_image['selector_12'].release(); break;
                                        case 78: object.elements.button_image['selector_13'].release(); break;
                                        case 77: object.elements.button_image['selector_14'].release(); break;
                                        case 188: object.elements.button_image['selector_15'].release(); break;
                                    }
                                });
                    
                            //io
                                object.io.signal.pulseIn.onchange = function(value){
                                    if(!value){return}
                                    step();
                                } 
                    
                        //interface
                            object.i = {
                                outputMode:function(mode){
                                    if(mode == undefined){ return state.outputMode; }
                                    setOutputConnectionNodes(mode);
                                },
                                step:function(){
                                    step();
                                },
                                currentChannel:function(channel){
                                    if(channel == undefined){ return state.currentChannel; }
                                    if(channel > channelCount-1 || channel < 0){return;}
                                    state.currentChannel = channel;
                                    refreshLEDs();
                                },
                                currentPage:function(channel, page){
                                    if(channel == undefined){ return; }
                                    if(channel > channelCount-1 || channel < 0){return;}
                                    if(page == undefined){ return state.channel[channel].currentPage; }
                                    if(page > pageCount-1 || page < 0){return;}
                                    state.channel[channel].currentPage = page;
                                    refreshLEDs();
                                },
                                pageData:function(channel, page, data){
                                    if(channel == undefined){ return; }
                                    if(channel > channelCount-1 || channel < 0){return;}
                                    if(page == undefined){ return state.channel[channel].pages; }
                                    if(page > pageCount-1 || page < 0){return;}
                                    if(data == undefined){ return state.channel[channel].pages[page]; }
                                    state.channel[channel].pages[page] = data;
                                    refreshLEDs();
                                },
                                clear:function(){
                                    object.elements.button_image.clear.press();
                                    object.elements.button_image.clear.release();
                                },
                                unify:function(bool){
                                    if(bool == undefined){ return state.unifyChannels; }
                                    object.elements.checkbox_image.unify.set(bool);
                                },
                                release:function(value){
                                    if(value == undefined){ return state.release-1; }
                                    object.elements.dial_discrete_image.releaseLength.set(value);
                                },
                                direction:function(mode){
                                    if(mode == undefined){ return state.direction; }
                                    object.elements.dial_discrete_image.direction.set( ['l2r','r2l','bounce','random'].indexOf(mode) );
                                },
                            };
                    
                        //import/export
                            object.exportData = function(){
                                return JSON.parse(JSON.stringify(state));
                            };
                            object.importData = function(data){
                                state.outputMode = data.outputMode;
                                state.step = data.step;
                                state.direction = data.direction;
                                state.bounceDirection = data.bounceDirection;
                                state.currentChannel = data.currentChannel;
                                state.unifyChannels = data.unifyChannels;
                                state.channel = data.channel;
                                state.currentlySoundingChannels = data.currentlySoundingChannels;
                                state.release = data.release;
                                refreshLEDs();
                            };
                    
                        //setup/tearDown
                            object.oncreate = function(){
                                setChannel(0);
                            };
                    
                        return object;
                    };
                    this['mrd-16'].metadata = {
                        name:'Mini Rhythm Designer - 16',
                        category:'',
                        helpURL:'/help/units/harbinger/mrd-16/'
                    };
                    const imageStoreURL = '/images/units/3 - harbinger/';
                    const style = {
                        primeColour:{
                            lightGrey:{r:0.77,g:0.77,b:0.77,a:1},
                        },
                    
                        connectionNode:{
                            signal:{
                                dim:{r:235/255,g:98/255,b:61/255,a:1},
                                glow:{r:237/255,g:154/255,b:132/255,a:1},
                                cable_dim:{r:235/255,g:98/255,b:61/255,a:1},
                                cable_glow:{r:237/255,g:154/255,b:132/255,a:1},
                            },
                            voltage:{
                                dim:{r:170/255,g:251/255,b:89/255,a:1},
                                glow:{r:210/255,g:255/255,b:165/255,a:1},
                                cable_dim:{r:170/255,g:251/255,b:89/255,a:1},
                                cable_glow:{r:210/255,g:255/255,b:165/255,a:1},
                            },
                            data:{
                                dim:{r:114/255,g:176/255,b:248/255,a:1},
                                glow:{r:168/255,g:208/255,b:255/255,a:1},
                                cable_dim:{r:114/255,g:176/255,b:248/255,a:1},
                                cable_glow:{r:168/255,g:208/255,b:255/255,a:1},
                            },
                            audio:{
                                dim:{r:243/255,g:173/255,b:61/255,a:1},
                                glow:{r:247/255,g:203/255,b:133/255,a:1},
                                cable_dim:{r:243/255,g:173/255,b:61/255,a:1},
                                cable_glow:{r:247/255,g:203/255,b:133/255,a:1},
                            },
                        },
                    };
                    this['rdp-32'] = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_localPrefix = imageStoreURL+'rdp-32/';
                                    this.imageStoreURL_commonPrefix = imageStoreURL+'common/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = { 
                                        file: { width:3450, height:1440 },
                                        design: { width:34.5, height:14 },
                                    };
                    
                                    this.offset = {x:5,y:2};
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //colours
                                    this.channelLEDstyle = {
                                        glow:{r:1,g:0,b:0,a:1},
                                        dim:{r:0.85,g:0.6,b:0.6,a:1},
                                    };
                                    this.selectorStepLEDstyle = {
                                        glow:{r:1,g:1,b:1,a:1},
                                        dim:{r:0.5,g:0.5,b:0.5,a:1},
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'rdp-32',
                                x:x, y:y, angle:angle,
                                space:[
                                    {x:-unitStyle.offset.x,                               y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                    {x:-unitStyle.offset.x,                               y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                ],
                                elements:
                                    (new Array(8)).fill().flatMap((item,index) => {
                                        return [
                                            {collection:'dynamic', type:'connectionNode_signal', name:'signal_out_'+index, data:{ 
                                                x:18 - (10/2) + index*30, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                            }},
                                            {collection:'dynamic', type:'connectionNode_voltage', name:'voltage_out_'+index, data:{ 
                                                x:18 - (10/2) + index*30, y:0, width:0, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                            }},
                                        ];
                                    }).concat(
                                        [
                                            {collection:'dynamic', type:'connectionNode_signal', name:'pulseIn', data:{ 
                                                x:unitStyle.drawingValue.width - unitStyle.offset.x, y:80, width:5, height:10, angle:0, cableVersion:2, style:style.connectionNode.signal,
                                            }},
                    
                                            {collection:'basic', type:'image', name:'backing', 
                                                data:{ x:-unitStyle.offset.x, y:-unitStyle.offset.y, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png' }
                                            },
                    
                                            {collection:'control', type:'checkbox_image', name:'unify', data:{
                                                x:10, y:22, width:8, height:20,
                                                checkURL:unitStyle.imageStoreURL_commonPrefix+'unify_on.png',
                                                uncheckURL:unitStyle.imageStoreURL_commonPrefix+'unify_off.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'clear', data:{
                                                x:21, y:22, width:8, height:20, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_commonPrefix+'clear_up.png',
                                                backingURL__press:unitStyle.imageStoreURL_commonPrefix+'clear_down.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'randomFill', data:{
                                                x:32, y:22, width:8, height:20, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_localPrefix+'randomFill_up.png',
                                                backingURL__press:unitStyle.imageStoreURL_localPrefix+'randomFill_down.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'cut', data:{
                                                x:43, y:22, width:8, height:20, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_localPrefix+'cut_up.png',
                                                backingURL__press:unitStyle.imageStoreURL_localPrefix+'cut_down.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'copy', data:{
                                                x:54, y:22, width:8, height:20, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_localPrefix+'copy_up.png',
                                                backingURL__press:unitStyle.imageStoreURL_localPrefix+'copy_down.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'paste', data:{
                                                x:65, y:22, width:8, height:20, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_localPrefix+'paste_up.png',
                                                backingURL__press:unitStyle.imageStoreURL_localPrefix+'paste_down.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'channel_left', data:{
                                                x:76, y:22, width:8, height:20, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_commonPrefix+'row_up.png',
                                                backingURL__press:unitStyle.imageStoreURL_commonPrefix+'row_down.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'channel_right', data:{
                                                x:87+8, y:22+20, width:8, height:20, angle:Math.PI, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_commonPrefix+'row_up.png',
                                                backingURL__press:unitStyle.imageStoreURL_commonPrefix+'row_down.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'page_up', data:{
                                                x:98, y:22, width:20, height:8, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_commonPrefix+'page_up_up.png',
                                                backingURL__press:unitStyle.imageStoreURL_commonPrefix+'page_up_down.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'page_down', data:{
                                                x:98, y:34, width:20, height:8, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_commonPrefix+'page_down_up.png',
                                                backingURL__press:unitStyle.imageStoreURL_commonPrefix+'page_down_down.png',
                                            }},
                                            {collection:'display', type:'sevenSegmentDisplay', name:'page', data:{
                                                x:121.5, y:22.5, width:11, height:19, canvasBased:true, resolution:5,
                                            }},
                    
                                            {collection:'control', type:'button_image', name:'step', data:{
                                                x:10, y:45, width:20, height:20, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_commonPrefix+'step_up.png',
                                                backingURL__press:unitStyle.imageStoreURL_commonPrefix+'step_down.png',
                                            }},
                                            {collection:'control', type:'dial_discrete_image', name:'releaseLength', data:{
                                                x:43, y:55, radius:20/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, optionCount:4, 
                                                handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                            }},
                                            {collection:'control', type:'dial_discrete_image', name:'direction', data:{
                                                x:66, y:55, radius:20/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, optionCount:4, 
                                                handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'region_left', data:{
                                                x:86, y:45, width:8, height:20, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_localPrefix+'region_up.png',
                                                backingURL__press:unitStyle.imageStoreURL_localPrefix+'region_down.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'region_right', data:{
                                                x:97+8, y:45+20, width:8, height:20, angle:Math.PI, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_localPrefix+'region_up.png',
                                                backingURL__press:unitStyle.imageStoreURL_localPrefix+'region_down.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'region_32', data:{
                                                x:108, y:45, width:8, height:20, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_localPrefix+'region_32_up.png',
                                                backingURL__press:unitStyle.imageStoreURL_localPrefix+'region_32_down.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'region_16', data:{
                                                x:119, y:45, width:8, height:20, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_localPrefix+'region_16_up.png',
                                                backingURL__press:unitStyle.imageStoreURL_localPrefix+'region_16_down.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'region_8', data:{
                                                x:130, y:45, width:8, height:20, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_localPrefix+'region_8_up.png',
                                                backingURL__press:unitStyle.imageStoreURL_localPrefix+'region_8_down.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'signal', data:{
                                                x:151, y:45, width:8, height:20, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_commonPrefix+'signal_off.png',
                                                backingURL__press:unitStyle.imageStoreURL_commonPrefix+'signal_off.png',
                                                backingURL__glow:unitStyle.imageStoreURL_commonPrefix+'signal_on.png',
                                                backingURL__glow_press:unitStyle.imageStoreURL_commonPrefix+'signal_on.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'voltage', data:{
                                                x:162, y:45, width:8, height:20, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_commonPrefix+'voltage_off.png',
                                                backingURL__press:unitStyle.imageStoreURL_commonPrefix+'voltage_off.png',
                                                backingURL__glow:unitStyle.imageStoreURL_commonPrefix+'voltage_on.png',
                                                backingURL__glow_press:unitStyle.imageStoreURL_commonPrefix+'voltage_on.png',
                                            }},
                                            {collection:'control', type:'button_image', name:'through', data:{
                                                x:173, y:45, width:8, height:20, hoverable:false,
                                                backingURL__up:unitStyle.imageStoreURL_localPrefix+'through_off.png',
                                                backingURL__press:unitStyle.imageStoreURL_localPrefix+'through_off.png',
                                                backingURL__glow:unitStyle.imageStoreURL_localPrefix+'through_on.png',
                                                backingURL__glow_press:unitStyle.imageStoreURL_localPrefix+'through_on.png',
                                            }},
                                        ]
                                    ).concat(
                                        (new Array(16)).fill().flatMap((item,index) => {
                                            return [
                                                {collection:'display', type:'glowbox_rectangle', name:'selectorStepLED_'+index, data:{
                                                    x:10 + index*20, y:100-3, width:15, height:5, style:unitStyle.selectorStepLEDstyle,
                                                }},
                                                {collection:'display', type:'glowbox_rectangle', name:'selectorStepLED_'+(index+16), data:{
                                                    x:10 + index*20, y:135-3, width:15, height:5, style:unitStyle.selectorStepLEDstyle,
                                                }},
                                            ];
                                        })
                                    ).concat(
                                        (new Array(8)).fill().flatMap((item,index) => {
                                            return [
                                                {collection:'display', type:'glowbox_path', name:'channelLED_'+index, data:{
                                                    x:10.5 + index*30, y:6, thickness:1.5, points:[{x:0,y:0},{x:15,y:0}], capType:'round', style:unitStyle.channelLEDstyle
                                                }},
                                            ]
                                        })
                                    ).concat(
                                        (new Array(8)).fill().flatMap((item,index) => {
                                            return [
                                                {collection:'control', type:'button_image', name:'selector_'+index, data:{
                                                    x:10 + index*20, y:70, width:15, height:30, hoverable:false, selectable:true,
                                                    backingURL__up:unitStyle.imageStoreURL_commonPrefix+'1_up.png',
                                                    backingURL__press:unitStyle.imageStoreURL_commonPrefix+'1_down.png',
                                                    backingURL__select:unitStyle.imageStoreURL_commonPrefix+'1_up_select.png',
                                                    backingURL__select_press:unitStyle.imageStoreURL_commonPrefix+'1_down_select.png',
                                                    backingURL__glow:unitStyle.imageStoreURL_commonPrefix+'1_up_glow.png',
                                                    backingURL__glow_press:unitStyle.imageStoreURL_commonPrefix+'1_down_glow.png',
                                                    backingURL__glow_select:unitStyle.imageStoreURL_commonPrefix+'1_up_glow_select.png',
                                                    backingURL__glow_select_press:unitStyle.imageStoreURL_commonPrefix+'1_down_glow_select.png',
                                                }},
                                                {collection:'control', type:'button_image', name:'selector_'+(index+8), data:{
                                                    x:10 + (index+8)*20, y:70, width:15, height:30, hoverable:false, selectable:true,
                                                    backingURL__up:unitStyle.imageStoreURL_commonPrefix+'2_up.png',
                                                    backingURL__press:unitStyle.imageStoreURL_commonPrefix+'2_down.png',
                                                    backingURL__select:unitStyle.imageStoreURL_commonPrefix+'2_up_select.png',
                                                    backingURL__select_press:unitStyle.imageStoreURL_commonPrefix+'2_down_select.png',
                                                    backingURL__glow:unitStyle.imageStoreURL_commonPrefix+'2_up_glow.png',
                                                    backingURL__glow_press:unitStyle.imageStoreURL_commonPrefix+'2_down_glow.png',
                                                    backingURL__glow_select:unitStyle.imageStoreURL_commonPrefix+'2_up_glow_select.png',
                                                    backingURL__glow_select_press:unitStyle.imageStoreURL_commonPrefix+'2_down_glow_select.png',
                                                }},
                                                {collection:'control', type:'button_image', name:'selector_'+(index+16), data:{
                                                    x:10 + index*20, y:105, width:15, height:30, hoverable:false, selectable:true,
                                                    backingURL__up:unitStyle.imageStoreURL_commonPrefix+'3_up.png',
                                                    backingURL__press:unitStyle.imageStoreURL_commonPrefix+'3_down.png',
                                                    backingURL__select:unitStyle.imageStoreURL_commonPrefix+'3_up_select.png',
                                                    backingURL__select_press:unitStyle.imageStoreURL_commonPrefix+'3_down_select.png',
                                                    backingURL__glow:unitStyle.imageStoreURL_commonPrefix+'3_up_glow.png',
                                                    backingURL__glow_press:unitStyle.imageStoreURL_commonPrefix+'3_down_glow.png',
                                                    backingURL__glow_select:unitStyle.imageStoreURL_commonPrefix+'3_up_glow_select.png',
                                                    backingURL__glow_select_press:unitStyle.imageStoreURL_commonPrefix+'3_down_glow_select.png',
                                                }},
                                                {collection:'control', type:'button_image', name:'selector_'+(index+24), data:{
                                                    x:10 + (index+8)*20, y:105, width:15, height:30, hoverable:false, selectable:true,
                                                    backingURL__up:unitStyle.imageStoreURL_commonPrefix+'4_up.png',
                                                    backingURL__press:unitStyle.imageStoreURL_commonPrefix+'4_down.png',
                                                    backingURL__select:unitStyle.imageStoreURL_commonPrefix+'4_up_select.png',
                                                    backingURL__select_press:unitStyle.imageStoreURL_commonPrefix+'4_down_select.png',
                                                    backingURL__glow:unitStyle.imageStoreURL_commonPrefix+'4_up_glow.png',
                                                    backingURL__glow_press:unitStyle.imageStoreURL_commonPrefix+'4_down_glow.png',
                                                    backingURL__glow_select:unitStyle.imageStoreURL_commonPrefix+'4_up_glow_select.png',
                                                    backingURL__glow_select_press:unitStyle.imageStoreURL_commonPrefix+'4_down_glow_select.png',
                                                }},
                    
                                                {collection:'control', type:'dial_continuous_image', name:'selectorDial_'+index, data:{
                                                    x:197.5 + index*16, y:20.5, radius:13/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, arcDistance:1.2, resetValue:0.5,
                                                    handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_small.png',
                                                }},
                                                {collection:'control', type:'dial_continuous_image', name:'selectorDial_'+(index+8), data:{
                                                    x:205.5 + index*16, y:20.5+13, radius:13/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, arcDistance:1.2, resetValue:0.5,
                                                    handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_small.png',
                                                }},
                                                {collection:'control', type:'dial_continuous_image', name:'selectorDial_'+(index+16), data:{
                                                    x:197.5 + index*16, y:20.5+26, radius:13/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, arcDistance:1.2, resetValue:0.5,
                                                    handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_small.png',
                                                }},
                                                {collection:'control', type:'dial_continuous_image', name:'selectorDial_'+(index+24), data:{
                                                    x:205.5 + index*16, y:20.5+39, radius:13/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, arcDistance:1.2, resetValue:0.5,
                                                    handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_small.png',
                                                }},
                                            ];
                                        })
                                    )
                            });
                    
                        //circuitry
                            const channelCount = 8;
                            const selectorCount = 32;
                            const pageCount = 16;
                            const state = {
                                outputMode:'signal', // signal / voltage
                                step:0,
                                direction:'l2r', // l2r / r2l / bounce / random
                                bounceDirection:1, // 1 / -1
                                currentChannel:0,
                                unifyChannels:false,
                                channel: (new Array(channelCount)).fill().map(() => {
                                    return {
                                        currentPage:0,
                                        pages:(new Array(pageCount)).fill().map(() => (new Array(selectorCount)).fill().map(() => ({value:1, state:false})) )
                                    }
                                }),
                                currentlySoundingChannels:[0,0,0,0,0,0,0,0],
                                release:1, // 1 / 2 / 3 / 4
                                playThrough:{active:false, values: (new Array(channelCount)).fill().map(() => 1) },
                                region:{start:0, end:31, mode:'32'},
                                clipboard:[],
                            };
                    
                            function refreshLEDs(){
                                //output select
                                    if(state.outputMode == 'signal'){
                                        object.elements.button_image.signal.glow(true);
                                        object.elements.button_image.voltage.glow(false);
                                    }else if(state.outputMode == 'voltage'){
                                        object.elements.button_image.signal.glow(false);
                                        object.elements.button_image.voltage.glow(true);
                                    }
                    
                                //channel
                                    for(let a = 0; a < channelCount; a++){
                                        object.elements.glowbox_path['channelLED_'+a].off();
                                    }
                                    object.elements.glowbox_path['channelLED_'+state.currentChannel].on();
                    
                                //page
                                    const page = state.channel[state.currentChannel].currentPage;
                                    object.elements.sevenSegmentDisplay.page.enterCharacter(['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'][page]);
                    
                                //step
                                    for(let a = 0; a < selectorCount; a++){
                                        object.elements.button_image['selector_'+a].glow(false);
                                    }
                                    object.elements.button_image['selector_'+state.step].glow(true);
                    
                                //selection region
                                    for(let a = 0; a < selectorCount; a++){
                                        object.elements.glowbox_rectangle['selectorStepLED_'+a].off();
                                        if(a >= state.region.start && a <= state.region.end){
                                            object.elements.glowbox_rectangle['selectorStepLED_'+a].on();
                                        }
                                    }
                            }
                            function refreshSelectors(){
                                const page = state.channel[state.currentChannel].currentPage;
                                for(let a = 0; a < selectorCount; a++){
                                    object.elements.button_image['selector_'+a].select(
                                        state.channel[state.currentChannel].pages[page][a].state
                                    );
                                    object.elements.dial_continuous_image['selectorDial_'+a].set(
                                        state.channel[state.currentChannel].pages[page][a].value/2
                                    );
                                }
                            }
                            function refresh(){
                                refreshLEDs();
                                refreshSelectors();
                    
                                //reset playThrough
                                    if(state.playThrough.active){
                                        toggleThroughMode();
                                    }
                            }
                            function setOutputConnectionNodes(mode){
                                if(mode != 'signal' && mode != 'voltage'){return;}
                                if(state.outputMode == mode){return;}
                                state.outputMode = mode;
                    
                                const duration = 500;
                                const detail = 30;
                                const zero2five = _canvas_.library.math.curveGenerator.s(detail,0,5);
                                const five2zero = _canvas_.library.math.curveGenerator.s(detail,5,0);
                    
                                if(mode == 'signal'){
                                    for(let a = 0; a < 8; a++){
                                        object.elements.connectionNode_voltage['voltage_out_'+a].disconnect();
                                        object.elements.connectionNode_voltage['voltage_out_'+a].set(0);
                                        
                                        for(let b = 0; b < detail; b++){
                                            setTimeout(()=>{
                                                object.elements.connectionNode_signal['signal_out_'+a].getChildren()[0].width(zero2five[b]);
                                                object.elements.connectionNode_voltage['voltage_out_'+a].getChildren()[0].width(five2zero[b]);
                                            },
                                            (duration/detail)*b);
                                        }
                                    }
                                }else if(mode == 'voltage'){
                                    for(let a = 0; a < 8; a++){
                                        object.elements.connectionNode_signal['signal_out_'+a].disconnect();
                                        object.elements.connectionNode_signal['signal_out_'+a].set(false);
                                        for(let b = 0; b < detail; b++){
                                            setTimeout(()=>{
                                                object.elements.connectionNode_signal['signal_out_'+a].getChildren()[0].width(five2zero[b]);
                                                object.elements.connectionNode_voltage['voltage_out_'+a].getChildren()[0].width(zero2five[b]);
                                            },
                                            (duration/detail)*b);
                                        }
                                    }
                                }
                                refresh();
                            }
                            function setChannel(channel){
                                if(channel == undefined){ return state.currentChannel; }
                                state.currentChannel = channel;
                                refresh();
                            }
                            function step(){
                                switch(state.direction){
                                    case 'l2r':
                                        state.step++;
                                        if(state.step == state.region.end+1 || state.step >= selectorCount){state.step = state.region.start;}
                                    break;
                                    case 'r2l': 
                                        state.step--;
                                        if(state.step == state.region.start-1 || state.step < 0){state.step = state.region.end;}
                                    break;
                                    case 'bounce':
                                        if(state.step == state.region.start || state.step == 0){state.bounceDirection = 1;}
                                        if(state.step == state.region.end || state.step == selectorCount-1){state.bounceDirection = -1;}
                                        state.step += state.bounceDirection;
                                    break;
                                    case 'random':
                                        state.step = state.region.start + Math.round(Math.random()*(state.region.end - state.region.start));
                                    break;
                                }
                    
                                state.currentlySoundingChannels = state.currentlySoundingChannels.map((item,index) => {
                                    if(item == 0){return 0;}
                                    if(item == 1){
                                        if( state.outputMode == 'signal' ){
                                            object.elements.connectionNode_signal['signal_out_'+index].set( false );
                                        }else if( state.outputMode == 'voltage' ){
                                            object.elements.connectionNode_voltage['voltage_out_'+index].set( 0 );
                                        }
                                        return 0;
                                    }
                                    if(item > 1){
                                        return item - 1;
                                    }
                                });
                                for(let a = 0; a < channelCount; a++){
                                    if( state.channel[a].pages[state.channel[a].currentPage][state.step].state && state.currentlySoundingChannels[a] == 0 ){
                                        if( state.outputMode == 'signal' ){
                                            object.elements.connectionNode_signal['signal_out_'+a].set( true );
                                        }else if( state.outputMode == 'voltage' ){
                                            object.elements.connectionNode_voltage['voltage_out_'+a].set( state.channel[a].pages[state.channel[a].currentPage][state.step].value );
                                        }
                                        state.currentlySoundingChannels[a] = state.release;
                                    }
                                }
                                
                                refreshLEDs();
                            }
                            function clear(){
                                const page = state.channel[state.currentChannel].currentPage;
                                if(state.unifyChannels){
                                    for(let a = 0; a < channelCount; a++){
                                        for(let b = 0; b < selectorCount; b++){
                                            state.channel[a].pages[page][b].state = false;
                                            state.channel[a].pages[page][b].value = 1;
                                        }
                                    }
                                }else{
                                    for(let a = 0; a < selectorCount; a++){
                                        state.channel[state.currentChannel].pages[page][a].state = false;
                                        state.channel[state.currentChannel].pages[page][a].value = 1;
                                    }
                                }
                                refresh();
                            }
                            function randomFill(){
                                const page = state.channel[state.currentChannel].currentPage;
                    
                                if(state.unifyChannels){
                                    for(let a = 0; a < channelCount; a++){
                                        for(let b = 0; b < selectorCount; b++){
                                            state.channel[a].pages[page][b].state = Math.round(Math.random()) == 1;
                                            state.channel[a].pages[page][b].value = Math.random()*2;
                                        }
                                    }
                                }else{
                                    for(let a = 0; a < selectorCount; a++){
                                        state.channel[state.currentChannel].pages[page][a].state = Math.round(Math.random()) == 1;
                                        state.channel[state.currentChannel].pages[page][a].value = Math.random()*2;
                                    }
                                }
                                refresh();
                            }
                            function copy(){
                                state.clipboard = [];
                                const page = state.channel[state.currentChannel].currentPage;
                    
                                if(state.unifyChannels){
                                    for(let a = 0; a < channelCount; a++){
                                        state.clipboard[a] = [];
                                        for(let b = 0; b < selectorCount; b++){
                                            state.clipboard[a].push({
                                                state: state.channel[a].pages[page][b].state,
                                                value: state.channel[a].pages[page][b].value,
                                            });
                                        }
                                    }
                                }else{
                                    for(let a = 0; a < selectorCount; a++){
                                        state.clipboard.push({
                                            state: state.channel[state.currentChannel].pages[page][a].state,
                                            value: state.channel[state.currentChannel].pages[page][a].value,
                                        });
                                    }
                                }
                            }
                            function cut(){
                                copy();
                                clear();
                            }
                            function paste(){
                                if(state.clipboard.length == 0){return;}
                    
                                const page = state.channel[state.currentChannel].currentPage;
                                if(state.unifyChannels){
                                    for(let a = 0; a < channelCount; a++){
                                        for(let b = 0; b < selectorCount; b++){
                                            state.channel[a].pages[page][b].state = state.clipboard[a][b].state;
                                            state.channel[a].pages[page][b].value = state.clipboard[a][b].value;
                                        }
                                    }
                                }else{
                                    for(let a = 0; a < selectorCount; a++){
                                        state.channel[state.currentChannel].pages[page][a].state = state.clipboard[a].state;
                                        state.channel[state.currentChannel].pages[page][a].value = state.clipboard[a].value;
                                    }
                                }
                                refresh();
                            }
                            function toggleThroughMode(){
                                state.playThrough.active = !state.playThrough.active;
                                object.elements.button_image.through.glow(state.playThrough.active);
                    
                                if(state.playThrough.active){
                                    for(let a = 0; a < selectorCount; a++){
                                        object.elements.button_image['selector_'+a].select(false,undefined,false);
                                        object.elements.button_image['selector_'+a].glow(false);
                                        object.elements.button_image['selector_'+a].selectable(false);
                                        object.elements.dial_continuous_image['selectorDial_'+a].set(
                                            state.playThrough.values[a] != undefined ? state.playThrough.values[a]/2 : 0
                                        );
                                    }
                                }else{
                                    for(let a = 0; a < selectorCount; a++){
                                        object.elements.button_image['selector_'+a].selectable(true);
                                    }
                                    refresh();
                                }
                            }
                    
                        //wiring
                            //hid
                                //page
                                    object.elements.checkbox_image.unify.onchange = function(bool){
                                        state.unifyChannels = bool;
                                        state.clipboard = [];
                                    };
                                    object.elements.button_image.clear.onpress = function(){
                                        clear();
                                    };
                                    object.elements.button_image.randomFill.onpress = function(){
                                        randomFill();
                                    };
                                    object.elements.button_image.cut.onpress = function(){
                                        cut();
                                    };
                                    object.elements.button_image.copy.onpress = function(){
                                        copy();
                                    };
                                    object.elements.button_image.paste.onpress = function(){
                                        paste();
                                    };
                                    object.elements.button_image.channel_left.onpress = function(){
                                        state.currentChannel--;
                                        if(state.currentChannel < 0){state.currentChannel = channelCount-1;}
                                        refresh();
                                    };
                                    object.elements.button_image.channel_right.onpress = function(){
                                        state.currentChannel++;
                                        if(state.currentChannel > channelCount-1){state.currentChannel = 0;}
                                        refresh();
                                    };
                                    object.elements.button_image.page_up.onpress = function(){
                                        state.channel[state.currentChannel].currentPage++;
                                        if(state.channel[state.currentChannel].currentPage > pageCount-1){state.channel[state.currentChannel].currentPage = 0;}
                        
                                        if(state.unifyChannels){
                                            for(let a = 0; a < channelCount; a++){
                                                state.channel[a].currentPage = state.channel[state.currentChannel].currentPage;
                                            }
                                        }
                        
                                        refresh();
                                    };
                                    object.elements.button_image.page_down.onpress = function(){
                                        state.channel[state.currentChannel].currentPage--;
                                        if(state.channel[state.currentChannel].currentPage < 0){state.channel[state.currentChannel].currentPage = pageCount-1;}
                        
                                        if(state.unifyChannels){
                                            for(let a = 0; a < channelCount; a++){
                                                state.channel[a].currentPage = state.channel[state.currentChannel].currentPage;
                                            }
                                        }
                        
                                        refresh();
                                    };
                            
                                //progression
                                    object.elements.button_image.step.onpress = function(){
                                        step();
                                    };
                                    object.elements.dial_discrete_image.releaseLength.onchange = function(value){
                                        state.release = value+1;
                                    };
                                    object.elements.dial_discrete_image.direction.onchange = function(value){
                                        state.direction = ['l2r','r2l','bounce','random'][value];
                                    };
                    
                                //subsection selection
                                    object.elements.button_image.region_left.onpress = function(){
                                        state.region.mode = 'left';
                                    };
                                    object.elements.button_image.region_right.onpress = function(){
                                        state.region.mode = 'right';
                                    };
                                    object.elements.button_image.region_32.onpress = function(){
                                        state.region = {start:0, end:31};
                                        refresh();
                                        state.region.mode = '32';
                                    };
                                    object.elements.button_image.region_16.onpress = function(){
                                        if( state.region.mode == '16_1' ){
                                            state.region = {start:16, end:31};
                                            state.region.mode = '16_2';
                                        }else{
                                            state.region = {start:0, end:15};
                                            state.region.mode = '16_1';
                                        }
                                        refresh();
                                    };
                                    object.elements.button_image.region_8.onpress = function(){
                                        if( state.region.mode == '8_1' ){
                                            state.region = {start:8, end:15};
                                            state.region.mode = '8_2';
                                        }else if( state.region.mode == '8_2' ){
                                            state.region = {start:16, end:23};
                                            state.region.mode = '8_3';
                                        }else if( state.region.mode == '8_3' ){
                                            state.region = {start:24, end:31};
                                            state.region.mode = '8_4';
                                        }else{
                                            state.region = {start:0, end:7};
                                            state.region.mode = '8_1';
                                        }
                                        refresh();
                                    };
                                    
                                //meta
                                    object.elements.button_image.signal.onpress = function(){
                                        setOutputConnectionNodes('signal');
                                    };
                                    object.elements.button_image.voltage.onpress = function(){
                                        setOutputConnectionNodes('voltage');
                                    };
                                    object.elements.button_image.through.onpress = function(){
                                        toggleThroughMode();
                                    };
                                
                                //selectors
                                    for(let a = 0; a < selectorCount; a++){
                                        object.elements.button_image['selector_'+a].onpress = function(){
                                            if(state.playThrough.active){
                                                if( state.outputMode == 'signal' ){
                                                    object.elements.connectionNode_signal['signal_out_'+a].set( true );
                                                }else if( state.outputMode == 'voltage' ){
                                                    object.elements.connectionNode_voltage['voltage_out_'+a].set( state.playThrough.values[a] );
                                                }
                                            }
                    
                                            if( state.region.mode != 'left' && state.region.mode != 'right' ){return;}
                    
                                            if( state.region.mode == 'left' ){
                                                if( a > state.region.end ){
                                                    state.region.mode = '';
                                                    return;
                                                }
                                                state.region.start = a;
                                            }else if( state.region.mode == 'right' ){
                                                if( a < state.region.start ){
                                                    state.region.mode = '';
                                                    return;
                                                }
                                                state.region.end = a;
                                            }
                    
                                            const page = state.channel[state.currentChannel].currentPage;
                                            state.channel[state.currentChannel].pages[page][a].state = !state.channel[state.currentChannel].pages[page][a].state;
                    
                                            state.region.mode = '';
                                            refresh();
                                        };
                                        object.elements.button_image['selector_'+a].onrelease = function(){
                                            if(state.playThrough.active){
                                                if( state.outputMode == 'signal' ){
                                                    object.elements.connectionNode_signal['signal_out_'+a].set( false );
                                                }else if( state.outputMode == 'voltage' ){
                                                    object.elements.connectionNode_voltage['voltage_out_'+a].set( 0 );
                                                }
                                            }
                                        };
                                        object.elements.button_image['selector_'+a].onselect = function(){
                                            const page = state.channel[state.currentChannel].currentPage;
                                            state.channel[state.currentChannel].pages[page][a].state = true;
                                        };
                                        object.elements.button_image['selector_'+a].ondeselect = function(){
                                            const page = state.channel[state.currentChannel].currentPage;
                                            state.channel[state.currentChannel].pages[page][a].state = false;
                                        };
                    
                                        object.elements.dial_continuous_image['selectorDial_'+a].onchange = function(value){
                                            if(state.playThrough.active){
                                                state.playThrough.values[a] = value*2;
                                                return;
                                            }
                    
                                            const page = state.channel[state.currentChannel].currentPage;
                                            state.channel[state.currentChannel].pages[page][a].value = value*2;
                                        };
                                    }
                    
                            //keycapture
                                object.elements.image.backing.attachCallback('onkeydown', function(x,y,event){
                                    const OEBI = object.elements.button_image;
                    
                                    switch(event.keyCode){
                                        case 49: setChannel(0); break;
                                        case 50: setChannel(1); break;
                                        case 51: setChannel(2); break;
                                        case 52: setChannel(3); break;
                                        case 53: setChannel(4); break;
                                        case 54: setChannel(5); break;
                                        case 55: setChannel(6); break;
                                        case 56: setChannel(7); break;
                    
                                        case 57: object.elements.dial_discrete_image.releaseLength.nudge(-1); break;
                                        case 48: object.elements.dial_discrete_image.releaseLength.nudge(1);  break;
                                        case 189: object.elements.dial_discrete_image.direction.nudge(-1); break;
                                        case 187: object.elements.dial_discrete_image.direction.nudge(1);  break;
                    
                                        case 191: object.elements.checkbox_image.unify.toggle(); break;
                                        case 186: OEBI.clear.press(); break;
                                        case 13: step(); break;
                    
                                        case 38: OEBI.page_up.press(); break;
                                        case 40: OEBI.page_down.press(); break;
                                        case 37: OEBI.channel_left.press(); break;
                                        case 39: OEBI.channel_right.press(); break;
                    
                                        case 81: OEBI.randomFill.press(); break;
                                        case 87: OEBI.cut.press(); break;
                                        case 69: OEBI.copy.press(); break;
                                        case 82: OEBI.paste.press(); break;
                                        case 84: OEBI.region_left.press(); break;
                                        case 89: OEBI.region_right.press(); break;
                                        case 85: OEBI.region_32.press(); break;
                                        case 73: OEBI.region_16.press(); break;
                                        case 79: OEBI.region_8.press(); break;
                                        case 80: OEBI.through.press(); break;
                    
                                        case 65:  if(!event.shiftKey){ OEBI['selector_0'].press();  }else{ OEBI['selector_16'].press(); } break;
                                        case 83:  if(!event.shiftKey){ OEBI['selector_1'].press();  }else{ OEBI['selector_17'].press(); } break;
                                        case 68:  if(!event.shiftKey){ OEBI['selector_2'].press();  }else{ OEBI['selector_18'].press(); } break;
                                        case 70:  if(!event.shiftKey){ OEBI['selector_3'].press();  }else{ OEBI['selector_19'].press(); } break;
                                        case 71:  if(!event.shiftKey){ OEBI['selector_4'].press();  }else{ OEBI['selector_20'].press(); } break;
                                        case 72:  if(!event.shiftKey){ OEBI['selector_5'].press();  }else{ OEBI['selector_21'].press(); } break;
                                        case 74:  if(!event.shiftKey){ OEBI['selector_6'].press();  }else{ OEBI['selector_22'].press(); } break;
                                        case 75:  if(!event.shiftKey){ OEBI['selector_7'].press();  }else{ OEBI['selector_23'].press(); } break;
                                        case 90:  if(!event.shiftKey){ OEBI['selector_8'].press();  }else{ OEBI['selector_24'].press(); } break;
                                        case 88:  if(!event.shiftKey){ OEBI['selector_9'].press();  }else{ OEBI['selector_25'].press(); } break;
                                        case 67:  if(!event.shiftKey){ OEBI['selector_10'].press(); }else{ OEBI['selector_26'].press(); } break;
                                        case 86:  if(!event.shiftKey){ OEBI['selector_11'].press(); }else{ OEBI['selector_27'].press(); } break;
                                        case 66:  if(!event.shiftKey){ OEBI['selector_12'].press(); }else{ OEBI['selector_28'].press(); } break;
                                        case 78:  if(!event.shiftKey){ OEBI['selector_13'].press(); }else{ OEBI['selector_29'].press(); } break;
                                        case 77:  if(!event.shiftKey){ OEBI['selector_14'].press(); }else{ OEBI['selector_30'].press(); } break;
                                        case 188: if(!event.shiftKey){ OEBI['selector_15'].press(); }else{ OEBI['selector_31'].press(); } break;
                                    }
                                });
                                object.elements.image.backing.attachCallback('onkeyup', function(x,y,event){
                                    const OEBI = object.elements.button_image;
                                    switch(event.keyCode){
                                        case 186: OEBI.clear.release(); break;
                    
                                        case 57: object.elements.button_image.page_up.release(); break;
                                        case 48: object.elements.button_image.page_down.release(); break;
                                        case 189: object.elements.button_image.channel_left.release(); break;
                                        case 187: object.elements.button_image.channel_right.release(); break;
                    
                                        case 81: object.elements.button_image.randomFill.release(); break;
                                        case 87: object.elements.button_image.cut.release(); break;
                                        case 69: object.elements.button_image.copy.release(); break;
                                        case 82: object.elements.button_image.paste.release(); break;
                                        case 84: object.elements.button_image.region_left.release(); break;
                                        case 89: object.elements.button_image.region_right.release(); break;
                                        case 85: object.elements.button_image.region_32.release(); break;
                                        case 73: object.elements.button_image.region_16.release(); break;
                                        case 79: object.elements.button_image.region_8.release(); break;
                                        case 80: object.elements.button_image.through.release(); break;
                    
                                        case 65:  if(!event.shiftKey){ OEBI['selector_0'].release();  }else{ OEBI['selector_16'].release(); } break;
                                        case 83:  if(!event.shiftKey){ OEBI['selector_1'].release();  }else{ OEBI['selector_17'].release(); } break;
                                        case 68:  if(!event.shiftKey){ OEBI['selector_2'].release();  }else{ OEBI['selector_18'].release(); } break;
                                        case 70:  if(!event.shiftKey){ OEBI['selector_3'].release();  }else{ OEBI['selector_19'].release(); } break;
                                        case 71:  if(!event.shiftKey){ OEBI['selector_4'].release();  }else{ OEBI['selector_20'].release(); } break;
                                        case 72:  if(!event.shiftKey){ OEBI['selector_5'].release();  }else{ OEBI['selector_21'].release(); } break;
                                        case 74:  if(!event.shiftKey){ OEBI['selector_6'].release();  }else{ OEBI['selector_22'].release(); } break;
                                        case 75:  if(!event.shiftKey){ OEBI['selector_7'].release();  }else{ OEBI['selector_23'].release(); } break;
                                        case 90:  if(!event.shiftKey){ OEBI['selector_8'].release();  }else{ OEBI['selector_24'].release(); } break;
                                        case 88:  if(!event.shiftKey){ OEBI['selector_9'].release();  }else{ OEBI['selector_25'].release(); } break;
                                        case 67:  if(!event.shiftKey){ OEBI['selector_10'].release(); }else{ OEBI['selector_26'].release(); } break;
                                        case 86:  if(!event.shiftKey){ OEBI['selector_11'].release(); }else{ OEBI['selector_27'].release(); } break;
                                        case 66:  if(!event.shiftKey){ OEBI['selector_12'].release(); }else{ OEBI['selector_28'].release(); } break;
                                        case 78:  if(!event.shiftKey){ OEBI['selector_13'].release(); }else{ OEBI['selector_29'].release(); } break;
                                        case 77:  if(!event.shiftKey){ OEBI['selector_14'].release(); }else{ OEBI['selector_30'].release(); } break;
                                        case 188: if(!event.shiftKey){ OEBI['selector_15'].release(); }else{ OEBI['selector_31'].release(); } break;
                                    }
                                });
                    
                            //io
                                object.io.signal.pulseIn.onchange = function(value){
                                    if(!value){return}
                                    step();
                                } 
                    
                        //interface
                            object.i = {
                                outputMode:function(mode){
                                    if(mode == undefined){ return state.outputMode; }
                                    setOutputConnectionNodes(mode);
                                },
                                playThrough:function(bool){
                                    if(bool == undefined){ return state.playThrough.active; }
                                    if( state.playThrough.active == bool ){ return; }
                                    toggleThroughMode();
                                },
                                step:function(){
                                    step();
                                },
                                currentChannel:function(channel){
                                    if(channel == undefined){ return state.currentChannel; }
                                    if(channel > channelCount-1 || channel < 0){return;}
                                    state.currentChannel = channel;
                                    refreshLEDs();
                                    refreshSelectors();
                                },
                                currentPage:function(channel, page){
                                    if(channel == undefined){ return; }
                                    if(channel > channelCount-1 || channel < 0){return;}
                                    if(page == undefined){ return state.channel[channel].currentPage; }
                                    if(page > pageCount-1 || page < 0){return;}
                                    state.channel[channel].currentPage = page;
                                    refreshLEDs();
                                    refreshSelectors();
                                },
                                pageData:function(channel, page, data){
                                    if(channel == undefined){ return; }
                                    if(channel > channelCount-1 || channel < 0){return;}
                                    if(page == undefined){ return state.channel[channel].pages; }
                                    if(page > pageCount-1 || page < 0){return;}
                                    if(data == undefined){ return state.channel[channel].pages[page]; }
                                    state.channel[channel].pages[page] = data;
                                    refreshLEDs();
                                    refreshSelectors();
                                },
                                unify:function(bool){
                                    if(bool == undefined){ return state.unifyChannels; }
                                    object.elements.checkbox_image.unify.set(bool);
                                },
                                clear:function(){
                                    clear();
                                },
                                randomFill:function(){
                                    randomFill();
                                },
                                release:function(value){
                                    if(value == undefined){ return state.release-1; }
                                    object.elements.dial_discrete_image.releaseLength.set(value);
                                },
                                direction:function(mode){
                                    if(mode == undefined){ return state.direction; }
                                    object.elements.dial_discrete_image.direction.set( ['l2r','r2l','bounce','random'].indexOf(mode) );
                                },
                                region:function(start,end){
                                    if(start == undefined && end == undefined){ return {start:state.region.start,end:state.region.end}; }
                                    if( start < 0 || start > selectorCount-1 || end < 0 || end > selectorCount-1){ return; }
                                    if( end < start ){ return; }
                                    state.region = {start:start, end:end};
                                    refresh();
                                    state.region.mode = '';
                                },
                                reset:function(){
                                    state.outputMode = 'signal';
                                    state.step = 0;
                                    state.direction = 'l2r';
                                    state.bounceDirection = 1;
                                    state.currentChannel = 0;
                                    state.unifyChannels = false;
                                    state.channel = (new Array(channelCount)).fill().map(() => {
                                        return {
                                            currentPage:0,
                                            pages:(new Array(pageCount)).fill().map(() => (new Array(selectorCount)).fill().map(() => ({value:1, state:false})) )
                                        }
                                    });
                                    state.currentlySoundingChannels = [0,0,0,0,0,0,0,0];
                                    state.release = 1;
                                    state.playThrough.active = false
                                    state.playThrough.values = (new Array(channelCount)).fill().map(() => 1);
                                    state.region.start = 0, 
                                    state.region.end = 31
                                    state.region.mode = '32'
                                    state.clipboard = [];
                    
                                    refresh();
                                },
                            };
                    
                        //import/export
                            object.exportData = function(){
                                return JSON.parse(JSON.stringify(state));
                            };
                            object.importData = function(data){
                                Object.keys(data).forEach(key => { state[key] = JSON.parse(JSON.stringify(data[key])); });
                                refresh();
                            };
                    
                        //setup/tearDown
                            object.oncreate = function(){
                                setChannel(0);
                            };
                    
                        return object;
                    };
                    this['rdp-32'].metadata = {
                        name:'Rhythm Designer Pro - 32',
                        category:'',
                        helpURL:'/help/units/harbinger/rdp-32/'
                    };
                    
                    this._collectionData = {
                        name:'Harbinger',
                        itemWidth:222.5,
                        categoryOrder:[
                        ],   
                    };
                    this._categoryData = {
                        // sequencers:{ printingName:'Sequencers',itemWidth:175},
                    };
                };
                this.acousticresearch = new function(){
                    this['momentary_amplitude_meter'] = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_commonPrefix = imageStoreURL+'common/';
                                    this.imageStoreURL_localPrefix = imageStoreURL+'momentary_amplitude_meter/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = { 
                                        file: { width:950, height:900 },
                                        design: { width:9.5, height:9 },
                                    };
                    
                                    this.offset = {x:0,y:0};
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                this.gauge = {needles:[{r:0,g:0,b:0,a:1}]};
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'momentary_amplitude_meter',
                                x:x, y:y, angle:angle,
                                space:[
                                    {x:-unitStyle.offset.x,                               y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                    {x:-unitStyle.offset.x,                               y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_audio', name:'input', data:{ 
                                        x:unitStyle.drawingValue.width, y:unitStyle.drawingValue.height/2 - 15/2, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:-unitStyle.offset.x, y:-unitStyle.offset.y, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png' }
                                    },
                    
                                    {collection:'display', type:'meter_gauge', name:'gauge', data:{ 
                                        x:10+0.5, y:10+0.5, width:60-1, height:40-1,
                                        markings:{},
                                        style:{
                                            backing:{r:0,g:0,b:0,a:0},
                                            needleColours:[{r:0.98,g:0.98,b:0.98,a:1}],
                                        },
                                    }},
                                    {collection:'control', type:'checkbox_image', name:'useFullSample', data:{
                                        x:15, y:60, width:10, height:20,
                                        uncheckURL:unitStyle.imageStoreURL_commonPrefix+'switch_large_up.png', 
                                        checkURL:unitStyle.imageStoreURL_commonPrefix+'switch_large_down.png',
                                    }},
                                    {collection:'control', type:'dial_continuous_image', name:'sampleRate', data:{
                                        x:50, y:71, radius:30/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, resetValue:0.5, arcDistance:1.2,
                                        handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                    }},
                                ]
                            });
                    
                        //circuitry
                            const state = {
                                sampleRate_dial:0,
                                sampleRate:1,
                                useFullSample:false,
                            };
                            const momentaryAmplitudeMeter = new _canvas_.interface.circuit.momentaryAmplitudeMeter(_canvas_.library.audio.context);
                            momentaryAmplitudeMeter.reading = function(data){
                                object.elements.meter_gauge.gauge.set( Math.abs(data) );
                            };
                    
                        //wiring
                            //hid
                                object.elements.dial_continuous_image.sampleRate.onchange = function(value){
                                    state.sampleRate_dial = value;
                                    value = Math.round(value*30);
                                    if(value < 1){value = 1;}
                                    momentaryAmplitudeMeter.updateDelay( 1000/value );
                                };
                                object.elements.checkbox_image.useFullSample.onchange = function(value){
                                    state.useFullSample = value;
                                    momentaryAmplitudeMeter.fullSample(value);
                                };
                            //io
                                object.io.audio.input.audioNode = momentaryAmplitudeMeter.in();
                    
                        //interface
                            object.i = {
                                sampleRate:function(value){
                                    if(value == undefined){ return state.sampleRate; }
                    
                                    if(value == 0 || value == 1){
                                        object.elements.dial_continuous_image.sampleRate.set(0);
                                        return;
                                    }
                                    object.elements.dial_continuous_image.sampleRate.set(value/30);
                                },
                                fullSample:function(bool){
                                    if(value == undefined){ return state.useFullSample; }
                                    object.elements.checkbox_image.useFullSample.set(bool);
                                },
                            };
                    
                        //import/export
                            object.exportData = function(){
                                return JSON.parse(JSON.stringify(state));
                            };
                            object.importData = function(data){
                                object.elements.dial_continuous_image.sampleRate.set(data.sampleRate_dial);
                                object.elements.checkbox_image.useFullSample.set(data.useFullSample);
                            };
                            
                        return object;
                    };
                    this['momentary_amplitude_meter'].metadata = {
                        name:'Momentary Amplitude Meter',
                        category:'',
                        helpURL:''
                    };
                    this['gain'] = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_commonPrefix = imageStoreURL+'common/';
                                    this.imageStoreURL_localPrefix = imageStoreURL+'gain/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = { 
                                        file: { width:1200, height:500 },
                                        design: { width:12, height:5 },
                                    };
                    
                                    this.offset = {x:0,y:0};
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'gain',
                                x:x, y:y, angle:angle,
                                space:[
                                    {x:-unitStyle.offset.x,                               y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                    {x:-unitStyle.offset.x,                               y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_audio', name:'input', data:{ 
                                        x:unitStyle.drawingValue.width, y:22.5, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'output', data:{ 
                                        x:0, y:37.5, width:5, height:15, angle:Math.PI, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'control', data:{ 
                                        x:32.5, y:unitStyle.drawingValue.height, width:5, height:15, angle:Math.PI/2, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'mux', data:{ 
                                        x:30, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'offset', data:{ 
                                        x:45, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'voltage_gain', data:{ 
                                        x:85, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:-unitStyle.offset.x, y:-unitStyle.offset.y, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'guide.png' }
                                    },
                    
                                    {collection:'control', type:'dial_continuous_image', name:'gain', data:{
                                        x:80, y:25, radius:30/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, resetValue:0.5, arcDistance:1.2, optionCount:128, 
                                        handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                    }},
                                    {collection:'control', type:'checkbox_image', name:'plusOne', data:{
                                        x:45, y:15, width:10, height:20,
                                        uncheckURL:unitStyle.imageStoreURL_commonPrefix+'switch_large_down.png', 
                                        checkURL:unitStyle.imageStoreURL_commonPrefix+'switch_large_up.png',
                                    }},
                                    {collection:'control', type:'checkbox_image', name:'byTen', data:{
                                        x:30, y:15, width:10, height:20,
                                        uncheckURL:unitStyle.imageStoreURL_commonPrefix+'switch_large_down.png', 
                                        checkURL:unitStyle.imageStoreURL_commonPrefix+'switch_large_up.png',
                                    }},
                                    {collection:'control', type:'checkbox_image', name:'flow', data:{
                                        x:10, y:15, width:10, height:20,
                                        uncheckURL:unitStyle.imageStoreURL_commonPrefix+'switch_large_up.png', 
                                        checkURL:unitStyle.imageStoreURL_commonPrefix+'switch_large_down.png',
                                    }},
                                ]
                            });
                    
                        //circuitry
                            const state = {
                                gain_dial:0.5,
                                gain:1,
                                plusOne:false,
                                byTen:false,
                                flow:false,
                            };
                            const gain = new _canvas_.interface.circuit.gain(_canvas_.library.audio.context);
                    
                            function update(){
                                const v = state.gain_dial*2 - 1;
                                state.gain = ( v + (state.plusOne?1:0) ) * (state.byTen?10:1);
                                gain.gain(state.gain);
                            }
                    
                        //wiring
                            //hid
                                object.elements.dial_continuous_image.gain.onchange = function(value){
                                    state.gain_dial = value;
                                    update();
                                };
                                object.elements.checkbox_image.plusOne.onchange = function(value){
                                    state.plusOne = value;
                                    update();
                                };
                                object.elements.checkbox_image.byTen.onchange = function(value){
                                    state.byTen = value;
                                    update();
                                };
                                object.elements.checkbox_image.flow.onchange = function(value){
                                    state.flow = value;
                                    gain.mode(value);
                                };
                            //io
                                object.io.audio.input.audioNode = gain.in();
                                object.io.audio.output.audioNode = gain.out();
                                object.io.audio.control.audioNode = gain.control();
                                object.io.signal.mux.onchange = function(value){
                                    if(!value){return;}
                                    object.elements.checkbox_image.byTen.set(
                                        !object.elements.checkbox_image.byTen.get()
                                    );
                                };
                                object.io.signal.offset.onchange = function(value){
                                    if(!value){return;}
                                    object.elements.checkbox_image.plusOne.set(
                                        !object.elements.checkbox_image.plusOne.get()
                                    );
                                };
                                object.io.voltage.voltage_gain.onchange = function(value){
                                    object.elements.dial_continuous_image.gain.set( (value+1)/2 );
                                };
                    
                        //interface
                            object.i = {
                                flow:function(a){
                                    if(a==undefined){ return state.flow; }
                                    object.elements.checkbox_image.flow.set( a );
                                },
                                plusOne:function(a){
                                    if(a==undefined){ return state.plusOne; }
                                    object.elements.checkbox_image.plusOne.set( a );
                                },
                                byTen:function(a){
                                    if(a==undefined){ return state.byTen; }
                                    object.elements.checkbox_image.byTen.set( a );
                                },
                                dial:function(a){
                                    if(a==undefined){ return state.gain_dial; }
                                    object.elements.dial_continuous_image.gain.set( a );
                                },
                            };
                    
                        //import/export
                            object.exportData = function(){
                                return JSON.parse(JSON.stringify(state));
                            };
                            object.importData = function(data){
                                object.elements.checkbox_image.flow.set( data.flow );
                                object.elements.checkbox_image.plusOne.set( data.plusOne );
                                object.elements.checkbox_image.byTen.set( data.byTen );
                                object.elements.dial_continuous_image.gain.set( data.gain_dial );
                            };
                    
                        //setup/tearDown
                            object.oncreate = function(){
                                object.elements.checkbox_image.plusOne.set(true);
                            };
                    
                        return object;
                    };
                    this['gain'].metadata = {
                        name:'Gain',
                        category:'',
                        helpURL:''
                    };
                    const imageStoreURL = '/images/units/4 - acoustic research/';
                    const style = {
                        connectionNode:{
                            signal:{
                                dim:{r:235/255,g:98/255,b:61/255,a:1},
                                glow:{r:237/255,g:154/255,b:132/255,a:1},
                                cable_dim:{r:235/255,g:98/255,b:61/255,a:1},
                                cable_glow:{r:237/255,g:154/255,b:132/255,a:1},
                            },
                            voltage:{
                                dim:{r:170/255,g:251/255,b:89/255,a:1},
                                glow:{r:210/255,g:255/255,b:165/255,a:1},
                                cable_dim:{r:170/255,g:251/255,b:89/255,a:1},
                                cable_glow:{r:210/255,g:255/255,b:165/255,a:1},
                            },
                            data:{
                                dim:{r:114/255,g:176/255,b:248/255,a:1},
                                glow:{r:168/255,g:208/255,b:255/255,a:1},
                                cable_dim:{r:114/255,g:176/255,b:248/255,a:1},
                                cable_glow:{r:168/255,g:208/255,b:255/255,a:1},
                            },
                            audio:{
                                dim:{r:243/255,g:173/255,b:61/255,a:1},
                                glow:{r:247/255,g:203/255,b:133/255,a:1},
                                cable_dim:{r:243/255,g:173/255,b:61/255,a:1},
                                cable_glow:{r:247/255,g:203/255,b:133/255,a:1},
                            },
                        },
                    };
                    this['frequency_amplitude_response_workstation'] = function(name,x,y,angle){
                        const graphMemoryCount = 10;
                    
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_commonPrefix = imageStoreURL+'common/';
                                    this.imageStoreURL_localPrefix = imageStoreURL+'frequency_amplitude_response_workstation/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = { 
                                        file: { width:4100, height:1700 },
                                        design: { width:41, height:17 },
                                    };
                    
                                    this.offset = {x:0,y:0};
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                    
                                //styling values
                                    this.waveport = { 
                                        backgroundText_size:10, 
                                        backing:{r:0.15,g:0.15,b:0.15,a:1},
                                        foregrounds:(new Array(graphMemoryCount)).fill().map((a,index) => ({
                                            colour:{r:0,g:_canvas_.library.math.curvePoint.linear(index/(graphMemoryCount-1),0.4,1),b:0,a:1}, 
                                            thickness:0.5
                                        }))
                                    };
                                    this.progressLED = {
                                        glow:{r:0.99,g:0.32,b:0.24,a:1},
                                        dim:{r:0.47,g:0.02,b:0.13,a:1},
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'frequency_amplitude_response_workstation',
                                x:x, y:y, angle:angle,
                                space:[
                                    {x:-unitStyle.offset.x,                               y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                    {x:-unitStyle.offset.x,                               y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_audio', name:'producer', data:{ 
                                        x:301 + 7.5, y:unitStyle.drawingValue.height, width:5, height:15, angle:Math.PI/2, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'consumer', data:{ 
                                        x:110 + 7.5, y:unitStyle.drawingValue.height, width:5, height:15, angle:Math.PI/2, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:-unitStyle.offset.x, y:-unitStyle.offset.y, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png' }
                                    },
                    
                                    {collection:'display', type:'grapher', name:'waveport', data:{
                                        x:10+0.5, y:10+0.5, width:200-1, height:150-1, canvasBased:true, style:unitStyle.waveport,
                                    }},
                    
                                    {collection:'display', type:'readout_sevenSegmentDisplay', name:'LCD_startFrequency', data:{ 
                                        x:221+0.5, y:21+0.5, width:74-1, height:29-1, canvasBased:true, count:5, decimalPlaces:true, style:unitStyle.LCD, resolution:5,
                                    }},
                                    {collection:'display', type:'readout_sevenSegmentDisplay', name:'LCD_endFrequency', data:{ 
                                        x:307+0.5, y:21+0.5, width:74-1, height:29-1, canvasBased:true, count:5, decimalPlaces:true, style:unitStyle.LCD, resolution:5,
                                    }},
                                    {collection:'display', type:'readout_sevenSegmentDisplay', name:'LCD_stepFrequency', data:{ 
                                        x:264+0.5, y:80.5+0.5, width:74-1, height:29-1, canvasBased:true, count:5, decimalPlaces:true, style:unitStyle.LCD, resolution:5,
                                    }},
                    
                                    {collection:'control', type:'button_image', name:'startFrequency_10000_up',    data:{ x:221+0,   y:11+0,  width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'startFrequency_1000_up',     data:{ x:221+15,  y:11+0,  width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'startFrequency_100_up',      data:{ x:221+30,  y:11+0,  width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'startFrequency_10_up',       data:{ x:221+45,  y:11+0,  width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'startFrequency_1_up',        data:{ x:221+60,  y:11+0,  width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'startFrequency_10000_down',  data:{ x:221+0,   y:11+40, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'startFrequency_1000_down',   data:{ x:221+15,  y:11+40, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'startFrequency_100_down',    data:{ x:221+30,  y:11+40, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'startFrequency_10_down',     data:{ x:221+45,  y:11+40, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'startFrequency_1_down',      data:{ x:221+60,  y:11+40, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                    
                                    {collection:'control', type:'button_image', name:'endFrequency_10000_up',      data:{ x:307+0,   y:11+0,  width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'endFrequency_1000_up',       data:{ x:307+15,  y:11+0,  width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'endFrequency_100_up',        data:{ x:307+30,  y:11+0,  width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'endFrequency_10_up',         data:{ x:307+45,  y:11+0,  width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'endFrequency_1_up',          data:{ x:307+60,  y:11+0,  width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'endFrequency_10000_down',    data:{ x:307+0,   y:11+40, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'endFrequency_1000_down',     data:{ x:307+15,  y:11+40, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'endFrequency_100_down',      data:{ x:307+30,  y:11+40, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'endFrequency_10_down',       data:{ x:307+45,  y:11+40, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'endFrequency_1_down',        data:{ x:307+60,  y:11+40, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                    
                                    {collection:'control', type:'button_image', name:'stepFrequency_10000_up',      data:{ x:264+0,   y:70.5+0,  width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'stepFrequency_1000_up',       data:{ x:264+15,  y:70.5+0,  width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'stepFrequency_100_up',        data:{ x:264+30,  y:70.5+0,  width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'stepFrequency_10_up',         data:{ x:264+45,  y:70.5+0,  width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'stepFrequency_1_up',          data:{ x:264+60,  y:70.5+0,  width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'stepFrequency_10000_down',    data:{ x:264+0,   y:70.5+40, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'stepFrequency_1000_down',     data:{ x:264+15,  y:70.5+40, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'stepFrequency_100_down',      data:{ x:264+30,  y:70.5+40, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'stepFrequency_10_down',       data:{ x:264+45,  y:70.5+40, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'stepFrequency_1_down',        data:{ x:264+60,  y:70.5+40, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                    
                                    {collection:'control', type:'button_image', name:'waveformSelect_sine', data:{ x:357.5, y:78.5, width:15, height:15, hoverable:false,
                                        backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_sine_up.png', 
                                        backingURL__glow:unitStyle.imageStoreURL_commonPrefix+'button_sine_down.png',
                                        backingURL__glow_press:unitStyle.imageStoreURL_commonPrefix+'button_sine_down.png'
                                    }},
                                    {collection:'control', type:'button_image', name:'waveformSelect_square', data:{ x:348.5, y:96.5, width:15, height:15, hoverable:false,
                                        backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_square_up.png', 
                                        backingURL__glow:unitStyle.imageStoreURL_commonPrefix+'button_square_down.png',
                                        backingURL__glow_press:unitStyle.imageStoreURL_commonPrefix+'button_square_down.png'
                                    }},
                                    {collection:'control', type:'button_image', name:'waveformSelect_triangle', data:{ x:366.5, y:96.5, width:15, height:15, hoverable:false,
                                        backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_triangle_up.png', 
                                        backingURL__glow:unitStyle.imageStoreURL_commonPrefix+'button_triangle_down.png',
                                        backingURL__glow_press:unitStyle.imageStoreURL_commonPrefix+'button_triangle_down.png'
                                    }},
                    
                                    {collection:'control', type:'dial_continuous_image', name:'seconds_per_step', data:{
                                        x:237.5, y:95, radius:30/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, resetValue:0.5, arcDistance:1.2,
                                        handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                    }},
                                    {collection:'control', type:'dial_continuous_image', name:'duty_cycle', data:{
                                        x:325, y:145, radius:30/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, resetValue:0.5, arcDistance:1.2,
                                        handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                    }},
                                    {collection:'control', type:'dial_continuous_image', name:'signalGeneratorGain', data:{
                                        x:367.5, y:145, radius:30/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, resetValue:0.5, arcDistance:1.2,
                                        handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                    }},
                    
                                    {collection:'control', type:'button_image', name:'clear', data:{ x:222.5, y:130, width:20, height:20, hoverable:false,
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_clear_up.png', 
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_clear_down.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'start', data:{ x:250, y:130, width:20, height:20, hoverable:false,
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_start_up.png', 
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_start_down.png',
                                    }},
                                    {collection:'control', type:'button_image', name:'stop', data:{ x:277.5, y:130, width:20, height:20, hoverable:false,
                                        backingURL__up:unitStyle.imageStoreURL_localPrefix+'button_stop_up.png', 
                                        backingURL__press:unitStyle.imageStoreURL_localPrefix+'button_stop_down.png',
                                    }},
                    
                                    {collection:'display', type:'glowbox_circle', name:'progressLED_0', data:{ x:225,       y:157.5, radius:2.5, style:unitStyle.progressLED }},
                                    {collection:'display', type:'glowbox_circle', name:'progressLED_1', data:{ x:225+7.5*1, y:157.5, radius:2.5, style:unitStyle.progressLED }},
                                    {collection:'display', type:'glowbox_circle', name:'progressLED_2', data:{ x:225+7.5*2, y:157.5, radius:2.5, style:unitStyle.progressLED }},
                                    {collection:'display', type:'glowbox_circle', name:'progressLED_3', data:{ x:225+7.5*3, y:157.5, radius:2.5, style:unitStyle.progressLED }},
                                    {collection:'display', type:'glowbox_circle', name:'progressLED_4', data:{ x:225+7.5*4, y:157.5, radius:2.5, style:unitStyle.progressLED }},
                                    {collection:'display', type:'glowbox_circle', name:'progressLED_5', data:{ x:225+7.5*5, y:157.5, radius:2.5, style:unitStyle.progressLED }},
                                    {collection:'display', type:'glowbox_circle', name:'progressLED_6', data:{ x:225+7.5*6, y:157.5, radius:2.5, style:unitStyle.progressLED }},
                                    {collection:'display', type:'glowbox_circle', name:'progressLED_7', data:{ x:225+7.5*7, y:157.5, radius:2.5, style:unitStyle.progressLED }},
                                    {collection:'display', type:'glowbox_circle', name:'progressLED_8', data:{ x:225+7.5*8, y:157.5, radius:2.5, style:unitStyle.progressLED }},
                                    {collection:'display', type:'glowbox_circle', name:'progressLED_9', data:{ x:225+7.5*9, y:157.5, radius:2.5, style:unitStyle.progressLED }},
                                ]
                            });
                    
                        //circuitry
                            const state = {
                                frequencyLimits:{top:20000, bottom:0.001},
                                startFrequencyDigits:[0,0,1,0,0],
                                endFrequencyDigits:[0,1,0,0,0],
                                stepFrequencyDigits:[0,0,0,1,0],
                                waveform:'sine',
                                dutyCycle:0.5,
                                timePerStep:0.05,
                                signalGeneratorGain:1,
                    
                                graphsCollected:[],
                            };
                            frequencyAmplitudeResponseAnalyser = new _canvas_.interface.circuit.frequencyAmplitudeResponseAnalyser(_canvas_.library.audio.context);
                            foolsOutput = new GainNode(_canvas_.library.audio.context); foolsOutput.gain.setValueAtTime(0,0);
                            frequencyAmplitudeResponseAnalyser.producer().connect(foolsOutput).connect(_canvas_.library.audio.destination);
                    
                            function stepFrequencyCharacter(aspect,index,increment){
                                if(increment){
                                    state[aspect+'FrequencyDigits'][index]++;
                                    if(state[aspect+'FrequencyDigits'][index] > 9){ state[aspect+'FrequencyDigits'][index] = 0; }
                                }else{
                                    state[aspect+'FrequencyDigits'][index]--;
                                    if(state[aspect+'FrequencyDigits'][index] < 0){ state[aspect+'FrequencyDigits'][index] = 9; }
                                }
                                updateFrequency();
                            }
                            function updateFrequency(){
                                ['start','end','step'].forEach(aspect => {
                                    let frequency = parseFloat(state[aspect+'FrequencyDigits'].join(''));
                                    if( frequency > state.frequencyLimits.top){
                                        state[aspect+'FrequencyDigits'] = [2,0,0,0,0];
                                    }else if(frequency < state.frequencyLimits.bottom){ 
                                        state[aspect+'FrequencyDigits'] = [0,0,0,0,1];
                                    }
                                    frequency = state[aspect+'FrequencyDigits'].join('');
                    
                                    object.elements.readout_sevenSegmentDisplay['LCD_'+aspect+'Frequency'].text( frequency );
                                    object.elements.readout_sevenSegmentDisplay['LCD_'+aspect+'Frequency'].print();
                                });
                    
                                frequencyAmplitudeResponseAnalyser.range( parseInt(state.startFrequencyDigits.join('')), parseInt(state.endFrequencyDigits.join('')) );
                                frequencyAmplitudeResponseAnalyser.stepSize( parseInt(state.stepFrequencyDigits.join('')) );
                                updateViewbox();
                                graphLine();
                            }
                            function selectWaveform(waveform){
                                if(state.waveform == waveform){ return; }
                                object.elements.button_image['waveformSelect_'+state.waveform].glow(false);
                                state.waveform = waveform;
                                object.elements.button_image['waveformSelect_'+state.waveform].glow(true);
                    
                                frequencyAmplitudeResponseAnalyser.waveform(waveform);
                            }
                            function updateViewbox(){
                                const startFrequency = parseInt(state.startFrequencyDigits.join(''));
                                const endFrequency = parseInt(state.endFrequencyDigits.join(''));
                                object.elements.grapher.waveport.viewbox( {bottom:0, top:2, left:startFrequency, right:endFrequency} );
                    
                                const scale = Math.pow(10,Math.round(Math.log10(endFrequency)))/10;
                    
                                let counter = startFrequency;
                                let markings = [];
                                while(counter < endFrequency){
                                    markings.push(counter);
                                    counter = counter+scale;
                                }
                    
                                object.elements.grapher.waveport.verticalMarkings({ points:markings });
                    
                                object.elements.grapher.waveport.drawBackground();
                            }
                            function clearScreen(){
                                frequencyAmplitudeResponseAnalyser.clear();
                                object.elements.grapher.waveport.clearAll();
                                updateViewbox();
                                state.graphsCollected = [];
                                
                                for(let a = 0; a < graphMemoryCount; a++){
                                    object.elements.grapher.waveport.drawForeground(undefined,undefined,a);
                                }
                            }
                            function graphLine(){
                                state.graphsCollected.forEach((data,index) => {
                                    let Y = [];
                                    let X = [];
                    
                                    data.forEach(point => {
                                        Y.push(point.response);
                                        X.push(point.frequency);
                                    });
                    
                                    object.elements.grapher.waveport.drawForeground(Y,X, (graphMemoryCount-1) - (state.graphsCollected.length-1-index));
                                });
                            }
                            frequencyAmplitudeResponseAnalyser.onCompletion = function(data){
                                state.graphsCollected.push(data);
                                if(state.graphsCollected.length > graphMemoryCount){
                                    state.graphsCollected.shift();
                                }
                                graphLine();
                                frequencyAmplitudeResponseAnalyser.clear();
                                thawControls();
                            };
                            function LEDprogress(value){
                                value *= 10;
                                for(let a = 0; a < value; a++){
                                    object.elements.glowbox_circle['progressLED_'+a].on();
                                }
                                for(let a = value; a < 10; a++){
                                    object.elements.glowbox_circle['progressLED_'+a].off();
                                }
                            }
                            frequencyAmplitudeResponseAnalyser.onValue = function(data){
                                const startFrequency = parseInt(state.startFrequencyDigits.join(''));
                                const endFrequency = parseInt(state.endFrequencyDigits.join(''));
                                LEDprogress( Math.round(10*(data.frequency - startFrequency) / (endFrequency - startFrequency))/10 );
                            };
                            function freezeControls(){
                                object.elements.dial_continuous_image.seconds_per_step.interactable(false);
                                object.elements.dial_continuous_image.duty_cycle.interactable(false);
                                object.elements.dial_continuous_image.signalGeneratorGain.interactable(false);
                    
                                object.elements.button_image.waveformSelect_sine.interactable(false);
                                object.elements.button_image.waveformSelect_square.interactable(false);
                                object.elements.button_image.waveformSelect_triangle.interactable(false);
                    
                                object.elements.button_image.startFrequency_10000_up.interactable(false);
                                object.elements.button_image.startFrequency_1000_up.interactable(false);
                                object.elements.button_image.startFrequency_100_up.interactable(false);
                                object.elements.button_image.startFrequency_10_up.interactable(false);
                                object.elements.button_image.startFrequency_1_up.interactable(false);
                                object.elements.button_image.startFrequency_10000_down.interactable(false);
                                object.elements.button_image.startFrequency_1000_down.interactable(false);
                                object.elements.button_image.startFrequency_100_down.interactable(false);
                                object.elements.button_image.startFrequency_10_down.interactable(false);
                                object.elements.button_image.startFrequency_1_down.interactable(false);
                                object.elements.button_image.endFrequency_10000_up.interactable(false);
                                object.elements.button_image.endFrequency_1000_up.interactable(false);
                                object.elements.button_image.endFrequency_100_up.interactable(false);
                                object.elements.button_image.endFrequency_10_up.interactable(false);
                                object.elements.button_image.endFrequency_1_up.interactable(false);
                                object.elements.button_image.endFrequency_10000_down.interactable(false);
                                object.elements.button_image.endFrequency_1000_down.interactable(false);
                                object.elements.button_image.endFrequency_100_down.interactable(false);
                                object.elements.button_image.endFrequency_10_down.interactable(false);
                                object.elements.button_image.endFrequency_1_down.interactable(false);
                                object.elements.button_image.stepFrequency_10000_up.interactable(false);
                                object.elements.button_image.stepFrequency_1000_up.interactable(false);
                                object.elements.button_image.stepFrequency_100_up.interactable(false);
                                object.elements.button_image.stepFrequency_10_up.interactable(false);
                                object.elements.button_image.stepFrequency_1_up.interactable(false);
                                object.elements.button_image.stepFrequency_10000_down.interactable(false);
                                object.elements.button_image.stepFrequency_1000_down.interactable(false);
                                object.elements.button_image.stepFrequency_100_down.interactable(false);
                                object.elements.button_image.stepFrequency_10_down.interactable(false);
                                object.elements.button_image.stepFrequency_1_down.interactable(false);
                            }
                            function thawControls(){
                                object.elements.dial_continuous_image.seconds_per_step.interactable(true);
                                object.elements.dial_continuous_image.duty_cycle.interactable(true);
                                object.elements.dial_continuous_image.signalGeneratorGain.interactable(true);
                    
                                object.elements.button_image.waveformSelect_sine.interactable(true);
                                object.elements.button_image.waveformSelect_square.interactable(true);
                                object.elements.button_image.waveformSelect_triangle.interactable(true);
                    
                                object.elements.button_image.startFrequency_10000_up.interactable(true);
                                object.elements.button_image.startFrequency_1000_up.interactable(true);
                                object.elements.button_image.startFrequency_100_up.interactable(true);
                                object.elements.button_image.startFrequency_10_up.interactable(true);
                                object.elements.button_image.startFrequency_1_up.interactable(true);
                                object.elements.button_image.startFrequency_10000_down.interactable(true);
                                object.elements.button_image.startFrequency_1000_down.interactable(true);
                                object.elements.button_image.startFrequency_100_down.interactable(true);
                                object.elements.button_image.startFrequency_10_down.interactable(true);
                                object.elements.button_image.startFrequency_1_down.interactable(true);
                                object.elements.button_image.endFrequency_10000_up.interactable(true);
                                object.elements.button_image.endFrequency_1000_up.interactable(true);
                                object.elements.button_image.endFrequency_100_up.interactable(true);
                                object.elements.button_image.endFrequency_10_up.interactable(true);
                                object.elements.button_image.endFrequency_1_up.interactable(true);
                                object.elements.button_image.endFrequency_10000_down.interactable(true);
                                object.elements.button_image.endFrequency_1000_down.interactable(true);
                                object.elements.button_image.endFrequency_100_down.interactable(true);
                                object.elements.button_image.endFrequency_10_down.interactable(true);
                                object.elements.button_image.endFrequency_1_down.interactable(true);
                                object.elements.button_image.stepFrequency_10000_up.interactable(true);
                                object.elements.button_image.stepFrequency_1000_up.interactable(true);
                                object.elements.button_image.stepFrequency_100_up.interactable(true);
                                object.elements.button_image.stepFrequency_10_up.interactable(true);
                                object.elements.button_image.stepFrequency_1_up.interactable(true);
                                object.elements.button_image.stepFrequency_10000_down.interactable(true);
                                object.elements.button_image.stepFrequency_1000_down.interactable(true);
                                object.elements.button_image.stepFrequency_100_down.interactable(true);
                                object.elements.button_image.stepFrequency_10_down.interactable(true);
                                object.elements.button_image.stepFrequency_1_down.interactable(true);
                            }
                    
                        //wiring
                            //hid
                                object.elements.button_image.clear.onpress = function(){
                                    frequencyAmplitudeResponseAnalyser.clear();
                                    clearScreen();
                                };
                                object.elements.button_image.start.onpress = function(){
                                    LEDprogress(0);
                                    frequencyAmplitudeResponseAnalyser.start();
                                    freezeControls();
                                };
                                object.elements.button_image.stop.onpress = function(){
                                    frequencyAmplitudeResponseAnalyser.stop();
                                    thawControls();
                                };
                                object.elements.dial_continuous_image.seconds_per_step.onchange = function(value){
                                    if(value == 0){ value = 0.001; }
                                    state.timePerStep = value/10;
                                    frequencyAmplitudeResponseAnalyser.timePerStep(state.timePerStep);
                                };
                                object.elements.dial_continuous_image.duty_cycle.onchange = function(value){
                                    state.dutyCycle = value;
                                    frequencyAmplitudeResponseAnalyser.dutyCycle(value);
                                };
                                object.elements.dial_continuous_image.signalGeneratorGain.onchange = function(value){
                                    state.signalGeneratorGain = value*2;
                                    frequencyAmplitudeResponseAnalyser.signalGeneratorGain(state.signalGeneratorGain);
                                };
                                object.elements.button_image.waveformSelect_sine.onpress = function(){
                                    selectWaveform('sine'); 
                                };
                                object.elements.button_image.waveformSelect_triangle.onpress = function(){
                                    selectWaveform('triangle'); 
                                };
                                object.elements.button_image.waveformSelect_square.onpress = function(){
                                    selectWaveform('square'); 
                                };
                                object.elements.button_image['startFrequency_10000_up'].onpress = function(){   stepFrequencyCharacter('start',0,true); };
                                object.elements.button_image['startFrequency_1000_up'].onpress = function(){    stepFrequencyCharacter('start',1,true); };
                                object.elements.button_image['startFrequency_100_up'].onpress = function(){     stepFrequencyCharacter('start',2,true); };
                                object.elements.button_image['startFrequency_10_up'].onpress = function(){      stepFrequencyCharacter('start',3,true); };
                                object.elements.button_image['startFrequency_1_up'].onpress = function(){       stepFrequencyCharacter('start',4,true); };
                                object.elements.button_image['startFrequency_10000_down'].onpress = function(){ stepFrequencyCharacter('start',0,false); };
                                object.elements.button_image['startFrequency_1000_down'].onpress = function(){  stepFrequencyCharacter('start',1,false); };
                                object.elements.button_image['startFrequency_100_down'].onpress = function(){   stepFrequencyCharacter('start',2,false); };
                                object.elements.button_image['startFrequency_10_down'].onpress = function(){    stepFrequencyCharacter('start',3,false); };
                                object.elements.button_image['startFrequency_1_down'].onpress = function(){     stepFrequencyCharacter('start',4,false); };
                                object.elements.button_image['endFrequency_10000_up'].onpress = function(){   stepFrequencyCharacter('end',0,true); };
                                object.elements.button_image['endFrequency_1000_up'].onpress = function(){    stepFrequencyCharacter('end',1,true); };
                                object.elements.button_image['endFrequency_100_up'].onpress = function(){     stepFrequencyCharacter('end',2,true); };
                                object.elements.button_image['endFrequency_10_up'].onpress = function(){      stepFrequencyCharacter('end',3,true); };
                                object.elements.button_image['endFrequency_1_up'].onpress = function(){       stepFrequencyCharacter('end',4,true); };
                                object.elements.button_image['endFrequency_10000_down'].onpress = function(){ stepFrequencyCharacter('end',0,false); };
                                object.elements.button_image['endFrequency_1000_down'].onpress = function(){  stepFrequencyCharacter('end',1,false); };
                                object.elements.button_image['endFrequency_100_down'].onpress = function(){   stepFrequencyCharacter('end',2,false); };
                                object.elements.button_image['endFrequency_10_down'].onpress = function(){    stepFrequencyCharacter('end',3,false); };
                                object.elements.button_image['endFrequency_1_down'].onpress = function(){     stepFrequencyCharacter('end',4,false); };
                                object.elements.button_image['stepFrequency_10000_up'].onpress = function(){   stepFrequencyCharacter('step',0,true); };
                                object.elements.button_image['stepFrequency_1000_up'].onpress = function(){    stepFrequencyCharacter('step',1,true); };
                                object.elements.button_image['stepFrequency_100_up'].onpress = function(){     stepFrequencyCharacter('step',2,true); };
                                object.elements.button_image['stepFrequency_10_up'].onpress = function(){      stepFrequencyCharacter('step',3,true); };
                                object.elements.button_image['stepFrequency_1_up'].onpress = function(){       stepFrequencyCharacter('step',4,true); };
                                object.elements.button_image['stepFrequency_10000_down'].onpress = function(){ stepFrequencyCharacter('step',0,false); };
                                object.elements.button_image['stepFrequency_1000_down'].onpress = function(){  stepFrequencyCharacter('step',1,false); };
                                object.elements.button_image['stepFrequency_100_down'].onpress = function(){   stepFrequencyCharacter('step',2,false); };
                                object.elements.button_image['stepFrequency_10_down'].onpress = function(){    stepFrequencyCharacter('step',3,false); };
                                object.elements.button_image['stepFrequency_1_down'].onpress = function(){     stepFrequencyCharacter('step',4,false); };
                    
                            //io
                                object.io.audio.producer.audioNode = frequencyAmplitudeResponseAnalyser.producer();
                                object.io.audio.consumer.audioNode = frequencyAmplitudeResponseAnalyser.consumer();
                    
                        //interface
                            object.i = {
                                clear:function(){ 
                                    object.elements.button_image.clear.press();
                                    object.elements.button_image.clear.release();
                                },
                                start:function(){
                                    object.elements.button_image.start.press();
                                    object.elements.button_image.start.release();
                                },
                                stop:function(){ 
                                    object.elements.button_image.stop.press();
                                    object.elements.button_image.stop.release();
                                },
                    
                                range:function(start,end){
                                    if(start == undefined || end == undefined){
                                        return {
                                            start: parseInt(state.startFrequencyDigits.join('')),
                                            end: parseInt(state.endFrequencyDigits.join('')),
                                        };
                                    }
                    
                                    state.startFrequencyDigits = _canvas_.library.misc.padString(String(start),5,'0').split('').map(a => parseInt(a));
                                    state.endFrequencyDigits = _canvas_.library.misc.padString(String(end),5,'0').split('').map(a => parseInt(a));
                                    updateFrequency();
                                },
                                stepSize:function(step){
                                    if(step == undefined){
                                        return parseInt(state.FrequencyDigits.join(''));
                                    }
                                    state.stepFrequencyDigits = _canvas_.library.misc.padString(String(step),5,'0').split('').map(a => parseInt(a));
                                    updateFrequency();
                                },
                                timePerStep:function(time){
                                    if(time == undefined){
                                        return state.timePerStep;
                                    }
                                    object.elements.dial_continuous_image.seconds_per_step.set( time*10 );
                                },
                    
                                dutyCycle:function(ratio){
                                    if(ratio == undefined){
                                        return object.elements.dial_continuous_image.duty_cycle.get();
                                    }
                                    object.elements.dial_continuous_image.duty_cycle.set(ratio);
                                },
                                signalGeneratorGain:function(gain){
                                    if(gain == undefined){
                                        return state.signalGeneratorGain;
                                    }
                                    object.elements.dial_continuous_image.signalGeneratorGain.set(gain/2);
                                },
                                waveform:function(waveform){
                                    if(waveform == undefined){
                                        return state.waveform;
                                    }
                                    selectWaveform(waveform);
                                },
                            };
                    
                        //import/export
                            object.exportData = function(){
                                return JSON.parse(JSON.stringify(state));
                            };
                            object.importData = function(data){
                                state.startFrequencyDigits = data.startFrequencyDigits;
                                state.endFrequencyDigits = data.endFrequencyDigits;
                                state.stepFrequencyDigits = data.stepFrequencyDigits;
                                updateFrequency();
                    
                                selectWaveform(data.waveform);
                    
                                object.i.timePerStep(data.timePerStep);
                                object.i.dutyCycle(data.dutyCycle);
                                object.i.signalGeneratorGain(data.signalGeneratorGain);
                            };
                    
                        //setup/tearDown
                            object.oncreate = function(){
                                object.elements.grapher.waveport.horizontalMarkings({points:[2, 1.75, 1.5, 1.25, 1, 0.75, 0.5, 0.25, 0]});
                                object.elements.grapher.waveport.verticalMarkings({mappedPosition:1});
                                object.elements.dial_continuous_image.seconds_per_step.set(0.5);
                                clearScreen();
                                object.elements.button_image.waveformSelect_sine.glow(true);
                                updateFrequency();
                            };
                            
                        return object;
                    };
                    this['frequency_amplitude_response_workstation'].metadata = {
                        name:'F/AR Workstation',
                        category:'',
                        helpURL:''
                    };
                    this['frequency_generator'] = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_commonPrefix = imageStoreURL+'common/';
                                    this.imageStoreURL_localPrefix = imageStoreURL+'frequency_generator/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = { 
                                        file: { width:1900, height:1050 },
                                        design: { width:19, height:10.5 },
                                    };
                    
                                    this.offset = {x:0,y:0};
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'frequency_generator',
                                x:x, y:y, angle:angle,
                                space:[
                                    {x:-unitStyle.offset.x,                               y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                    {x:-unitStyle.offset.x,                               y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'voltage_gain', data:{ 
                                        x:45, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'control_gain', data:{ 
                                        x:20, y:unitStyle.drawingValue.height, width:5, height:15, angle:Math.PI/2, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'voltage_detune', data:{ 
                                        x:100, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'control_detune', data:{ 
                                        x:75, y:unitStyle.drawingValue.height, width:5, height:15, angle:Math.PI/2, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'voltage_adjust', data:{ 
                                        x:155, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'control_adjust', data:{ 
                                        x:130, y:unitStyle.drawingValue.height, width:5, height:15, angle:Math.PI/2, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'output', data:{ 
                                        x:0, y:unitStyle.drawingValue.height/2 + 15/2, width:5, height:15, angle:Math.PI, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:-unitStyle.offset.x, y:-unitStyle.offset.y, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png' }
                                    },
                    
                                    {collection:'display', type:'readout_sevenSegmentDisplay', name:'LCD', data:{ 
                                        x:10+0.5, y:20+0.5, width:119-1, height:29.5-1, canvasBased:true, count:8, decimalPlaces:true, style:unitStyle.LCD, resolution:5,
                                    }},
                    
                                    {collection:'control', type:'button_image', name:'waveformSelect_sine', data:{ x:133.5, y:18.5, width:15, height:15, hoverable:false,
                                        backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_sine_up.png', 
                                        backingURL__glow:unitStyle.imageStoreURL_commonPrefix+'button_sine_down.png',
                                        backingURL__glow_press:unitStyle.imageStoreURL_commonPrefix+'button_sine_down.png'
                                    }},
                                    {collection:'control', type:'button_image', name:'waveformSelect_triangle', data:{ x:151.5, y:18.5, width:15, height:15, hoverable:false,
                                        backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_triangle_up.png', 
                                        backingURL__glow:unitStyle.imageStoreURL_commonPrefix+'button_triangle_down.png',
                                        backingURL__glow_press:unitStyle.imageStoreURL_commonPrefix+'button_triangle_down.png'
                                    }},
                                    {collection:'control', type:'button_image', name:'waveformSelect_square', data:{ x:133.5, y:36.5, width:15, height:15, hoverable:false,
                                        backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_square_up.png', 
                                        backingURL__glow:unitStyle.imageStoreURL_commonPrefix+'button_square_down.png',
                                        backingURL__glow_press:unitStyle.imageStoreURL_commonPrefix+'button_square_down.png'
                                    }},
                                    {collection:'control', type:'button_image', name:'waveformSelect_noise', data:{ x:151.5, y:36.5, width:15, height:15, hoverable:false,
                                        backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_noise_up.png', 
                                        backingURL__glow:unitStyle.imageStoreURL_commonPrefix+'button_noise_down.png',
                                        backingURL__glow_press:unitStyle.imageStoreURL_commonPrefix+'button_noise_down.png'
                                    }},
                    
                                    {collection:'control', type:'button_image', name:'10000_up',    data:{ x:10, y:10, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'1000_up',     data:{ x:25, y:10, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'100_up',      data:{ x:40, y:10, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'10_up',       data:{ x:55, y:10, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'1_up',        data:{ x:70, y:10, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'0.1_up',      data:{ x:85, y:10, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'0.01_up',     data:{ x:100, y:10, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'0.001_up',    data:{ x:115, y:10, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'10000_down',  data:{ x:10, y:50, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'1000_down',   data:{ x:25, y:50, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'100_down',    data:{ x:40, y:50, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'10_down',     data:{ x:55, y:50, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'1_down',      data:{ x:70, y:50, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'0.1_down',    data:{ x:85, y:50, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'0.01_down',   data:{ x:100, y:50, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                                    {collection:'control', type:'button_image', name:'0.001_down',  data:{ x:115, y:50, width:14, height:9, hoverable:false, backingURL__up:unitStyle.imageStoreURL_commonPrefix+'button_tab_up.png', backingURL__press:unitStyle.imageStoreURL_commonPrefix+'button_tab_down.png' }},
                    
                                    {collection:'control', type:'dial_continuous_image', name:'gain', data:{
                                        x:40, y:80, radius:30/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI,value:1, resetValue:0.5, arcDistance:1.2,
                                        handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                    }},
                                    {collection:'control', type:'dial_continuous_image', name:'detune', data:{
                                        x:95, y:80, radius:30/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI,value:0.5, resetValue:0.5, arcDistance:1.2,
                                        handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                    }},
                                    {collection:'control', type:'dial_continuous_image', name:'adjust', data:{
                                        x:150, y:80, radius:30/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI,value:0.5, resetValue:0.5, arcDistance:1.2,
                                        handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                    }},
                                    {collection:'control', type:'checkbox_image', name:'gain_mode', data:{
                                        x:7.5, y:70, width:10, height:20,
                                        uncheckURL:unitStyle.imageStoreURL_commonPrefix+'switch_large_up.png', 
                                        checkURL:unitStyle.imageStoreURL_commonPrefix+'switch_large_down.png',
                                    }},
                                    {collection:'control', type:'checkbox_image', name:'detune_mode', data:{
                                        x:62.5, y:70, width:10, height:20,
                                        uncheckURL:unitStyle.imageStoreURL_commonPrefix+'switch_large_up.png', 
                                        checkURL:unitStyle.imageStoreURL_commonPrefix+'switch_large_down.png',
                                    }},
                                    {collection:'control', type:'checkbox_image', name:'adjust_mode', data:{
                                        x:117.5, y:70, width:10, height:20,
                                        uncheckURL:unitStyle.imageStoreURL_commonPrefix+'switch_large_up.png', 
                                        checkURL:unitStyle.imageStoreURL_commonPrefix+'switch_large_down.png',
                                    }},
                                ]
                            });
                    
                        //circuitry
                            const state = {
                                frequencyLimits:{top:20000, bottom:0.001},
                                frequencyDigits:[0,0,1,0,0,0,0,0],
                                waveform:'sine',
                                gain:1,
                                detune:0,
                                adjust:0.5,
                                gain_mode:false,
                                detune_mode:false,
                                adjust_mode:false,
                            };
                            const oscillator = new _canvas_.interface.circuit.oscillator(_canvas_.library.audio.context);
                            function stepFrequencyCharacter(index,increment){
                                if(increment){
                                    state.frequencyDigits[index]++;
                                    if(state.frequencyDigits[index] > 9){ state.frequencyDigits[index] = 0; }
                                }else{
                                    state.frequencyDigits[index]--;
                                    if(state.frequencyDigits[index] < 0){ state.frequencyDigits[index] = 9; }
                                }
                                updateFrequency();
                            }
                            function updateFrequency(){
                                let frequency = parseFloat(state.frequencyDigits.slice(0,5).join('') +'.'+ state.frequencyDigits.slice(5).join(''));
                                if( frequency > state.frequencyLimits.top){
                                    state.frequencyDigits = [2,0,0,0,0,0,0,0];
                                }else if(frequency < state.frequencyLimits.bottom){ 
                                    state.frequencyDigits = [0,0,0,0,0,0,0,1];
                                }
                                frequency = state.frequencyDigits.slice(0,5).join('') +'.'+ state.frequencyDigits.slice(5).join('');
                    
                                object.elements.readout_sevenSegmentDisplay.LCD.text( frequency );
                                object.elements.readout_sevenSegmentDisplay.LCD.print();
                    
                                oscillator.frequency(parseFloat(frequency));
                            }
                            function selectWaveform(waveform){
                                if(state.waveform == waveform){ return; }
                                object.elements.button_image['waveformSelect_'+state.waveform].glow(false);
                                state.waveform = waveform;
                                object.elements.button_image['waveformSelect_'+state.waveform].glow(true);
                    
                                oscillator.waveform(
                                    ['sine','square','triangle','noise'].indexOf(waveform)
                                );
                            }
                    
                        //wiring
                            //hid
                                object.elements.button_image.waveformSelect_sine.onpress = function(){ selectWaveform('sine'); };
                                object.elements.button_image.waveformSelect_triangle.onpress = function(){ selectWaveform('triangle'); };
                                object.elements.button_image.waveformSelect_square.onpress = function(){ selectWaveform('square'); };
                                object.elements.button_image.waveformSelect_noise.onpress = function(){ selectWaveform('noise'); };
                                
                                object.elements.button_image['10000_up'].onpress = function(){   stepFrequencyCharacter(0,true); };
                                object.elements.button_image['1000_up'].onpress = function(){    stepFrequencyCharacter(1,true); };
                                object.elements.button_image['100_up'].onpress = function(){     stepFrequencyCharacter(2,true); };
                                object.elements.button_image['10_up'].onpress = function(){      stepFrequencyCharacter(3,true); };
                                object.elements.button_image['1_up'].onpress = function(){       stepFrequencyCharacter(4,true); };
                                object.elements.button_image['0.1_up'].onpress = function(){     stepFrequencyCharacter(5,true); };
                                object.elements.button_image['0.01_up'].onpress = function(){    stepFrequencyCharacter(6,true); };
                                object.elements.button_image['0.001_up'].onpress = function(){   stepFrequencyCharacter(7,true); };
                                object.elements.button_image['10000_down'].onpress = function(){ stepFrequencyCharacter(0,false); };
                                object.elements.button_image['1000_down'].onpress = function(){  stepFrequencyCharacter(1,false); };
                                object.elements.button_image['100_down'].onpress = function(){   stepFrequencyCharacter(2,false); };
                                object.elements.button_image['10_down'].onpress = function(){    stepFrequencyCharacter(3,false); };
                                object.elements.button_image['1_down'].onpress = function(){     stepFrequencyCharacter(4,false); };
                                object.elements.button_image['0.1_down'].onpress = function(){   stepFrequencyCharacter(5,false); };
                                object.elements.button_image['0.01_down'].onpress = function(){  stepFrequencyCharacter(6,false); };
                                object.elements.button_image['0.001_down'].onpress = function(){ stepFrequencyCharacter(7,false); };
                    
                                object.elements.dial_continuous_image.gain.onchange = function(value){ 
                                    state.gain = value;
                                    oscillator.gain(value*2 - 1);
                                };
                                object.elements.dial_continuous_image.detune.onchange = function(value){ 
                                    state.detune = value;
                                    oscillator.detune(value*2 - 1);
                                };
                                object.elements.dial_continuous_image.adjust.onchange = function(value){ 
                                    state.adjust = value;
                                    oscillator.dutyCycle(value);
                                };
                                object.elements.checkbox_image.gain_mode.onchange = function(value){ 
                                    state.gain_mode = value;
                                    oscillator.gainMode(value?1:0);
                                };
                                object.elements.checkbox_image.detune_mode.onchange = function(value){ 
                                    state.detune_mode = value;
                                    oscillator.detuneMode(value?1:0);
                                };
                                object.elements.checkbox_image.adjust_mode.onchange = function(value){ 
                                    state.adjust_mode = value;
                                    oscillator.dutyCycleMode(value?1:0);
                                };
                    
                            //io
                                object.io.voltage.voltage_gain.onchange = function(value){
                                    object.elements.dial_continuous_image.gain.set( (value+1)/2 );
                                };
                                object.io.voltage.voltage_detune.onchange = function(value){
                                    object.elements.dial_continuous_image.detune.set( (value+1)/2 );
                                };
                                object.io.voltage.voltage_adjust.onchange = function(value){
                                    object.elements.dial_continuous_image.adjust.set(value);
                                };
                                object.io.audio.control_gain.audioNode = oscillator.gainControl();
                                object.io.audio.control_detune.audioNode = oscillator.detuneControl();
                                object.io.audio.control_adjust.audioNode = oscillator.dutyCycleControl();
                                object.io.audio.output.audioNode = oscillator.out();
                    
                        //interface
                            object.i = {
                                frequency:function(value){
                                    if(value == undefined){ return parseFloat(state.frequencyDigits.slice(0,5).join('') +'.'+ state.frequencyDigits.slice(5).join('')); }
                    
                                    if( value > state.frequencyLimits.top){
                                        value = 20000;
                                    }else if(value < state.frequencyLimits.bottom){ 
                                        value = 0.001;
                                    }
                    
                                    const sides = String(value).split('.');
                                    _canvas_.library.misc.padString(String(sides[0]).split('.')[0],5,'0').split('').forEach((value,index) => {
                                        state.frequencyDigits[index] = value;
                                    });
                                    if(sides.length > 1){
                                        _canvas_.library.misc.padString(String(sides[1]).split('.')[0],3,'0','r').split('').forEach((value,index) => {
                                            state.frequencyDigits[index+5] = value;
                                        });
                                    }
                    
                                    updateFrequency();
                                },
                                waveform:function(wavename){
                                    if(wavename == undefined){ return state.waveform; }
                                    selectWaveform(wavename);
                                },
                                gain:function(value){
                                    if(value == undefined){ return state.gain; }
                                    object.elements.dial_continuous_image.gain.set((value+1)/2);
                                },
                                detune:function(value){
                                    if(value == undefined){ return state.detune; }
                                    object.elements.dial_continuous_image.detune.set((value+1)/2);
                                },
                                adjust:function(value){
                                    if(value == undefined){ return state.adjust; }
                                    object.elements.dial_continuous_image.adjust.set(value);
                                },
                                gainMode:function(bool){
                                    if(bool == undefined){ return state.gain_mode; }
                                    object.elements.checkbox_image.gain_mode.set(bool);
                                },
                                detuneMode:function(bool){
                                    if(bool == undefined){ return state.detune_mode; }
                                    object.elements.checkbox_image.detune_mode.set(bool);
                                },
                                adjustMode:function(bool){
                                    if(bool == undefined){ return state.adjust_mode; }
                                    object.elements.checkbox_image.adjust_mode.set(bool);
                                },
                            };
                    
                        //import/export
                            object.exportData = function(){
                                return JSON.parse(JSON.stringify(state));
                            };
                            object.importData = function(data){
                                state.frequencyDigits = data.frequencyDigits;
                                updateFrequency();
                                selectWaveform(data.waveform);
                                object.elements.dial_continuous_image.gain.set((data.gain+1)/2);
                                object.elements.dial_continuous_image.detune.set((data.detune+1)/2);
                                object.elements.dial_continuous_image.adjust.set(data.adjust);
                                object.elements.checkbox_image.gain_mode.set(data.gain_mode);
                                object.elements.checkbox_image.detune_mode.set(data.detune_mode);
                                object.elements.checkbox_image.adjust_mode.set(data.adjust_mode);
                            };
                    
                        //oncreate/ondelete
                            object.oncreate = function(){
                                updateFrequency();
                                object.elements.button_image.waveformSelect_sine.glow(true);
                            };
                        
                        return object;
                    };
                    this['frequency_generator'].metadata = {
                        name:'Frequency Generator',
                        category:'',
                        helpURL:''
                    };
                    this['bitcrusher'] = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_commonPrefix = imageStoreURL+'common/';
                                    this.imageStoreURL_localPrefix = imageStoreURL+'bitcrusher/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = { 
                                        file: { width:1050, height:600 },
                                        design: { width:10.5, height:6 },
                                    };
                    
                                    this.offset = {x:0,y:0};
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'bitcrusher',
                                x:x, y:y, angle:angle,
                                space:[
                                    {x:-unitStyle.offset.x,                               y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                    {x:-unitStyle.offset.x,                               y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_audio', name:'input', data:{ 
                                        x:unitStyle.drawingValue.width, y:22.5, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'output', data:{ 
                                        x:0, y:37.5, width:5, height:15, angle:Math.PI, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'voltage_amplitudeResolution', data:{ 
                                        x:30, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'voltage_sampleFrequency', data:{ 
                                        x:70, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:-unitStyle.offset.x, y:-unitStyle.offset.y, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png' }
                                    },
                    
                                    {collection:'control', type:'dial_continuous_image', name:'amplitudeResolution', data:{
                                        x:25, y:30, radius:30/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, optionCount:128, 
                                        handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                    }},
                                    {collection:'control', type:'dial_discrete_image', name:'sampleFrequency', data:{
                                        x:65, y:30, radius:30/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2, optionCount:8, 
                                        handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                    }},
                                ]
                            });
                    
                        //circuitry
                            const state = {
                                amplitudeResolution:0.425,
                                sampleFrequency:4,
                            };
                            const bitcrusher = new _canvas_.interface.circuit.bitcrusher(_canvas_.library.audio.context);
                    
                        //wiring
                            //hid
                                object.elements.dial_continuous_image.amplitudeResolution.onchange = function(value){
                                    bitcrusher.amplitudeResolution( Math.pow(2,value*7) );
                                    state.amplitudeResolution = value;
                                };
                                object.elements.dial_discrete_image.sampleFrequency.onchange = function(value){
                                    bitcrusher.sampleFrequency(Math.pow(2, value));
                                    state.sampleFrequency = value;
                                };
                    
                            //io
                                object.io.audio.input.audioNode = bitcrusher.in();
                                object.io.audio.output.audioNode = bitcrusher.out();
                                object.io.voltage.voltage_amplitudeResolution.onchange = function(value){
                                    object.elements.dial_continuous_image.amplitudeResolution.set(value);
                                };
                                object.io.voltage.voltage_sampleFrequency.onchange = function(value){
                                    object.elements.dial_discrete_image.sampleFrequency.set(Math.round(value*7));
                                };
                    
                        //interface
                            object.i = {
                                amplitudeResolution:function(a){
                                    if(a == undefined){ return bitcrusher.amplitudeResolution(); }
                                    object.elements.dial_continuous_image.amplitudeResolution.set( Math.log2(a)/7 );
                                },
                                sampleFrequency:function(a){
                                    if(a == undefined){ return bitcrusher.sampleFrequency(); }
                                    if( ![1,2,4,8,16,32,64,128].includes(a) ){ return; }
                                    object.elements.dial_discrete_image.sampleFrequency.set( Math.log2(a) );
                                },
                            };
                    
                        //import/export
                            object.exportData = function(){
                                return JSON.parse(JSON.stringify(state));
                            };
                            object.importData = function(data){
                                object.elements.dial_continuous_image.amplitudeResolution.set( data.amplitudeResolution );
                                object.elements.dial_discrete_image.sampleFrequency.set( data.sampleFrequency );
                            };
                    
                        //setup/tearDown
                            object.oncreate = function(){
                                object.elements.dial_continuous_image.amplitudeResolution.set(0.425);
                                object.elements.dial_discrete_image.sampleFrequency.set(4);
                            };
                    
                        return object;
                    };
                    this['bitcrusher'].metadata = {
                        name:'Bitcrusher',
                        category:'',
                        helpURL:''
                    };
                    this['stable_amplitude_generator'] = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_commonPrefix = imageStoreURL+'common/';
                                    this.imageStoreURL_localPrefix = imageStoreURL+'stable_amplitude_generator/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = { 
                                        file: { width:750, height:600 },
                                        design: { width:7.5, height:6 },
                                    };
                    
                                    this.offset = {x:0,y:0};
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'stable_amplitude_generator',
                                x:x, y:y, angle:angle,
                                space:[
                                    {x:-unitStyle.offset.x,                               y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                    {x:-unitStyle.offset.x,                               y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_audio', name:'output', data:{ 
                                        x:0, y:unitStyle.drawingValue.height/2 + 15/2, width:5, height:15, angle:Math.PI, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'voltage', data:{ 
                                        x:unitStyle.drawingValue.width/2 - 2.5, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:-unitStyle.offset.x, y:-unitStyle.offset.y, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png' }
                                    },
                    
                                    {collection:'control', type:'dial_continuous_image', name:'amplitude', data:{
                                        x:30, y:30, radius:30/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, resetValue:0.5, arcDistance:1.2,
                                        handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                    }},
                                ]
                            });
                    
                        //circuitry
                            const state = {
                                amplitude:0,
                                amplitude_dial:0.5,
                            };
                            const stableAmplitudeGenerator = new _canvas_.interface.circuit.stableAmplitudeGenerator(_canvas_.library.audio.context);
                    
                        //wiring
                            //hid
                                object.elements.dial_continuous_image.amplitude.onchange = function(value){
                                    state.amplitude_dial = value;
                                    state.amplitude = value*2 - 1;
                                    stableAmplitudeGenerator.amplitude( state.amplitude );
                                };
                            //io
                                object.io.audio.output.audioNode = stableAmplitudeGenerator.out();
                                object.io.voltage.voltage.onchange = function(value){
                                    object.elements.dial_continuous_image.amplitude.set( (value+1)/2 );
                                };
                    
                        //interface
                            object.i = {
                                amplitude:function(a){
                                    object.elements.dial_continuous_image.amplitude.set(a);
                                },
                            };
                    
                        //import/export
                            object.exportData = function(){
                                return JSON.parse(JSON.stringify(state));
                            };
                            object.importData = function(data){
                                object.elements.dial_continuous_image.gain.set( data.amplitude_dial );
                            };
                            
                        return object;
                    };
                    this['stable_amplitude_generator'].metadata = {
                        name:'Stable Amplitude Generator',
                        category:'',
                        helpURL:''
                    };
                    this['sigmoids_affecter'] = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_commonPrefix = imageStoreURL+'common/';
                                    this.imageStoreURL_localPrefix = imageStoreURL+'sigmoids_affecter/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = { 
                                        file: { width:875, height:600 },
                                        design: { width:8.75, height:6 },
                                    };
                    
                                    this.offset = {x:0,y:0};
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'sigmoids_affecter',
                                x:x, y:y, angle:angle,
                                space:[
                                    {x:-unitStyle.offset.x,                               y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                    {x:-unitStyle.offset.x,                               y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_audio', name:'input', data:{ 
                                        x:unitStyle.drawingValue.width, y:unitStyle.drawingValue.height/2 - 15/2, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'output', data:{ 
                                        x:0, y:unitStyle.drawingValue.height/2 + 15/2, width:5, height:15, angle:Math.PI, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'voltage_gain', data:{ 
                                        x:10, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'voltage_sharpness', data:{ 
                                        x:50, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:-unitStyle.offset.x, y:-unitStyle.offset.y, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png' }
                                    },
                    
                                    {collection:'control', type:'dial_continuous_image', name:'gain', data:{
                                        x:15, y:22.5, radius:15/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:1, resetValue:0.5, arcDistance:1.2,
                                        handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_small.png',
                                    }},
                                    {collection:'control', type:'dial_continuous_image', name:'sharpness', data:{
                                        x:45, y:30, radius:30/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, resetValue:0.5, arcDistance:1.2,
                                        handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                    }},
                                    {collection:'control', type:'checkbox_image', name:'allowOne', data:{
                                        x:8.5, y:35, width:5, height:10,
                                        uncheckURL:unitStyle.imageStoreURL_commonPrefix+'switch_small_down.png', 
                                        checkURL:unitStyle.imageStoreURL_commonPrefix+'switch_small_up.png',
                                    }},
                                    {collection:'control', type:'checkbox_image', name:'exponentialMode', data:{
                                        x:16.5, y:35, width:5, height:10,
                                        uncheckURL:unitStyle.imageStoreURL_commonPrefix+'switch_small_down.png', 
                                        checkURL:unitStyle.imageStoreURL_commonPrefix+'switch_small_up.png',
                                    }},
                                ]
                            });
                    
                        //circuitry
                            const state = {
                                gain:1,
                                sharpness:0,
                                sharpnessDial:0,
                                allowOne:false,
                                exponentialMode:false,
                                asCloseToOneAsIsAllowed:0.999,
                            };
                            const amplitudeExciter = new _canvas_.interface.circuit.sigmoid(_canvas_.library.audio.context);
                            function setSharpness(value){
                                if(state.exponentialMode){
                                    value = _canvas_.library.math.curvePoint.halfSigmoid_up( value, 0, 1, 0.75 );
                                }
                    
                                if(!state.allowOne && value == 1){
                                    value = state.asCloseToOneAsIsAllowed;
                                }
                    
                                amplitudeExciter.sharpness(value);
                                state.sharpness = value;
                            }
                    
                        //wiring
                            //hid
                                object.elements.dial_continuous_image.gain.onchange = function(value){
                                    amplitudeExciter.gain(value);
                                    state.gain = value;
                                };
                                object.elements.dial_continuous_image.sharpness.onchange = function(value){
                                    state.sharpnessDial = value;
                                    setSharpness(value);
                                };
                                object.elements.checkbox_image.allowOne.onchange = function(value){
                                    state.allowOne = value;
                                    setSharpness(state.sharpnessDial);
                                };
                                object.elements.checkbox_image.exponentialMode.onchange = function(value){
                                    state.exponentialMode = value;
                                    setSharpness(state.sharpnessDial);
                                };
                            //io
                                object.io.audio.input.audioNode = amplitudeExciter.in();
                                object.io.audio.output.audioNode = amplitudeExciter.out();
                                object.io.voltage.voltage_gain.onchange = function(value){
                                    object.elements.dial_continuous_image.gain.set(value);
                                };
                                object.io.voltage.voltage_sharpness.onchange = function(value){
                                    object.elements.dial_continuous_image.sharpness.set(value);
                                };
                    
                        //interface
                            object.i = {
                                gain:function(value){
                                    if(value == undefined){
                                        return object.elements.dial_continuous_image.gain.get();
                                    }
                                    object.elements.dial_continuous_image.gain.set(value);
                                },
                                sharpness:function(value){
                                    if(value == undefined){
                                        return object.elements.dial_continuous_image.sharpness.get();
                                    }
                                    object.elements.dial_continuous_image.sharpness.set(value);
                                },
                                allowOne:function(bool){
                                    if(bool == undefined){
                                        return state.allowOne;
                                    }
                                    state.allowOne = bool;
                                    object.elements.checkbox_image.allowOne.set(bool);
                                },
                                exponentialMode:function(bool){
                                    if(bool == undefined){
                                        return state.exponentialMode;
                                    }
                                    state.exponentialMode = bool;
                                    object.elements.checkbox_image.exponentialMode.set(bool);
                                },
                            };
                    
                        //import/export
                            object.exportData = function(){
                                return {
                                    gain:state.gain,
                                    sharpnessDial:state.sharpnessDial,
                                    allowOne:state.allowOne,
                                    exponentialMode:state.exponentialMode,
                                };
                            };
                            object.importData = function(data){
                                object.elements.dial_continuous_image.gain.set(data.gain);
                                object.elements.dial_continuous_image.sharpness.set(data.sharpnessDial);
                                object.elements.checkbox_image.allowOne.set(data.allowOne);
                                object.elements.checkbox_image.exponentialMode.set(data.exponentialMode);
                            };
                            
                        return object;
                    };
                    this['sigmoids_affecter'].metadata = {
                        name:'Sigmoid\'s Affecter',
                        category:'',
                        helpURL:''
                    };
                    this['stream_adder'] = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_commonPrefix = imageStoreURL+'common/';
                                    this.imageStoreURL_localPrefix = imageStoreURL+'stream_adder/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = { 
                                        file: { width:775, height:600 },
                                        design: { width:7.75, height:6 },
                                    };
                    
                                    this.offset = {x:0,y:0};
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'stream_adder',
                                x:x, y:y, angle:angle,
                                space:[
                                    {x:-unitStyle.offset.x,                               y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                    {x:-unitStyle.offset.x,                               y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_audio', name:'input_1', data:{ 
                                        x:unitStyle.drawingValue.width, y:unitStyle.drawingValue.height*0.75 - 15/2, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'input_2', data:{ 
                                        x:unitStyle.drawingValue.width, y:unitStyle.drawingValue.height*0.25 - 15/2, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'voltage_mix', data:{ 
                                        x:30, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'control', data:{ 
                                        x:42.5, y:unitStyle.drawingValue.height, width:5, height:15, angle:Math.PI/2, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'output', data:{ 
                                        x:0, y:unitStyle.drawingValue.height/2 + 15/2, width:5, height:15, angle:Math.PI, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:-unitStyle.offset.x, y:-unitStyle.offset.y, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png' }
                                    },
                    
                                    {collection:'control', type:'dial_continuous_image', name:'mix', data:{
                                        x:35, y:30, radius:30/2, startAngle:(Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, resetValue:0.5, arcDistance:1.2,
                                        handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                    }},
                                    {collection:'control', type:'checkbox_image', name:'invert', data:{
                                        x:5, y:20, width:10, height:20,
                                        uncheckURL:unitStyle.imageStoreURL_commonPrefix+'switch_large_up.png', 
                                        checkURL:unitStyle.imageStoreURL_commonPrefix+'switch_large_down.png',
                                    }},
                                ]
                            });
                    
                        //circuitry
                            const state = {
                                mix:0.5,
                                mode:false,
                            };
                            const streamAdder = new _canvas_.interface.circuit.streamAdder(_canvas_.library.audio.context);
                    
                        //wiring
                            //hid
                                object.elements.dial_continuous_image.mix.onchange = function(value){
                                    state.mix = value;
                                    streamAdder.mix( value );
                                };
                                object.elements.checkbox_image.invert.onchange = function(value){
                                    state.mode = value;
                                    streamAdder.mode(value);
                                };
                            //io
                                object.io.audio.input_1.audioNode = streamAdder.in_1();
                                object.io.audio.input_2.audioNode = streamAdder.in_2();
                                object.io.audio.control.audioNode = streamAdder.mixControl();
                                object.io.voltage.voltage_mix.onchange = function(value){
                                    object.elements.dial_continuous_image.mix.set( (value+1)/2 );
                                };
                                object.io.audio.output.audioNode = streamAdder.out();
                    
                        //interface
                            object.i = {
                                mix:function(a){
                                    if(a == undefined){ return state.mix; }
                                    object.elements.dial_continuous_image.mix.set(a);
                                },
                            };
                    
                        //import/export
                            object.exportData = function(){
                                return JSON.parse(JSON.stringify(state));
                            };
                            object.importData = function(data){
                                object.elements.dial_continuous_image.mix.set( data.mix );
                            };
                            
                        return object;
                    };
                    this['stream_adder'].metadata = {
                        name:'Stream Adder',
                        category:'',
                        helpURL:''
                    };
                    this['amplitude_modifier'] = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_commonPrefix = imageStoreURL+'common/';
                                    this.imageStoreURL_localPrefix = imageStoreURL+'amplitude_modifier/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = { 
                                        file: { width:1150, height:900 },
                                        design: { width:11.5, height:9 },
                                    };
                    
                                    this.offset = {x:0,y:0};
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'amplitude_modifier',
                                x:x, y:y, angle:angle,
                                space:[
                                    {x:-unitStyle.offset.x,                               y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                    {x:-unitStyle.offset.x,                               y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_audio', name:'input', data:{ 
                                        x:unitStyle.drawingValue.width, y:unitStyle.drawingValue.height/2 - 15/2, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'output', data:{ 
                                        x:0, y:unitStyle.drawingValue.height/2 + 15/2, width:5, height:15, angle:Math.PI, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'voltage_offset', data:{ 
                                        x:30, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'voltage_divideBy', data:{ 
                                        x:40, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'voltage_ceiling', data:{ 
                                        x:70, y:0, width:5, height:10, angle:-Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'voltage_floor', data:{ 
                                        x:80, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    {collection:'dynamic', type:'connectionNode_signal', name:'signal_invert', data:{ 
                                        x:15, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.signal,
                                    }},
                                    
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:-unitStyle.offset.x, y:-unitStyle.offset.y, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'guide.png' }
                                    },
                    
                                    {collection:'control', type:'dial_continuous_image', name:'offset', data:{
                                        x:35, y:25, radius:30/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0.5, resetValue:0.5, arcDistance:1.2,
                                        handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                    }},
                                    {collection:'control', type:'dial_continuous_image', name:'divideBy', data:{
                                        x:35, y:65, radius:30/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, resetValue:1/7, arcDistance:1.2,
                                        handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                    }},
                                    {collection:'control', type:'dial_continuous_image', name:'ceiling', data:{
                                        x:75, y:25, radius:30/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:1, arcDistance:1.2,
                                        handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                    }},
                                    {collection:'control', type:'dial_continuous_image', name:'floor', data:{
                                        x:75, y:65, radius:30/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, arcDistance:1.2,
                                        handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                    }},
                                    {collection:'control', type:'checkbox_image', name:'invert', data:{
                                        x:5, y:35, width:10, height:20,
                                        uncheckURL:unitStyle.imageStoreURL_commonPrefix+'switch_large_up.png', 
                                        checkURL:unitStyle.imageStoreURL_commonPrefix+'switch_large_down.png',
                                    }},
                                ]
                            });
                    
                        //circuitry
                            const state = {
                                offset:0,
                                divideBy:1,
                                ceiling:2,
                                floor:-2,
                                invert:false,
                            };
                            const amplitudeModifier = new _canvas_.interface.circuit.amplitudeModifier(_canvas_.library.audio.context);
                    
                        //wiring
                            //hid
                                object.elements.dial_continuous_image.offset.onchange = function(value){
                                    amplitudeModifier.offset(value*2 - 1);
                                    state.offset = value*2 - 1;
                                };
                                object.elements.dial_continuous_image.divideBy.onchange = function(value){
                                    amplitudeModifier.divisor(value*7 + 1);
                                    state.divideBy = value*7 + 1;
                                };
                                object.elements.dial_continuous_image.ceiling.onchange = function(value){
                                    amplitudeModifier.ceiling(value*2);
                                    state.ceiling = value*2;
                                };
                                object.elements.dial_continuous_image.floor.onchange = function(value){
                                    amplitudeModifier.floor(-(1-value)*2);
                                    state.floor = -(1-value)*2;
                                };
                                object.elements.checkbox_image.invert.onchange = function(value){
                                    amplitudeModifier.invert(value);
                                    state.invert = value;
                                };
                            //io
                                object.io.audio.input.audioNode = amplitudeModifier.in();
                                object.io.audio.output.audioNode = amplitudeModifier.out();
                                object.io.voltage.voltage_offset.onchange = function(value){
                                    object.elements.dial_continuous_image.offset.set( (value+1)/2 );
                                };
                                object.io.voltage.voltage_divideBy.onchange = function(value){
                                    object.elements.dial_continuous_image.divideBy.set( value/8 );
                                };
                                object.io.voltage.voltage_ceiling.onchange = function(value){
                                    object.elements.dial_continuous_image.ceiling.set( value/2 );
                                };
                                object.io.voltage.voltage_floor.onchange = function(value){
                                    object.elements.dial_continuous_image.floor.set( (2+value)/2 );
                                };
                                object.io.signal.signal_invert.onchange = function(value){
                                    if(!value){return;}
                                    object.elements.checkbox_image.invert.set(
                                        !object.elements.checkbox_image.invert.get()
                                    );
                                };
                    
                        //interface
                            object.i = {
                                offset:function(a){
                                    if(a==undefined){ return state.offset; }
                                    object.elements.dial_continuous_image.offset.set( (a+1)/2 );
                                },
                                divideBy:function(a){
                                    if(a==undefined){ return state.divideBy; }
                                    object.elements.dial_continuous_image.divideBy.set( (a-1)/7 );
                                },
                                ceiling:function(a){
                                    if(a==undefined){ return state.ceiling; }
                                    object.elements.dial_continuous_image.ceiling.set( a/2 );
                                },
                                floor:function(a){
                                    if(a==undefined){ return state.floor; }
                                    object.elements.dial_continuous_image.floor.set( 1 + a/2 );
                                },
                                invert:function(a){
                                    if(a==undefined){ return state.invert; }
                                    object.elements.checkbox_image.invert.set( a );
                                },
                            };
                    
                        //import/export
                            object.exportData = function(){
                                return JSON.parse(JSON.stringify(state));
                            };
                            object.importData = function(data){
                                object.elements.dial_continuous_image.offset.set( (data.offset+1)/2 );
                                object.elements.dial_continuous_image.divideBy.set( (data.divideBy-1)/7 );
                                object.elements.dial_continuous_image.ceiling.set( data.ceiling/2 );
                                object.elements.dial_continuous_image.floor.set( -data.floor/2 );
                                object.elements.checkbox_image.invert.set( data.invert );
                            };
                            
                        return object;
                    };
                    this['amplitude_modifier'].metadata = {
                        name:'Amplitude Modifier',
                        category:'',
                        helpURL:''
                    };
                    this['lag_processor'] = function(name,x,y,angle){
                        //style data
                            const unitStyle = new function(){
                                //image store location URL
                                    this.imageStoreURL_commonPrefix = imageStoreURL+'common/';
                                    this.imageStoreURL_localPrefix = imageStoreURL+'lag_processor/';
                    
                                //calculation of measurements
                                    const div = 10;
                                    const measurement = { 
                                        file: { width:750, height:600 },
                                        design: { width:7.5, height:6 },
                                    };
                    
                                    this.offset = {x:0,y:0};
                                    this.drawingValue = { 
                                        width: measurement.file.width/div, 
                                        height: measurement.file.height/div
                                    };
                            };
                    
                        //main object creation
                            const object = _canvas_.interface.unit.builder({
                                name:name,
                                model:'lag_processor',
                                x:x, y:y, angle:angle,
                                space:[
                                    {x:-unitStyle.offset.x,                               y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:-unitStyle.offset.y},
                                    {x:unitStyle.drawingValue.width - unitStyle.offset.x, y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                    {x:-unitStyle.offset.x,                               y:unitStyle.drawingValue.height - unitStyle.offset.y},
                                ],
                                elements:[
                                    {collection:'dynamic', type:'connectionNode_audio', name:'input', data:{ 
                                        x:unitStyle.drawingValue.width, y:unitStyle.drawingValue.height/2 - 15/2, width:5, height:15, angle:0, isAudioOutput:false, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_audio', name:'output', data:{ 
                                        x:0, y:unitStyle.drawingValue.height/2 + 15/2, width:5, height:15, angle:Math.PI, isAudioOutput:true, cableVersion:2, style:style.connectionNode.audio
                                    }},
                                    {collection:'dynamic', type:'connectionNode_voltage', name:'voltage_dial', data:{ 
                                        x:35, y:unitStyle.drawingValue.height, width:5, height:10, angle:Math.PI/2, cableVersion:2, style:style.connectionNode.voltage,
                                    }},
                                    
                                    {collection:'basic', type:'image', name:'backing', 
                                        data:{ x:-unitStyle.offset.x, y:-unitStyle.offset.y, width:unitStyle.drawingValue.width, height:unitStyle.drawingValue.height, url:unitStyle.imageStoreURL_localPrefix+'backing.png' }
                                    },
                    
                                    {collection:'control', type:'dial_continuous_image', name:'samples', data:{
                                        x:30, y:30, radius:30/2, startAngle:(3*Math.PI)/4, maxAngle:1.5*Math.PI, value:0, resetValue:0.5, arcDistance:1.2,
                                        handleURL:unitStyle.imageStoreURL_commonPrefix+'dial_large.png',
                                    }},
                                ]
                            });
                    
                        //circuitry
                            const state = {
                                samples:1,
                                samples_dial:0,
                            };
                            const lagProcessor = new _canvas_.interface.circuit.lagProcessor(_canvas_.library.audio.context);
                    
                        //wiring
                            //hid
                                object.elements.dial_continuous_image.samples.onchange = function(value){
                                    state.samples_dial = value;
                    
                                    if(value <= 0.5){ value = 1 + 2*value * 9; }
                                    else if(value > 0.5){ value = 10 * (1 + (2*value-1) * 9); }
                    
                                    lagProcessor.samples( Math.round(value) );
                                    state.samples = value;
                                };
                            //io
                                object.io.audio.input.audioNode = lagProcessor.in();
                                object.io.audio.output.audioNode = lagProcessor.out();
                                object.io.voltage.voltage_dial.onchange = function(value){
                                    object.elements.dial_continuous_image.samples.set(value);
                                };
                    
                        //interface
                            object.i = {
                                samples:function(a){
                                    if(a == undefined){ return state.samples_dial; }
                                    object.elements.dial_continuous_image.samples.set(a);
                                },
                            };
                    
                        //import/export
                            object.exportData = function(){
                                return JSON.parse(JSON.stringify(state));
                            };
                            object.importData = function(data){
                                object.elements.dial_continuous_image.samples.set( data.samples_dial );
                            };
                            
                        return object;
                    };
                    this['lag_processor'].metadata = {
                        name:'Lag Processor',
                        category:'',
                        helpURL:''
                    };
                    
                    this._collectionData = {
                        name:'Acoustic Research',
                        itemWidth:210,
                        categoryOrder:[
                        ],   
                    };
                    this._categoryData = {
                    };
                };
            };
            
            _canvas_.interface.unit.collection.metadata = {
                mainList:[
                    'alpha',
                    'curvetech',
                    'harbinger',
                    'acousticresearch',
                ],
                devList:[
                    'development',
                ],
            };
            _canvas_.control.go.add( function(){
                //a design object for the menubar options and their respective dropdown menu items
                    _canvas_.control.gui.elements.menubar.dropdowns = [];
            
                //file
                    _canvas_.control.gui.elements.menubar.dropdowns.push(
                        {
                            text:'file',
                            width:45,
                            listWidth:170,
                            listItemHeight:22.5,
                            breakHeight: 0.5,
                            spaceHeight: 1,
                            itemList:[
                                {type:'button', text_left:'New Scene', function:function(){ _canvas_.control.scene.new(true); } },
                                {type:'button', text_left:'Open Scene',text_right:'ctrl-f2', function:function(){ _canvas_.control.scene.load(undefined,undefined,true); } },
                                {type:'button', text_left:'Save Scene',text_right:'ctrl-f3', function:function(){ _canvas_.control.scene.save('project.crv',true); } },
                            ]
                        }
                    );
            
                //edit
                    _canvas_.control.gui.elements.menubar.dropdowns.push(
                        {
                            text:'edit',
                            width:45,
                            listWidth:250,//150,
                            listItemHeight:22.5,
                            breakHeight: 0.5,
                            spaceHeight: 1,
                            itemList:[
                                {type:'button', text_left:'Undo',      text_right:'ctrl-z',       function:function(){_canvas_.control.actionRegistry.undo();} },
                                {type:'button', text_left:'Redo',      text_right:'ctrl-shift-z', function:function(){_canvas_.control.actionRegistry.redo();} },
                                {type:'break'},
                                {type:'button', text_left:'Cut',       text_right:'ctrl-x', function:function(){_canvas_.control.selection.cut();}       },
                                {type:'button', text_left:'Copy',      text_right:'ctrl-c', function:function(){_canvas_.control.selection.copy();}      },
                                {type:'button', text_left:'Paste',     text_right:'ctrl-v', function:function(){_canvas_.control.selection.paste();}     },
                                {type:'button', text_left:'Duplicate', text_right:'ctrl-b', function:function(){_canvas_.control.selection.duplicate();} },
                                {type:'button', text_left:'Delete',    text_right:'del',    function:function(){_canvas_.control.selection.delete();}    },
                                {type:'break'},
                                {type:'button', text_left:'Select Everything', text_right:'ctrl-a', function:function(){_canvas_.control.selection.selectEverything();} },
                                {type:'button', text_left:'Deselect Everything', text_right:'ctrl-shift-a', function:function(){_canvas_.control.selection.deselectEverything();} },
                            ]
                        }
                    );
            
                //create
                    _canvas_.control.gui.elements.menubar.dropdowns.push(
                        {
                            text:'create',
                            width:65,
                            listWidth:200,
                            listItemHeight:22.5,
                            breakHeight: 0.5,
                            spaceHeight: 1,
                            itemList:(function(){
                                const collections = _canvas_.interface.unit.collection;
                                const outputItemList = [];
                                const unitPlacementPosition = {x:30,y:30};
            
                                function populator(collectionKey){
                                    const collection = collections[collectionKey];
                                    const collectionItemList = {
                                        type:'list', 
                                        text:collection._collectionData ? collection._collectionData.name : collectionKey, 
                                        list:[],
                                        itemWidth:collection._collectionData ? collection._collectionData.itemWidth : 260, 
                                    };
            
                                    //for this collection, sort models into their categories
                                        const categorySortingList = {};
                                        Object.keys(collection).sort().filter(a => a[0]!='_').forEach(modelKey => {
                                            const model = collection[modelKey]; //console.log(model.metadata);
                                            if(model.metadata.category == undefined){ model.metadata.category = 'unknown'; }
                                            if(!categorySortingList.hasOwnProperty(model.metadata.category)){ categorySortingList[model.metadata.category] = []; }
                                            categorySortingList[model.metadata.category].push(modelKey);
                                        });
            
                                    //run though categories and generate item list for this collection (except the "" one)
                                        Object.keys(categorySortingList).sort().forEach(categoryKey => {
                                            if(categoryKey == ""){return;}
            
                                            //get category printing name
                                                let categoryPrintingName = categoryKey;
                                                let itemWidth = undefined;
                                                if(collection._categoryData != undefined){
                                                    if(collection._categoryData[categoryKey] != undefined){
                                                        categoryPrintingName = collection._categoryData[categoryKey].printingName;
                                                        itemWidth = collection._categoryData[categoryKey].itemWidth;
                                                    }
                                                }
            
                                            //generate sub list for this category
                                                const categoryList = { type:'list', text:categoryPrintingName, categoryKey:categoryKey, list:[], itemWidth:itemWidth, };
                                                categorySortingList[categoryKey].forEach(model => {
                                                    categoryList.list.push(
                                                        {
                                                            type:'button', text_left:collection[model].metadata.name,
                                                            function:function(design){return function(){
                                                                const p = _canvas_.core.viewport.adapter.windowPoint2workspacePoint(unitPlacementPosition.x,unitPlacementPosition.y);
                                                                _canvas_.control.scene.addUnit(p.x,p.y,0,design,collectionKey);
                                                            }}(model),
                                                        }
                                                    );
                                                });
            
                                            //push sublist
                                                collectionItemList.list.push(categoryList);
                                        });
            
                                    //if the collection has an order for it's categories; resort the item list to match
                                        if(collection._collectionData != undefined && collection._collectionData.categoryOrder != undefined){
                                            collectionItemList.list = collection._collectionData.categoryOrder.map(category => {
                                                const result = collectionItemList.list.filter(item => item.categoryKey==category)[0];
                                                if(result == undefined){ console.error('Error::menubar generation::create: bad sorting for "'+collectionKey+'" for the category: "'+category+'"'); }
                                                return result
                                            });
                                        }
            
                                    //add this item list to the output array
                                        outputItemList.push(collectionItemList);
            
                                    //if there is one, add the units from the "" list to the main list
                                        if( categorySortingList[""] != undefined){
                                            categorySortingList[""].forEach(model => {
                                                collectionItemList.list.push(
                                                    {
                                                        type:'button', text_left:collection[model].metadata.name,
                                                        function:function(design){return function(){
                                                            const p = _canvas_.core.viewport.adapter.windowPoint2workspacePoint(unitPlacementPosition.x,unitPlacementPosition.y);
                                                            _canvas_.control.scene.addUnit(p.x,p.y,0,design,collectionKey);
                                                        }}(model),
                                                    }
                                                );
                                            });
                                        }
                                }
            
                                collections.metadata.mainList.forEach(collectionKey => { populator(collectionKey); });
                                if(_canvas_.control.interaction.development()){
                                    outputItemList.push({type:'break'});
                                    collections.metadata.devList.forEach(collectionKey => { populator(collectionKey); });
                                }
            
                                return outputItemList;
                            })(),
                        }
                    );
            
                //tools
                    _canvas_.control.gui.elements.menubar.dropdowns.push(
                        {
                            text:'tools',
                            width:50,
                            listWidth:170,
                            listItemHeight:22.5,
                            breakHeight: 0.5,
                            spaceHeight: 1,
                            itemList:[
                                { type:'checkbox', text:'Snapping', updateFunction:function(){return _canvas_.control.scene.activeSnapping();}, onclickFunction:function(val){_canvas_.control.scene.activeSnapping(val);} },
                                { type:'checkbox', text:'Dark Mode', 
                                    updateFunction:function(){return _canvas_.control.gui.style.currentStyleMode == 'dark';}, 
                                    onclickFunction:function(val){
                                        if(val){ _canvas_.control.gui.style.darkMode(); }
                                        else{ _canvas_.control.gui.style.lightMode(); }
                                    }
                                },
                                { type:'radio', text:'Mouse Wheel Mode', itemWidth:150, 
                                    options:['Magic', 'Clicky Wheel'],
                                    updateFunction:function(){
                                        if( _canvas_.control.mouseWheelMode == 'magic' ){ return 0; }
                                        if( _canvas_.control.mouseWheelMode == 'clickyWheel' ){ return 1; }
                                    },
                                    onclickFunction:function(value){
                                        _canvas_.control.mouseWheelMode = ['magic','clickyWheel'][value];
                                    }
                                },
                                {type:'button', text_left:'Reset Viewport', function:function(){
                                    _canvas_.control.viewport.position(0,0);
                                    _canvas_.control.viewport.scale(1);
                                } },
                            ]
                        }
                    );
            
                //help
                    _canvas_.control.gui.elements.menubar.dropdowns.push(
                        {
                            text:'help',
                            width:50,
                            listWidth:160,
                            listItemHeight:22.5,
                            breakHeight: 0.5,
                            spaceHeight: 1,
                            itemList:[
                                {type:'button', text_left:'Help Docs', text_right:'(empty)', function:function(){ console.log('go to help site'); } },
                                {type:'button', text_left:'Development Log', function:function(){window.open('https://raw.githubusercontent.com/metasophiea/curve/master/docs/notes/log');}},
                                {type:'button', text_left:'Github', function:function(){window.open('https://github.com/metasophiea/curve');}},
                                {type:'button', text_left:'Ideas List', function:function(){window.open('https://raw.githubusercontent.com/metasophiea/curve/master/docs/notes/ideas');}},
                                {type:'button', text_left:'Unit Development', function:function(){window.open('https://raw.githubusercontent.com/metasophiea/curve/master/docs/notes/units');}},
                                {type:'button', text_left:'Bug Tracker', function:function(){window.open('https://raw.githubusercontent.com/metasophiea/curve/master/docs/notes/bugs');}},
                            ]
                        },
                    );
            
                //dev tools
                    if(_canvas_.control.interaction.development()){
                        _canvas_.control.gui.elements.menubar.dropdowns.push(
                            {
                                text:'dev',
                                width:50,
                                listWidth:210,
                                listItemHeight:22.5,
                                breakHeight: 0.5,
                                spaceHeight: 1,
                                itemList:[
                                    {type:'button', text_left:'Release All Keyboard Keys', function:function(){ _canvas_.system.keyboard.releaseAll(); } },
                                    {type:'button', text_left:'Reset Cursor', function:function(){ _canvas_.core.viewport.cursor('default'); } },
                                    {type:'checkbox', text_left:'Limit Frame Rate (30fps)', 
                                        updateFunction:_canvas_.core.render.activeLimitToFrameRate, 
                                        onclickFunction:function(val){_canvas_.core.render.activeLimitToFrameRate(val);}
                                    },
                                    { type:'checkbox', text:'No Unload Warning', 
                                        updateFunction:function(){return !_canvas_.control.interaction.unloadWarning(); }, 
                                        onclickFunction:function(val){ _canvas_.control.interaction.unloadWarning(!val); }
                                    },
                                    { type:'checkbox', text:'Frame Skipping', 
                                        updateFunction:function(){return _canvas_.core.render.allowFrameSkipping(); }, 
                                        onclickFunction:function(val){ _canvas_.core.render.allowFrameSkipping(val); }
                                    },
                                    { type:'checkbox', text:'Stat Readout', 
                                        updateFunction:function(){return _canvas_.core.stats.onScreenAutoPrint(); }, 
                                        onclickFunction:function(val){ _canvas_.core.stats.onScreenAutoPrint(val); }
                                    },
                                    {type:'break'}
                                ].concat(
                                    _canvas_.layers.getVersionInformation().map(item => {
                                        if(item.name[0] == '_'){ item.name = item.name.substr(1); }
                                        return {
                                            name:item.name,date:item.data.lastDateModified.y+'/'+_canvas_.library.misc.padString(item.data.lastDateModified.m,2,'0')+'/'+_canvas_.library.misc.padString(item.data.lastDateModified.d,2,'0')
                                        }
                                    } ).map( item => ({type:'text', text_left:item.name, text_centre:'-', text_right:item.date})
                                    ).reverse()
                                )
                            }
                        );
                    }
            
                //push changes to menubar
                    _canvas_.control.gui.heavyRefresh();
            });

        }
    }
})();
